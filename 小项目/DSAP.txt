Data Structures and
Algorithms in Python
Michael T. Goodrich
DepartmentofComputerScience
UniversityofCalifornia, Irvine
Roberto Tamassia
DepartmentofComputerScience
BrownUniversity
Michael H. Goldwasser
DepartmentofMathematicsand ComputerScienceVP & PUBLISHER  Don Fowley
EXECUTIVE EDITOR  Beth Lang Golub
EDITORIAL PROGRAM ASSISTANT  Katherine Willis
MARKETING MANAGER  Christopher Ruel
DESIGNER  Kenji Ngieng
SENIOR PRODUCTION MANAGER  Janis Soo
ASSOCIATE PRODUCTION MANAGER  Joyce Poh
This book was set in LaTEX by the authors. Printed and bound by Courier Westford.
The cover was printed by Courier Westford.
This book is printed on acid free paper. 
Founded in 1807, John Wiley & Sons, Inc. has been a valued source of knowledge and understanding for 
more than 200 years, helping people around the world meet their needs and fulﬁ ll their aspirations. Our 
company is built on a foundation of principles that include responsibility to the communities we serve and 
where we live and work. In 2008, we launched a Corporate Citizenship Initiative, a global effort to address 
the environmental, social, economic, and ethical challenges we face in our business. Among the issues we are 
addressing are carbon impact, paper speciﬁ cations and procurement, ethical conduct within our business and 
among our vendors, and community and charitable support. For more information, please visit our website: 
www.wiley.com/go/citizenship. 
Copyright © 2013 John Wiley & Sons, Inc. All rights reserved. No part of this publication may be 
reproduced, stored in a retrieval system or transmitted in any form or by any means, electronic, mechanical, 
photocopying, recording, scanning or otherwise, except as permitted under Sections 107 or 108 of 
the 1976 United States Copyright Act, without either the prior written permission of the Publisher, or 
authorization through payment of the appropriate per-copy fee to the Copyright Clearance Center, Inc. 222 
Rosewood Drive, Danvers, MA 01923, website www.copyright.com. Requests to the Publisher for permission 
should be addressed to the Permissions Department, John Wiley & Sons, Inc., 111 River Street, Hoboken, 
NJ 07030-5774, (201)748-6011, fax (201)748-6008, website http://www.wiley.com/go/permissions.
 Evaluation copies are provided to qualiﬁ ed academics and professionals for review purposes only, for use 
in their courses during the next academic year.  These copies are licensed and may not be sold or transferred 
to a third party. Upon completion of the review period, please return the evaluation copy to Wiley.  Return 
instructions and a free of charge return mailing label are available at www.wiley.com/go/returnlabel.  If you 
have chosen to adopt this textbook for use in your course, please accept this book as your complimentary desk 
copy. Outside of the United States, please contact your local sales representative. 
Printed in the United States of AmericaTo Karen, Paul,Anna, and Jack
– MichaelT.Goodrich
To Isabel
– RobertoTamassia
To Susan, Calista,and MayaPreface
The design and analysis of efﬁcient data structures has longbeen recognized as a
vital subject in computing and is part of the core curriculum of computer science
andcomputerengineering undergraduate degrees. DataStructures andAlgorithms
inPythonprovidesanintroductiontodatastructuresandalgorithms,includingtheir
design,analysis,andimplementation. Thisbookisdesignedforuseinabeginning-
level data structures course, or in an intermediate-level introduction to algorithms
course. Wediscussitsuseforsuchcoursesinmoredetaillaterinthispreface.
Topromote the development of robust and reusable software,wehave tried to
take a consistent object-oriented viewpoint throughout this text. One of the main
ideas ofthe object-oriented approach isthat data should bepresented as being en-
capsulated with the methods that access and modify them. That is, rather than
simply viewing data as a collection of bytes and addresses, we think of data ob-
jects as instances of an abstract data type (ADT), which includes a repertoire of
methods for performing operations on data objects of this type. We then empha-
size that there may be several different implementation strategies for a particular
ADT,andexploretherelativeprosandconsofthesechoices. Weprovidecomplete
Python implementations for almost all data structures and algorithms discussed,
and we introduce important object-oriented design patterns as means to organize
thoseimplementations intoreusablecomponents.
Desiredoutcomesforreaders ofourbookincludethat:
• They have knowledge of the most common abstractions for datacollections
(e.g.,stacks, queues, lists,trees,maps).
• Theyunderstandalgorithmicstrategiesforproducingefﬁcientrealizationsof
commondatastructures.
• They can analyze algorithmic performance, both theoretically and experi-
mentally, andrecognize commontrade-offs betweencompeting strategies.
• Theycanwiselyuseexistingdatastructuresandalgorithmsfoundinmodern
programming language libraries.
• Theyhaveexperienceworkingwithconcreteimplementationsformostfoun-
dational datastructures andalgorithms.
• Theycanapplydatastructures andalgorithms tosolvecomplexproblems.
Insupportofthelastgoal,wepresentmanyexampleapplicationsofdatastructures
throughout the book, including the processing of ﬁle systems, matching of tags
in structured formats such as HTML, simple cryptography, text frequency analy-
sis, automated geometric layout, Huffman coding, DNA sequence alignment, and
searchengineindexing.vi Preface
Book Features
This book is based upon the book Data Structures and Algorithms in Java by
Goodrich and Tamassia, and the related Data Structures and Algorithms in C++
byGoodrich, Tamassia,andMount. However,thisbookisnotsimplyatranslation
of those other books to Python. In adapting the material for this book, we have
signiﬁcantly redesigned theorganization andcontentofthebookasfollows:
• Thecodebasehasbeenentirelyredesigned totakeadvantageofthefeatures
ofPython,suchasuseofgenerators foriterating elementsofacollection.
• Many algorithms that were presented as pseudo-code in the Java and C++
versions aredirectly presented ascompletePythoncode.
• Ingeneral,ADTsaredeﬁnedtohaveconsistentinterfacewithPython’sbuilt-
indatatypesandthoseinPython’scollectionsmodule.
• Chapter 5 provides an in-depth exploration of the dynamic array-based un-
derpinnings ofPython’sbuilt-inlist,tuple,andstrclasses. NewAppendixA
servesasanadditional reference regardingthefunctionality ofthestrclass.
• Over450illustrations havebeencreatedorrevised.
• Newandrevisedexercises bringtheoveralltotalnumberto750.
Online Resources
This book is accompanied by an extensive set of online resources, which can be
foundatthefollowingWebsite:
www.wiley.com/college/goodrich
Studentsareencouraged tousethissitealongwiththebook,tohelpwithexer-
cises and increase understanding of the subject. Instructors are likewise welcome
to use the site to help plan, organize, and present their course materials. Included
on this Web site is a collection of educational aids that augment the topics of this
book,forbothstudentsandinstructors. Becauseoftheiraddedvalue,someofthese
onlineresources arepasswordprotected.
Forallreaders,andespeciallyforstudents,weincludethefollowingresources:
• AllthePythonsourcecodepresented inthisbook.
• PDFhandouts ofPowerpointslides(four-per-page) provided toinstructors.
• Adatabaseofhintstoallexercises,indexedbyproblem number.
Forinstructors usingthisbook,weincludethefollowingadditional teachingaids:
• Solutions tohundreds ofthebook’sexercises.
• Colorversionsofallﬁguresandillustrations fromthebook.
• SlidesinPowerpointandPDF(one-per-page) format.
The slides are fully editable, so as to allow an instructor using this book full free-
domincustomizing hisorherpresentations. Alltheonline resources areprovidedPreface vii
Contents and Organization
The chapters for this book are organized to provide a pedagogical path that starts
with the basics of Python programming and object-oriented design. We then add
foundational techniques likealgorithm analysis andrecursion. Inthemainportion
of the book, we present fundamental data structures and algorithms, concluding
withadiscussion ofmemorymanagement (that is,thearchitectural underpinnings
ofdatastructures). Speciﬁcally,thechaptersforthisbookareorganizedasfollows:
1. Python Primer
2. Object-Oriented Programming
3. Algorithm Analysis
4. Recursion
5. Array-Based Sequences
6. Stacks, Queues, and Deques
7. Linked Lists
8. Trees
9. Priority Queues
10. Maps, Hash Tables, and Skip Lists
11. Search Trees
12. Sorting and Selection
13. Text Processing
14. Graph Algorithms
15. Memory Management and B-Trees
A. Character Strings in Python
B. Useful Mathematical Facts
Amoredetailedtableofcontents followsthispreface, beginning onpagexi.
Prerequisites
We assume that the reader is at least vaguely familiar with a high-level program-
minglanguage,suchasC,C++,Python,orJava,andthatheorsheunderstands the
mainconstructs fromsuchahigh-level language, including:
• Variablesandexpressions.
• Decisionstructures (suchasif-statements andswitch-statements).
• Iteration structures (forloopsandwhileloops).
• Functions (whetherstand-alone orobject-oriented methods).
For readers who are familiar with these concepts, but not with how they are ex-
pressedinPython,weprovideaprimeronthePythonlanguageinChapter1. Still,
thisbookisprimarily adatastructures book, notaPythonbook;hence, itdoesnotviii Preface
Wedelaytreatment ofobject-oriented programming inPythonuntilChapter2.
This chapter is useful for those new toPython, and forthose who maybe familiar
withPython,yetnotwithobject-oriented programming.
Intermsofmathematicalbackground,weassumethereaderissomewhatfamil-
iar with topics from high-school mathematics. Even so, in Chapter 3, we discuss
thesevenmost-importantfunctionsforalgorithmanalysis. Infact,sectionsthatuse
something otherthanoneofthesesevenfunctions areconsidered optional, andare
(cid:2)
indicated with a star ( ). We give a summary of other useful mathematical facts,
including elementary probability, inAppendixB.
Relation to Computer Science Curriculum
To assist instructors in designing a course in the context of the IEEE/ACM 2013
Computing Curriculum, the following table describes curricular knowledge units
thatarecoveredwithinthisbook.
KnowledgeUnit RelevantMaterial
AL/BasicAnalysis Chapter3andSections4.2&12.2.4
AL/AlgorithmicStrategies Sections12.2.1,13.2.1,13.3,&13.4.2
AL/Fundamental Data Structures Sections4.1.3, 5.5.2,9.4.1,9.3, 10.2,11.1, 13.2,
andAlgorithms Chapter12&muchofChapter14
Sections 5.3, 10.4, 11.2 through 11.6, 12.3.1,
AL/AdvancedDataStructures
13.5,14.5.1,&15.3
AR/MemorySystemOrganization Chapter15
andArchitecture
DS/Sets,RelationsandFunctions Sections10.5.1,10.5.2,&9.4
DS/ProofTechniques Sections3.4,4.2,5.3.2,9.3.6,&12.4.1
DS/BasicsofCounting Sections2.4.2,6.2.2,12.2.4,8.2.2&AppendixB
DS/GraphsandTrees MuchofChapters8and14
DS/DiscreteProbability Sections1.11.1,10.2,10.4.2,&12.3.1
Much of the book, yet especially Chapter 2 and
PL/Object-OrientedProgramming
Sections7.4,9.5.1,10.1.3,&11.2.1
PL/FunctionalProgramming Section1.10
SDF/AlgorithmsandDesign Sections2.1,3.3,&12.2.1
SDF/FundamentalProgramming Chapters1&4
Concepts
Chapters6&7,AppendixA,andSections1.2.1,
SDF/FundamentalDataStructures
5.2,5.4,9.1,&10.1
SDF/DevelopmentalMethods Sections1.7&2.2
SE/SoftwareDesign Sections2.1&2.1.3
Mapping IEEE/ACM2013Computing Curriculumknowledge units tocoverageinPreface ix
About the Authors
MichaelGoodrichreceivedhisPh.D.inComputerSciencefromPurdueUniversity
in 1987. He is currently a Chancellor’s Professor in the Department of Computer
ScienceatUniversityofCalifornia, Irvine. Previously, hewasaprofessor atJohns
Hopkins University. He is a Fulbright Scholar and a Fellow ofthe American As-
sociation for the Advancement of Science (AAAS), Association for Computing
Machinery (ACM), and Institute of Electrical and Electronics Engineers (IEEE).
He is a recipient of the IEEE Computer Society Technical Achievement Award,
the ACM Recognition of Service Award, and the Pond Award for Excellence in
Undergraduate Teaching.
Roberto Tamassia received his Ph.D. in Electrical and Computer Engineering
from the University of Illinois at Urbana-Champaign in 1988. He is the Plastech
Professor ofComputer Science andtheChairoftheDepartment ofComputer Sci-
enceatBrownUniversity. HeisalsotheDirectorofBrown’sCenterforGeometric
Computing. Hisresearchinterestsincludeinformationsecurity,cryptography,anal-
ysis, design, and implementation of algorithms, graph drawing and computational
geometry. He is a Fellow of the American Association for the Advancement of
Science (AAAS), Association for Computing Machinery (ACM)and Institute for
Electrical andElectronic Engineers (IEEE).Heisalso arecipient ofthe Technical
AchievementAwardfromtheIEEEComputerSociety.
Michael Goldwasser received his Ph.D. in Computer Science from Stanford
University in 1997. Heis currently aProfessor inthe Department ofMathematics
and Computer Science at Saint Louis University and the Director of their Com-
puter Science program. Previously, he was a faculty member in the Department
of Computer Science at Loyola University Chicago. His research interests focus
onthe design and implementation ofalgorithms, having published workinvolving
approximationalgorithms,onlinecomputation,computationalbiology,andcompu-
tationalgeometry. Heisalsoactiveinthecomputerscienceeducation community.
Additional Books by These Authors
• M.T.GoodrichandR.Tamassia,DataStructuresandAlgorithmsinJava,Wiley.
• M.T.Goodrich, R.Tamassia, and D.M.Mount, Data Structures and Algorithms
inC++,Wiley.
• M.T.Goodrich and R.Tamassia,Algorithm Design: Foundations, Analysis, and
Internet Examples,Wiley.
• M.T. Goodrich and R. Tamassia, Introduction to Computer Security, Addison-
Wesley.
• M.H. Goldwasser and D. Letscher, Object-Oriented Programming in Python,x Preface
Acknowledgments
We have depended greatly upon the contributions of many individuals as part of
the development of this book. We begin by acknowledging the wonderful team at
Wiley. We are grateful to our editor, Beth Golub, for her enthusiastic support of
this project, from beginning to end. The efforts of Elizabeth Mills and Katherine
Williswerecriticalinkeepingtheprojectmoving,fromitsearlystagesasaninitial
proposal, through the extensive peer review process. We greatly appreciate the
attention to detail demonstrated by Julie Kennedy, the copyeditor for this book.
Finally, many thanks are due to Joyce Poh for managing the ﬁnal months of the
production process.
We are truly indebted to the outside reviewers and readers for their copious
comments,emails,andconstructivecriticism,whichwereextremelyusefulinwrit-
ingthisedition. Wethereforethankthefollowingreviewersfortheircommentsand
suggestions: Claude Anderson (Rose Hulman Institute of Technology), Alistair
Campbell(Hamilton College), BarryCohen(NewJersey Institute ofTechnology),
RobertFranks(CentralCollege),AndrewHarrington(LoyolaUniversityChicago),
DaveMusicant (Carleton College), andVictorNorman(CalvinCollege). Wewish
to particularly acknowledge Claude for going above and beyond the call of duty,
providing uswithanenumeration of400detailed corrections orsuggestions.
Wethank David Mount, of University of Maryland, for graciously sharing the
wisdomgainedfromhisexperiencewiththeC++versionofthistext. Wearegrate-
fultoErinChambersandDavidLetscher,ofSaintLouisUniversity,fortheirintan-
gible contributions during many hallway conversations about the teaching of data
structures,andtoDavidforcommentsonearlyversionsofthePythoncodebasefor
this book. We thank David Zampino, a student at Loyola University Chicago, for
his feedback while using a draft of this book during an independent study course,
andtoAndrewHarringtonforsupervising David’sstudies.
We also wish to reiterate our thanks to the many research collaborators and
teaching assistants whose feedback shaped the previous Java and C++ versions of
thismaterial. Thebeneﬁtsofthosecontributions carryforwardtothisbook.
Finally, wewouldliketowarmlythank SusanGoldwasser, Isabel Cruz, Karen
Goodrich, Giuseppe Di Battista, Franco Preparata, Ioannis Tollis, and our parents
for providing advice, encouragement, and support at various stages of the prepa-
ration of this book, and Calista and Maya Goldwasser for offering their advice
regarding the artistic merits of many illustrations. More importantly, we thank all
ofthesepeopleforremindingusthattherearethingsinlifebeyondwritingbooks.
MichaelT.Goodrich
RobertoTamassiaContents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . v
1 Python Primer 1
1.1 Python Overview . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.1 The Python Interpreter . . . . . . . . . . . . . . . . . . 2
1.1.2 Preview of a Python Program . . . . . . . . . . . . . . 3
1.2 Objects in Python . . . . . . . . . . . . . . . . . . . . . . . . 4
1.2.1 Identiﬁers, Objects, and the Assignment Statement . . . 4
1.2.2 Creating and Using Objects . . . . . . . . . . . . . . . . 6
1.2.3 Python’s Built-In Classes . . . . . . . . . . . . . . . . . 7
1.3 Expressions, Operators, and Precedence . . . . . . . . . . . 12
1.3.1 Compound Expressions and Operator Precedence . . . . 17
1.4 Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4.1 Conditionals . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4.2 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.5 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.5.1 Information Passing . . . . . . . . . . . . . . . . . . . . 24
1.5.2 Python’s Built-In Functions . . . . . . . . . . . . . . . . 28
1.6 Simple Input and Output . . . . . . . . . . . . . . . . . . . . 30
1.6.1 Console Input and Output . . . . . . . . . . . . . . . . 30
1.6.2 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.7 Exception Handling . . . . . . . . . . . . . . . . . . . . . . . 33
1.7.1 Raising an Exception . . . . . . . . . . . . . . . . . . . 34
1.7.2 Catching an Exception . . . . . . . . . . . . . . . . . . 36
1.8 Iterators and Generators . . . . . . . . . . . . . . . . . . . . 39
1.9 Additional Python Conveniences . . . . . . . . . . . . . . . . 42
1.9.1 Conditional Expressions . . . . . . . . . . . . . . . . . . 42
1.9.2 Comprehension Syntax . . . . . . . . . . . . . . . . . . 43
1.9.3 Packing and Unpacking of Sequences . . . . . . . . . . 44
1.10 Scopes and Namespaces . . . . . . . . . . . . . . . . . . . . 46
1.11 Modules and the Import Statement . . . . . . . . . . . . . . 48
1.11.1 Existing Modules . . . . . . . . . . . . . . . . . . . . . 49
1.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51xii Contents
2 Object-Oriented Programming 56
2.1 Goals, Principles, and Patterns . . . . . . . . . . . . . . . . 57
2.1.1 Object-Oriented Design Goals . . . . . . . . . . . . . . 57
2.1.2 Object-Oriented Design Principles . . . . . . . . . . . . 58
2.1.3 Design Patterns . . . . . . . . . . . . . . . . . . . . . . 61
2.2 Software Development . . . . . . . . . . . . . . . . . . . . . 62
2.2.1 Design . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
2.2.2 Pseudo-Code . . . . . . . . . . . . . . . . . . . . . . . 64
2.2.3 Coding Style and Documentation . . . . . . . . . . . . . 64
2.2.4 Testing and Debugging . . . . . . . . . . . . . . . . . . 67
2.3 Class Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . 69
2.3.1 Example: CreditCard Class . . . . . . . . . . . . . . . . 69
2.3.2 Operator Overloading and Python’s Special Methods . . 74
2.3.3 Example: Multidimensional Vector Class . . . . . . . . . 77
2.3.4 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . 79
2.3.5 Example: Range Class . . . . . . . . . . . . . . . . . . . 80
2.4 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
2.4.1 Extending the CreditCard Class . . . . . . . . . . . . . . 83
2.4.2 Hierarchy of Numeric Progressions . . . . . . . . . . . . 87
2.4.3 Abstract Base Classes . . . . . . . . . . . . . . . . . . . 93
2.5 Namespaces and Object-Orientation . . . . . . . . . . . . . 96
2.5.1 Instance and Class Namespaces . . . . . . . . . . . . . . 96
2.5.2 Name Resolution and Dynamic Dispatch . . . . . . . . . 100
2.6 Shallow and Deep Copying . . . . . . . . . . . . . . . . . . . 101
2.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
3 Algorithm Analysis 109
3.1 Experimental Studies . . . . . . . . . . . . . . . . . . . . . . 111
3.1.1 Moving Beyond Experimental Analysis . . . . . . . . . . 113
3.2 The Seven Functions Used in This Book . . . . . . . . . . . 115
3.2.1 Comparing Growth Rates . . . . . . . . . . . . . . . . . 122
3.3 Asymptotic Analysis . . . . . . . . . . . . . . . . . . . . . . . 123
3.3.1 The “Big-Oh” Notation . . . . . . . . . . . . . . . . . . 123
3.3.2 Comparative Analysis . . . . . . . . . . . . . . . . . . . 128
3.3.3 Examples of Algorithm Analysis . . . . . . . . . . . . . 130
3.4 Simple Justiﬁcation Techniques . . . . . . . . . . . . . . . . 137
3.4.1 By Example . . . . . . . . . . . . . . . . . . . . . . . . 137
3.4.2 The “Contra” Attack . . . . . . . . . . . . . . . . . . . 137
3.4.3 Induction and Loop Invariants . . . . . . . . . . . . . . 138Contents xiii
4 Recursion 148
4.1 Illustrative Examples . . . . . . . . . . . . . . . . . . . . . . 150
4.1.1 The Factorial Function . . . . . . . . . . . . . . . . . . 150
4.1.2 Drawing an English Ruler . . . . . . . . . . . . . . . . . 152
4.1.3 Binary Search . . . . . . . . . . . . . . . . . . . . . . . 155
4.1.4 File Systems . . . . . . . . . . . . . . . . . . . . . . . . 157
4.2 Analyzing Recursive Algorithms . . . . . . . . . . . . . . . . 161
4.3 Recursion Run Amok . . . . . . . . . . . . . . . . . . . . . . 165
4.3.1 Maximum Recursive Depth in Python . . . . . . . . . . 168
4.4 Further Examples of Recursion . . . . . . . . . . . . . . . . . 169
4.4.1 Linear Recursion . . . . . . . . . . . . . . . . . . . . . . 169
4.4.2 Binary Recursion . . . . . . . . . . . . . . . . . . . . . 174
4.4.3 Multiple Recursion . . . . . . . . . . . . . . . . . . . . 175
4.5 Designing Recursive Algorithms . . . . . . . . . . . . . . . . 177
4.6 Eliminating Tail Recursion . . . . . . . . . . . . . . . . . . . 178
4.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
5 Array-Based Sequences 183
5.1 Python’s Sequence Types . . . . . . . . . . . . . . . . . . . . 184
5.2 Low-Level Arrays . . . . . . . . . . . . . . . . . . . . . . . . . 185
5.2.1 Referential Arrays . . . . . . . . . . . . . . . . . . . . . 187
5.2.2 Compact Arrays in Python . . . . . . . . . . . . . . . . 190
5.3 Dynamic Arrays and Amortization . . . . . . . . . . . . . . . 192
5.3.1 Implementing a Dynamic Array . . . . . . . . . . . . . . 195
5.3.2 Amortized Analysis of Dynamic Arrays . . . . . . . . . . 197
5.3.3 Python’s List Class . . . . . . . . . . . . . . . . . . . . 201
5.4 Eﬃciency of Python’s Sequence Types . . . . . . . . . . . . 202
5.4.1 Python’s List and Tuple Classes . . . . . . . . . . . . . 202
5.4.2 Python’s String Class . . . . . . . . . . . . . . . . . . . 208
5.5 Using Array-Based Sequences . . . . . . . . . . . . . . . . . 210
5.5.1 Storing High Scores for a Game . . . . . . . . . . . . . 210
5.5.2 Sorting a Sequence . . . . . . . . . . . . . . . . . . . . 214
5.5.3 Simple Cryptography . . . . . . . . . . . . . . . . . . . 216
5.6 Multidimensional Data Sets . . . . . . . . . . . . . . . . . . 219
5.7 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
6 Stacks, Queues, and Deques 228
6.1 Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
6.1.1 The Stack Abstract Data Type . . . . . . . . . . . . . . 230
6.1.2 Simple Array-Based Stack Implementation . . . . . . . . 231
6.1.3 Reversing Data Using a Stack . . . . . . . . . . . . . . 235xiv Contents
6.2 Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
6.2.1 The Queue Abstract Data Type . . . . . . . . . . . . . 240
6.2.2 Array-Based Queue Implementation . . . . . . . . . . . 241
6.3 Double-Ended Queues . . . . . . . . . . . . . . . . . . . . . . 247
6.3.1 The Deque Abstract Data Type . . . . . . . . . . . . . 247
6.3.2 Implementing a Deque with a Circular Array . . . . . . . 248
6.3.3 Deques in the Python Collections Module . . . . . . . . 249
6.4 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
7 Linked Lists 255
7.1 Singly Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . 256
7.1.1 Implementing a Stack with a Singly Linked List . . . . . 261
7.1.2 Implementing a Queue with a Singly Linked List . . . . . 264
7.2 Circularly Linked Lists . . . . . . . . . . . . . . . . . . . . . . 266
7.2.1 Round-Robin Schedulers . . . . . . . . . . . . . . . . . 267
7.2.2 Implementing a Queue with a Circularly Linked List . . . 268
7.3 Doubly Linked Lists . . . . . . . . . . . . . . . . . . . . . . . 270
7.3.1 Basic Implementation of a Doubly Linked List . . . . . . 273
7.3.2 Implementing a Deque with a Doubly Linked List . . . . 275
7.4 The Positional List ADT . . . . . . . . . . . . . . . . . . . . 277
7.4.1 The Positional List Abstract Data Type . . . . . . . . . 279
7.4.2 Doubly Linked List Implementation . . . . . . . . . . . . 281
7.5 Sorting a Positional List . . . . . . . . . . . . . . . . . . . . 285
7.6 Case Study: Maintaining Access Frequencies . . . . . . . . 286
7.6.1 Using a Sorted List . . . . . . . . . . . . . . . . . . . . 286
7.6.2 Using a List with the Move-to-Front Heuristic . . . . . . 289
7.7 Link-Based vs. Array-Based Sequences . . . . . . . . . . . . 292
7.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
8 Trees 299
8.1 General Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . 300
8.1.1 Tree Deﬁnitions and Properties . . . . . . . . . . . . . . 301
8.1.2 The Tree Abstract Data Type . . . . . . . . . . . . . . 305
8.1.3 Computing Depth and Height . . . . . . . . . . . . . . . 308
8.2 Binary Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
8.2.1 The Binary Tree Abstract Data Type . . . . . . . . . . . 313
8.2.2 Properties of Binary Trees . . . . . . . . . . . . . . . . 315
8.3 Implementing Trees . . . . . . . . . . . . . . . . . . . . . . . 317
8.3.1 Linked Structure for Binary Trees . . . . . . . . . . . . . 317
8.3.2 Array-Based Representation of a Binary Tree . . . . . . 325
8.3.3 Linked Structure for General Trees . . . . . . . . . . . . 327Contents xv
8.4.1 Preorder and Postorder Traversals of General Trees . . . 328
8.4.2 Breadth-First Tree Traversal . . . . . . . . . . . . . . . 330
8.4.3 Inorder Traversal of a Binary Tree . . . . . . . . . . . . 331
8.4.4 Implementing Tree Traversals in Python . . . . . . . . . 333
8.4.5 Applications of Tree Traversals . . . . . . . . . . . . . . 337
(cid:2)
8.4.6 Euler Tours and the Template Method Pattern . . . . 341
8.5 Case Study: An Expression Tree . . . . . . . . . . . . . . . . 348
8.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
9 Priority Queues 362
9.1 The Priority Queue Abstract Data Type . . . . . . . . . . . 363
9.1.1 Priorities . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9.1.2 The Priority Queue ADT . . . . . . . . . . . . . . . . . 364
9.2 Implementing a Priority Queue . . . . . . . . . . . . . . . . 365
9.2.1 The Composition Design Pattern . . . . . . . . . . . . . 365
9.2.2 Implementation with an Unsorted List . . . . . . . . . . 366
9.2.3 Implementation with a Sorted List . . . . . . . . . . . . 368
9.3 Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370
9.3.1 The Heap Data Structure . . . . . . . . . . . . . . . . . 370
9.3.2 Implementing a Priority Queue with a Heap . . . . . . . 372
9.3.3 Array-Based Representation of a Complete Binary Tree . 376
9.3.4 Python Heap Implementation . . . . . . . . . . . . . . . 376
9.3.5 Analysis of a Heap-Based Priority Queue . . . . . . . . . 379
(cid:2)
9.3.6 Bottom-Up Heap Construction . . . . . . . . . . . . . 380
9.3.7 Python’s heapq Module . . . . . . . . . . . . . . . . . . 384
9.4 Sorting with a Priority Queue . . . . . . . . . . . . . . . . . 385
9.4.1 Selection-Sort and Insertion-Sort . . . . . . . . . . . . . 386
9.4.2 Heap-Sort . . . . . . . . . . . . . . . . . . . . . . . . . 388
9.5 Adaptable Priority Queues . . . . . . . . . . . . . . . . . . . 390
9.5.1 Locators . . . . . . . . . . . . . . . . . . . . . . . . . . 390
9.5.2 Implementing an Adaptable Priority Queue . . . . . . . 391
9.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395
10 Maps, Hash Tables, and Skip Lists 401
10.1 Maps and Dictionaries . . . . . . . . . . . . . . . . . . . . . 402
10.1.1 The Map ADT . . . . . . . . . . . . . . . . . . . . . . 403
10.1.2 Application: Counting Word Frequencies . . . . . . . . . 405
10.1.3 Python’s MutableMapping Abstract Base Class . . . . . 406
10.1.4 Our MapBase Class . . . . . . . . . . . . . . . . . . . . 407
10.1.5 Simple Unsorted Map Implementation . . . . . . . . . . 408
10.2 Hash Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . 410xvi Contents
10.2.2 Collision-Handling Schemes . . . . . . . . . . . . . . . . 417
10.2.3 Load Factors, Rehashing, and Eﬃciency . . . . . . . . . 420
10.2.4 Python Hash Table Implementation . . . . . . . . . . . 422
10.3 Sorted Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . 427
10.3.1 Sorted Search Tables . . . . . . . . . . . . . . . . . . . 428
10.3.2 Two Applications of Sorted Maps . . . . . . . . . . . . 434
10.4 Skip Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
10.4.1 Search and Update Operations in a Skip List . . . . . . 439
(cid:2)
10.4.2 Probabilistic Analysis of Skip Lists . . . . . . . . . . . 443
10.5 Sets, Multisets, and Multimaps . . . . . . . . . . . . . . . . 446
10.5.1 The Set ADT . . . . . . . . . . . . . . . . . . . . . . . 446
10.5.2 Python’s MutableSet Abstract Base Class . . . . . . . . 448
10.5.3 Implementing Sets, Multisets, and Multimaps . . . . . . 450
10.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
11 Search Trees 459
11.1 Binary Search Trees . . . . . . . . . . . . . . . . . . . . . . . 460
11.1.1 Navigating a Binary Search Tree . . . . . . . . . . . . . 461
11.1.2 Searches . . . . . . . . . . . . . . . . . . . . . . . . . . 463
11.1.3 Insertions and Deletions . . . . . . . . . . . . . . . . . . 465
11.1.4 Python Implementation . . . . . . . . . . . . . . . . . . 468
11.1.5 Performance of a Binary Search Tree . . . . . . . . . . . 473
11.2 Balanced Search Trees . . . . . . . . . . . . . . . . . . . . . 475
11.2.1 Python Framework for Balancing Search Trees . . . . . . 478
11.3 AVL Trees. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
11.3.1 Update Operations . . . . . . . . . . . . . . . . . . . . 483
11.3.2 Python Implementation . . . . . . . . . . . . . . . . . . 488
11.4 Splay Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.4.1 Splaying . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.4.2 When to Splay . . . . . . . . . . . . . . . . . . . . . . . 494
11.4.3 Python Implementation . . . . . . . . . . . . . . . . . . 496
(cid:2)
11.4.4 Amortized Analysis of Splaying . . . . . . . . . . . . 497
11.5 (2,4) Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
11.5.1 Multiway Search Trees . . . . . . . . . . . . . . . . . . 502
11.5.2 (2,4)-Tree Operations . . . . . . . . . . . . . . . . . . . 505
11.6 Red-Black Trees . . . . . . . . . . . . . . . . . . . . . . . . . 512
11.6.1 Red-Black Tree Operations . . . . . . . . . . . . . . . . 514
11.6.2 Python Implementation . . . . . . . . . . . . . . . . . . 525Contents xvii
12 Sorting and Selection 536
12.1 Why Study Sorting Algorithms? . . . . . . . . . . . . . . . . 537
12.2 Merge-Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
12.2.1 Divide-and-Conquer . . . . . . . . . . . . . . . . . . . . 538
12.2.2 Array-Based Implementation of Merge-Sort . . . . . . . 543
12.2.3 The Running Time of Merge-Sort . . . . . . . . . . . . 544
(cid:2)
12.2.4 Merge-Sort and Recurrence Equations . . . . . . . . . 546
12.2.5 Alternative Implementations of Merge-Sort . . . . . . . 547
12.3 Quick-Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550
12.3.1 Randomized Quick-Sort . . . . . . . . . . . . . . . . . . 557
12.3.2 Additional Optimizations for Quick-Sort . . . . . . . . . 559
12.4 Studying Sorting through an Algorithmic Lens . . . . . . . 562
12.4.1 Lower Bound for Sorting . . . . . . . . . . . . . . . . . 562
12.4.2 Linear-Time Sorting: Bucket-Sort and Radix-Sort . . . . 564
12.5 Comparing Sorting Algorithms . . . . . . . . . . . . . . . . . 567
12.6 Python’s Built-In Sorting Functions . . . . . . . . . . . . . . 569
12.6.1 Sorting According to a Key Function . . . . . . . . . . . 569
12.7 Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
12.7.1 Prune-and-Search . . . . . . . . . . . . . . . . . . . . . 571
12.7.2 Randomized Quick-Select . . . . . . . . . . . . . . . . . 572
12.7.3 Analyzing Randomized Quick-Select . . . . . . . . . . . 573
12.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
13 Text Processing 581
13.1 Abundance of Digitized Text . . . . . . . . . . . . . . . . . . 582
13.1.1 Notations for Strings and the Python str Class. . . . . . 583
13.2 Pattern-Matching Algorithms . . . . . . . . . . . . . . . . . 584
13.2.1 Brute Force . . . . . . . . . . . . . . . . . . . . . . . . 584
13.2.2 The Boyer-Moore Algorithm . . . . . . . . . . . . . . . 586
13.2.3 The Knuth-Morris-Pratt Algorithm . . . . . . . . . . . . 590
13.3 Dynamic Programming . . . . . . . . . . . . . . . . . . . . . 594
13.3.1 Matrix Chain-Product . . . . . . . . . . . . . . . . . . . 594
13.3.2 DNA and Text Sequence Alignment . . . . . . . . . . . 597
13.4 Text Compression and the Greedy Method . . . . . . . . . 601
13.4.1 The Huﬀman Coding Algorithm . . . . . . . . . . . . . 602
13.4.2 The Greedy Method . . . . . . . . . . . . . . . . . . . . 603
13.5 Tries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
13.5.1 Standard Tries . . . . . . . . . . . . . . . . . . . . . . . 604
13.5.2 Compressed Tries . . . . . . . . . . . . . . . . . . . . . 608
13.5.3 Suﬃx Tries . . . . . . . . . . . . . . . . . . . . . . . . 610xviii Contents
13.6 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 613
14 Graph Algorithms 619
14.1 Graphs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620
14.1.1 The Graph ADT . . . . . . . . . . . . . . . . . . . . . . 626
14.2 Data Structures for Graphs . . . . . . . . . . . . . . . . . . . 627
14.2.1 Edge List Structure . . . . . . . . . . . . . . . . . . . . 628
14.2.2 Adjacency List Structure . . . . . . . . . . . . . . . . . 630
14.2.3 Adjacency Map Structure . . . . . . . . . . . . . . . . . 632
14.2.4 Adjacency Matrix Structure . . . . . . . . . . . . . . . . 633
14.2.5 Python Implementation . . . . . . . . . . . . . . . . . . 634
14.3 Graph Traversals . . . . . . . . . . . . . . . . . . . . . . . . . 638
14.3.1 Depth-First Search . . . . . . . . . . . . . . . . . . . . 639
14.3.2 DFS Implementation and Extensions . . . . . . . . . . . 644
14.3.3 Breadth-First Search . . . . . . . . . . . . . . . . . . . 648
14.4 Transitive Closure . . . . . . . . . . . . . . . . . . . . . . . . 651
14.5 Directed Acyclic Graphs . . . . . . . . . . . . . . . . . . . . 655
14.5.1 Topological Ordering . . . . . . . . . . . . . . . . . . . 655
14.6 Shortest Paths . . . . . . . . . . . . . . . . . . . . . . . . . . 659
14.6.1 Weighted Graphs . . . . . . . . . . . . . . . . . . . . . 659
14.6.2 Dijkstra’s Algorithm . . . . . . . . . . . . . . . . . . . . 661
14.7 Minimum Spanning Trees . . . . . . . . . . . . . . . . . . . . 670
14.7.1 Prim-Jarn´ık Algorithm . . . . . . . . . . . . . . . . . . 672
14.7.2 Kruskal’s Algorithm . . . . . . . . . . . . . . . . . . . . 676
14.7.3 Disjoint Partitions and Union-Find Structures . . . . . . 681
14.8 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 686
15 Memory Management and B-Trees 697
15.1 Memory Management . . . . . . . . . . . . . . . . . . . . . . 698
15.1.1 Memory Allocation . . . . . . . . . . . . . . . . . . . . 699
15.1.2 Garbage Collection . . . . . . . . . . . . . . . . . . . . 700
15.1.3 Additional Memory Used by the Python Interpreter . . . 703
15.2 Memory Hierarchies and Caching . . . . . . . . . . . . . . . 705
15.2.1 Memory Systems . . . . . . . . . . . . . . . . . . . . . 705
15.2.2 Caching Strategies . . . . . . . . . . . . . . . . . . . . 706
15.3 External Searching and B-Trees . . . . . . . . . . . . . . . . 711
15.3.1 (a,b) Trees . . . . . . . . . . . . . . . . . . . . . . . . . 712
15.3.2 B-Trees . . . . . . . . . . . . . . . . . . . . . . . . . . 714
15.4 External-Memory Sorting . . . . . . . . . . . . . . . . . . . . 715
15.4.1 Multiway Merging . . . . . . . . . . . . . . . . . . . . . 716Contents xix
A Character Strings in Python 721
B Useful Mathematical Facts 725
Bibliography 732Chapter
1
Python Primer
Contents
1.1 Python Overview . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.1 The Python Interpreter . . . . . . . . . . . . . . . . . . . 2
1.1.2 Preview of a Python Program . . . . . . . . . . . . . . . 3
1.2 Objects in Python . . . . . . . . . . . . . . . . . . . . . . . 4
1.2.1 Identiﬁers, Objects, and the Assignment Statement . . . . 4
1.2.2 Creating and Using Objects . . . . . . . . . . . . . . . . . 6
1.2.3 Python’s Built-In Classes . . . . . . . . . . . . . . . . . . 7
1.3 Expressions, Operators, and Precedence . . . . . . . . . . . 12
1.3.1 Compound Expressions and Operator Precedence . . . . . 17
1.4 Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4.1 Conditionals . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4.2 Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.5 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.5.1 Information Passing . . . . . . . . . . . . . . . . . . . . . 24
1.5.2 Python’s Built-In Functions . . . . . . . . . . . . . . . . . 28
1.6 Simple Input and Output . . . . . . . . . . . . . . . . . . . 30
1.6.1 Console Input and Output . . . . . . . . . . . . . . . . . 30
1.6.2 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
1.7 Exception Handling . . . . . . . . . . . . . . . . . . . . . . 33
1.7.1 Raising an Exception . . . . . . . . . . . . . . . . . . . . 34
1.7.2 Catching an Exception . . . . . . . . . . . . . . . . . . . 36
1.8 Iterators and Generators . . . . . . . . . . . . . . . . . . . 39
1.9 Additional Python Conveniences . . . . . . . . . . . . . . . 42
1.9.1 Conditional Expressions . . . . . . . . . . . . . . . . . . . 42
1.9.2 Comprehension Syntax . . . . . . . . . . . . . . . . . . . 43
1.9.3 Packing and Unpacking of Sequences . . . . . . . . . . . 44
1.10 Scopes and Namespaces . . . . . . . . . . . . . . . . . . . 46
1.11 Modules and the Import Statement . . . . . . . . . . . . . 48
1.11.1 Existing Modules . . . . . . . . . . . . . . . . . . . . . . 492 Chapter1. PythonPrimer
1.1 Python Overview
Building datastructures and algorithms requires that wecommunicate detailed in-
structions to a computer. An excellent way to perform such communications is
using a high-level computer language, such as Python. The Python programming
language was originally developed by Guido van Rossum in the early 1990s, and
hassincebecomeaprominentlyusedlanguageinindustryandeducation. Thesec-
ond major version of the language, Python 2, was released in 2000, and the third
major version, Python 3, released in 2008. We note that there are signiﬁcant in-
compatibilities between Python 2 and Python 3. This book is based on Python 3
(morespeciﬁcally,Python3.1orlater). Thelatestversionofthelanguageisfreely
available atwww.python.org,alongwithdocumentation andtutorials.
In this chapter, weprovide anoverview of the Python programming language,
and we continue this discussion in the next chapter, focusing on object-oriented
principles. We assume that readers of this book have prior programming experi-
ence, although not necessarily using Python. This book does not provide a com-
plete description of the Python language (there are numerous language references
for that purpose), but it does introduce all aspects of the language that are used in
codefragments laterinthisbook.
1.1.1 The Python Interpreter
Python is formally an interpreted language. Commands are executed through a
pieceofsoftwareknownasthePythoninterpreter. Theinterpreterreceivesacom-
mand, evaluates that command, and reports the result of the command. While the
interpreter can be used interactively (especially when debugging), a programmer
typically deﬁnes aseries of commands inadvance and saves those commands in a
plaintextﬁleknownassourcecodeorascript. ForPython,sourcecodeisconven-
tionally storedinaﬁlenamedwiththe.pysufﬁx(e.g.,demo.py).
On most operating systems, the Python interpreter can be started by typing
python from the command line. By default, the interpreter starts in interactive
mode with a clean workspace. Commands from a predeﬁned script saved in a
ﬁle (e.g., demo.py) are executed by invoking the interpreter with the ﬁlename as
an argument (e.g., python demo.py), or using an additional -i ﬂag in order to
executeascriptandthenenterinteractive mode(e.g.,python -i demo.py).
Many integrated development environments (IDEs) provide richer software
development platforms for Python, including one named IDLE that is included
withthestandardPythondistribution. IDLEprovidesanembeddedtext-editorwith
support for displaying and editing Python code, and a basic debugger, allowing1.1. PythonOverview 3
1.1.2 Preview of a Python Program
Asasimpleintroduction, CodeFragment1.1presents aPythonprogram thatcom-
putes the grade-point average (GPA) for a student based on letter grades that are
entered by a user. Many of the techniques demonstrated in this example will be
discussedintheremainderofthischapter. Atthispoint,wedrawattentiontoafew
high-level issues,forreaderswhoarenewtoPythonasaprogramminglanguage.
Python’s syntax relies heavily on the use ofwhitespace. Individual statements
are typically concluded with anewline character, althoughacommand can extend
to another line, either with a concluding backslash character (\), or if an opening
delimiterhasnotyetbeenclosed, suchasthe{characterindeﬁningvalue map.
Whitespace isalsokeyindelimitingthebodiesofcontrolstructures inPython.
Speciﬁcally, a block of code is indented to designate it as the body of a control
structure, and nested control structures use increasing amounts of indentation. In
Code Fragment 1.1, the body ofthe whileloop consists of the subsequent 8 lines,
including anestedconditional structure.
Comments are annotations provided for human readers, yet ignored by the
Python interpreter. The primary syntax for comments in Python is based on use
ofthe#character, whichdesignates theremainder ofthelineasacomment.
print( Welcome to the GPA calculator. )
print( Please enter all your letter grades, one per line. )
print( Enter a blank line to designate the end. )
# map from letter grade to point value
points = { A+ :4.0, A :4.0, A- :3.67, B+ :3.33, B :3.0, B- :2.67,
C+ :2.33, C :2.0, C :1.67, D+ :1.33, D :1.0, F :0.0}
num courses = 0
total points = 0
done = False
while not done:
grade = input( ) # read line from user
if grade == : # empty line was entered
done = True
elif grade not in points: # unrecognized grade entered
print("Unknown grade {0} being ignored".format(grade))
else:
num courses += 1
total points += points[grade]
if num courses > 0: # avoid division by zero
print( Your GPA is {0:.3} .format(total points / num courses))4 Chapter1. PythonPrimer
1.2 Objects in Python
Pythonisanobject-oriented languageandclasses formthebasisforalldatatypes.
In this section, we describe key aspects of Python’s object model, and we intro-
duce Python’s built-in classes, such as the int class for integers, the ﬂoat class
for ﬂoating-point values, and the str class for character strings. A more thorough
presentation ofobject-orientation isthefocusofChapter2.
1.2.1 Identiﬁers, Objects, and the Assignment Statement
ThemostimportantofallPythoncommandsisanassignmentstatement,suchas
temperature = 98.6
This command establishes temperature as an identiﬁer (also known as a name),
andthen associates itwiththeobject expressed ontheright-hand sideoftheequal
sign, in this case a ﬂoating-point object with value98.6. We portray the outcome
ofthisassignmentinFigure1.1.
ﬂoat
temperature
98.6
Figure 1.1: The identiﬁer temperature references an instance of the ﬂoat class
havingvalue98.6.
Identiﬁers
Identiﬁers in Python are case-sensitive, so temperature and Temperature are dis-
tinct names. Identiﬁers can be composed of almost any combination of letters,
numerals, and underscore characters (or more general Unicode characters). The
primary restrictions are that an identiﬁer cannot begin with a numeral (thus 9lives
is an illegal name), and that there are 33 specially reserved words that cannot be
usedasidentiﬁers, asshowninTable1.1.
ReservedWords
False as continue else from in not return yield
None assert def except global is or try
True break del ﬁnally if lambda pass while
and class elif for import nonlocal raise with
Table1.1: A listing of the reserved words in Python. These names cannotbe used1.2. ObjectsinPython 5
For readers familiar with other programming languages, the semantics of a
PythonidentiﬁerismostsimilartoareferencevariableinJavaorapointervariable
in C++. Each identiﬁer is implicitly associated with the memory address of the
object to which it refers. A Python identiﬁer may be assigned to a special object
namedNone,servingasimilarpurpose toanullreference inJavaorC++.
Unlike Java and C++, Python is a dynamically typed language, as there is no
advance declaration associating an identiﬁer with a particular data type. An iden-
tiﬁer can be associated with any type of object, and it can later be reassigned to
another object of the same (or different) type. Although an identiﬁer has no de-
clared type, the object to which it refers has a deﬁnite type. In our ﬁrst example,
thecharacters 98.6arerecognized asaﬂoating-point literal, andthustheidentiﬁer
temperatureisassociated withaninstanceoftheﬂoatclasshavingthatvalue.
A programmer can establish an alias by assigning a second identiﬁer to an
existingobject. Continuing withourearlierexample,Figure1.2portraystheresult
ofasubsequent assignment,original = temperature.
ﬂoat
temperature original
98.6
Figure1.2: Identiﬁerstemperatureandoriginalarealiasesforthesameobject.
Onceanaliashasbeenestablished,eithernamecanbeusedtoaccesstheunder-
lying object. Ifthatobject supports behaviors thataffectitsstate, changes enacted
throughonealiaswillbeapparentwhenusingtheotheralias(becausetheyreferto
the sameobject). However, if oneof thenames isreassigned toanew value using
asubsequent assignment statement, thatdoesnotaffectthealiased object, ratherit
breaksthealias. Continuingwithourconcreteexample,weconsiderthecommand:
temperature = temperature + 5.0
Theexecutionofthiscommandbeginswiththeevaluationoftheexpressiononthe
right-hand side of the = operator. That expression, temperature + 5.0, is eval-
uated based on the existing binding of the name temperature, and so the result
has value 103.6, that is, 98.6 + 5.0. That result is stored as a new ﬂoating-point
instance, and only then is the name on the left-hand side of the assignment state-
ment,temperature,(re)assigned totheresult. Thesubsequent conﬁguration isdia-
grammedinFigure1.3. Ofparticular note, this lastcommandhad noeffect onthe
valueoftheexistingﬂoatinstance thatidentiﬁeroriginalcontinues toreference.
ﬂoat ﬂoat
temperature original
103.6 98.6
Figure 1.3: The temperature identiﬁer has been assigned to a new value, while6 Chapter1. PythonPrimer
1.2.2 Creating and Using Objects
Instantiation
The process of creating a new instance of a class is known as instantiation. In
general,thesyntaxforinstantiatinganobjectistoinvoketheconstructorofaclass.
For example, if there were a class named Widget, we could create an instance of
thatclassusingasyntaxsuchasw = Widget(),assumingthattheconstructordoes
not require any parameters. If the constructor does require parameters, we might
useasyntaxsuchasWidget(a, b, c)toconstruct anewinstance.
Many of Python’s built-in classes (discussed in Section 1.2.3) support what is
knownasaliteralformfordesignating newinstances. Forexample, thecommand
temperature = 98.6resultsinthecreationofanewinstanceoftheﬂoatclass;the
term 98.6 in that expression is a literal form. We discuss further cases of Python
literalsinthecomingsection.
From a programmer’s perspective, yet another way to indirectly create a new
instanceofaclassistocallafunctionthatcreatesandreturnssuchaninstance. For
example,Pythonhasabuilt-infunctionnamedsorted(seeSection1.5.2)thattakes
a sequence of comparable elements as a parameter and returns a new instance of
thelistclasscontaining thoseelementsinsortedorder.
Calling Methods
Pythonsupportstraditional functions (seeSection1.5)thatareinvoked withasyn-
tax such as sorted(data), in which case data is a parameter sent to the function.
Python’s classes may also deﬁne one or more methods (also known as member
functions), which are invoked on a speciﬁc instance of a class using the dot (“.”)
operator. For example, Python’s list class has a method named sort that can be
invoked with a syntax such as data.sort(). This particular method rearranges the
contents ofthelistsothattheyaresorted.
Theexpressiontotheleftofthedotidentiﬁestheobjectuponwhichthemethod
isinvoked. Often, this willbe an identiﬁer (e.g.,data), but wecan use the dot op-
erator to invoke amethod upon the immediate result of some other operation. For
example,ifresponseidentiﬁesastringinstance(wewilldiscussstringslaterinthis
section), the syntax response.lower().startswith( y ) ﬁrst evaluates the method
call, response.lower(), which itself returns a new string instance, and then the
startswith( y )methodiscalledonthatintermediate string.
When using a method of a class, it is important to understand its behavior.
Some methods return information about the state of an object, but do not change
that state. These are known asaccessors. Othermethods, such as thesortmethod
of the list class, do change the state of an object. These methods are known as1.2. ObjectsinPython 7
1.2.3 Python’s Built-In Classes
Table 1.2 provides a summary of commonly used, built-in classes in Python; we
takeparticularnoteofwhichclassesaremutableandwhichareimmutable. Aclass
is immutable if each object of that class has a ﬁxed value upon instantiation that
cannot subsequently be changed. Forexample, theﬂoatclass is immutable. Once
an instance has been created, its value cannot be changed (although an identiﬁer
referencing thatobjectcanbereassigned toadifferent value).
Class Description Immutable?
bool Booleanvalue (cid:2)
int integer(arbitrary magnitude) (cid:2)
ﬂoat ﬂoating-point number (cid:2)
list mutablesequence ofobjects
tuple immutablesequence ofobjects (cid:2)
str characterstring (cid:2)
set unordered setofdistinctobjects
frozenset immutableformofsetclass (cid:2)
dict associativemapping(akadictionary)
Table1.2: Commonlyusedbuilt-in classesforPython
In this section, we provide an introduction to these classes, discussing their
purpose and presenting several means forcreating instances ofthe classes. Literal
forms (such as 98.6) exist for most of the built-in classes, and all of the classes
support a traditional constructor form that creates instances that are based upon
oneormoreexisting values. Operators supported bythese classes aredescribed in
Section 1.3. More detailed information about these classes can be found in later
chapters as follows: lists and tuples (Chapter 5); strings (Chapters 5 and 13, and
AppendixA);setsanddictionaries (Chapter10).
The bool Class
The bool class is used to manipulate logical (Boolean) values, and the only two
instances of that class are expressed as the literals True and False. The default
constructor, bool(), returns False, but there is no reason to use that syntax rather
than the more direct literal form. Python allows the creation of a Boolean value
fromanonbooleantypeusingthesyntaxbool(foo)forvaluefoo. Theinterpretation
depends upon the type of the parameter. Numbers evaluate to False if zero, and
True if nonzero. Sequences and other container types, such as strings and lists,
evaluate toFalseif empty and True if nonempty. An important application of this8 Chapter1. PythonPrimer
The int Class
TheintandﬂoatclassesaretheprimarynumerictypesinPython. Theintclassis
designed to represent integer values with arbitrary magnitude. Unlike Java and
C++, which support different integral types with different precisions (e.g., int,
short, long), Python automatically chooses the internal representation for an in-
tegerbaseduponthemagnitude ofitsvalue. Typicalliterals forintegers include0,
137,and−23. Insomecontexts, itisconvenient toexpressanintegral valueusing
binary, octal, or hexadecimal. That can be done by using apreﬁx of the number 0
andthenacharacter todescribe thebase. Exampleofsuchliterals arerespectively
0b1011,0o52,and0x7f.
The integer constructor, int(), returns value 0 by default. But this constructor
can be used to construct an integer value based upon an existing value of another
type. Forexample, iffrepresents aﬂoating-point value, thesyntaxint(f)produces
the truncated value of f. For example, both int(3.14) and int(3.99) produce the
value 3,while int(−3.9) produces the value−3. Theconstructor can also beused
to parse a string that is presumed to represent an integral value (such as one en-
tered by a user). If s represents a string, then int(s) produces the integral value
that string represents. For example, the expression int( 137 ) produces the inte-
ger value 137. If an invalid string is given as a parameter, as in int( hello ), a
ValueErrorisraised(seeSection1.7fordiscussionofPython’sexceptions). Byde-
fault,thestringmustusebase10. Ifconversionfromadifferentbaseisdesired,that
basecanbeindicatedasasecond,optional,parameter. Forexample,theexpression
int( 7f , 16)evaluatestotheinteger127.
The ﬂoat Class
The ﬂoat class is the sole ﬂoating-point type in Python, using a ﬁxed-precision
representation. Its precision is more akin to a double in Java or C++, rather than
thoselanguages’ﬂoattype. Wehavealready discussed atypicalliteralform,98.6.
We note that the ﬂoating-point equivalent of an integral number can be expressed
directly as 2.0. Technically, the trailing zero is optional, so some programmers
might use the expression 2. todesignate this ﬂoating-point literal. One other form
of literal for ﬂoating-point values uses scientiﬁc notation. For example, the literal
6.022e23represents themathematical value6.022×1023.
Theconstructor form ofﬂoat() returns 0.0. Whengiven aparameter, thecon-
structorattemptstoreturntheequivalentﬂoating-pointvalue. Forexample,thecall
ﬂoat(2) returns the ﬂoating-point value 2.0. If the parameter to the constructor is
a string, as with ﬂoat( 3.14 ), it attempts to parse that string as a ﬂoating-point1.2. ObjectsinPython 9
Sequence Types: The list, tuple, and str Classes
The list, tuple, and str classes are sequence types in Python, representing a col-
lectionofvaluesinwhichtheorderissigniﬁcant. Thelistclassisthemostgeneral,
representingasequenceofarbitraryobjects(akintoan“array”inotherlanguages).
Thetupleclass isanimmutableversion ofthelistclass, beneﬁting fromastream-
lined internal representation. The str class is specially designed for representing
an immutable sequence of text characters. We note that Python does not have a
separate classforcharacters; theyarejuststringswithlengthone.
The list Class
A list instance stores a sequence of objects. A list is areferential structure, as it
technically stores a sequence of references to its elements (see Figure 1.4). El-
ements of a list may be arbitrary objects (including the None object). Lists are
array-based sequences and are zero-indexed, thus a list of length n has elements
indexedfrom0ton−1inclusive. Listsareperhapsthemostusedcontainertypein
Pythonandtheywillbeextremely central toourstudy ofdatastructures andalgo-
rithms. They have many valuable behaviors, including the ability to dynamically
expandandcontracttheircapacitiesasneeded. Inthischapter,wewilldiscussonly
the most basic properties of lists. We revisit the inner working of all of Python’s
sequence typesasthefocusofChapter5.
Pythonusesthecharacters [ ]asdelimitersforalistliteral, with[ ]itselfbeing
anemptylist. Asanotherexample,[ red , green , blue ]isalistcontaining
threestringinstances. Thecontentsofalistliteralneednotbeexpressedasliterals;
ifidentiﬁersaandbhavebeenestablished, thensyntax[a, b]islegitimate.
Thelist()constructorproducesanemptylistbydefault. However,theconstruc-
tor will accept any parameter that is of an iterable type. We will discuss iteration
furtherinSection1.8,butexamplesofiterabletypesincludeallofthestandardcon-
tainer types (e.g., strings, list, tuples, sets, dictionaries). For example, the syntax
list( hello )produces alistofindividual characters,[ h , e , l , l , o ].
Because an existing list is itself iterable, the syntax backup = list(data) can be
usedtoconstruct anewlistinstancereferencing thesamecontents astheoriginal.
2 3 5 7 11 13 17 19 23 29 31
primes:
0 1 2 3 4 5 6 7 8 9 10
Figure 1.4: Python’s internal representation of a list of integers, instantiated as
prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]. The implicit indices of the ele-10 Chapter1. PythonPrimer
The tuple Class
The tuple class provides an immutable version of a sequence, and therefore its
instanceshaveaninternalrepresentation thatmaybemorestreamlinedthanthatof
a list. While Python uses the [ ] characters to delimit a list, parentheses delimit a
tuple, with () being an empty tuple. There is one important subtlety. To express
a tuple of length one as a literal, a comma must be placed after the element, but
within the parentheses. Forexample, (17,) is a one-element tuple. The reason for
thisrequirement isthat, without thetrailing comma, theexpression (17)isviewed
asasimpleparenthesized numericexpression.
The str Class
Python’s str class is speciﬁcally designed to efﬁciently represent an immutable
sequenceofcharacters, basedupontheUnicodeinternational characterset. Strings
haveamorecompactinternalrepresentation thanthereferential listsandtuples,as
portrayed inFigure1.5.
S A M P L E
0 1 2 3 4 5
Figure1.5: APythonstring, whichisanindexedsequence ofcharacters.
String literals can be enclosed in single quotes, as in hello , or double
quotes, as in "hello". This choice is convenient, especially when using an-
other of the quotation characters as an actual character in the sequence, as in
"Don t worry". Alternatively, the quote delimiter can be designated using a
backslash as a so-called escape character, as in Don\ t worry . Because the
backslash hasthispurpose, thebackslash mustitselfbeescapedtooccurasanatu-
ralcharacterofthestringliteral,asin C:\\Python\\ ,forastringthatwouldbe
displayed asC:\Python\. Othercommonlyescapedcharacters are\nfornewline
and \t for tab. Unicode characters can be included, such as 20\u20AC for the
string20 .
Python also supports using the delimiter or """ to begin and end a string
literal. The advantage of such triple-quoted strings is that newline characters can
be embedded naturally (rather than escaped as \n). This can greatly improve the
readability oflong, multilinestrings insourcecode. Forexample, atthebeginning
of Code Fragment 1.1, rather than use separate print statements for each line of
introductory output, wecanuseasingleprintstatement, asfollows:
print(”””Welcome to the GPA calculator.
Please enter all your letter grades, one per line.1.2. ObjectsinPython 11
The set and frozenset Classes
Python’ssetclassrepresents themathematical notionofaset,namelyacollection
of elements, without duplicates, and without an inherent order to those elements.
The major advantage of using a set, as opposed to a list, is that it has a highly
optimized method for checking whether a speciﬁc element is contained in the set.
Thisisbasedonadatastructure knownasahashtable(whichwillbetheprimary
topic of Chapter 10). However, there are two important restrictions due to the
algorithmic underpinnings. The ﬁrstis that the set does notmaintain the elements
inanyparticularorder. Thesecondisthatonlyinstancesofimmutabletypescanbe
addedtoaPythonset. Therefore, objects suchasintegers, ﬂoating-point numbers,
andcharacterstringsareeligibletobeelementsofaset. Itispossibletomaintaina
setoftuples, butnotasetoflistsorasetofsets, aslistsandsetsaremutable. The
frozenset class isanimmutable form oftheset type, soitislegaltohaveasetof
frozensets.
Python uses curly braces { and } as delimiters for a set, for example, as{17}
or { red , green , blue }. The exception to this rule is that { } does not
represent an empty set; for historical reasons, it represents an empty dictionary
(see next paragraph). Instead, the constructor syntaxset() produces an empty set.
If an iterable parameter is sent to the constructor, then theset of distinct elements
isproduced. Forexample,set( hello )produces{ h , e , l , o }.
The dict Class
Python’sdictclassrepresents adictionary, ormapping,fromasetofdistinctkeys
toassociatedvalues. Forexample,adictionary mightmapfromunique studentID
numbers,tolargerstudentrecords(suchasthestudent’sname,address, andcourse
grades). Python implements adict using an almost identical approach to that of a
set,butwithstorageoftheassociated values.
Adictionary literalalsousescurlybraces, andbecausedictionaries wereintro-
duced in Python prior to sets, the literal form { } produces an empty dictionary.
A nonempty dictionary is expressed using a comma-separated series of key:value
pairs. For example, the dictionary { ga : Irish , de : German } maps
ga to Irish and de to German .
The constructor for the dict class accepts an existing mapping as a parameter,
inwhichcaseitcreatesanewdictionary withidentical associations astheexisting
one. Alternatively, the constructor accepts a sequence of key-value pairs as a pa-12 Chapter1. PythonPrimer
1.3 Expressions, Operators, and Precedence
In the previous section, we demonstrated how names can be used to identify ex-
isting objects, and how literals and constructors can be used to create instances of
built-in classes. Existing values canbecombined intolarger syntactic expressions
using avariety ofspecial symbols andkeywords knownasoperators. Theseman-
tics of an operator depends upon the type of its operands. For example, when a
andbarenumbers,thesyntaxa + bindicatesaddition,whileifaandbarestrings,
the operator indicates concatenation. In this section, we describe Python’s opera-
torsinvariouscontextsofthebuilt-in types.
We continue, in Section 1.3.1, by discussing compound expressions, such as
a + b c, which rely on the evaluation of two or more operations. The order
in which the operations of a compound expression are evaluated can affect the
overall value of the expression. Forthis reason, Python deﬁnes a speciﬁc order of
precedence for evaluating operators, and it allows a programmer to override this
orderbyusingexplicitparentheses togroupsubexpressions.
Logical Operators
Pythonsupports thefollowingkeywordoperators forBooleanvalues:
not unarynegation
and conditional and
or conditional or
The and and or operators short-circuit, in that they do not evaluate the second
operand if the result can be determined based on the value of the ﬁrst operand.
Thisfeatureisusefulwhenconstructing Booleanexpressions inwhichweﬁrsttest
thatacertaincondition holds(suchasareference notbeingNone),andthentesta
condition thatcould haveotherwise generated anerror condition hadthe prior test
notsucceeded.
Equality Operators
Pythonsupports thefollowingoperators totesttwonotionsofequality:
is sameidentity
is not differentidentity
== equivalent
!= notequivalent
The expression a is b evaluates to True, precisely when identiﬁers a and b are
aliases forthesameobject. Theexpression a == btestsamoregeneral notion of
equivalence. Ifidentiﬁersaandbrefertothesameobject,thena == bshouldalso1.3. Expressions,Operators,andPrecedence 13
differentobjectsthathappentohavevaluesthataredeemedequivalent. Theprecise
notion ofequivalence depends on thedata type. Forexample,twostrings arecon-
sidered equivalent ifthey match character forcharacter. Twosets are equivalent if
theyhavethesamecontents,irrespectiveoforder. Inmostprogrammingsituations,
theequivalencetests==and!=aretheappropriate operators;useofisandis not
shouldbereservedforsituations inwhichitisnecessary todetecttruealiasing.
Comparison Operators
Datatypesmaydeﬁneanaturalorderviathefollowingoperators:
< lessthan
<= lessthanorequalto
> greaterthan
>= greaterthanorequalto
These operators have expected behavior for numeric types, and are deﬁned lexi-
cographically, and case-sensitively, for strings. An exception is raised if operands
haveincomparable types,aswith5 < hello .
Arithmetic Operators
Pythonsupports thefollowingarithmeticoperators:
+ addition
− subtraction
multiplication
/ truedivision
// integerdivision
% themodulooperator
Theuseofaddition,subtraction,andmultiplicationisstraightforward,notingthatif
bothoperandshavetypeint,thentheresultisanintaswell;ifoneorbothoperands
havetypeﬂoat,theresultwillbeaﬂoat.
Python takes more care in its treatment of division. We ﬁrst consider the case
in which both operands have type int, for example, the quantity 27 divided by
4. In mathematical notation, 27÷4 = 63 = 6.75. In Python, the / operator
4
designates true division, returning the ﬂoating-point result of the computation.
Thus, 27 / 4 results in the ﬂoat value 6.75. Python supports the pair of opera-
tors // and % toperform the integral calculations, withexpression27 // 4evalu-
atingtointvalue6(themathematicalﬂoorofthequotient),andexpression27 % 4
evaluating to int value 3, the remainder of the integer division. We note that lan-
guages suchasC,C++,andJava donotsupport the//operator; instead, the/op-
eratorreturnsthetruncatedquotientwhenbothoperandshaveintegraltype,andthe14 Chapter1. PythonPrimer
Pythoncarefullyextendsthesemanticsof//and%tocaseswhereoneorboth
operands are negative. For the sake of notation, let us assume that variables n
n
and m represent respectively the dividend and divisor of a quotient , and that
m
q = n // m and r = n % m. Python guarantees that q m + r will equal n. We
already saw an example of this identity with positive operands, as 6∗4+3 =27.
When the divisor m is positive, Python further guarantees that 0≤ r < m. As
a consequence, we ﬁnd that −27 // 4 evaluates to −7 and −27 % 4 evaluates
to 1, as (−7)∗4+1=−27. When the divisor is negative, Python guarantees that
m< r ≤ 0. As an example, 27 // −4 is −7 and 27 % −4 is −1, satisfying the
identity 27=(−7)∗(−4)+(−1).
The conventions for the // and % operators are even extended to ﬂoating-
point operands, with the expression q = n // m being the integral ﬂoor of the
quotient, and r = n % m being the “remainder” to ensure that q m + r equals
n. Forexample, 8.2 // 3.14 evaluates to2.0 and 8.2 % 3.14 evaluates to1.92, as
2.0∗3.14+1.92=8.2.
Bitwise Operators
Pythonprovides thefollowingbitwiseoperators forintegers:
∼ bitwisecomplement(preﬁxunaryoperator)
& bitwiseand
| bitwiseor
ˆ bitwiseexclusive-or
<< shiftbitsleft,ﬁllinginwithzeros
>> shiftbitsright,ﬁllinginwithsignbit
Sequence Operators
EachofPython’sbuilt-insequencetypes(str,tuple,andlist)supportthefollowing
operator syntaxes:
s[j] elementatindex j
s[start:stop] sliceincluding indices[start,stop)
s[start:stop:step] sliceincluding indicesstart,start + step,
start + 2 step,...,uptobutnotequalling orstop
s + t concatenation ofsequences
k s shorthand fors + s + s + ...(ktimes)
val in s containment check
val not in s non-containment check
Python relies on zero-indexing of sequences, thus a sequence of length n has ele-
ments indexed from 0 ton−1inclusive. Python also supports the use ofnegative
indices, which denote a distance from the end of the sequence; index−1 denotes1.3. Expressions,Operators,andPrecedence 15
notation todescribe subsequences ofasequence. Slicesaredescribed ashalf-open
intervals, withastart index that isincluded, and astop index thatis excluded. For
example, the syntax data[3:8] denotes a subsequence including the ﬁve indices:
3,4,5,6,7. Anoptional “step” value, possibly negative, canbeindicated asathird
parameter of the slice. If a start index or stop index is omitted in the slicing nota-
tion,itispresumedtodesignate therespective extremeoftheoriginal sequence.
Because lists are mutable, the syntax s[j] = val can be used to replace an ele-
mentatagivenindex. Listsalsosupport asyntax,del s[j],thatremovesthedesig-
nated element from the list. Slice notation can also be used to replace or delete a
sublist.
The notation val in s can be used for any of the sequences to see if there is an
element equivalent to val in the sequence. For strings, this syntax can be used to
checkforasinglecharacterorforalargersubstring,aswith amp in example .
Allsequencesdeﬁnecomparisonoperationsbasedonlexicographicorder,per-
forming an element by element comparison until the ﬁrst difference is found. For
example,[5, 6, 9] < [5, 7]becauseoftheentriesatindex1. Therefore,thefollow-
ingoperations aresupported bysequence types:
s == t equivalent (elementbyelement)
s != t notequivalent
s < t lexicographically lessthan
s <= t lexicographically lessthanorequalto
s > t lexicographically greaterthan
s >= t lexicographically greaterthanorequalto
Operators for Sets and Dictionaries
Setsandfrozensets supportthefollowingoperators:
key in s containment check
key not in s non-containment check
s1 == s2 s1isequivalent tos2
s1 != s2 s1isnotequivalent tos2
s1 <= s2 s1issubsetofs2
s1 < s2 s1ispropersubsetofs2
s1 >= s2 s1issuperset ofs2
s1 > s2 s1ispropersuperset ofs2
s1 | s2 theunionofs1ands2
s1 & s2 theintersection ofs1ands2
s1 − s2 thesetofelementsins1butnots2
s1 ˆ s2 thesetofelementsinprecisely oneofs1ors2
Note well that sets do not guarantee a particular order of their elements, so the
comparison operators, such as <, are not lexicographic; rather, they are based on16 Chapter1. PythonPrimer
a partial order, but not a total order, as disjoint sets are neither “less than,” “equal
to,” or “greater than” each other. Sets also support many fundamental behaviors
through named methods (e.g., add, remove); we will explore their functionality
morefullyinChapter10.
Dictionaries, like sets, do not maintain a well-deﬁned order on their elements.
Furthermore,theconceptofasubsetisnottypicallymeaningfulfordictionaries,so
thedictclassdoesnotsupportoperatorssuchas<. Dictionariessupportthenotion
ofequivalence, withd1 == d2ifthetwodictionaries containthesamesetofkey-
value pairs. The most widely used behavior of dictionaries is accessing a value
associated with a particular key k with the indexing syntax, d[k]. The supported
operators areasfollows:
d[key] valueassociated withgivenkey
d[key] = value set(orreset)thevalueassociated withgivenkey
del d[key] removekeyanditsassociated valuefromdictionary
key in d containment check
key not in d non-containment check
d1 == d2 d1isequivalent tod2
d1 != d2 d1isnotequivalent tod2
Dictionaries also support many useful behaviors through named methods, which
weexploremorefullyinChapter10.
Extended Assignment Operators
Python supports an extended assignment operator for most binary operators, for
example,allowingasyntaxsuchascount += 5. Bydefault,thisisashorthandfor
themoreverbosecount = count + 5. Foranimmutabletype,suchasanumberor
a string, one should not presume that this syntax changes thevalue of the existing
object, but instead that it will reassign the identiﬁer to a newly constructed value.
(See discussion of Figure 1.3.) However, it is possible for atype to redeﬁne such
semanticstomutatetheobject,asthelistclassdoesforthe+=operator.
alpha = [1, 2, 3]
beta = alpha # an alias for alpha
beta += [4, 5] # extends the original list with two more elements
beta = beta + [6, 7] # reassigns beta to a new list [1, 2, 3, 4, 5, 6, 7]
print(alpha) # will be [1, 2, 3, 4, 5]
Thisexampledemonstrates thesubtle difference between thelistsemantics forthe1.3. Expressions,Operators,andPrecedence 17
1.3.1 Compound Expressions and Operator Precedence
Programming languages must have clear rules for the order in which compound
expressions, such as 5 + 2 3, are evaluated. The formal order of precedence
for operators in Python is given in Table 1.3. Operators in a category with higher
precedencewillbeevaluatedbeforethosewithlowerprecedence,unlesstheexpres-
sionisotherwiseparenthesized. Therefore,weseethatPythongivesprecedenceto
multiplication over addition, and therefore evaluates the expression 5 + 2 3 as
5 + (2 3), with value 11, but the parenthesized expression (5 + 2) 3 evalu-
ates to value 21. Operators within a category are typically evaluated from left to
right, thus 5 − 2 + 3hasvalue 6. Exceptions tothisrule include that unary oper-
atorsandexponentiation areevaluatedfromrighttoleft.
Python allows a chained assignment, such as x = y = 0, to assign multiple
identiﬁers to the rightmost value. Python also allows thechaining of comparison
operators. For example, the expression 1 <= x + y <= 10 is evaluated as the
compound (1 <= x + y) and (x + y <= 10), but without computing the inter-
mediatevaluex + ytwice.
OperatorPrecedence
Type Symbols
1 memberaccess expr.member
function/methodcalls expr(...)
2
containersubscripts/slices expr[...]
3 exponentiation
4 unaryoperators +expr, −expr, ˜expr
5 multiplication,division , /, //, %
6 addition,subtraction +, −
7 bitwiseshifting <<, >>
8 bitwise-and &
9 bitwise-xor ˆ
10 bitwise-or |
comparisons is, is not, ==, !=, <, <=, >, >=
11
containment in, not in
12 logical-not not expr
13 logical-and and
14 logical-or or
15 conditional val1 if cond else val2
16 assignments =, +=, −=, =, etc.
Table 1.3: Operator precedence in Python, with categories ordered from highest
precedence to lowest precedence. When stated, we use expr to denote a literal,
identiﬁer, or result of a previously evaluated expression. All operators without18 Chapter1. PythonPrimer
1.4 Control Flow
In this section, we review Python’s most fundamental control structures: condi-
tional statements and loops. Common to all control structures is the syntax used
in Python for deﬁning blocks of code. The colon character is used to delimit the
beginning ofablockofcodethatactsasabodyforacontrolstructure. Ifthebody
canbestatedasasingleexecutablestatement,itcantechnicallyplacedonthesame
line, to the right of the colon. However, a body is more typically typeset as an
indentedblockstartingonthelinefollowingthecolon. Pythonreliesontheinden-
tation level to designate the extent of that block of code, or any nested blocks of
code within. The same principles will be applied when designating the body of a
function (seeSection1.5),andthebodyofaclass(seeSection2.3).
1.4.1 Conditionals
Conditional constructs (also known as if statements) provide a way to execute a
chosen block of code based on the run-time evaluation of one or more Boolean
expressions. InPython,themostgeneralformofaconditionaliswrittenasfollows:
if ﬁrst condition:
ﬁrst body
elif second condition:
second body
elif third condition:
third body
else:
fourth body
Eachcondition isaBooleanexpression, andeachbodycontains oneormorecom-
mandsthataretobeexecutedconditionally. Iftheﬁrstconditionsucceeds, theﬁrst
body will be executed; no other conditions or bodies are evaluated in that case.
If the ﬁrst condition fails, then the process continues in similar manner with the
evaluation of the second condition. The execution of this overall construct will
cause precisely one of the bodies to be executed. There may be any number of
elifclauses (including zero), and theﬁnalelse clause isoptional. Asdescribed on
page 7, nonboolean types may be evaluated as Booleans with intuitive meanings.
For example, if response is a string that was entered by a user, and we want to
condition abehavior onthisbeinganonemptystring, wemaywrite
if response:
asashorthand fortheequivalent,1.4. ControlFlow 19
Asasimpleexample,arobotcontroller mighthavethefollowinglogic:
if door is closed:
open door()
advance()
Noticethattheﬁnalcommand,advance(),isnotindentedandthereforenotpartof
theconditional body. Itwillbeexecutedunconditionally (although afteropening a
closeddoor).
We may nest one control structure within another, relying on indentation to
makecleartheextentofthevariousbodies. Revisitingourrobotexample,hereisa
morecomplexcontrolthataccounts forunlocking acloseddoor.
if door is closed:
if door is locked:
unlock door()
open door()
advance()
Thelogicexpressedbythisexamplecanbediagrammedasatraditionalﬂowchart,
asportrayed inFigure1.6.
False True
door is closed
False True
door is locked
unlock door()
open door()
advance()20 Chapter1. PythonPrimer
1.4.2 Loops
Python offers twodistinct looping constructs. Awhileloop allowsgeneral repeti-
tion based upon the repeated testing of a Boolean condition. A for loop provides
convenient iteration ofvalues from adeﬁned series (such ascharacters ofastring,
elementsofalist,ornumberswithinagivenrange). Wediscuss bothformsinthis
section.
While Loops
ThesyntaxforawhileloopinPythonisasfollows:
while condition:
body
As with an if statement, condition can be an arbitrary Boolean expression, and
body can be an arbitrary block of code (including nested control structures). The
executionofawhileloopbeginswithatestoftheBooleancondition. Ifthatcondi-
tion evaluates to True, the body of the loop is performed. After each execution of
thebody,theloopconditionisretested,andifitevaluatestoTrue,anotheriteration
of the body is performed. When the conditional test evaluates to False (assuming
it ever does), the loop is exited and the ﬂow of control continues just beyond the
bodyoftheloop.
As an example, here is a loop that advances an index through a sequence of
charactersuntilﬁndinganentrywithvalue X orreachingtheendofthesequence.
j = 0
while j < len(data) and data[j] != X :
j += 1
The len function, which we willintroduce in Section 1.5.2, returnsthe length of a
sequence such as a list or string. The correctness of this loop relies on the short-
circuiting behavior of the and operator, as described on page 12. We intention-
ally test j < len(data) to ensure that j is a valid index, prior to accessing element
data[j]. Hadwewrittenthatcompoundcondition withtheopposite order,theeval-
uationofdata[j]wouldeventuallyraiseanIndexErrorwhen X isnotfound. (See
Section1.7fordiscussion ofexceptions.)
As written, when this loop terminates, variable j’s value will be the index of
the leftmost occurrence of X , if found, or otherwise the length of the sequence
(which is recognizable as an invalid index to indicate failure of the search). It is
worthnotingthatthiscodebehavescorrectly, eveninthespecialcasewhenthelist
isempty, as the condition j < len(data)willinitially fail and the body of theloop1.4. ControlFlow 21
For Loops
Python’s for-loop syntax is a more convenient alternative to a while loop when
iterating through a series of elements. The for-loop syntax can be used on any
type ofiterable structure, such asalist, tuplestr, set,dict, orﬁle(wewilldiscuss
iterators moreformallyinSection1.8). Itsgeneral syntaxappearsasfollows.
for element in iterable:
body # body may refer to element as an identiﬁer
Forreaders familiar with Java, the semantics of Python’s for loop is similar to the
“foreach”loopstyleintroduced inJava1.5.
As an instructive example of such a loop, we consider the task of computing
thesumofalist ofnumbers. (Admittedly, Python hasabuilt-in function, sum,for
thispurpose.) Weperformthecalculation withaforloopasfollows,assumingthat
dataidentiﬁesthelist:
total = 0
for val in data:
total += val # note use of the loop variable, val
Theloopbodyexecutesonceforeachelementofthedatasequence, withtheiden-
tiﬁer, val, from the for-loop syntax assigned at the beginning of each pass to a
respective element. It is worth noting thatval is treated as a standard identiﬁer. If
the element of the original data happens to be mutable, the val identiﬁer can be
used toinvoke itsmethods. Butareassignment ofidentiﬁervaltoanewvalue has
noaffectontheoriginal data,noronthenextiteration oftheloop.
As a second classic example, we consider the task of ﬁnding the maximum
value in a list of elements (again, admitting that Python’s built-in max function
alreadyprovides thissupport). Ifwecanassumethatthelist,data,hasatleastone
element,wecouldimplementthistaskasfollows:
biggest = data[0] # as we assume nonempty list
for val in data:
if val > biggest:
biggest = val
Although we could accomplish both of the above tasks with a while loop, the
for-loop syntax had an advantage of simplicity, as there is no need to manage an
explicitindexintothelistnortoauthoraBooleanloopcondition. Furthermore,we
can use a for loop in cases for which a while loop does not apply, such as when
iterating through a collection, such as a set, that does not support any direct form22 Chapter1. PythonPrimer
Index-Based For Loops
Thesimplicityofastandardforloopovertheelementsofalistiswonderful;how-
ever, one limitation of that form is that we do not know where an element resides
within the sequence. In some applications, we need knowledge of the index of an
element within the sequence. For example, suppose that we want to know where
themaximumelementinalistresides.
Ratherthandirectlyloopingovertheelementsofthelistinthatcase,weprefer
to loop over all possible indices of the list. For this purpose, Python provides
a built-in class named range that generates integer sequences. (We will discuss
generators in Section 1.8.) In simplest form, the syntax range(n) generates the
series of n values from 0 to n−1. Conveniently, these are precisely the series of
valid indices into a sequence of length n. Therefore, a standard Python idiom for
looping throughtheseriesofindicesofadatasequence usesasyntax,
for j in range(len(data)):
In this case, identiﬁer j is not an element of the data—it is an integer. But the
expression data[j]canbeused toretrieve therespective element. Forexample,we
canﬁndtheindexofthemaximumelementofalistasfollows:
big index = 0
for j in range(len(data)):
if data[j] > data[big index]:
big index = j
Break and Continue Statements
Python supports abreak statement that immediately terminate awhile or for loop
when executed within its body. More formally, if applied within nested control
structures, it causes the termination of the most immediately enclosing loop. As
a typical example, here is code that determines whether a target value occurs in a
dataset:
found = False
for item in data:
if item == target:
found = True
break
Python also supports a continue statement that causes the current iteration of a
loopbodytostop,butwithsubsequent passesoftheloopproceeding asexpected.
Werecommend thatthebreakandcontinuestatements beusedsparingly. Yet,
there are situations in which these commands can be effectively used to avoid in-1.5. Functions 23
1.5 Functions
In this section, we explore the creation of and use of functions in Python. As we
did in Section 1.2.2, we draw a distinction between functions and methods. We
use the general termfunction todescribe atraditional, stateless function that isin-
voked without thecontext of aparticular class or aninstance ofthat class, such as
sorted(data). Weusethemorespeciﬁctermmethodtodescribeamemberfunction
thatisinvokeduponaspeciﬁcobjectusinganobject-orientedmessagepassingsyn-
tax, suchasdata.sort(). Inthissection, weonlyconsider purefunctions; methods
willbeexploredwithmoregeneralobject-oriented principles inChapter2.
We begin with an example to demonstrate the syntax for deﬁning functions in
Python. Thefollowingfunctioncountsthenumberofoccurrences ofagiventarget
valuewithinanyformofiterabledataset.
def count(data, target):
n = 0
for item in data:
if item == target: # found a match
n += 1
return n
The ﬁrstline, beginning with the keyword def, serves as the function’s signature.
This establishes a new identiﬁer as the name of the function (count, in this exam-
ple), and it establishes the number of parameters that it expects, as well as names
identifying those parameters (data and target, in this example). Unlike Java and
C++, Python is a dynamically typed language, and therefore a Python signature
does not designate the types of those parameters, nor the type (if any) of a return
value. Those expectations should be stated in the function’s documentation (see
Section2.2.3)andcanbeenforcedwithinthebodyofthefunction, butmisuseofa
function willonlybedetectedatrun-time.
The remainder of the function deﬁnition is known as the body of the func-
tion. As is the case with control structures in Python, the body of a function is
typically expressed as an indented block of code. Each time a function is called,
Pythoncreatesadedicatedactivation recordthatstoresinformationrelevanttothe
current call. This activation record includes what is known as a namespace (see
Section1.10)tomanageallidentiﬁersthathavelocalscopewithinthecurrentcall.
Thenamespaceincludesthefunction’sparametersandanyotheridentiﬁersthatare
deﬁned locally within the body of the function. An identiﬁer in the local scope
of the function caller has no relation to any identiﬁer with the same name in the
caller’s scope (although identiﬁers in different scopes may be aliases to the same
object). In our ﬁrstexample, the identiﬁernhas scope that is local to the function24 Chapter1. PythonPrimer
Return Statement
Areturnstatement isusedwithin thebody ofafunction toindicate that thefunc-
tion should immediately cease execution, and that an expressed value should be
returned to the caller. If a return statement is executed without an explicit argu-
ment,theNonevalueisautomatically returned. Likewise,Nonewillbereturnedif
theﬂowofcontroleverreachestheendofafunctionbodywithouthavingexecuted
areturn statement. Often, areturnstatement willbetheﬁnalcommandwithin the
body of the function, as was the case in our earlier example of a count function.
However, there can be multiple return statements in the same function, with con-
ditional logic controlling which such command is executed, if any. As a further
example,consider thefollowingfunctionthattestsifavalueexistsinasequence.
def contains(data, target):
for item in target:
if item == target: # found a match
return True
return False
Iftheconditionalwithintheloopbodyiseversatisﬁed,thereturn Truestatementis
executed and the function immediately ends, withTrue designating that the target
value was found. Conversely, if the for loop reaches its conclusion without ever
ﬁndingthematch,theﬁnalreturn Falsestatementwillbeexecuted.
1.5.1 Information Passing
To be a successful programmer, one must have clear understanding of the mech-
anism in which a programming language passes information to and from a func-
tion. In the context of a function signature, the identiﬁers used to describe the
expected parameters are known asformal parameters, and the objects sent by the
caller when invoking the function are the actual parameters. Parameter passing
in Python follows the semantics of the standard assignment statement. When a
functionisinvoked, eachidentiﬁerthatservesasaformalparameterisassigned,in
thefunction’slocalscope,totherespectiveactualparameterthatisprovidedbythe
callerofthefunction.
Forexample,consider thefollowingcalltoourcountfunction frompage23:
prizes = count(grades, A )
Just before the function body is executed, the actual parameters, grades and A ,
areimplicitlyassigned totheformalparameters,dataandtarget,asfollows:
data = grades1.5. Functions 25
These assignment statements establish identiﬁer data as an alias for grades and
targetasanameforthestringliteral A . (SeeFigure1.7.)
grades data target
list str
... A
Figure 1.7: A portrayal of parameter passing in Python, for the function call
count(grades, A ). Identiﬁers data and target are formal parameters deﬁned
withinthelocalscopeofthecountfunction.
The communication of a return value from the function back to the caller is
similarlyimplemented asanassignment. Therefore, withoursampleinvocation of
prizes = count(grades, A ), the identiﬁer prizes in the caller’s scope is assigned
totheobjectthatisidentiﬁedasninthereturnstatementwithinourfunctionbody.
An advantage to Python’s mechanism for passing information to and from a
functionisthatobjectsarenotcopied. Thisensuresthattheinvocationofafunction
isefﬁcient,eveninacasewhereaparameterorreturnvalueisacomplexobject.
Mutable Parameters
Python’sparameterpassingmodelhasadditional implications whenaparameteris
amutableobject. Becausetheformalparameterisanaliasfortheactualparameter,
the body ofthe function mayinteract with theobject inwaysthat change its state.
Considering again our sample invocation of thecount function, if the body of the
function executes the command data.append( F ), the new entry is added to the
end ofthe list identiﬁed asdatawithin the function, which isone and the sameas
the list known to the caller asgrades. Asan aside, wenote that reassigning anew
value to a formal parameter with a function body, such as by setting data = [ ],
doesnotaltertheactualparameter; suchareassignment simplybreaksthealias.
Our hypothetical example of acount method that appends a new element to a
listlackscommonsense. Thereisnoreasontoexpectsuchabehavior,anditwould
be quite a poor design to have such an unexpected effect on theparameter. There
are, however, many legitimate cases in which a function may be designed (and
clearly documented) to modify the state of a parameter. As a concrete example,
we present the following implementation of a method namedscale that’s primary
purpose istomultiplyallentriesofanumericdatasetbyagivenfactor.
def scale(data, factor):
for j in range(len(data)):26 Chapter1. PythonPrimer
Default Parameter Values
Python provides means for functions to support more than one possible calling
signature. Such a function is said to be polymorphic (which is Greek for “many
forms”). Most notably, functions can declare one or more default values for pa-
rameters, thereby allowing thecaller toinvoke afunction withvarying numbersof
actualparameters. Asanartiﬁcialexample,ifafunction isdeclared withsignature
def foo(a, b=15, c=27):
there are three parameters, the last two of which offer default values. A caller is
welcometosendthreeactualparameters, asinfoo(4, 12, 8),inwhichcasethede-
faultvaluesarenotused. If,ontheotherhand,thecalleronlysendsoneparameter,
foo(4), the function will execute with parameters values a=4, b=15, c=27. If a
callersendstwoparameters,theyareassumedtobetheﬁrsttwo,withthethirdbe-
ing the default. Thus, foo(8, 20) executes witha=8, b=20, c=27. However, it is
illegal todeﬁne afunction withasignature such asbar(a, b=15, c)withbhaving
adefaultvalue, yetnotthesubsequentc;ifadefault parameter valueispresent for
oneparameter, itmustbepresentforallfurtherparameters.
As a more motivating example for the use of a default parameter, we revisit
the task of computing a student’s GPA (see Code Fragment 1.1). Rather than as-
sume direct input and output with the console, we prefer to design a function that
computes and returns a GPA. Our original implementation uses a ﬁxed mapping
from each letter grade (such as a B−) to a corresponding point value (such as
2.67). While that point system is somewhat common, it may not agree with the
system usedbyallschools. (Forexample, somemayassignan A+ gradeavalue
higher than 4.0.) Therefore, we design a compute gpa function, given in Code
Fragment1.2,whichallowsthecallertospecify acustom mappingfromgrades to
values,whileofferingthestandard pointsystemasadefault.
def compute gpa(grades, points={ A+ :4.0, A :4.0, A- :3.67, B+ :3.33,
B :3.0, B- :2.67, C+ :2.33, C :2.0,
C :1.67, D+ :1.33, D :1.0, F :0.0}):
num courses = 0
total points = 0
for g in grades:
if g in points: # a recognizable grade
num courses += 1
total points += points[g]
return total points / num courses
CodeFragment1.2: A function that computes a student’s GPA with a point value1.5. Functions 27
Asan additional example of an interesting polymorphic function, weconsider
Python’s support for range. (Technically, this is a constructor for therange class,
butforthesakeofthisdiscussion, wecantreatitasapurefunction.) Threecalling
syntaxesaresupported. Theone-parameterform,range(n),generatesasequenceof
integersfrom0uptobutnotincludingn. Atwo-parameterform,range(start,stop)
generates integers from start up to, but not including, stop. A three-parameter
form,range(start, stop, step),generates asimilarrangeasrange(start, stop),but
withincrements ofsizestepratherthan1.
This combination of forms seems to violate the rules for default parameters.
In particular, when a single parameter is sent, as inrange(n), it serves as the stop
value (which is the second parameter); the value of start is effectively 0 in that
case. However,thiseffectcanbeachieved withsomesleightofhand,asfollows:
def range(start, stop=None, step=1):
if stop is None:
stop = start
start = 0
...
Fromatechnicalperspective,whenrange(n)isinvoked,theactualparameternwill
be assigned to formal parameter start. Within the body, if only one parameter is
received, thestartandstopvaluesarereassigned toprovide thedesired semantics.
Keyword Parameters
The traditional mechanism for matching the actual parameters sent by a caller, to
the formal parameters declared by the function signature is based on the concept
of positional arguments. For example, with signature foo(a=10, b=20, c=30),
parameters sentbythecaller arematched, inthegivenorder, totheformal param-
eters. Aninvocation offoo(5)indicates thata=5, whileband careassigned their
defaultvalues.
Python supports analternate mechanism for sending aparameter to afunction
known as a keyword argument. A keyword argument is speciﬁed by explicitly
assigning an actual parameter to a formal parameter by name. For example, with
the above deﬁnition of functionfoo, acall foo(c=5) willinvoke the function with
parametersa=10, b=20, c=5.
Afunction’sauthorcanrequirethatcertainparametersbesentonlythroughthe
keyword-argument syntax. We never place such a restriction in our own function
deﬁnitions, but we will see several important uses of keyword-only parameters in
Python’s standard libraries. As an example, the built-in max function accepts a
keyword parameter, coincidentally namedkey, that can be used to vary the notion28 Chapter1. PythonPrimer
By default, max operates based upon the natural order of elements according
to the < operator for that type. Butthe maximum can be computed by comparing
someother aspectoftheelements. Thisisdonebyproviding anauxiliary function
that converts a natural element to some other value for the sake of comparison.
Forexample,ifweareinterested inﬁndinganumericvaluewithmagnitudethatis
maximal(i.e.,considering−35tobelarger than+20),wecanusethecallingsyn-
tax max(a, b, key=abs). In this case, the built-in abs function is itself sent as the
valueassociated withthekeywordparameterkey. (Functionsareﬁrst-classobjects
inPython;seeSection1.10.) Whenmaxiscalledinthisway,itwillcompareabs(a)
toabs(b),ratherthanatob. Themotivationforthekeywordsyntaxasanalternate
topositional arguments isimportant inthecaseofmax. Thisfunction ispolymor-
phic in the number of arguments, allowing a call such asmax(a,b,c,d); therefore,
it is not possible to designate a key function as a traditional positional element.
Sorting functions in Python also support a similar key parameter for indicating a
nonstandard order. (We explore this further in Section 9.4 and in Section 12.6.1,
whendiscussing sortingalgorithms).
1.5.2 Python’s Built-In Functions
Table 1.4 provides an overview of common functions that are automatically avail-
able in Python, including the previously discussed abs, max, and range. When
choosing names for the parameters, weuse identiﬁersx, y, zfor arbitrary numeric
types, k for an integer, and a, b, and c for arbitrary comparable types. We use
the identiﬁer, iterable, to represent an instance of any iterable type (e.g., str, list,
tuple, set, dict); we will discuss iterators and iterable data types in Section 1.8.
Asequence represents amorenarrow category of indexable classes, including str,
list, and tuple, but neither set nor dict. Most of the entries in Table 1.4 can be
categorized according totheirfunctionality asfollows:
Input/Output: print,input,andopenwillbemorefullyexplainedinSection1.6.
Character Encoding: ordandchrrelatecharacters andtheirintegercodepoints.
Forexample,ord( A )is65andchr(65)is A .
Mathematics: abs,divmod,pow,round,andsumprovidecommonmathematical
functionality; anadditionalmathmodulewillbeintroduced inSection1.11.
Ordering: maxand minapply to any data type that supports a notion of compar-
ison, or to any collection of such values. Likewise, sorted can be used to produce
anorderedlistofelementsdrawnfromanyexistingcollection.
Collections/Iterations: rangegeneratesanewsequenceofnumbers;lenreports
the length of any existing collection; functions reversed, all, any, and map oper-
ate on arbitrary iterations as well; iter and next provide a general framework for1.5. Functions 29
CommonBuilt-InFunctions
CallingSyntax Description
abs(x) Returntheabsolutevalueofanumber.
all(iterable) ReturnTrueifbool(e)isTrueforeachelemente.
any(iterable) ReturnTrueifbool(e)isTrueforatleastoneelemente.
chr(integer) Returnaone-characterstringwiththegivenUnicodecodepoint.
divmod(x, y) Return(x // y, x % y)astuple,ifxandyareintegers.
hash(obj) Returnanintegerhashvaluefortheobject(seeChapter10).
id(obj) Returntheuniqueintegerservingasan“identity”fortheobject.
input(prompt) Returnastringfromstandardinput;thepromptisoptional.
isinstance(obj, cls) Determineifobjisaninstanceoftheclass(orasubclass).
iter(iterable) Returnanewiteratorobjectfortheparameter(seeSection1.8).
len(iterable) Returnthenumberofelementsinthegiveniteration.
Returnaniteratoryieldingtheresultoffunctioncallsf(e1, e2, ...)
map(f, iter1, iter2, ...)
forrespectiveelementse1∈iter1,e2∈iter2,...
max(iterable) Returnthelargestelementofthegiveniteration.
max(a, b, c, ...) Returnthelargestofthearguments.
min(iterable) Returnthesmallestelementofthegiveniteration.
min(a, b, c, ...) Returnthesmallestofthearguments.
next(iterator) Returnthenextelementreportedbytheiterator(seeSection1.8).
open(ﬁlename, mode) Openaﬁlewiththegivennameandaccessmode.
ord(char) ReturntheUnicodecodepointofthegivencharacter.
Returnthevaluexy(asanintegerifxandyareintegers);
pow(x, y)
equivalenttox y.
pow(x, y, z) Returnthevalue(xy modz)asaninteger.
print(obj1, obj2, ...) Printthearguments,withseparatingspacesandtrailingnewline.
range(stop) Constructaniterationofvalues0,1,...,stop−1.
range(start, stop) Constructaniterationofvaluesstart,start+1,...,stop−1.
range(start, stop, step) Constructaniterationofvaluesstart,start+step,start+2 step,...
reversed(sequence) Returnaniterationofthesequenceinreverse.
round(x) Returnthenearestintvalue(atieisbrokentowardtheevenvalue).
round(x, k) Returnthevalueroundedtothenearest10−k(return-typematchesx).
sorted(iterable) Returnalistcontainingelementsoftheiterableinsortedorder.
sum(iterable) Returnthesumoftheelementsintheiterable(mustbenumeric).
type(obj) Returntheclasstowhichtheinstanceobjbelongs.30 Chapter1. PythonPrimer
1.6 Simple Input and Output
Inthissection,weaddressthebasicsofinputandoutputinPython,describingstan-
dard input and output through the user console, and Python’s support for reading
andwritingtextﬁles.
1.6.1 Console Input and Output
The print Function
The built-in function, print, is used to generate standard output to the console.
In its simplest form, it prints an arbitrary sequence of arguments, separated by
spaces, and followed by a trailing newline character. For example, the command
print( maroon , 5) outputs the string maroon 5\n . Note that arguments need
notbestringinstances. Anonstringargumentxwillbedisplayedasstr(x). Without
anyarguments, thecommandprint()outputsasinglenewlinecharacter.
Theprintfunctioncanbecustomizedthroughtheuseofthefollowingkeyword
parameters (seeSection1.5foradiscussion ofkeywordparameters):
• By default, the print function inserts a separating space into the output be-
tweeneachpairofarguments. Theseparatorcanbecustomizedbyproviding
adesiredseparating stringasakeywordparameter,sep. Forexample,colon-
separatedoutputcanbeproducedasprint(a, b, c, sep= : ). Theseparating
string need not be a single character; it can be a longer string, and it can be
the empty string, sep= , causing successive arguments to be directly con-
catenated.
• By default, a trailing newline is output after the ﬁnal argument. Analterna-
tive trailing string can be designated using a keyword parameter, end. Des-
ignating theemptystringend= suppresses alltrailingcharacters.
• Bydefault, theprintfunction sends itsoutputtothestandard console. How-
ever, output can be directed to a ﬁle by indicating an output ﬁle stream (see
Section1.6.2)usingﬁleasakeywordparameter.
The input Function
The primary means for acquiring information from the user console is a built-in
function namedinput. Thisfunction displays aprompt, ifgiven asanoptional pa-
rameter, andthen waitsuntiltheuser enters somesequence ofcharacters followed
bythereturnkey. Theformalreturnvalueofthefunctionisthestringofcharacters
that wereentered strictly before the return key (i.e., no newline character exists in1.6. SimpleInputandOutput 31
Whenreadinganumericvaluefromtheuser,aprogrammermustusetheinput
function to get the string of characters, and then use the int or ﬂoat syntax to
construct the numeric value that character string represents. That is, if a call to
response = input()reportsthattheuserenteredthecharacters, 2013 ,thesyntax
int(response)couldbeusedtoproduce theintegervalue2013. Itisquitecommon
tocombinetheseoperations withasyntaxsuchas
year = int(input( In what year were you born? ))
if we assume that the user will enter an appropriate response. (In Section 1.7 we
discusserrorhandling insuchasituation.)
Becauseinputreturnsastringasitsresult,useofthatfunctioncanbecombined
withtheexisting functionality ofthestring class, asdescribed inAppendix A. For
example, if the user enters multiple pieces of information on the same line, it is
commontocallthesplitmethodontheresult,asin
reply = input( Enter x and y, separated by spaces: )
pieces = reply.split( ) # returns a list of strings, as separated by spaces
x = ﬂoat(pieces[0])
y = ﬂoat(pieces[1])
A Sample Program
Here is a simple, but complete, program that demonstrates the use of the input
and print functions. The tools for formatting the ﬁnal output is discussed in Ap-
pendixA.
age = int(input( Enter your age in years: ))
max heart rate = 206.9 − (0.67 age) # as per Med Sci Sports Exerc.
target = 0.65 max heart rate
print( Your target fat-burning heart rate is , target)
1.6.2 Files
Files are typically accessed in Python beginning with a callto a built-in function,
named open, that returns a proxy for interactions with the underlying ﬁle. For
example,thecommand,fp = open( sample.txt ),attemptstoopenaﬁlenamed
sample.txt,returning aproxythatallowsread-only accesstothetextﬁle.
The open function accepts an optional second parameter that determines the
access mode. Thedefault modeis r forreading. Other commonmodesare w
for writing to the ﬁle (causing any existing ﬁle with that name to be overwritten),
or a for appending to the end of an existing ﬁle. Although we focus on use of
textﬁles,itispossible toworkwithbinary ﬁles,using access modes suchas rb32 Chapter1. PythonPrimer
Whenprocessingaﬁle,theproxymaintainsacurrentpositionwithintheﬁleas
an offset from the beginning, measured in number of bytes. When opening a ﬁle
with mode r or w , the position is initially 0; if opened in append mode, a ,
the position is initially at the end of the ﬁle. The syntax fp.close() closes the ﬁle
associated withproxyfp,ensuring thatanywrittencontents aresaved. Asummary
ofmethodsforreadingandwritingaﬁleisgiveninTable1.5
CallingSyntax Description
fp.read() Returnthe(remaining)contentsofareadableﬁleasastring.
fp.read(k) Returnthenextkbytesofareadableﬁleasastring.
fp.readline() Return(remainderof)thecurrentlineofareadableﬁleasastring.
fp.readlines() Returnall(remaining)linesofareadableﬁleasalistofstrings.
for line in fp: Iterateall(remaining)linesofareadableﬁle.
fp.seek(k) Changethecurrentpositiontobeatthekth byteoftheﬁle.
fp.tell() Returnthecurrentposition,measuredasbyte-offsetfromthestart.
fp.write(string) Writegivenstringatcurrentpositionofthewritableﬁle.
Writeeachofthestringsofthegivensequenceatthecurrent
fp.writelines(seq) positionofthewritableﬁle. Thiscommanddoesnotinsert
anynewlines,beyondthosethatareembeddedinthestrings.
print(..., ﬁle=fp) Redirectoutputofprintfunctiontotheﬁle.
Table1.5: Behaviorsforinteracting withatextﬁleviaaﬁleproxy(namedfp).
Reading from a File
Themostbasiccommandforreadingviaaproxyisthereadmethod. Wheninvoked
onﬁleproxyfp,asfp.read(k),thecommandreturnsastringrepresentingthenextk
bytes of the ﬁle, starting at the current position. Without a parameter, the syntax
fp.read() returns the remaining contents of the ﬁle in entirety. For convenience,
ﬁles can be read a line at a time, using the readline method to read one line, or
the readlines method to return a list of all remaining lines. Files also support the
for-loop syntax, withiteration beinglinebyline(e.g.,for line in fp:).
Writing to a File
When a ﬁle proxy is writable, for example, if created with access mode w or
a ,text can bewritten using methodswriteorwritelines. Forexample, ifwede-
ﬁnefp = open( results.txt , w ),thesyntax fp.write( Hello World.\n )
writes a single line to the ﬁle with the given string. Note well that write does not
explicitly add a trailing newline, so desired newline characters must be embedded
directly in the string parameter. Recall that the output of the print method can be1.7. ExceptionHandling 33
1.7 Exception Handling
Exceptions are unexpected events that occur during the execution of a program.
An exception might result from a logical error or an unanticipated situation. In
Python,exceptions(alsoknownaserrors)areobjectsthatareraised(orthrown)by
code thatencounters anunexpected circumstance. ThePython interpreter can also
raiseanexception shoulditencounteranunexpectedcondition, likerunningoutof
memory. Araisederrormaybecaughtbyasurroundingcontextthat“handles”the
exceptioninanappropriatefashion. Ifuncaught,anexceptioncausestheinterpreter
tostopexecuting theprogram andtoreportanappropriate messagetotheconsole.
Inthissection,weexaminethemostcommonerrortypesinPython,themechanism
for catching and handling errors that have been raised, and the syntax for raising
errorsfromwithinuser-deﬁned blocksofcode.
Common Exception Types
Python includes a rich hierarchy of exception classes that designate various cate-
goriesoferrors;Table1.6showsmanyofthoseclasses. TheExceptionclassserves
as a base class for most other error types. An instance of the various subclasses
encodes details about a problem that has occurred. Several of these errors may be
raised in exceptional cases by behaviors introduced in this chapter. For example,
useofanundeﬁned identiﬁer inanexpression causes aNameError,anderrant use
of the dot notation, as in foo.bar(), will generate an AttributeError if object foo
doesnotsupport amembernamedbar.
Class Description
Exception Abaseclassformosterrortypes
AttributeError Raisedbysyntaxobj.foo,ifobjhasnomembernamedfoo
EOFError Raisedif“endofﬁle”reachedforconsoleorﬁleinput
IOError RaiseduponfailureofI/Ooperation (e.g.,openingﬁle)
IndexError Raisedifindextosequence isoutofbounds
KeyError Raisedifnonexistent keyrequested forsetordictionary
KeyboardInterrupt Raisedifusertypesctrl-Cwhileprogram isexecuting
NameError Raisedifnonexistent identiﬁerused
StopIteration Raisedbynext(iterator)ifnoelement;seeSection1.8
TypeError Raisedwhenwrongtypeofparameterissenttoafunction
ValueError Raisedwhenparameterhasinvalid value(e.g.,sqrt(−5))
ZeroDivisionError Raisedwhenanydivisionoperator usedwith0asdivisor34 Chapter1. PythonPrimer
Sendingthewrongnumber,type,orvalueofparameterstoafunctionisanother
common cause for an exception. Forexample, acall toabs( hello ) willraise a
TypeError because the parameter is not numeric, and a call toabs(3, 5) will raise
a TypeError because one parameter is expected. A ValueError is typically raised
whenthecorrectnumberandtypeofparametersaresent,butavalueisillegitimate
for the context of the function. For example, the int constructor accepts a string,
as with int( 137 ), but a ValueError is raised if that string does not represent an
integer, aswithint( 3.14 )orint( hello ).
Python’s sequence types (e.g., list, tuple, and str) raise an IndexError when
syntaxsuchasdata[k]isusedwithanintegerkthatisnotavalidindexforthegiven
sequence (as described in Section 1.2.3). Sets and dictionaries raise a KeyError
whenanattemptismadetoaccessanonexistent element.
1.7.1 Raising an Exception
An exception is thrown by executing the raise statement, with an appropriate in-
stanceofanexceptionclassasanargumentthatdesignatestheproblem. Forexam-
ple,ifafunctionforcomputingasquarerootissentanegativevalueasaparameter,
itcanraiseanexception withthecommand:
raise ValueError( x cannot be negative )
This syntax raises a newly created instance of theValueError class, with the error
message serving as a parameter to the constructor. If this exception is not caught
within the body of the function, the execution of the function immediately ceases
andtheexception ispropagated tothecalling context(andpossibly beyond).
When checking the validity of parameters sent to a function, it is customary
to ﬁrst verify that a parameter is of an appropriate type, and then to verify that it
has an appropriate value. For example, the sqrt function in Python’s math library
performserror-checking thatmightbeimplemented asfollows:
def sqrt(x):
if not isinstance(x, (int, ﬂoat)):
raise TypeError( x must be numeric )
elif x < 0:
raise ValueError( x cannot be negative )
# do the real work here...
Checking the type of an object can be performed at run-time using the built-in
function, isinstance. In simplest form, isinstance(obj, cls) returns True if object,
obj,isaninstanceofclass,cls,oranysubclassofthattype. Intheaboveexample,a
moregeneralformisusedwithatupleofallowabletypesindicatedwiththesecond
parameter. After conﬁrming that the parameter is numeric, the function enforces1.7. ExceptionHandling 35
How much error-checking to perform within a function is a matter of debate.
Checkingthetypeandvalueofeachparameter demandsadditional executiontime
and, if taken to an extreme, seems counter to the nature of Python. Consider the
built-in sum function, which computes a sum of a collection of numbers. Anim-
plementation withrigorous error-checking mightbewrittenasfollows:
def sum(values):
if not isinstance(values, collections.Iterable):
raise TypeError( parameter must be an iterable type )
total = 0
for v in values:
if not isinstance(v, (int, ﬂoat)):
raise TypeError( elements must be numeric )
total = total+ v
return total
The abstract base class, collections.Iterable, includes all of Python’s iterable con-
tainers types that guarantee support for the for-loop syntax (e.g., list, tuple, set);
wediscuss iterables in Section 1.8, and the use ofmodules, such as collections, in
Section 1.11. Within the body of the for loop, each element isveriﬁed as numeric
before beingadded tothetotal. Afarmoredirect andclearimplementation ofthis
function canbewrittenasfollows:
def sum(values):
total = 0
for v in values:
total = total + v
return total
Interestingly, this simple implementation performs exactly like Python’s built-in
version of the function. Even without the explicit checks, appropriate exceptions
are raised naturally by the code. In particular, ifvalues is not an iterable type, the
attempttousethefor-loopsyntaxraisesaTypeErrorreportingthattheobjectisnot
iterable. In the case when a user sends an iterable type that includes a nonnumer-
ical element, such as sum([3.14, oops ]), a TypeError is naturally raised by the
evaluation ofexpression total + v. Theerrormessage
unsupported operand type(s) for +: ’float’ and ’str’
should besufﬁciently informative tothecaller. Perhapsslightly lessobvious isthe
errorthatresultsfromsum([ alpha , beta ]). Itwilltechnically reportafailed
attempt to add an int and str, due to the initial evaluation of total + alpha ,
whentotalhasbeeninitialized to0.
In the remainder of this book, we tend to favor the simpler implementations
in the interest of clean presentation, performing minimal error-checking in most36 Chapter1. PythonPrimer
1.7.2 Catching an Exception
There are several philosophies regarding how to cope with possible exceptional
cases when writing code. For example, if a division x/y is to be computed, there
isclearriskthataZeroDivisionErrorwillberaisedwhenvariableyhasvalue0. In
anideal situation, thelogic ofthe program maydictate thatyhas anonzero value,
thereby removing the concern for error. However, for more complex code, or in
a case where the value of y depends on some external input to the program, there
remainssomepossibility ofanerror.
One philosophy for managing exceptional cases is to “look before you leap.”
The goal is to entirely avoid the possibility of an exception being raised through
the use of a proactive conditional test. Revisiting our division example, we might
avoidtheoffending situation bywriting:
if y != 0:
ratio = x / y
else:
... do something else ...
A second philosophy, often embraced by Python programmers, is that “it is
easier toaskforforgiveness thanitistogetpermission.” Thisquote isattributed
to Grace Hopper, an early pioneer in computer science. The sentiment is that we
need not spend extra execution time safeguarding against every possible excep-
tional case, as long as there is a mechanism for coping with a problem after it
arises. InPython, thisphilosophy isimplemented using atry-except control struc-
ture. Revisingourﬁrstexample,thedivisionoperation canbeguarded asfollows:
try:
ratio = x / y
except ZeroDivisionError:
... do something else ...
In this structure, the “try” block is the primary code to be executed. Although it
is a single command in this example, it can more generally be a larger block of
indented code. Following the try-block are one or more “except” cases, each with
anidentiﬁederrortypeandanindentedblockofcodethatshouldbeexecutedifthe
designated errorisraisedwithinthetry-block.
Therelativeadvantageofusingatry-exceptstructureisthatthenon-exceptional
caserunsefﬁciently,withoutextraneouschecksfortheexceptionalcondition. How-
ever, handling the exceptional case requires slightly moretime when using a try-
except structure than with a standard conditional statement. For this reason, the
try-except clause is best used when there is reason to believe that the exceptional
caseisrelativelyunlikely, orwhenitisprohibitively expensivetoproactively eval-1.7. ExceptionHandling 37
Exception handling is particularly useful when working with user input, or
whenreading fromorwritingtoﬁles,becausesuchinteractions areinherently less
predictable. In Section 1.6.2, we suggest the syntax,fp = open( sample.txt ),
foropeningaﬁlewithreadaccess. ThatcommandmayraiseanIOErrorforavari-
etyofreasons,suchasanon-existentﬁle,orlackofsufﬁcientprivilegeforopening
aﬁle. Itissigniﬁcantlyeasiertoattemptthecommandandcatchtheresultingerror
thanitistoaccurately predictwhetherthecommandwillsucceed.
Wecontinue bydemonstrating afewother formsofthetry-except syntax. Ex-
ceptionsareobjectsthatcanbeexaminedwhencaught. Todoso,anidentiﬁermust
beestablished withasyntaxasfollows:
try:
fp = open( sample.txt )
except IOError as e:
print( Unable to open the file: , e)
Inthiscase,thename,e,denotestheinstanceoftheexceptionthatwasthrown,and
printing itcausesadetailed errormessagetobedisplayed (e.g.,“ﬁlenotfound”).
A try-statement may handle more than one type of exception. For example,
consider thefollowingcommandfromSection1.6.1:
age = int(input( Enter your age in years: ))
This command could fail for a variety of reasons. The call to input will raise an
EOFErroriftheconsole input fails. Ifthecall toinputcompletes successfully, the
intconstructor raises aValueErroriftheuserhasnotentered characters represent-
ing a valid integer. If we want to handle two or more types of errors in the same
way,wecanuseasingleexcept-statement, asinthefollowingexample:
age = −1 # an initially invalid choice
while age <= 0:
try:
age = int(input( Enter your age in years: ))
if age <= 0:
print( Your age must be positive )
except (ValueError, EOFError):
print( Invalid response )
Weusethetuple,(ValueError, EOFError),todesignate thetypesoferrors thatwe
wishtocatchwiththeexcept-clause. Inthisimplementation, wecatcheithererror,
print a response, and continue with another pass of the enclosing while loop. We
note that when an error is raised within the try-block, the remainder of that body
is immediately skipped. In this example, if the exception arises within the call to
input, or the subsequent call to the int constructor, the assignment to age never38 Chapter1. PythonPrimer
willbeunchanged, thewhile loop willcontinue. Ifwepreferred tohave the while
loopcontinuewithoutprintingthe Invalid response message,wecouldhave
writtentheexception-clause as
except (ValueError, EOFError):
pass
The keyword, pass, is astatement that does nothing, yet it can serve syntactically
asabodyofacontrolstructure. Inthisway,wequietlycatchtheexception,thereby
allowingthesurrounding whilelooptocontinue.
Inorder toprovide different responses todifferent typesoferrors, wemayuse
two or more except-clauses as part of a try-structure. In ourprevious example, an
EOFErrorsuggests amoreinsurmountable errorthansimplyanerrant valuebeing
entered. In that case, we might wish to provide a more speciﬁc error message, or
perhaps to allow the exception to interrupt the loop and be propagated to a higher
context. Wecouldimplementsuchbehavior asfollows:
age = −1 # an initially invalid choice
while age <= 0:
try:
age = int(input( Enter your age in years: ))
if age <= 0:
print( Your age must be positive )
except ValueError:
print( That is an invalid age specification )
except EOFError:
print( There was an unexpected error reading input. )
raise # let s re-raise this exception
In this implementation, we have separate except-clauses for the ValueError and
EOFErrorcases. ThebodyoftheclauseforhandlinganEOFErrorreliesonanother
technique inPython. Ituses theraisestatement without anysubsequent argument,
to re-raise the same exception that is currently being handled. This allows us to
provideourownresponsetotheexception, andthentointerruptthewhileloopand
propagate theexceptionupward.
In closing, we note two additional features of try-except structures in Python.
It is permissible to have a ﬁnal except-clause without any identiﬁed error types,
using syntax except:, to catch any other exceptions that occurred. However, this
technique should be used sparingly, as it is difﬁcult to suggest how to handle an
errorofanunknowntype. Atry-statementcanhaveaﬁnallyclause,withabodyof
code that will always be executed in the standard or exceptional cases, even when
anuncaught orre-raised exception occurs. Thatblock istypically used for critical1.8. IteratorsandGenerators 39
1.8 Iterators and Generators
InSection1.4.2,weintroduced thefor-loop syntaxbeginning as:
for element in iterable:
and we noted that there are many types of objects in Python that qualify as being
iterable. Basiccontainertypes,suchaslist,tuple,andset,qualifyasiterabletypes.
Furthermore, a string can produce an iteration of its characters, a dictionary can
produceaniterationofitskeys,andaﬁlecanproduceaniterationofitslines. User-
deﬁnedtypesmayalsosupport iteration. InPython,themechanism foriteration is
baseduponthefollowingconventions:
• Aniteratorisanobjectthatmanagesaniterationthroughaseriesofvalues. If
variable,i,identiﬁesaniteratorobject,theneachcalltothebuilt-infunction,
next(i), produces a subsequent element from the underlying series, with a
StopIterationexception raisedtoindicate thattherearenofurther elements.
• Aniterableisanobject,obj,thatproducesaniteratorviathesyntaxiter(obj).
By these deﬁnitions, an instance of a list is an iterable, but not itself an iterator.
With data = [1, 2, 4, 8], it is not legal to call next(data). However, an iterator
object can be produced withsyntax, i = iter(data), and then each subsequent call
tonext(i)willreturn anelement ofthatlist. Thefor-loop syntax inPythonsimply
automatesthisprocess,creatinganiteratorforthegiveiterable,andthenrepeatedly
callingforthenextelementuntilcatchingtheStopIterationexception.
More generally, it is possible to create multiple iterators based upon the same
iterable object, with each iterator maintaining its own state of progress. However,
iterators typically maintain their state with indirect reference back to the original
collection ofelements. Forexample, callingiter(data)on a list instance produces
aninstanceofthelist iteratorclass. Thatiteratordoesnotstoreitsowncopyofthe
listofelements. Instead,itmaintainsacurrentindexintotheoriginallist,represent-
ing the next element to be reported. Therefore, if the contents of the original list
are modiﬁed after the iterator is constructed, but before the iteration is complete,
theiteratorwillbereporting theupdatedcontents ofthelist.
Pythonalsosupports functions andclassesthatproduceanimplicititerablese-
riesofvalues, thatis, withoutconstructing adatastructure tostoreallofitsvalues
atonce. Forexample,thecallrange(1000000) doesnotreturnalistofnumbers;it
returns arangeobject that isiterable. Thisobject generates the million values one
at a time, and only as needed. Such a lazy evaluation technique has great advan-
tage. In the case of range, it allows a loop of the form, for j in range(1000000):,
to execute without setting aside memory for storing one million values. Also, if
such a loop were to be interrupted in some fashion, no time will have been spent40 Chapter1. PythonPrimer
We see lazy evaluation used in many of Python’s libraries. For example, the
dictionary class supports methods keys(), values(), and items(), which respec-
tivelyproducea“view”ofallkeys,values,or(key,value)pairswithinadictionary.
None of these methods produces an explicit list of results. Instead, the views that
are produced are iterable objects based upon the actual contents of the dictionary.
Anexplicitlistofvaluesfromsuchaniteration canbeimmediatelyconstructed by
calling thelistclassconstructor withtheiteration asaparameter. Forexample, the
syntax list(range(1000)) produces alist instance with values from 0to 999, while
thesyntaxlist(d.values())produces alistthathaselementsbaseduponthecurrent
values of dictionary d. We can similarly construct a tuple or set instance based
uponagiveniterable.
Generators
In Section 2.3.4, we will explain how to deﬁne a class whose instances serve as
iterators. However, the most convenient technique for creating iterators in Python
is through the use of generators. A generator is implemented with a syntax that
is very similar to a function, but instead of returning values, a yield statement is
executed to indicate each element of the series. As an example, consider the goal
of determining all factors of a positive integer. For example, the number 100 has
factors 1, 2, 4, 5, 10, 20, 25, 50, 100. A traditional function might produce and
returnalistcontaining allfactors, implementedas:
def factors(n): # traditional function that computes factors
results = [ ] # store factors in a new list
for k in range(1,n+1):
if n % k == 0: # divides evenly, thus k is a factor
results.append(k) # add k to the list of factors
return results # return the entire list
Incontrast,animplementation ofageneratorforcomputingthosefactorscouldbe
implementedasfollows:
def factors(n): # generator that computes factors
for k in range(1,n+1):
if n % k == 0: # divides evenly, thus k is a factor
yield k # yield this factor as next result
Notice use of the keyword yield rather than return to indicate a result. This indi-
catestoPythonthatwearedeﬁningagenerator,ratherthanatraditionalfunction. It
isillegaltocombineyieldandreturnstatementsinthesameimplementation, other
thanazero-argument returnstatement tocause agenerator toenditsexecution. If
aprogrammer writesaloop suchasfor factor in factors(100):,aninstance ofour1.8. IteratorsandGenerators 41
untilayieldstatement indicates thenextvalue. Atthatpoint, theprocedure istem-
porarily interrupted, only to be resumed when another value is requested. When
the ﬂowof control naturally reaches theend ofour procedure(or a zero-argument
returnstatement), aStopIterationexception isautomatically raised. Although this
particularexampleusesasingleyieldstatementinthesourcecode,ageneratorcan
rely on multiple yield statements in different constructs, with the generated series
determined by the natural ﬂow of control. For example, we can greatly improve
the efﬁciency of our generator for computing factors of a number, n, by only test-
ing values up to the square root of that number, while reporting the factor n//k
that is associated with eachk (unless n//k equals k). Wemight implement such a
generator asfollows:
def factors(n): # generator that computes factors
k = 1
while k k < n: # while k < sqrt(n)
if n % k == 0:
yield k
yield n // k
k += 1
if k k == n: # special case if n is perfect square
yield k
We should note that this generator differs from our ﬁrst version in that the factors
are notgenerated instrictly increasing order. Forexample, factors(100) generates
theseries1,100,2,50,4,25,5,20,10.
In closing, wewish to emphasize the beneﬁts of lazy evaluation when using a
generator rather than a traditional function. The results are only computed if re-
quested, and the entire series need not reside in memory at one time. In fact, a
generator can effectively produce an inﬁnite series of values. As an example, the
Fibonacci numbers form a classic mathematical sequence, starting with value 0,
then value 1, and then each subsequent value being the sum of the two preceding
values. Hence, the Fibonacci series begins as: 0,1,1,2,3,5,8,13,.... The follow-
inggenerator produces thisinﬁniteseries.
def ﬁbonacci():
a = 0
b = 1
while True: # keep going...
yield a # report value, a, during this pass
future = a + b
a = b # this will be next value reported42 Chapter1. PythonPrimer
1.9 Additional Python Conveniences
Inthissection, weintroduce severalfeatures ofPythonthatareparticularly conve-
nient forwritingclean, concise code. Eachofthesesyntaxes provide functionality
that could otherwise be accomplished using functionality that we have introduced
earlierinthischapter. However,attimes,thenewsyntaxisamoreclearanddirect
expression ofthelogic.
1.9.1 Conditional Expressions
Python supports aconditional expression syntax that canreplace asimplecontrol
structure. Thegeneralsyntaxisanexpression oftheform:
expr1 if condition else expr2
Thiscompoundexpressionevaluatestoexpr1iftheconditionistrue,andotherwise
evaluates to expr2. For those familiar with Java or C++, this is equivalent to the
syntax,condition ? expr1 : expr2,inthoselanguages.
Asanexample,considerthegoalofsendingtheabsolutevalueofavariable,n,
to a function (and without relying on the built-in abs function, for the sake of ex-
ample). Usingatraditional controlstructure, wemightaccomplish thisasfollows:
if n >= 0:
param = n
else:
param = −n
result = foo(param) # call the function
With the conditional expression syntax, wecan directly assign avalue to variable,
param,asfollows:
param = n if n >= 0 else −n # pick the appropriate value
result = foo(param) # call the function
Infact, thereisnoneed toassignthecompound expression toavariable. Acondi-
tionalexpression canitselfserveasaparametertothefunction, writtenasfollows:
result = foo(n if n >= 0 else −n)
Sometimes, the mere shortening of source code is advantageous because it
avoids the distraction of a more cumbersome control structure. However, we rec-
ommendthataconditionalexpressionbeusedonlywhenitimprovesthereadability
ofthesourcecode,andwhentheﬁrstofthetwooptionsisthemore“natural”case,
givenitsprominenceinthesyntax. (Weprefertoviewthealternativevalueasmore1.9. AdditionalPythonConveniences 43
1.9.2 Comprehension Syntax
A very common programming task is to produce one series of values based upon
theprocessing ofanotherseries. Often,thistaskcanbeaccomplished quitesimply
in Python using what is known as acomprehension syntax. We begin by demon-
strating list comprehension, as this was the ﬁrst form to be supported by Python.
Itsgeneralformisasfollows:
[ expression for value in iterable if condition ]
We note that both expression and condition may depend on value, and that the
if-clause is optional. The evaluation of the comprehension is logically equivalent
tothefollowingtraditional controlstructure forcomputingaresulting list:
result = [ ]
for value in iterable:
if condition:
result.append(expression)
As a concrete example, a list of the squares of the numbers from 1 to n, that is
[1,4,9,16,25,...,n2],canbecreatedbytraditional meansasfollows:
squares = [ ]
for k in range(1, n+1):
squares.append(k k)
Withlistcomprehension, thislogicisexpressed asfollows:
squares = [k k for k in range(1, n+1)]
Asasecond example,Section1.8introduced thegoalofproducing alistoffactors
foranintegern. Thattaskisaccomplished withthefollowinglistcomprehension:
factors = [k for k in range(1,n+1) if n % k == 0]
Python supports similar comprehension syntaxes that respectively produce a
set, generator, or dictionary. We compare those syntaxes using our example for
producing thesquares ofnumbers.
[ k k for k in range(1, n+1) ] listcomprehension
{ k k for k in range(1, n+1) } setcomprehension
( k k for k in range(1, n+1) ) generator comprehension
{ k : k k for k in range(1, n+1) } dictionary comprehension
Thegeneratorsyntaxisparticularlyattractivewhenresultsdonotneedtobestored
in memory. For example, to compute the sum of the ﬁrst n squares, the genera-
torsyntax,total = sum(k k for k in range(1, n+1)),ispreferredtotheuseofan44 Chapter1. PythonPrimer
1.9.3 Packing and Unpacking of Sequences
Pythonprovidestwoadditional conveniences involving thetreatmentoftuplesand
other sequence types. The ﬁrst is rather cosmetic. If a series of comma-separated
expressionsaregiveninalargercontext,theywillbetreatedasasingletuple,even
ifnoenclosing parentheses areprovided. Forexample,theassignment
data = 2, 4, 6, 8
results in identiﬁer, data, being assigned to the tuple (2, 4, 6, 8). This behavior
is called automatic packing of a tuple. One common use of packing in Python is
whenreturning multiplevalues fromafunction. Ifthebodyofafunction executes
thecommand,
return x, y
itwillbeformallyreturning asingleobjectthatisthetuple(x, y).
As a dual to the packing behavior, Python can automatically unpack a se-
quence, allowing one to assign a series of individual identiﬁers to the elements
ofsequence. Asanexample,wecanwrite
a, b, c, d = range(7, 11)
which hasthe effect of assigning a=7, b=8, c=9,and d=10, asthose are the four
valuesinthesequencereturnedbythecalltorange. Forthissyntax,theright-hand
sideexpression canbeanyiterabletype, aslong asthenumber ofvariables onthe
left-hand sideisthesameasthenumberofelementsintheiteration.
Thistechnique canbeusedtounpack tuplesreturned byafunction. Forexam-
ple, thebuilt-in function, divmod(a, b),returns thepairofvalues(a // b, a % b)
associated with an integer division. Although the caller can consider the return
valuetobeasingletuple, itispossible towrite
quotient, remainder = divmod(a, b)
toseparately identify thetwoentriesofthereturned tuple. Thissyntax canalsobe
usedinthecontextofaforloop,wheniteratingoverasequence ofiterables, asin
for x, y in [ (7, 2), (5, 8), (6, 4) ]:
Inthisexample,therewillbethreeiterationsoftheloop. Duringtheﬁrstpass,x=7
and y=2, and so on. This style of loop is quite commonly used to iterate through
key-value pairsthatarereturned bytheitems()methodofthedictclass,asin:1.9. AdditionalPythonConveniences 45
Simultaneous Assignments
The combination of automatic packing and unpacking forms a technique known
as simultaneous assignment, whereby we explicitly assign a series of values to a
seriesofidentiﬁers, usingasyntax:
x, y, z = 6, 2, 5
Ineffect,theright-handsideofthisassignmentisautomaticallypackedintoatuple,
andthenautomatically unpacked withitselements assignedtothethreeidentiﬁers
ontheleft-hand side.
When using a simultaneous assignment, all of the expressions are evaluated
on the right-hand side before any of the assignments are made to the left-hand
variables. This is signiﬁcant, as it provides a convenient means for swapping the
valuesassociated withtwovariables:
j, k = k, j
Withthiscommand,jwillbeassigned totheoldvalueofk,andkwillbeassigned
to the old value of j. Without simultaneous assignment, a swap typically requires
moredelicateuseofatemporary variable, suchas
temp = j
j = k
k = temp
Withthesimultaneousassignment, theunnamedtuplerepresenting thepackedval-
ues on the right-hand side implicitly serves as the temporary variable when per-
formingsuchaswap.
The use of simultaneous assignments can greatly simplify the presentation of
code. As an example, we reconsider the generator on page 41 that produces the
Fibonacci series. The original code requires separate initialization of variables a
and bto begin the series. Within each pass of the loop, the goal wasto reassign a
and b, respectively, tothevalues ofbanda+b. Atthetime, weaccomplished this
with brief use of a third variable. With simultaneous assignments, that generator
canbeimplemented moredirectly asfollows:
def ﬁbonacci():
a, b = 0, 1
while True:
yield a46 Chapter1. PythonPrimer
1.10 Scopes and Namespaces
When computing a sum with the syntax x + y in Python, the names x and y must
have been previously associated with objects that serve as values; a NameError
will be raised if no such deﬁnitions are found. The process of determining the
valueassociated withanidentiﬁerisknownasnameresolution.
Whenever an identiﬁer is assigned to a value, that deﬁnition is made with a
speciﬁcscope. Top-levelassignmentsaretypicallymadeinwhatisknownasglobal
scope. Assignmentsmadewithinthebodyofafunctiontypicallyhavescopethatis
local to that function call. Therefore, an assignment, x = 5, within afunction has
noeffectontheidentiﬁer,x,inthebroader scope.
Each distinct scope in Python is represented using an abstraction known as a
namespace. A namespace manages all identiﬁers that are currently deﬁned in a
given scope. Figure 1.8portrays twonamespaces, onebeing thatof acaller toour
count function from Section 1.5, and the other being the local namespace during
theexecutionofthatfunction.
str
ﬂoat
n
A int
3.56 gpa
target
2
grades
data
list
major
str item
CS
str str str
A- B+ A-
Figure 1.8: A portrayal of the two namespaces associated with a user’s call
count(grades, A ), as deﬁned in Section 1.5. The left namespace is the caller’s
andtherightnamespace represents thelocalscopeofthefunction.
Python implements a namespace with its own dictionary that maps each iden-
tifying string (e.g., n ) to its associated value. Python provides several ways to
examine agivennamespace. Thefunction, dir, reports thenamesoftheidentiﬁers
in a given namespace (i.e., the keys of the dictionary), while the function, vars,
returns the full dictionary. Bydefault, calls todir() and vars() report on the most1.10. ScopesandNamespaces 47
When an identiﬁer is indicated in a command, Python searches a series of
namespaces in the process of name resolution. First, the most locally enclosing
scope is searched for a given name. If not found there, the next outer scope is
searched, and so on. We will continue our examination of namespaces, in Sec-
tion 2.5, when discussing Python’s treatment of object-orientation. We will see
thateach object hasitsownnamespace tostoreitsattributes, andthatclasses each
haveanamespace aswell.
First-Class Objects
In the terminology of programming languages, ﬁrst-class objects are instances of
a type that can be assigned to an identiﬁer, passed as a parameter, or returned by
a function. All of the data types we introduced in Section 1.2.3, such as int and
list,areclearlyﬁrst-classtypesinPython. InPython,functionsandclassesarealso
treatedasﬁrst-classobjects. Forexample,wecouldwritethefollowing:
scream = print # assign name ’scream’ to the function denoted as ’print’
scream( Hello ) # call that function
In this case, we have not created a new function, we have simply deﬁned scream
as an alias for the existing print function. While there is little motivation for pre-
cisely this example, it demonstrates the mechanism that is used by Python to al-
low one function to be passed as a parameter to another. On page 28, we noted
that the built-in function, max, accepts an optional keyword parameter to specify
a non-default order when computing a maximum. For example, a caller can use
the syntax, max(a, b, key=abs), to determine which value has the larger absolute
value. Within the body of that function, the formal parameter, key, is an identiﬁer
thatwillbeassigned totheactualparameter,abs.
Intermsofnamespaces, anassignment suchasscream = print,introduces the
identiﬁer, scream, into the current namespace, with its value being the object that
representsthebuilt-infunction,print. Thesamemechanismisappliedwhenauser-
deﬁned function is declared. For example, our count function from Section 1.5
beingswiththefollowingsyntax:
def count(data, target):
...
Such a declaration introduces the identiﬁer, count, into the current namespace,
withthevaluebeingafunctioninstancerepresentingitsimplementation. Insimilar
fashion, the name of a newly deﬁned class is associated with a representation of48 Chapter1. PythonPrimer
1.11 Modules and the Import Statement
We have already introduced many functions (e.g., max) and classes (e.g., list)
that are deﬁned within Python’s built-in namespace. Depending on the version of
Python, there areapproximately 130–150 deﬁnitions that were deemed signiﬁcant
enoughtobeincluded inthatbuilt-innamespace.
Beyond the built-in deﬁnitions, the standard Python distribution includes per-
haps tensofthousands ofother values, functions, andclasses that areorganized in
additional libraries, known as modules, that can be imported from within a pro-
gram. Asanexample,weconsiderthemathmodule. Whilethebuilt-innamespace
includes a few mathematical functions (e.g., abs, min, max, round), many more
are relegated to the math module (e.g., sin, cos, sqrt). That module also deﬁnes
approximate valuesforthemathematical constants,piande.
Python’s import statement loads deﬁnitions from a module into the current
namespace. Oneformofanimportstatementusesasyntaxsuchasthefollowing:
from math import pi, sqrt
Thiscommand adds bothpiand sqrt,as deﬁned inthe mathmodule, into thecur-
rent namespace, allowing direct use of the identiﬁer, pi, or a call of the function,
sqrt(2). If there are many deﬁnitions from the same module to be imported, an
asterisk may be used as a wild card, as in, from math import , but this form
shouldbeusedsparingly. Thedangeristhatsomeofthenamesdeﬁnedinthemod-
ule may conﬂict with names already in the current namespace (or being imported
fromanothermodule),andtheimportcausesthenewdeﬁnitionstoreplaceexisting
ones.
Another approach that can be used to access many deﬁnitions from the same
moduleistoimportthemoduleitself,usingasyntaxsuchas:
import math
Formally,thisaddstheidentiﬁer,math,tothecurrentnamespace, withthemodule
as its value. (Modules are also ﬁrst-class objects in Python.) Once imported, in-
dividual deﬁnitions fromthemodulecanbeaccessed usingafully-qualiﬁed name,
suchasmath.piormath.sqrt(2).
Creating a New Module
To create a new module, one simply has to put the relevant deﬁnitions in a ﬁle
named with a .py sufﬁx. Those deﬁnitions can be imported from any other .py
ﬁlewithinthesameprojectdirectory. Forexample,ifweweretoputthedeﬁnition
of our count function (see Section 1.5) into a ﬁle named utility.py, we could1.11. ModulesandtheImportStatement 49
It is worth noting that top-level commands with the module source code are
executed when the module is ﬁrst imported, almost as if the module were its own
script. There is a special construct for embedding commands within the module
that will be executed if the module is directly invoked as a script, but not when
themoduleisimportedfromanotherscript. Suchcommandsshould beplacedina
bodyofaconditional statementofthefollowingform,
if name == __main__ :
Using our hypothetical utility.pymodule as an example, such commands will
beexecutediftheinterpreterisstartedwithacommandpython utility.py,but
notwhentheutilitymoduleisimportedintoanothercontext. Thisapproachisoften
usedtoembedwhatareknownasunittestswithinthemodule;wewilldiscussunit
testingfurtherinSection2.2.4.
1.11.1 Existing Modules
Table 1.7 provides a summary of a few available modules that are relevant to a
studyofdatastructures. Wehavealreadydiscussedthemathmodulebrieﬂy. Inthe
remainderofthissection,wehighlightanothermodulethatisparticularlyimportant
forsomeofthedatastructures andalgorithms thatwewillstudylaterinthisbook.
ExistingModules
ModuleName Description
array Providescompactarraystorageforprimitivetypes.
Deﬁnesadditionaldatastructuresandabstractbaseclasses
collections
involvingcollectionsofobjects.
copy Deﬁnesgeneralfunctionsformakingcopiesofobjects.
heapq Providesheap-basedpriorityqueuefunctions(seeSection9.3.7).
math Deﬁnescommonmathematicalconstantsandfunctions.
os Providessupportforinteractionswiththeoperatingsystem.
random Providesrandomnumbergeneration.
re Providessupportforprocessingregularexpressions.
sys ProvidesadditionallevelofinteractionwiththePythoninterpreter.
time Providessupportformeasuringtime,ordelayingaprogram.
Table1.7:SomeexistingPythonmodulesrelevanttodatastructuresandalgorithms.
Pseudo-Random Number Generation
Python’srandommoduleprovidestheabilitytogeneratepseudo-random numbers,
that is, numbers that are statistically random (but not necessarily truly random).50 Chapter1. PythonPrimer
next number in a sequence based upon one or more past numbers that it has gen-
erated. Indeed, asimple yetpopular pseudo-random number generator chooses its
nextnumberbasedsolelyonthemostrecentlychosennumberandsomeadditional
parameters usingthefollowingformula.
next=(a*current+b)%n;
wherea,b, andnareappropriately chosen integers. Python usesamoreadvanced
technique known as aMersenne twister. It turns out that the sequences generated
by these techniques can be proven to be statistically uniform, which is usually
goodenough formostapplications requiring random numbers, suchasgames. For
applications, such as computer security settings, where one needs unpredictable
random sequences, this kind of formula should not be used. Instead, one should
ideally sample from a source that is actually random, such asradio static coming
fromouterspace.
Sincethenextnumberinapseudo-random generator isdetermined bythepre-
vious number(s), suchagenerator alwaysneeds aplacetostart, whichiscalled its
seed. Thesequenceofnumbersgeneratedforagivenseedwillalwaysbethesame.
Onecommontrick togetadifferent sequence eachtimeaprogram isrunistouse
a seed that will be different for each run. For example, we could use some timed
inputfromauserorthecurrentsystemtimeinmilliseconds.
Python’s random module provides support for pseudo-random number gener-
ation by deﬁning aRandom class; instances of that class serve as generators with
independent state. This allows different aspects of a program to rely on their own
pseudo-random number generator, so that calls to one generator do not affect the
sequence of numbers produced by another. For convenience, all of the methods
supported by the Random class are also supported as stand-alone functions of the
randommodule(essentiallyusingasinglegeneratorinstanceforalltop-levelcalls).
Syntax Description
Initializesthepseudo-randomnumbergenerator
seed(hashable)
baseduponthehashvalueoftheparameter
Returnsapseudo-randomﬂoating-point
random()
valueintheinterval[0.0,1.0).
Returnsapseudo-randominteger
randint(a,b)
intheclosedinterval[a,b].
Returnsapseudo-randomintegerinthestandard
randrange(start, stop, step)
Pythonrangeindicatedbytheparameters.
Returnsanelementofthegivensequence
choice(seq)
chosenpseudo-randomly.
Reorderstheelementsofthegiven
shuﬄe(seq)
sequencepseudo-randomly.
Table 1.8: Methods supported by instances of the Random class, and as top-level1.12. Exercises 51
1.12 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-1.1 Write a short Python function, is multiple(n, m), that takes two integer
values and returns True if n is a multiple of m, that is, n=mi for some
integeri,andFalseotherwise.
R-1.2 Write ashort Python function, is even(k), that takes aninteger value and
returns True if k is even, and False otherwise. However, your function
cannotusethemultiplication, modulo,ordivision operators.
R-1.3 Write a short Python function, minmax(data), that takes a sequence of
oneormorenumbers,andreturnsthesmallestandlargestnumbers,inthe
form of a tuple of length two. Do not use the built-in functions min or
maxinimplementing yoursolution.
R-1.4 Write a short Python function that takes a positive integer n and returns
thesumofthesquares ofallthepositiveintegerssmallerthann.
R-1.5 GiveasinglecommandthatcomputesthesumfromExerciseR-1.4,rely-
ingonPython’scomprehension syntaxandthebuilt-insumfunction.
R-1.6 Write a short Python function that takes a positive integer n and returns
thesumofthesquares ofalltheoddpositiveintegerssmallerthann.
R-1.7 GiveasinglecommandthatcomputesthesumfromExerciseR-1.6,rely-
ingonPython’scomprehension syntaxandthebuilt-insumfunction.
R-1.8 Python allows negative integers to be used as indices into a sequence,
suchasastring. Ifstringshaslengthn,andexpressions[k]isusedforin-
dex−n≤k<0,whatistheequivalentindex j≥0suchthats[j]references
thesameelement?
R-1.9 What parameters should be sent to the range constructor, to produce a
rangewithvalues50,60,70,80?
R-1.10 What parameters should be sent to the range constructor, to produce a
rangewithvalues8,6,4,2,0,−2,−4,−6,−8?
R-1.11 Demonstrate how to use Python’s list comprehension syntax to produce
thelist[1, 2, 4, 8, 16, 32, 64, 128, 256].
R-1.12 Python’s random module includes a function choice(data) that returns a
random element from a non-empty sequence. The random module in-
cludes amore basic functionrandrange, withparameterization similar to
the built-in range function, that return a random choice from the given
range. Using only the randrange function, implement your own version52 Chapter1. PythonPrimer
Creativity
C-1.13 Write a pseudo-code description of a function that reverses a list of n
integers, so that the numbers are listed in the opposite order than they
were before, and compare this method to an equivalent Python function
fordoingthesamething.
C-1.14 Write ashort Python function that takes asequence of integer values and
determines if there is a distinct pair of numbers in the sequence whose
product isodd.
C-1.15 WriteaPythonfunctionthattakesasequenceofnumbersanddetermines
ifallthenumbersaredifferentfromeachother(thatis,theyaredistinct).
C-1.16 Inourimplementationofthescalefunction(page25),thebodyoftheloop
executesthecommanddata[j] = factor. Wehavediscussedthatnumeric
typesareimmutable,andthatuseofthe =operatorinthiscontextcauses
the creation of a new instance (not the mutation of an existing instance).
Howisitstillpossible,then,thatourimplementationofscalechangesthe
actualparametersentbythecaller?
C-1.17 Hadweimplementedthescalefunction(page25)asfollows,doesitwork
properly?
def scale(data, factor):
for val in data:
val = factor
Explainwhyorwhynot.
C-1.18 Demonstrate how to use Python’s list comprehension syntax to produce
thelist[0, 2, 6, 12, 20, 30, 42, 56, 72, 90].
C-1.19 Demonstrate how to use Python’s list comprehension syntax to produce
the list [ a , b , c , ..., z ], but without having to type all 26 such
characters literally.
C-1.20 Python’s randommodule includes afunction shuﬄe(data)that accepts a
list of elements and randomly reorders the elements so that each possi-
ble order occurs with equal probability. The random module includes a
morebasicfunctionrandint(a, b)thatreturnsauniformlyrandominteger
from a to b (including both endpoints). Using only the randintfunction,
implementyourownversionoftheshuﬄefunction.
C-1.21 Write a Python program that repeatedly reads lines from standard input
until an EOFError is raised, and then outputs those lines in reverse order1.12. Exercises 53
C-1.22 Write a short Python program that takes two arrays a and b of length n
storingintvalues,andreturnsthedotproductofaandb. Thatis,itreturns
anarraycoflengthnsuchthatc[i]=a[i]·b[i],fori=0,...,n−1.
C-1.23 GiveanexampleofaPythoncodefragment thatattemptstowriteanele-
ment to a list based on an index that may be out of bounds. If that index
isoutofbounds, theprogram should catch theexception thatresults, and
printthefollowingerrormessage:
“Don’t try buffer overflow attacks in Python!”
C-1.24 WriteashortPythonfunctionthatcountsthenumberofvowelsinagiven
character string.
C-1.25 WriteashortPythonfunctionthattakesastrings,representingasentence,
and returns acopy ofthe string withallpunctuation removed. Forexam-
ple,ifgiventhestring"Let s try, Mike.",thisfunction wouldreturn
"Lets try Mike".
C-1.26 Write ashort program that takes asinput three integers,a, b, and c, from
the console and determines if they can be used in a correct arithmetic
formula(inthegivenorder), like“a+b=c,”“a=b−c,”or“a∗b=c.”
C-1.27 InSection1.8,weprovidedthreedifferentimplementationsofagenerator
that computes factors of a given integer. The third of those implementa-
tions, from page 41, was the most efﬁcient, but we noted that it did not
yieldthefactorsinincreasingorder. Modifythegeneratorsothatitreports
factorsinincreasing order,whilemaintaining itsgeneralperformance ad-
vantages.
C-1.28 The p-norm of a vector v=(v ,v ,...,v ) in n-dimensional space is de-
1 2 n
ﬁnedas
(cid:2)
p
(cid:7)v(cid:7)= vp+vp+···+vp.
1 2 n
For the special case of p = 2, this results in the traditional Euclidean
norm, which represents the length of the vector. For example, the Eu-
clidean norm of a t√wo-dimensio√nal vector√with coordinates (4,3) has a
Euclidean norm of 42+32 = 16+9= 25=5. Givean implemen-
tation ofafunction namednormsuchthatnorm(v, p)returns the p-norm
valueofvandnorm(v)returnstheEuclideannormofv. Youmayassume54 Chapter1. PythonPrimer
Projects
P-1.29 Write aPython program that outputs allpossible strings formed byusing
thecharacters c , a , t , d , o ,and g exactlyonce.
P-1.30 Write a Python program that can take a positive integer greater than 2 as
input and write out the number of times one must repeatedly divide this
numberby2beforegetting avaluelessthan2.
P-1.31 Write a Python program that can “make change.” Your program should
taketwonumbersasinput,onethatisamonetaryamountchargedandthe
other that is a monetary amount given. It should then return the number
of each kind of bill and coin to give back as change for the difference
between the amount given and the amount charged. The values assigned
tothebillsandcoinscanbebasedonthemonetarysystem ofanycurrent
or former government. Try to design your program so that it returns as
fewbillsandcoinsaspossible.
P-1.32 Write a Python program that can simulate a simple calculator, using the
consoleastheexclusiveinputandoutputdevice. Thatis,eachinputtothe
calculator, beitanumber, like12.34or1034,oranoperator, like+or=,
can be done on a separate line. After each such input, you should output
tothePythonconsolewhatwouldbedisplayed onyourcalculator.
P-1.33 Write a Python program that simulates a handheld calculator. Your pro-
gram should process input from the Python console representing buttons
thatare“pushed,”andthenoutputthecontentsofthescreenaftereachop-
erationisperformed. Minimally,yourcalculatorshouldbeabletoprocess
thebasicarithmetic operations andareset/clear operation.
P-1.34 Acommonpunishmentforschoolchildrenistowriteoutasentencemul-
tiple times. Write a Python stand-alone program that will write out the
following sentence one hundred times: “I will never spam my friends
again.” Your program should number each of the sentences andit should
makeeightdifferent random-looking typos.
P-1.35 Thebirthday paradox says thattheprobability thattwopeople inaroom
will have the same birthday is more than half, provided n, the number of
peopleintheroom,ismorethan23. Thispropertyisnotreallyaparadox,
butmanypeopleﬁnditsurprising. DesignaPythonprogramthatcantest
thisparadox byaseriesofexperiments onrandomlygenerated birthdays,
whichtestthisparadox forn=5,10,15,20,...,100.
P-1.36 Write a Python program that inputs a list of words, separated by white-
space, and outputs how many times each word appears in the list. You
need not worry about efﬁciency at this point, however, as this topic isChapterNotes 55
Chapter Notes
The ofﬁcial Python Web site (http://www.python.org) has a wealth of information, in-
cluding a tutorial and full documentation of the built-in functions, classes, and standard
modules. The Python interpreter is itself a useful reference, as the interactive command
help(foo)providesdocumentationforanyfunction,class,ormodulethatfooidentiﬁes.
BooksprovidinganintroductiontoprogramminginPythonincludetitlesauthoredby
Campbelletal.[22],Cedar[25], Dawson[32], GoldwasserandLetscher[43], Lutz[72],
Perkovic[82],andZelle[105].MorecompletereferencebooksonPythonincludetitlesbyChapter
2
Object-Oriented Programming
Contents
2.1 Goals, Principles, and Patterns . . . . . . . . . . . . . . . . 57
2.1.1 Object-Oriented Design Goals . . . . . . . . . . . . . . . 57
2.1.2 Object-Oriented Design Principles . . . . . . . . . . . . . 58
2.1.3 Design Patterns . . . . . . . . . . . . . . . . . . . . . . . 61
2.2 Software Development . . . . . . . . . . . . . . . . . . . . 62
2.2.1 Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
2.2.2 Pseudo-Code . . . . . . . . . . . . . . . . . . . . . . . . 64
2.2.3 Coding Style and Documentation . . . . . . . . . . . . . . 64
2.2.4 Testing and Debugging . . . . . . . . . . . . . . . . . . . 67
2.3 Class Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . 69
2.3.1 Example: CreditCard Class . . . . . . . . . . . . . . . . . 69
2.3.2 Operator Overloading and Python’s Special Methods . . . 74
2.3.3 Example: MultidimensionalVector Class . . . . . . . . . . 77
2.3.4 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
2.3.5 Example: Range Class. . . . . . . . . . . . . . . . . . . . 80
2.4 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
2.4.1 Extending the CreditCard Class . . . . . . . . . . . . . . . 83
2.4.2 Hierarchy of Numeric Progressions . . . . . . . . . . . . . 87
2.4.3 Abstract Base Classes . . . . . . . . . . . . . . . . . . . . 93
2.5 Namespaces and Object-Orientation . . . . . . . . . . . . . 96
2.5.1 Instance and Class Namespaces . . . . . . . . . . . . . . . 96
2.5.2 Name Resolutionand Dynamic Dispatch . . . . . . . . . . 100
2.6 Shallow and Deep Copying . . . . . . . . . . . . . . . . . . 1012.1. Goals,Principles,andPatterns 57
2.1 Goals, Principles, and Patterns
Asthe name implies, the main “actors” in the object-oriented paradigm are called
objects. Each object is an instance of a class. Each class presents to the outside
world a concise and consistent view of the objects that are instances of this class,
withoutgoingintotoomuchunnecessary detailorgivingothersaccesstotheinner
workingsoftheobjects. Theclassdeﬁnitiontypicallyspeciﬁesinstancevariables,
alsoknownasdatamembers,thattheobjectcontains, aswellasthemethods,also
known asmember functions, that the object can execute. This view ofcomputing
isintended tofulﬁll several goals and incorporate severaldesign principles, which
wediscussinthischapter.
2.1.1 Object-Oriented Design Goals
Software implementations should achieve robustness, adaptability, and reusabil-
ity. (SeeFigure2.1.)
Robustness Adaptability Reusability
Figure2.1: Goalsofobject-oriented design.
Robustness
Everygoodprogrammerwantstodevelopsoftwarethatiscorrect,whichmeansthat
a program produces the right output for all the anticipated inputs in the program’s
application. Inaddition,wewantsoftwaretoberobust,thatis,capableofhandling
unexpected inputs that are not explicitly deﬁned for its application. For example,
if a program is expecting a positive integer (perhaps representing the price of an
item) and instead is given a negative integer, then the program should be able to
recover gracefully from this error. More importantly, inlife-critical applications,
where asoftware error can lead toinjury or loss oflife, software that is not robust
could bedeadly. Thispointwasdriven homeinthelate1980s inaccidents involv-
ingTherac-25, aradiation-therapy machine, whichseverely overdosed sixpatients
between 1985 and 1987, some of whom died from complications resulting from58 Chapter2. Object-OrientedProgramming
Adaptability
Modern software applications, such as Web browsers and Internet search engines,
typically involve large programs that are used for many years. Software, there-
fore, needs tobeabletoevolve overtimeinresponse tochanging conditions inits
environment. Thus, another important goal of quality software is that it achieves
adaptability (alsocalledevolvability). Relatedtothisconcept isportability, which
is the ability of software to run with minimal change on different hardware and
operating system platforms. An advantage of writing software in Python is the
portability providedbythelanguageitself.
Reusability
Going hand in hand with adaptability is the desire that software be reusable, that
is, the same code should be usable as a component of differentsystems in various
applications. Developing quality software can be an expensive enterprise, and its
costcanbeoffsetsomewhatifthesoftwareisdesignedinawaythatmakesiteasily
reusable infuture applications. Such reuse should bedone withcare, however, for
oneofthemajorsourcesofsoftwareerrorsintheTherac-25camefrominappropri-
ate reuse of Therac-20 software (which was not object-oriented and not designed
forthehardwareplatformusedwiththeTherac-25).
2.1.2 Object-Oriented Design Principles
Chief among theprinciples of theobject-oriented approach, which are intended to
facilitate thegoalsoutlined above,arethefollowing(seeFigure2.2):
• Modularity
• Abstraction
• Encapsulation
Modularity Abstraction Encapsulation2.1. Goals,Principles,andPatterns 59
Modularity
Modern software systems typically consist of several different components that
must interact correctly in order for the entire system to work properly. Keeping
these interactions straight requires that these different components be well orga-
nized. Modularity refers toanorganizing principle in whichdifferent components
ofasoftwaresystem aredivided intoseparatefunctional units.
As a real-world analogy, a house or apartment can be viewed asconsisting of
several interacting units: electrical, heating and cooling, plumbing, and structural.
Rather than viewing these systems as one giant jumble of wires, vents, pipes, and
boards, the organized architect designing a house or apartment will view them as
separate modulesthatinteractinwell-deﬁnedways. Insodoing, heorsheisusing
modularity to bring a clarity of thought that provides a natural way of organizing
functions intodistinct manageable units.
Inlikemanner, using modularity inasoftware system canalsoprovide apow-
erful organizing framework that brings clarity to an implementation. In Python,
wehavealready seenthat amoduleisacollection ofclosely related functions and
classes that are deﬁned together in a single ﬁle of source code. Python’s standard
librariesinclude,forexample,themathmodule,whichprovidesdeﬁnitionsforkey
mathematical constants and functions, and theos module, which provides support
forinteracting withtheoperating system.
The use of modularity helps support the goals listed in Section 2.1.1. Robust-
nessisgreatlyincreasedbecauseitiseasiertotestanddebugseparate components
beforetheyareintegratedintoalargersoftwaresystem. Furthermore,bugsthatper-
sist inacomplete system mightbe traced toaparticular component, which canbe
ﬁxed in relative isolation. The structure imposed by modularity also helps enable
softwarereusability. Ifsoftwaremodulesarewritteninageneralway,themodules
can be reused when related need arises in other contexts. This is particularly rel-
evant in astudy ofdata structures, which can typically bedesigned with sufﬁcient
abstraction andgenerality tobereusedinmanyapplications.
Abstraction
Thenotionofabstractionistodistillacomplicatedsystemdowntoitsmostfunda-
mentalparts. Typically, describingthepartsofasysteminvolves namingthemand
explaining their functionality. Applying the abstraction paradigm to the design of
datastructuresgivesrisetoabstractdatatypes(ADTs). AnADTisamathematical
model of a data structure that speciﬁes the type ofdata stored, the operations sup-
ported on them, and the types of parameters of the operations. An ADT speciﬁes
what each operation does, but not how it does it. We will typically refer to the60 Chapter2. Object-OrientedProgramming
Asaprogramming language, Pythonprovides agreatdealoflatitude inregard
to the speciﬁcation of an interface. Python has a tradition of treating abstractions
implicitly using a mechanism known as duck typing. As an interpreted and dy-
namically typed language, there is no “compile time” checking of data types in
Python, and no formal requirement for declarations of abstract base classes. In-
stead programmers assume that an object supports a set of known behaviors, with
the interpreter raising a run-time error if those assumptions fail. The description
of this as “duck typing” comes from an adage attributed to poet James Whitcomb
Riley, stating that “when Isee abird that walks like aduck and swimslike aduck
andquackslikeaduck, Icallthatbirdaduck.”
Moreformally, Python supports abstract data types using amechanism known
as an abstract base class (ABC). An abstract base class cannot be instantiated
(i.e.,youcannotdirectlycreateaninstanceofthatclass),butitdeﬁnesoneormore
common methods that all implementations of the abstraction must have. AnABC
isrealizedbyoneormoreconcreteclassesthatinheritfromtheabstractbaseclass
whileproviding implementations forthosemethoddeclaredbytheABC.Python’s
abcmoduleprovidesformalsupportforABCs,althoughweomitsuchdeclarations
for simplicity. We will make use of several existing abstract base classes coming
from Python’s collections module, which includes deﬁnitions for several common
datastructure ADTs,andconcreteimplementations ofsomeofthoseabstractions.
Encapsulation
Another important principle of object-oriented design isencapsulation. Different
components of a software system should not reveal the internal details of their
respective implementations. Oneofthemainadvantages ofencapsulation isthatit
gives one programmer freedom to implement the details of a component, without
concern that other programmers will be writing code that intricately depends on
those internal decisions. The only constraint on the programmer of a component
is to maintain the public interface for the component, as other programmers will
be writing code that depends on that interface. Encapsulation yields robustness
and adaptability, for it allows the implementation details of parts of a program to
changewithoutadverselyaffectingotherparts,therebymakingiteasiertoﬁxbugs
oraddnewfunctionality withrelatively localchanges toacomponent.
Throughoutthisbook,wewilladheretotheprincipleofencapsulation, making
clear which aspects of a data structure are assumed to be public and which are
assumed to be internal details. With that said, Python provides only loose support
forencapsulation. Byconvention,namesofmembersofaclass(bothdatamembers
and member functions) that start with a single underscore character (e.g., secret)
are assumed to be nonpublic and should not be relied upon. Those conventions
are reinforced by the intentional omission of those members from automatically2.1. Goals,Principles,andPatterns 61
2.1.3 Design Patterns
Object-oriented design facilitates reusable, robust, and adaptable software. De-
signing good code takes more than simply understanding object-oriented method-
ologies,however. Itrequirestheeffectiveuseofobject-oriented designtechniques.
Computing researchers andpractitioners havedeveloped avariety oforganiza-
tional concepts and methodologies for designing quality object-oriented software
that is concise, correct, and reusable. Ofspecial relevance to this book is the con-
cept ofadesign pattern, whichdescribes asolution toa“typical” software design
problem. Apatternprovidesageneraltemplateforasolutionthatcanbeappliedin
manydifferentsituations. Itdescribesthemainelementsofasolutioninanabstract
way that can be specialized for a speciﬁc problem at hand. It consists of a name,
whichidentiﬁesthepattern;acontext,whichdescribesthescenariosforwhichthis
pattern canbeapplied; atemplate, whichdescribes howthepatternisapplied; and
aresult, whichdescribes andanalyzes whatthepattern produces.
Wepresent several design patterns inthis book, andweshow how they canbe
consistently applied to implementations of data structures and algorithms. These
design patterns fall into two groups—patterns for solving algorithm design prob-
lemsandpatternsforsolvingsoftwareengineeringproblems. Thealgorithmdesign
patterns wediscuss includethefollowing:
• Recursion (Chapter4)
• Amortization (Sections5.3and11.4)
• Divide-and-conquer (Section12.2.1)
• Prune-and-search, alsoknownasdecrease-and-conquer (Section12.7.1)
• Bruteforce(Section13.2.1)
• Dynamicprogramming (Section13.3).
• Thegreedymethod(Sections13.4.2,14.6.2,and14.7)
Likewise,thesoftwareengineering designpatterns wediscussinclude:
• Iterator (Sections1.8and2.3.4)
• Adapter(Section6.1.2)
• Position(Sections7.4and8.1.2)
• Composition (Sections7.6.1,9.2.1,and10.1.4)
• Templatemethod(Sections 2.4.3,8.4.6,10.1.3,10.5.2,and11.2.1)
• Locator(Section9.5.1)
• Factorymethod(Section11.2.1)
Rather than explain each of these concepts here, however, weintroduce them
throughoutthetextasnotedabove. Foreachpattern,beitforalgorithmengineering
orsoftwareengineering, weexplainitsgeneraluseandweillustrateitwithatleast62 Chapter2. Object-OrientedProgramming
2.2 Software Development
Traditional softwaredevelopment involves severalphases. Threemajorstepsare:
1. Design
2. Implementation
3. TestingandDebugging
In this section, we brieﬂy discuss the role of these phases, and we introduce sev-
eral good practices for programming in Python, including coding style, naming
conventions, formaldocumentation, andunittesting.
2.2.1 Design
For object-oriented programming, the design step is perhaps the most important
phase in the process of developing software. For it is in the design step that we
decide how to divide the workings of our program into classes, we decide how
these classes will interact, what data each will store, and what actions each will
perform. Indeed, one of the main challenges that beginning programmers face is
deciding what classes to deﬁne to do the work of their program. While general
prescriptions arehardtocomeby,therearesomerulesofthumbthatwecanapply
whendetermining howtodesignourclasses:
• Responsibilities: Dividetheworkintodifferentactors, eachwithadifferent
responsibility. Try to describe responsibilities using action verbs. These
actorswillformtheclassesfortheprogram.
• Independence: Deﬁne the work for each class to be as independent from
other classes as possible. Subdivide responsibilities between classes so that
each classhasautonomy oversomeaspect oftheprogram. Givedata(asin-
stancevariables)totheclassthathasjurisdictionovertheactionsthatrequire
accesstothisdata.
• Behaviors: Deﬁne the behaviors for each class carefully and precisely, so
that the consequences of each action performed by a class will be well un-
derstood by other classes that interact with it. These behaviors will deﬁne
the methods that this class performs, and the set ofbehaviors for aclass are
theinterfacetotheclass,astheseformthemeansforotherpiecesofcodeto
interact withobjectsfromtheclass.
Deﬁning the classes, together with their instance variables and methods, are key
to the design of an object-oriented program. A good programmer will naturally
develop greater skill in performing these tasks over time, as experience teaches
him or her to notice patterns in the requirements of a programthat match patterns2.2. SoftwareDevelopment 63
A common tool for developing an initial high-level design for a project is the
use of CRC cards. Class-Responsibility-Collaborator (CRC) cards are simple in-
dexcardsthatsubdividetheworkrequiredofaprogram. Themainideabehindthis
tool is to have each card represent a component, which will ultimately become a
classintheprogram. Wewritethenameofeachcomponent onthetopofanindex
card. On the left-hand side of the card, we begin writing the responsibilities for
this component. On the right-hand side, we list the collaborators for this compo-
nent,thatis,theothercomponentsthatthiscomponentwillhavetointeractwithto
perform itsduties.
The design process iterates through an action/actor cycle,where we ﬁrstiden-
tify an action (that is, a responsibility), and we then determine an actor (that is, a
component)thatisbestsuitedtoperformthataction. Thedesigniscompletewhen
wehaveassigned allactions toactors. Inusing indexcardsforthisprocess (rather
thanlargerpiecesofpaper),wearerelyingonthefactthateachcomponent should
haveasmallsetofresponsibilitiesandcollaborators. Enforcingthisrulehelpskeep
theindividual classesmanageable.
As the design takes form, a standard approach to explain and document the
design is the use of UML (Uniﬁed Modeling Language) diagrams to express the
organizationofaprogram. UMLdiagramsareastandardvisualnotationtoexpress
object-oriented software designs. Several computer-aided tools are available to
build UML diagrams. One type of UML ﬁgure is known as a class diagram. An
example of such a diagram is given in Figure 2.3, for a class that represents a
consumer credit card. The diagram has three portions, with the ﬁrst designating
thenameoftheclass,theseconddesignating therecommended instancevariables,
andthethird designating therecommended methods oftheclass. InSection2.2.3,
we discuss our naming conventions, and in Section 2.3.1, we provide a complete
implementation ofaPythonCreditCardclassbasedonthisdesign.
Class: CreditCard
Fields: customer balance
bank limit
account
Behaviors: get customer() get balance()
get bank() get limit()
get account() charge(price)
make payment(amount)64 Chapter2. Object-OrientedProgramming
2.2.2 Pseudo-Code
As an intermediate step before the implementation of a design, programmers are
often asked to describe algorithms in a way that is intended for human eyes only.
Suchdescriptionsarecalledpseudo-code. Pseudo-codeisnotacomputerprogram,
but is more structured than usual prose. It is a mixture of natural language and
high-level programming constructs that describe the main ideas behind a generic
implementation ofadatastructure oralgorithm. Because pseudo-code isdesigned
forahumanreader, notacomputer, wecancommunicatehigh-levelideas,without
beingburdenedwithlow-levelimplementationdetails. Atthesametime,weshould
notglossoverimportantsteps. Likemanyformsofhumancommunication,ﬁnding
therightbalance isanimportantskillthatisreﬁnedthroughpractice.
In this book, we rely on a pseudo-code style that we hope will be evident to
Pythonprogrammers, yetwithamixofmathematical notations andEnglishprose.
Forexample,wemightusethephrase“indicateanerror”ratherthanaformalraise
statement. Following conventions of Python, we rely on indentation to indicate
the extent of control structures and on an indexing notation in which entries of a
sequence A with length n are indexed from A[0] to A[n−1]. However, we choose
to enclose comments within curly braces{ like these } in our pseudo-code, rather
thanusingPython’s#character.
2.2.3 Coding Style and Documentation
Programsshouldbemadeeasytoreadandunderstand. Goodprogrammers should
therefore be mindful of their coding style, and develop a style that communicates
theimportant aspects ofaprogram’s designforbothhumansandcomputers. Con-
ventionsforcodingstyletendtovarybetweendifferentprogrammingcommunities.
TheofﬁcialStyleGuideforPythonCodeisavailableonlineat
http://www.python.org/dev/peps/pep-0008/
Themainprinciples thatweadoptareasfollows:
• Python code blocks are typically indented by 4 spaces. However, to avoid
having our code fragments overrun the book’s margins, weuse2 spaces for
eachlevelofindentation. Itisstronglyrecommendedthattabsbeavoided,as
tabs aredisplayed withdiffering widthsacross systems, andtabs andspaces
are not viewed as identical by the Python interpreter. Many Python-aware2.2. SoftwareDevelopment 65
• Usemeaningful names foridentiﬁers. Tryto choose namesthat can be read
aloud, and choose names that reﬂect the action, responsibility, or data each
identiﬁerisnaming.
◦ Classes (other than Python’s built-in classes) should havea name that
serves as a singular noun, and should be capitalized (e.g.,Date rather
than date or Dates). When multiple words are concatenated to form a
class name, they should follow the so-called “CamelCase” convention
inwhichtheﬁrstletterofeachwordiscapitalized (e.g.,CreditCard).
◦ Functions,includingmemberfunctionsofaclass,shouldbelowercase.
If multiple words are combined, they should be separated by under-
scores (e.g.,make payment). Thename ofafunction should typically
be a verb that describes its affect. However, if the only purpose of the
function is to return a value, the function name may be a noun that
describes thevalue(e.g.,sqrtratherthancalculate sqrt).
◦ Names that identify an individual object (e.g., a parameter, instance
variable, or local variable) should be a lowercase noun (e.g., price).
Occasionally, we stray from this rule when using a single uppercase
lettertodesignate thenameofadatastructures (suchastreeT).
◦ Identiﬁers that represent a value considered to be a constant are tradi-
tionally identiﬁed using all capital letters and with underscores to sep-
aratewords(e.g.,MAX SIZE).
Recall from our discussion of encapsulation that identiﬁers in any context
that begin with a single leading underscore (e.g., secret) are intended to
suggestthattheyareonlyfor“internal”usetoaclassormodule,andnotpart
ofapublicinterface.
• Use comments that add meaning to a program and explain ambiguous or
confusing constructs. In-line comments are good for quick explanations;
theyareindicated inPythonfollowingthe#character, asin
if n % 2 == 1: # n is odd
Multiline block comments are good for explaining more complex code sec-
tions. In Python, these are technically multiline string literals, typically de-
limited withtriplequotes (”””),whichhavenoeffectwhenexecuted. Inthe66 Chapter2. Object-OrientedProgramming
Documentation
Python provides integrated support for embedding formal documentation directly
insourcecodeusingamechanismknownasadocstring. Formally,anystringliteral
that appears as the ﬁrst statement within the body of a module, class, or function
(including a member function of a class) will be considered to be a docstring. By
convention, those string literals should bedelimited within triple quotes (”””). As
an example, our version of the scale function from page 25 could be documented
asfollows:
def scale(data, factor):
”””Multiply all entries of numeric data list by the given factor.”””
for j in range(len(data)):
data[j] = factor
It is common to use the triple-quoted string delimiter for a docstring, even when
the string ﬁts on a single line, as in the above example. More detailed docstrings
should begin with a single line that summarizes the purpose, followed by a blank
line, and then further details. For example, we might more clearly document the
scalefunction asfollows:
def scale(data, factor):
”””Multiply all entries of numeric data list by the given factor.
data an instance of any mutable sequence type (such as a list)
containing numeric elements
factor a number that serves as the multiplicative factor for scaling
”””
for j in range(len(data)):
data[j] = factor
A docstring is stored as a ﬁeld of the module, function, or class in which it
is declared. It serves as documentation and can be retrieved in a variety of ways.
For example, the command help(x), within the Python interpreter, produces the
documentation associated with the identiﬁed object x. An external tool named
pydocisdistributedwithPythonandcanbeusedtogenerateformaldocumentation
as text or as a Web page. Guidelines forauthoring useful docstrings are available
at:
http://www.python.org/dev/peps/pep-0257/
In this book, we will try to present docstrings when space allows. Omitted2.2. SoftwareDevelopment 67
2.2.4 Testing and Debugging
Testing is the process of experimentally checking the correctness of a program,
whiledebugging isthe process oftracking the execution ofaprogram and discov-
ering the errors in it. Testing and debugging are often the most time-consuming
activityinthedevelopment ofaprogram.
Testing
Acarefultestingplanisanessentialpartofwritingaprogram. Whileverifyingthe
correctness of a program over all possible inputs is usually infeasible, we should
aim at executing the program on a representative subset of inputs. At the very
minimum,weshould makesurethateverymethodofaclassistestedatleastonce
(method coverage). Even better, each code statement in the program should be
executedatleastonce(statement coverage).
Programsoftentendtofailonspecialcasesoftheinput. Suchcasesneedtobe
carefully identiﬁed andtested. Forexample, whentesting amethodthatsorts(that
is,putsinorder)asequence ofintegers, weshouldconsiderthefollowinginputs:
• Thesequence haszerolength(noelements).
• Thesequence hasoneelement.
• Alltheelementsofthesequence arethesame.
• Thesequence isalreadysorted.
• Thesequence isreversesorted.
In addition to special inputs to the program, we should also consider special
conditions forthestructures usedbytheprogram. Forexample,ifweuseaPython
list to store data, we should make sure that boundary cases, such as inserting or
removingatthebeginning orendofthelist,areproperly handled.
While it is essential to use handcrafted test suites, it is also advantageous to
run the program on a large collection of randomly generated inputs. The random
module in Python provides several means for generating random numbers, or for
randomizing theorderofcollections.
The dependencies among the classes and functions of a program induce a hi-
erarchy. Namely, a component A is above a component B in the hierarchy if A
depends uponB, such aswhen function Acalls function B,or function Arelies on
a parameter that is an instance of class B. There are two main testing strategies,
top-downandbottom-up,whichdifferintheorderinwhichcomponentsaretested.
Top-downtestingproceedsfromthetoptothebottomoftheprogramhierarchy.
It is typically used in conjunction with stubbing, a boot-strapping technique that
replaces a lower-level component with a stub, a replacement for the component
that simulates the functionality of the original. For example, if function A calls
functionBtogettheﬁrstlineofaﬁle,whentestingAwecanreplaceBwithastub68 Chapter2. Object-OrientedProgramming
Bottom-uptesting proceeds fromlower-level components tohigher-level com-
ponents. Forexample,bottom-levelfunctions,whichdonotinvokeotherfunctions,
are tested ﬁrst, followed by functions that call only bottom-level functions, and so
on. Similarly a class that does not depend upon any other classes can be tested
before another class that depends on the former. This form of testing is usually
described as unit testing, as the functionality of a speciﬁc component is tested in
isolationofthelargersoftwareproject. Ifusedproperly,thisstrategybetterisolates
thecauseoferrorstothecomponent beingtested,aslower-levelcomponents upon
whichitreliesshouldhavealreadybeenthoroughly tested.
Python provides several forms of support for automated testing. When func-
tions or classes are deﬁned in a module, testing for that module can be embedded
inthesameﬁle. Themechanism fordoingsowasdescribed inSection1.11. Code
thatisshielded inaconditional construct oftheform
if name == __main__ :
# perform tests...
willbeexecutedwhenPythonisinvoked directlyonthatmodule,butnotwhenthe
module is imported for use in a larger software project. It iscommon to put tests
insuchaconstruct totestthefunctionality ofthefunctions andclassesspeciﬁcally
deﬁnedinthatmodule.
More robust support for automation of unit testing is provided by Python’s
unittestmodule. Thisframework allowsthe grouping of individual test cases into
larger test suites, and provides support for executing those suites, and reporting or
analyzingtheresultsofthosetests. Assoftwareismaintained,theactofregression
testingisused,wherebyallprevioustestsarere-executedtoensurethatchangesto
thesoftwaredonotintroduce newbugsinpreviously testedcomponents.
Debugging
The simplest debugging technique consists of using print statements to track the
values of variables during the execution of the program. A problem with this ap-
proach is that eventually the print statements need to be removed or commented
out,sotheyarenotexecutedwhenthesoftwareisﬁnallyreleased.
Abetterapproach istoruntheprogram within adebugger, whichisaspecial-
ized environment for controlling and monitoring the execution of a program. The
basic functionality provided by a debugger is the insertion of breakpoints within
the code. When the program is executed within the debugger, it stops at each
breakpoint. While the program is stopped, the current value of variables can be
inspected.
ThestandardPythondistributionincludesamodulenamedpdb,whichprovides
debugging support directly within the interpreter. Most IDEs for Python, such as2.3. ClassDeﬁnitions 69
2.3 Class Deﬁnitions
A class serves as the primary means for abstraction in object-oriented program-
ming. In Python, every piece of data is represented as an instance of some class.
A class provides a set of behaviors in the form ofmember functions (also known
as methods), with implementations that are common to all instances of that class.
Aclass alsoserves asablueprint foritsinstances, effectively determining theway
thatstateinformationforeachinstanceisrepresentedintheformofattributes(also
knownasﬁelds,instancevariables, ordatamembers).
2.3.1 Example: CreditCard Class
As a ﬁrst example, we provide an implementation of a CreditCard class based on
the design we introduced in Figure 2.3 of Section 2.2.1. The instances deﬁned by
theCreditCardclassprovideasimplemodelfortraditionalcreditcards. Theyhave
identifyinginformationaboutthecustomer,bank,accountnumber,creditlimit,and
currentbalance. Theclassrestrictscharges thatwouldcauseacard’sbalancetogo
over its spending limit, but it does not charge interest or late payments (we revisit
suchthemesinSection2.4.1).
Our code begins in Code Fragment 2.1 and continues in Code Fragment 2.2.
Theconstruct beginswiththekeyword,class,followedbythenameoftheclass, a
colon, andthenanindented block ofcodethatservesasthebody oftheclass. The
bodyincludesdeﬁnitionsforallmethodsoftheclass. Thesemethodsaredeﬁnedas
functions, usingtechniquesintroduced inSection1.5,yetwithaspecialparameter,
named self,that serves toidentify theparticular instance upon whichamemberis
invoked.
The self Identiﬁer
In Python, the self identiﬁer plays a key role. In the context of the CreditCard
class,therecanpresumablybemanydifferentCreditCardinstances,andeachmust
maintain itsownbalance, itsowncredit limit, and soon. Therefore, each instance
storesitsowninstance variables toreﬂectitscurrentstate.
Syntactically, selfidentiﬁes the instance upon which amethod is invoked. For
example, assume that a user of our class has a variable, my card, that identiﬁes
an instance of the CreditCard class. When the user calls my card.get balance(),
identiﬁer self, within the deﬁnition of the get balance method, refers to the card
knownasmy cardbythecaller. Theexpression,self. balancereferstoaninstance70 Chapter2. Object-OrientedProgramming
1 class CreditCard:
2 ”””A consumer credit card.”””
3
4 def init (self, customer, bank, acnt, limit):
5 ”””Create a new credit card instance.
6
7 The initial balance is zero.
8
9 customer the name of the customer (e.g., John Bowman)
10 bank the name of the bank (e.g., California Savings)
11 acnt the acount identiﬁer (e.g., 5391 0375 9387 5309)
12 limit credit limit (measured in dollars)
13 ”””
14 self. customer = customer
15 self. bank = bank
16 self. account = acnt
17 self. limit = limit
18 self. balance = 0
19
20 def get customer(self):
21 ”””Return name of the customer.”””
22 return self. customer
23
24 def get bank(self):
25 ”””Return the banks name.”””
26 return self. bank
27
28 def get account(self):
29 ”””Return the card identifying number (typically stored as a string).”””
30 return self. account
31
32 def get limit(self):
33 ”””Return current credit limit.”””
34 return self. limit
35
36 def get balance(self):
37 ”””Return current balance.”””
38 return self. balance
CodeFragment2.1: Thebeginning oftheCreditCardclassdeﬁnition(continued in2.3. ClassDeﬁnitions 71
39 def charge(self, price):
40 ”””Charge given price to the card, assuming suﬃcient credit limit.
41
42 Return True if charge was processed; False if charge was denied.
43 ”””
44 if price + self. balance > self. limit: # if charge would exceed limit,
45 return False # cannot accept charge
46 else:
47 self. balance += price
48 return True
49
50 def make payment(self, amount):
51 ”””Process customer payment that reduces balance.”””
52 self. balance −= amount
Code Fragment 2.2: The conclusion of the CreditCard class deﬁnition (continued
fromCodeFragment2.1). Thesemethodsareindented withintheclassdeﬁnition.
We draw attention to the difference between the method signature as declared
within the class versus that used by a caller. For example, from a user’s perspec-
tive we have seen that the get balance method takes zero parameters, yet within
the class deﬁnition, self is an explicit parameter. Likewise, the charge method is
declared within the class having two parameters (self and price), even though this
method is called with one parameter, for example, as my card.charge(200). The
interpretter automatically binds the instance upon which the method is invoked to
theselfparameter.
The Constructor
AusercancreateaninstanceoftheCreditCardclassusingasyntaxas:
cc = CreditCard( John Doe, 1st Bank , 5391 0375 9387 5309 , 1000)
Internally, this results inacall tothe specially named init method that serves
astheconstructoroftheclass. Itsprimaryresponsibility istoestablish thestateof
a newly created credit card object with appropriate instance variables. In the case
of the CreditCard class, each object maintains ﬁve instance variables, which we
name: customer, bank, account, limit,and balance. Theinitialvaluesforthe
ﬁrst four of those ﬁveare provided as explicit parameters that are sent by the user
when instantiating the credit card, and assigned within the body of the construc-
tor. For example, the command, self. customer = customer, assigns the instance
variable self. customer to the parameter customer; note that because customer is72 Chapter2. Object-OrientedProgramming
Encapsulation
By the conventions described in Section 2.2.3, a single leading underscore in the
nameofadatamember,suchas balance,impliesthatitisintended asnonpublic.
Usersofaclassshouldnotdirectlyaccesssuchmembers.
As a general rule, we will treat all data members as nonpublic. This allows
us to better enforce a consistent state for all instances. Wecan provide accessors,
such as get balance, to provide a user of our class read-only access to a trait. If
we wish to allow the user to change the state, we can provide appropriate update
methods. Inthecontextofdatastructures,encapsulatingtheinternalrepresentation
allows us greater ﬂexibility to redesign the wayaclass works, perhaps to improve
theefﬁciencyofthestructure.
Additional Methods
The most interesting behaviors in our class are charge and make payment. The
charge function typically adds the given price to the credit card balance, to reﬂect
a purchase of said price by the customer. However, before accepting the charge,
our implementation veriﬁes that the new purchase would not cause the balance to
exceed the credit limit. The make payment charge reﬂects the customer sending
payment to the bank for the given amount, thereby reducing the balance on the
card. We note that in the command, self. balance −= amount, the expression
self. balance is qualiﬁed with the self identiﬁer because it represents an instance
variableofthecard,whiletheunqualiﬁedamountrepresents thelocalparameter.
Error Checking
Our implementation of the CreditCard class is not particularly robust. First, we
note that we did not explicitly check the types of the parameters to charge and
make payment,noranyoftheparameterstotheconstructor. Ifauserweretomake
a call such as visa.charge( candy ), our code would presumably crash when at-
temptingtoaddthatparametertothecurrentbalance. Ifthisclassweretobewidely
usedinalibrary,wemightusemorerigoroustechniquestoraiseaTypeErrorwhen
facingsuchmisuse(seeSection1.7).
Beyondtheobvioustypeerrors,ourimplementationmaybesusceptibletolog-
ical errors. For example, if a user were allowed to charge a negative price, such
asvisa.charge(−300),thatwouldservetolowerthecustomer’s balance. Thispro-
vides a loophole for lowering a balance without making a payment. Of course,
this might be considered valid usage if modeling the credit received when a cus-
tomer returns merchandise to a store. We will explore some such issues with the2.3. ClassDeﬁnitions 73
Testing the Class
In Code Fragment 2.3, we demonstrate some basic usage of the CreditCard class,
inserting three cards into alist namedwallet. Weuse loops tomake some charges
andpayments, andusevariousaccessors toprintresultstotheconsole.
Thesetestsareenclosedwithinaconditional,if name == __main__ :,
so that they can be embedded in the source code with the class deﬁnition. Using
the terminology of Section 2.2.4, these tests provide method coverage, as each of
the methods is called at least once, but it does not provide statement coverage, as
there is never a case in which a charge is rejected due to the credit limit. This
is not a particular advanced from of testing as the output of the given tests must
be manually audited in order to determine whether the class behaved as expected.
Python has tools for more formal testing (see discussion of the unittest module
in Section 2.2.4), so that resulting values can be automatically compared to the
predicted outcomes, withoutputgenerated onlywhenanerrorisdetected.
53 if name == __main__ :
54 wallet = [ ]
55 wallet.append(CreditCard( John Bowman , California Savings ,
56 5391 0375 9387 5309 , 2500) )
57 wallet.append(CreditCard( John Bowman , California Federal ,
58 3485 0399 3395 1954 , 3500) )
59 wallet.append(CreditCard( John Bowman , California Finance ,
60 5391 0375 9387 5309 , 5000) )
61
62 for val in range(1, 17):
63 wallet[0].charge(val)
64 wallet[1].charge(2 val)
65 wallet[2].charge(3 val)
66
67 for c in range(3):
68 print( Customer = , wallet[c].get customer())
69 print( Bank = , wallet[c].get bank())
70 print( Account = , wallet[c].get account())
71 print( Limit = , wallet[c].get limit())
72 print( Balance = , wallet[c].get balance())
73 while wallet[c].get balance( ) > 100:
74 wallet[c].make payment(100)
75 print( New balance = , wallet[c].get balance())
76 print()74 Chapter2. Object-OrientedProgramming
2.3.2 Operator Overloading and Python’s Special Methods
Python’s built-in classes provide natural semantics for many operators. For ex-
ample, thesyntax a + binvokes addition fornumeric types, yet concatenation for
sequence types. When deﬁning a new class, we must consider whether a syntax
likea + bshouldbedeﬁnedwhenaorbisaninstance ofthatclass.
By default, the + operator is undeﬁned for a new class. However, the author
ofaclassmayprovide adeﬁnition usingatechnique knownasoperator overload-
ing. This is done by implementing a specially named method. In particular, the
+operator isoverloaded byimplementing amethodnamed add ,whichtakes
the right-hand operand as a parameter and which returns the result of the expres-
sion. That is, the syntax, a + b, is converted to a method call on object a of the
form, a. add (b). Similar specially named methods exist for other operators.
Table2.1providesacomprehensive listofsuchmethods.
When a binary operator is applied to two instances of different types, as in
3 love me , Python gives deference to the class of the left operand. In this
example, it would effectively check if theint class provides a sufﬁcient deﬁnition
for how to multiply an instance by a string, via the mul method. However,
if that class does not implement such a behavior, Python checks the class deﬁni-
tion for the right-hand operand, in the form of a special method named rmul
(i.e.,“rightmultiply”). Thisprovidesawayforanewuser-deﬁnedclasstosupport
mixedoperations thatinvolve aninstance ofanexisting class(given thattheexist-
ing class would presumably nothave deﬁned abehavior involving this newclass).
The distinction between mul and rmul also allows a class to deﬁne dif-
ferent semantics in cases, such as matrix multiplication, in which an operation is
noncommutative (thatis,A xmaydifferfromx A).
Non-Operator Overloads
In addition to traditional operator overloading, Python relies on specially named
methods to control the behavior of various other functionality, when applied to
user-deﬁned classes. For example, the syntax, str(foo), is formally a call to the
constructor forthestringclass. Ofcourse, iftheparameterisaninstanceofauser-
deﬁned class, the original authors of the string class could not have known how
thatinstanceshouldbeportrayed. Sothestringconstructor callsaspecially named
method,foo. str (),thatmustreturnanappropriate stringrepresentation.
Similarspecialmethodsareusedtodeterminehowtoconstructanint,ﬂoat,or
boolbased onaparameter from auser-deﬁned class. Theconversion toaBoolean
value isparticularly important, because thesyntax,if foo:, can beused evenwhen
foo is not formally a Boolean value (see Section 1.4.1). For a user-deﬁned class,2.3. ClassDeﬁnitions 75
CommonSyntax SpecialMethodForm
a + b a. add (b); alternativelyb. radd (a)
a − b a. sub (b); alternativelyb. rsub (a)
a b a. mul (b); alternativelyb. rmul (a)
a / b a. truediv (b); alternativelyb. rtruediv (a)
a // b a. ﬂoordiv (b); alternativelyb. rﬂoordiv (a)
a % b a. mod (b); alternativelyb. rmod (a)
a b a. pow (b); alternativelyb. rpow (a)
a << b a. lshift (b); alternativelyb. rlshift (a)
a >> b a. rshift (b); alternativelyb. rrshift (a)
a & b a. and (b); alternativelyb. rand (a)
a ˆ b a. xor (b); alternativelyb. rxor (a)
a | b a. or (b); alternativelyb. ror (a)
a += b a. iadd (b)
a −= b a. isub (b)
a = b a. imul (b)
... ...
+a a. pos ()
−a a. neg ()
˜a a. invert ()
abs(a) a. abs ()
a < b a. lt (b)
a <= b a. le (b)
a > b a. gt (b)
a >= b a. ge (b)
a == b a. eq (b)
a != b a. ne (b)
v in a a. contains (v)
a[k] a. getitem (k)
a[k] = v a. setitem (k,v)
del a[k] a. delitem (k)
a(arg1, arg2, ...) a. call (arg1, arg2, ...)
len(a) a. len ()
hash(a) a. hash ()
iter(a) a. iter ()
next(a) a. next ()
bool(a) a. bool ()
ﬂoat(a) a. ﬂoat ()
int(a) a. int ()
repr(a) a. repr ()
reversed(a) a. reversed ()
str(a) a. str ()76 Chapter2. Object-OrientedProgramming
Severalothertop-level functions relyoncalling specially namedmethods. For
example, the standard way to determine the size of a container type is by calling
the top-level len function. Note well that the calling syntax, len(foo), is not the
traditional method-calling syntax with the dot operator. However, in the case of a
user-deﬁned class, the top-level len function relies on a call to a specially named
len method of that class. That is, the call len(foo) is evaluated through a
method call, foo. len (). When developing data structures, we will routinely
deﬁnethe len methodtoreturnameasureofthesizeofthestructure.
Implied Methods
Asageneralrule,ifaparticularspecialmethodisnotimplementedinauser-deﬁned
class, thestandard syntax that relies upon thatmethod willraiseanexception. For
example, evaluating the expression, a + b, for instances of a user-deﬁned class
without add or radd willraiseanerror.
However, there are some operators that have default deﬁnitions provided by
Python, in the absence of special methods, and there are some operators whose
deﬁnitions are derived from others. For example, the bool method, which
supports the syntax if foo:, has default semantics so that every object other than
None is evaluated as True. However, for container types, the len method is
typically deﬁned to return the size of the container. If such a method exists, then
the evaluation of bool(foo) is interpreted by default to be True for instances with
nonzerolength, andFalseforinstanceswithzerolength, allowingasyntaxsuchas
if waitlist:tobeusedtotestwhetherthereareoneormoreentriesinthewaitlist.
In Section 2.3.4, we will discuss Python’s mechanism for providing iterators
forcollections viathespecialmethod, iter . Withthatsaid,ifacontainerclass
providesimplementations forboth len and getitem ,adefault iterationis
provided automatically (using means we describe in Section2.3.4). Furthermore,
onceaniteratorisdeﬁned,defaultfunctionality of contains isprovided.
In Section 1.3 we drew attention to the distinction between expression a is b
andexpression a == b,withtheformerevaluating whetheridentiﬁersaandbare
aliases forthesameobject, and thelatter testing anotion ofwhether the twoiden-
tiﬁers reference equivalent values. The notion of “equivalence” depends upon the
contextoftheclass,andsemanticsisdeﬁnedwiththe eq method. However,if
noimplementation isgivenfor eq ,thesyntaxa == bislegalwithsemantics
ofa is b,thatis,aninstance isequivalent toitselfandnoothers.
We should caution that some natural implications are not automatically pro-
vided by Python. For example, the eq method supports syntax a == b, but
providingthatmethoddoesnotaffecttheevaluationofsyntaxa != b. (The ne
method should be provided, typically returning not (a == b) as a result.) Simi-
larly, providing a lt method supports syntax a < b, and indirectly b > a, but2.3. ClassDeﬁnitions 77
2.3.3 Example: Multidimensional Vector Class
To demonstrate the use of operator overloading via special methods, we provide
an implementation of a Vector class, representing the coordinates of a vector in a
multidimensionalspace. Forexample,inathree-dimensionalspace,wemightwish
torepresentavectorwithcoordinates(cid:10)5,−2, 3(cid:11). Althoughitmightbetemptingto
directly use a Python list to represent those coordinates, a list does not provide an
appropriate abstraction for a geometric vector. In particular, if using lists, the ex-
pression[5, −2, 3] + [1, 4, 2]resultsinthelist[5, −2, 3, 1, 4, 2]. Whenworking
withvectors, ifu=(cid:10)5,−2, 3(cid:11)andv=(cid:10)1, 4, 2(cid:11),onewouldexpecttheexpression,
u + v,toreturnathree-dimensional vectorwithcoordinates(cid:10)6, 2, 5(cid:11).
WethereforedeﬁneaVectorclass,inCodeFragment2.4,thatprovidesabetter
abstraction for the notion of a geometric vector. Internally, our vector relies upon
an instance of a list, named coords, as its storage mechanism. By keeping the
internal listencapsulated, wecanenforce thedesired public interface forinstances
ofourclass. Ademonstration ofsupported behaviors includes thefollowing:
v = Vector(5) # construct ﬁve-dimensional <0, 0, 0, 0, 0>
v[1] = 23 # <0, 23, 0, 0, 0> (based on use of setitem )
v[−1] = 45 # <0, 23, 0, 0, 45> (also via setitem )
print(v[4]) # print 45 (via getitem )
u = v + v # <0, 46, 0, 0, 90> (via add )
print(u) # print <0, 46, 0, 0, 90>
total = 0
for entry in v: # implicit iteration via len and getitem
total += entry
We implement many of the behaviors by trivially invoking a similar behavior
on the underlying list of coordinates. However, our implementation of add
is customized. Assuming the two operands are vectors with the same length, this
methodcreatesanewvectorandsetsthecoordinates ofthenewvectortobeequal
totherespective sumoftheoperands’ elements.
Itisinteresting tonotethattheclassdeﬁnition, asgiveninCodeFragment2.4,
automatically supports the syntax u = v + [5, 3, 10, −2, 1], resulting in a new
vector that is the element-by-element “sum” of the ﬁrst vector and the list in-
stance. This is a result of Python’s polymorphism. Literally, “polymorphism”
means “many forms.” Although it is tempting to think of the other parameter of
our add method as another Vector instance, we never declared it as such.
Within the body, the only behaviors we rely on for parameter other is that it sup-
ports len(other) and access to other[j]. Therefore, our code executes when the78 Chapter2. Object-OrientedProgramming
1 class Vector:
2 ”””Represent a vector in a multidimensional space.”””
3
4 def init (self, d):
5 ”””Create d-dimensional vector of zeros.”””
6 self. coords = [0] d
7
8 def len (self):
9 ”””Return the dimension of the vector.”””
10 return len(self. coords)
11
12 def getitem (self, j):
13 ”””Return jth coordinate of vector.”””
14 return self. coords[j]
15
16 def setitem (self, j, val):
17 ”””Set jth coordinate of vector to given value.”””
18 self. coords[j] = val
19
20 def add (self, other):
21 ”””Return sum of two vectors.”””
22 if len(self) != len(other): # relies on len method
23 raise ValueError( dimensions must agree )
24 result = Vector(len(self)) # start with vector of zeros
25 for j in range(len(self)):
26 result[j] = self[j] + other[j]
27 return result
28
29 def eq (self, other):
30 ”””Return True if vector has same coordinates as other.”””
31 return self. coords == other. coords
32
33 def ne (self, other):
34 ”””Return True if vector diﬀers from other.”””
35 return not self == other # rely on existing eq deﬁnition
36
37 def str (self):
38 ”””Produce string representation of vector.”””
39 return < + str(self. coords)[1:−1] + > # adapt list representation2.3. ClassDeﬁnitions 79
2.3.4 Iterators
Iteration is an important concept in the design of data structures. We introduced
Python’s mechanism for iteration in Section 1.8. In short, an iterator for a collec-
tionprovidesonekeybehavior: Itsupports aspecial methodnamed next that
returnsthenextelementofthecollection,ifany,orraisesaStopIterationexception
toindicate thattherearenofurtherelements.
Fortunately, it is rare to have to directly implement an iterator class. Our pre-
ferred approach is the use of thegenerator syntax (also described in Section 1.8),
whichautomatically producesaniteratorofyieldedvalues.
Python also helps by providing an automatic iterator implementation for any
class thatdeﬁnes both len and getitem . Toprovide aninstructive exam-
ple of a low-level iterator, Code Fragment 2.5 demonstrates just such an iterator
class that works on any collection that supports both len and getitem .
ThisclasscanbeinstantiatedasSequenceIterator(data). Itoperatesbykeepingan
internalreferencetothedatasequence,aswellasacurrentindexintothesequence.
Each time next is called, the index is incremented, until reaching the end of
thesequence.
1 class SequenceIterator:
2 ”””An iterator for any of Pythons sequence types.”””
3
4 def init (self, sequence):
5 ”””Create an iterator for the given sequence.”””
6 self. seq = sequence # keep a reference to the underlying data
7 self. k = −1 # will increment to 0 on ﬁrst call to next
8
9 def next (self):
10 ”””Return the next element, or else raise StopIteration error.”””
11 self. k += 1 # advance to next index
12 if self. k < len(self. seq):
13 return(self. seq[self. k]) # return the data element
14 else:
15 raise StopIteration( ) # there are no more elements
16
17 def iter (self):
18 ”””By convention, an iterator must return itself as an iterator.”””
19 return self80 Chapter2. Object-OrientedProgramming
2.3.5 Example: Range Class
As the ﬁnal example for this section, we develop our own implementation of a
class that mimics Python’s built-in range class. Before introducing our class, we
discuss the history of the built-in version. Prior to Python3 being released, range
was implemented as a function, and it returned a list instance with elements in
the speciﬁed range. For example, range(2, 10, 2) returned the list [2, 4, 6, 8].
However, a typical use of the function was to support a for-loop syntax, such as
for k in range(10000000). Unfortunately, thiscaused theinstantiation andinitial-
ization of a list with the range of numbers. That was an unnecessarily expensive
step,intermsofbothtimeandmemoryusage.
The mechanism used to support ranges in Python 3 is entirely different (to be
fair, the “new” behavior existed in Python 2 under the name xrange). It uses a
strategy known aslazy evaluation. Rather than creating anew list instance, range
is a class that can effectively represent the desired range of elements without ever
storing them explicitly in memory. To better explore the built-in range class, we
recommend that you create an instance as r = range(8, 140, 5). The result is a
relatively lightweight object, an instance of the range class, that has only a few
behaviors. The syntax len(r) will report the number of elements that are in the
given range (27, inourexample). Arange also supports the getitem method,
so that syntax r[15] reports the sixteenth element in the range (as r[0] is the ﬁrst
element). Because the class supports both len and getitem , it inherits
automatic support for iteration (see Section 2.3.4), which is why it is possible to
executeaforloopoverarange.
Atthispoint,wearereadytodemonstrateourownversionofsuchaclass. Code
Fragment2.6providesaclasswenameRange(soastoclearlydifferentiate itfrom
built-inrange). Thebiggestchallengeintheimplementationisproperlycomputing
the number of elements that belong in the range, given the parameters sent by the
caller when constructing a range. Bycomputing that value inthe constructor, and
storingitasself. length,itbecomestrivialtoreturnitfromthe len method. To
properly implement acallto getitem (k),wesimply takethestarting valueof
therange plusktimesthestepsize(i.e.,fork=0,wereturn thestart value). There
areafewsubtleties worthexamininginthecode:
• Toproperly supportoptional parameters, werelyonthetechnique described
onpage27,whendiscussing afunctional versionofrange.
• Wecomputethenumberofelementsintherangeas
max(0, (stop − start + step − 1) // step)
Itisworthtestingthisformulaforbothpositiveandnegativestepsizes.
• The getitem method properly supports negative indices by converting2.3. ClassDeﬁnitions 81
1 class Range:
2 ”””A class that mimics the built-in range class.”””
3
4 def init (self, start, stop=None, step=1):
5 ”””Initialize a Range instance.
6
7 Semantics is similar to built-in range class.
8 ”””
9 if step == 0:
10 raise ValueError( step cannot be 0 )
11
12 if stop is None: # special case of range(n)
13 start, stop = 0, start # should be treated as if range(0,n)
14
15 # calculate the eﬀective length once
16 self. length = max(0, (stop − start + step − 1) // step)
17
18 # need knowledge of start and step (but not stop) to support getitem
19 self. start = start
20 self. step = step
21
22 def len (self):
23 ”””Return number of entries in the range.”””
24 return self. length
25
26 def getitem (self, k):
27 ”””Return entry at index k (using standard interpretation if negative).”””
28 if k < 0:
29 k += len(self) # attempt to convert negative index
30
31 if not 0 <= k < self. length:
32 raise IndexError( index out of range )
33
34 return self. start + k self. step82 Chapter2. Object-OrientedProgramming
2.4 Inheritance
A natural way to organize various structural components of a software package
is in a hierarchical fashion, with similar abstract deﬁnitions grouped together in
a level-by-level manner that goes from speciﬁc to more general as one traverses
up the hierarchy. An example of such a hierarchy is shown in Figure 2.4. Using
mathematical notations, the set of houses is a subset of the set of buildings, but a
supersetofthesetofranches. Thecorrespondence betweenlevelsisoftenreferred
toasan“isa”relationship, asahouseisabuilding, andaranchisahouse.
Building
Commercial
Apartment House
Building
Low-rise High-rise Two-story
Ranch Skyscraper
Apartment Apartment House
Figure2.4: Anexampleofan“isa”hierarchyinvolving architectural buildings.
Ahierarchical design isuseful in software development, ascommon function-
ality can be grouped at the most general level, thereby promoting reuse of code,
while differentiated behaviors can be viewed as extensions of the general case, In
object-oriented programming, themechanism foramodularandhierarchical orga-
nizationisatechniqueknownasinheritance. Thisallowsanewclasstobedeﬁned
based upon an existing class as the starting point. In object-oriented terminology,
the existing class is typically described as the base class, parent class, or super-
class,whilethenewlydeﬁnedclassisknownasthesubclassorchildclass.
There are two ways in which a subclass can differentiate itself from its su-
perclass. A subclass may specialize an existing behavior by providing a new im-
plementation that overrides an existing method. A subclass may also extend its2.4. Inheritance 83
Python’s Exception Hierarchy
Another example of a rich inheritance hierarchy is the organization of various ex-
ception types in Python. We introduced many of those classes in Section 1.7, but
did not discuss their relationship with each other. Figure 2.5 illustrates a (small)
portion of that hierarchy. TheBaseException class is the root of the entire hierar-
chy, while the more speciﬁc Exception class includes most of the error types that
wehavediscussed. Programmersarewelcometodeﬁnetheirownspecialexception
classes to denote errors that may occur in the context of their application. Those
user-deﬁned exception typesshouldbedeclared assubclasses ofException.
BaseException
SystemExit Exception KeyboardInterrupt
ValueError LookupError ArithmeticError
IndexError KeyError ZeroDivisionError
Figure2.5: AportionofPython’shierarchyofexception types.
2.4.1 Extending the CreditCard Class
TodemonstratethemechanismsforinheritanceinPython,werevisittheCreditCard
class of Section 2.3, implementing a subclass that, for lack of a better name, we
name PredatoryCreditCard. The new class will differ from the original in two
ways: (1) if an attempted charge is rejected because it would have exceeded the
creditlimit,a$5feewillbecharged, and(2)therewillbeamechanism forassess-
ing a monthly interest charge on the outstanding balance, based upon an Annual
Percentage Rate(APR)speciﬁedasaconstructor parameter.
In accomplishing this goal, we demonstrate the techniques of specialization
and extension. To charge a fee for an invalid charge attempt, we override the
existing charge method, thereby specializing it to provide the new functionality
(although the new version takes advantage of a call to the overridden version). To
providesupportforcharginginterest,weextendtheclasswithanewmethodnamed84 Chapter2. Object-OrientedProgramming
Class: CreditCard
Fields: customer balance
bank limit
account
Behaviors: get customer() get balance()
get bank() get limit()
get account() charge(price)
make payment(amount)
Class: PredatoryCreditCard
Fields: apr
Behaviors: process month() charge(price)
Figure2.6: Diagramofaninheritance relationship.
Figure2.6provides anoverviewofouruseofinheritance indesigning thenew
PredatoryCreditCard class, and Code Fragment 2.7 gives a complete Python im-
plementation ofthatclass.
To indicate that the new class inherits from the existing CreditCard class, our
deﬁnition begins with the syntax, class PredatoryCreditCard(CreditCard). The
body of the new class provides three member functions: init , charge, and
process month. The init constructor serves averysimilarroletotheoriginal
CreditCard constructor, except that for our new class, there is an extra parameter
tospecifytheannualpercentage rate. Thebodyofournewconstructor reliesupon
making a call to the inherited constructor to perform most ofthe initialization (in
fact, everything other than the recording of the percentage rate). The mechanism
for calling the inherited constructor relies on the syntax, super(). Speciﬁcally, at
line15thecommand
super(). init (customer, bank, acnt, limit)
callsthe init methodthatwasinherited fromtheCreditCardsuperclass. Note
wellthat this method only accepts four parameters. Werecord the APRvalue in a
newﬁeldnamed apr.
In similar fashion, our PredatoryCreditCard class provides a new implemen-
tation of the charge method that overrides the inherited method. Yet, our imple-
mentation of the new method relies on a call to the inherited method, with syntax2.4. Inheritance 85
1 class PredatoryCreditCard(CreditCard):
2 ”””An extension to CreditCard that compounds interest and fees.”””
3
4 def init (self, customer, bank, acnt, limit, apr):
5 ”””Create a new predatory credit card instance.
6
7 The initial balance is zero.
8
9 customer the name of the customer (e.g., John Bowman)
10 bank the name of the bank (e.g., California Savings)
11 acnt the acount identiﬁer (e.g., 5391 0375 9387 5309)
12 limit credit limit (measured in dollars)
13 apr annual percentage rate (e.g., 0.0825 for 8.25% APR)
14 ”””
15 super(). init (customer, bank, acnt, limit) # call super constructor
16 self. apr = apr
17
18 def charge(self, price):
19 ”””Charge given price to the card, assuming suﬃcient credit limit.
20
21 Return True if charge was processed.
22 Return False and assess 5 fee if charge is denied.
23 ”””
24 success = super().charge(price) # call inherited method
25 if not success:
26 self. balance += 5 # assess penalty
27 return success # caller expects return value
28
29 def process month(self):
30 ”””Assess monthly interest on outstanding balance.”””
31 if self. balance > 0:
32 # if positive balance, convert APR to monthly multiplicative factor
33 monthly factor = pow(1 + self. apr, 1/12)
34 self. balance = monthly factor86 Chapter2. Object-OrientedProgramming
the charge was successful. We examine that return value to decide whether to as-
sess afee, and inturn wereturn that value tothe caller ofmethod, sothat the new
versionofchargehasasimilaroutwardinterfaceastheoriginal.
Theprocess monthmethod isanew behavior, so there isno inherited version
upon which to rely. In our model, this method should be invoked by the bank,
onceeach month, toaddnewinterest charges tothecustomer’s balance. Themost
challenging aspect in implementing this method is making sure we have working
knowledge of how an annual percentage rate translates to a monthly rate. We do
notsimplydividetheannualratebytwelvetogetamonthlyrate(thatwouldbetoo
predatory, as it would result in a higher APR than advertised). The correct com-
putation is to take the twelfth-root of 1 + self. apr, and use that as a multiplica-
ti√ve factor. For example, if the APR is 0.0825 (representing 8.25%), we compute
12 1.0825 ≈1.006628, and therefore charge 0.6628% interest per month. In this
way,each$100ofdebtwillamass$8.25ofcompounded interestinayear.
Protected Members
OurPredatoryCreditCardsubclassdirectlyaccessesthedatamemberself. balance,
which was established by the parent CreditCard class. The underscored name, by
convention, suggests thatthisisanonpublic member, sowemightaskifitisokay
that we access it in this fashion. While general users of the class should not be
doing so, our subclass has asomewhat privileged relationship with the superclass.
Severalobject-oriented languages (e.g., Java, C++)draw adistinction fornonpub-
licmembers,allowingdeclarationsofprotectedorprivateaccessmodes. Members
that are declared as protected are accessible to subclasses, but not to the general
public, while members that are declared as private are not accessible to either. In
thisrespect, weareusing balanceasifitwereprotected (butnotprivate).
Pythondoesnotsupportformalaccesscontrol,butnamesbeginningwithasin-
gleunderscore areconventionally akintoprotected, whilenamesbeginning witha
double underscore (other than special methods) are akin toprivate. Inchoosing to
useprotected data,wehavecreatedadependency inthatourPredatoryCreditCard
class might be compromised if the author of the CreditCard class were to change
the internal design. Note that wecould have relied upon the public get balance()
method to retrieve the current balance within theprocess month method. But the
current design of the CreditCard class does not afford an effective way for a sub-
classtochange thebalance, other thanbydirectmanipulation ofthedatamember.
It may be tempting to use charge to add fees or interest to the balance. However,
that method does not allow the balance to go above the customer’s credit limit,
even though a bank would presumably let interest compound beyond the credit
limit, ifwarranted. Ifweweretoredesign theoriginalCreditCardclass, wemight
addanonpublic method, set balance,thatcouldbeusedbysubclasses toaffecta2.4. Inheritance 87
2.4.2 Hierarchy of Numeric Progressions
Asasecondexampleoftheuseofinheritance,wedevelopahierarchyofclassesfor
iterating numeric progressions. A numeric progression is asequence of numbers,
whereeachnumberdependsononeormoreofthepreviousnumbers. Forexample,
an arithmetic progression determines the next number by adding a ﬁxed constant
to the previous value, and a geometric progression determines the next number
by multiplying the previous value by a ﬁxed constant. In general, a progression
requires a ﬁrst value, and a way of identifying a new value based on one or more
previous values.
To maximize reusability of code, we develop a hierarchy of classes stemming
from ageneral base class that we nameProgression (see Figure 2.7). Technically,
the Progression class produces the progression of whole numbers: 0, 1, 2, ....
However,thisclassisdesignedtoserveasthebaseclassforotherprogressiontypes,
providing as much common functionality as possible, and thereby minimizing the
burdenonthesubclasses.
Progression
ArithmeticProgression GeometricProgression FibonacciProgression
Figure2.7: Ourhierarchyofprogression classes.
Our implementation of the basic Progression class is provided in Code Frag-
ment2.8. Theconstructor forthisclassacceptsastarting valuefortheprogression
(0bydefault), andinitializes adatamember,self. current,tothatvalue.
The Progression class implements the conventions of a Python iterator (see
Section 2.3.4), namely the special next and iter methods. If a user of
theclasscreates aprogression asseq = Progression(),eachcalltonext(seq)will
return a subsequent element of the progression sequence. Itwould also be possi-
ble to use a for-loop syntax, for value in seq:, although we note that our default
progression isdeﬁnedasaninﬁnitesequence.
Tobetter separate the mechanics oftheiterator conventionfrom thecore logic
ofadvancing the progression, our framework relies onanonpublic method named
advancetoupdate the value oftheself. currentﬁeld. Inthe default implementa-
tion, advance adds one to the current value, but our intent is that subclasses will
override advancetoprovideadifferent ruleforcomputingthenextentry.
For convenience, the Progression class also provides a utility method, named88 Chapter2. Object-OrientedProgramming
1 class Progression:
2 ”””Iterator producing a generic progression.
3
4 Default iterator produces the whole numbers 0, 1, 2, ...
5 ”””
6
7 def init (self, start=0):
8 ”””Initialize current to the ﬁrst value of the progression.”””
9 self. current = start
10
11 def advance(self):
12 ”””Update self. current to a new value.
13
14 This should be overridden by a subclass to customize progression.
15
16 By convention, if current is set to None, this designates the
17 end of a ﬁnite progression.
18 ”””
19 self. current += 1
20
21 def next (self):
22 ”””Return the next element, or else raise StopIteration error.”””
23 if self. current is None: # our convention to end a progression
24 raise StopIteration()
25 else:
26 answer = self. current # record current value to return
27 self. advance( ) # advance to prepare for next time
28 return answer # return the answer
29
30 def iter (self):
31 ”””By convention, an iterator must return itself as an iterator.”””
32 return self
33
34 def print progression(self, n):
35 ”””Print next n values of the progression.”””
36 print( .join(str(next(self)) for j in range(n)))2.4. Inheritance 89
An Arithmetic Progression Class
Ourﬁrstexample ofaspecialized progression is anarithmetic progression. While
the default progression increases its value by one in each step, an arithmetic pro-
gression adds a ﬁxed constant to one term of the progression to produce the next.
Forexample, using an increment of 4for an arithmetic progression that starts at 0
resultsinthesequence 0,4,8,12,....
Code Fragment 2.9 presents our implementation of an ArithmeticProgression
class, which relies on Progression as its base class. The constructor for this new
class accepts both anincrement value and astarting value asparameters, although
defaultvaluesforeachareprovided. Byourconvention,ArithmeticProgression(4)
produces the sequence 0,4,8,12,..., and ArithmeticProgression(4, 1) produces
thesequence 1,5,9,13,....
Thebody oftheArithmeticProgression constructor calls the super constructor
to initialize the current data member to the desired start value. Then it directly
establishes the new increment data member for the arithmetic progression. The
onlyremainingdetailinourimplementation istooverridethe advancemethodso
astoaddtheincrementtothecurrentvalue.
1 class ArithmeticProgression(Progression): # inherit from Progression
2 ”””Iterator producing an arithmetic progression.”””
3
4 def init (self, increment=1, start=0):
5 ”””Create a new arithmetic progression.
6
7 increment the ﬁxed constant to add to each term (default 1)
8 start the ﬁrst term of the progression (default 0)
9 ”””
10 super(). init (start) # initialize base class
11 self. increment = increment
12
13 def advance(self): # override inherited version
14 ”””Update current value by adding the ﬁxed increment.”””
15 self. current += self. increment90 Chapter2. Object-OrientedProgramming
A Geometric Progression Class
Our second example of a specialized progression is a geometric progression, in
which each value is produced by multiplying the preceding value by a ﬁxed con-
stant, known as the base of the geometric progression. The starting point of a ge-
ometric progression is traditionally 1, rather than 0, because multiplying 0 by any
factorresultsin0. Asanexample,ageometricprogression withbase2proceedsas
1,2,4,8,16,....
Code Fragment 2.10 presents our implementation of a GeometricProgression
class. Theconstructor uses2asadefaultbaseand1asadefaultstartingvalue, but
eitherofthosecanbevariedusingoptionalparameters.
1 class GeometricProgression(Progression): # inherit from Progression
2 ”””Iterator producing a geometric progression.”””
3
4 def init (self, base=2, start=1):
5 ”””Create a new geometric progression.
6
7 base the ﬁxed constant multiplied to each term (default 2)
8 start the ﬁrst term of the progression (default 1)
9 ”””
10 super(). init (start)
11 self. base = base
12
13 def advance(self): # override inherited version
14 ”””Update current value by multiplying it by the base value.”””
15 self. current = self. base
CodeFragment2.10: Aclassthatproduces ageometricprogression.
A Fibonacci Progression Class
As our ﬁnal example, we demonstrate how to use our progression framework to
produce a Fibonacci progression. We originally discussed the Fibonacci series
on page 41 in the context of generators. Each value of a Fibonacci series is the
sum of the two most recent values. To begin the series, the ﬁrst two values are
conventionally 0 and 1, leading to the Fibonacci series 0,1,1,2,3,5,8,... . More
generally,suchaseriescanbegeneratedfromanytwostartingvalues. Forexample,2.4. Inheritance 91
1 class FibonacciProgression(Progression):
2 ”””Iterator producing a generalized Fibonacci progression.”””
3
4 def init (self, ﬁrst=0, second=1):
5 ”””Create a new ﬁbonacci progression.
6
7 ﬁrst the ﬁrst term of the progression (default 0)
8 second the second term of the progression (default 1)
9 ”””
10 super(). init (ﬁrst) # start progression at ﬁrst
11 self. prev = second − ﬁrst # ﬁctitious value preceding the ﬁrst
12
13 def advance(self):
14 ”””Update current value by taking sum of previous two.”””
15 self. prev, self. current = self. current, self. prev + self. current
CodeFragment2.11: Aclassthatproduces aFibonacciprogression.
WeuseourprogressionframeworktodeﬁneanewFibonacciProgressionclass,
asshowninCodeFragment2.11. Thisclassismarkedlydifferentfromthoseforthe
arithmeticandgeometricprogressions becausewecannotdeterminethenextvalue
ofaFibonacci seriessolely from thecurrent one. Wemustmaintain knowledge of
the two most recent values. The base Progression class already provides storage
of the most recent value as the current data member. Our FibonacciProgression
classintroduces anewmember,named prev,tostorethevaluethatproceeded the
currentone.
Withbothprevious valuesstored, theimplementation of advanceisrelatively
straightforward. (We use a simultaneous assignment similar to that on page 45.)
However, the question arises as to how to initialize the previous value in the con-
structor. The desired ﬁrst and second values are provided as parameters to the
constructor. The ﬁrst should be stored as current so that it becomes the ﬁrst
one that is reported. Looking ahead, once the ﬁrst value is reported, we will do
an assignment to set the new current value (which will be the second value re-
ported), equal to the ﬁrst value plus the “previous.” By initializing the previous
valueto(second − ﬁrst),theinitialadvancement willsetthenewcurrent valueto
ﬁrst + (second − ﬁrst) = second,asdesired.
Testing Our Progressions
To complete our presentation, Code Fragment 2.12 provides a unit test for all of92 Chapter2. Object-OrientedProgramming
if name == __main__ :
print( Default progression: )
Progression().print progression(10)
print( Arithmetic progression with increment 5: )
ArithmeticProgression(5).print progression(10)
print( Arithmetic progression with increment 5 and start 2: )
ArithmeticProgression(5, 2).print progression(10)
print( Geometric progression with default base: )
GeometricProgression().print progression(10)
print( Geometric progression with base 3: )
GeometricProgression(3).print progression(10)
print( Fibonacci progression with default start values: )
FibonacciProgression().print progression(10)
print( Fibonacci progression with start values 4 and 6: )
FibonacciProgression(4, 6).print progression(10)
CodeFragment2.12: Unittestsforourprogression classes.
Default progression:
0 1 2 3 4 5 6 7 8 9
Arithmetic progression with increment 5:
0 5 10 15 20 25 30 35 40 45
Arithmetic progression with increment 5 and start 2:
2 7 12 17 22 27 32 37 42 47
Geometric progression with default base:
1 2 4 8 16 32 64 128 256 512
Geometric progression with base 3:
1 3 9 27 81 243 729 2187 6561 19683
Fibonacci progression with default start values:
0 1 1 2 3 5 8 13 21 34
Fibonacci progression with start values 4 and 6:
4 6 10 16 26 42 68 110 178 2882.4. Inheritance 93
2.4.3 Abstract Base Classes
Whendeﬁningagroupofclassesaspartofaninheritancehierarchy,onetechnique
for avoiding repetition of code is to design a base class with common function-
ality that can be inherited by other classes that need it. As an example, the hi-
erarchy from Section 2.4.2 includes a Progression class, which serves as a base
class for three distinct subclasses: ArithmeticProgression, GeometricProgression,
and FibonacciProgression. Although it is possible to create an instance of the
Progressionbaseclass, thereislittle valueindoing sobecause itsbehavior issim-
plyaspecialcaseofanArithmeticProgressionwithincrement 1. Therealpurpose
of the Progression class was to centralize the implementations of behaviors that
other progressions needed, thereby streamlining the code that is relegated tothose
subclasses.
Inclassic object-oriented terminology, wesayaclass isanabstract base class
if its only purpose is to serve as a base class through inheritance. More formally,
an abstract base class is one that cannot be directly instantiated, while a concrete
class is one that can be instantiated. By this deﬁnition, our Progression class is
technically concrete, although weessentially designed itasanabstract baseclass.
InstaticallytypedlanguagessuchasJavaandC++,anabstractbaseclassserves
as aformal type that may guarantee one or moreabstract methods. This provides
support for polymorphism, as avariable mayhave an abstractbase class as its de-
clared type, even though it refers to an instance of a concrete subclass. Because
there are no declared types in Python, this kind of polymorphism can be accom-
plished without the need for a unifying abstract base class. For this reason, there
is not as strong a tradition of deﬁning abstract base classes in Python, although
Python’sabcmoduleprovidessupport fordeﬁningaformalabstract baseclass.
Ourreason forfocusing onabstract baseclasses inourstudyofdatastructures
isthatPython’scollectionsmoduleprovidesseveralabstractbaseclassesthatassist
when deﬁning custom data structures that share a common interface with some of
Python’s built-in data structures. These rely onanobject-oriented software design
pattern known as the template method pattern. The template method pattern is
when an abstract base class provides concrete behaviors that rely upon calls to
otherabstract behaviors. Inthatway,assoonasasubclass provides deﬁnitions for
themissingabstract behaviors, theinherited concretebehaviors arewelldeﬁned.
Asatangibleexample,thecollections.Sequenceabstractbaseclassdeﬁnesbe-
haviors common to Python’s list, str, and tuple classes, as sequences that sup-
port element access via an integer index. More so, the collections.Sequence class
provides concrete implementations of methods, count, index, and contains
that can be inherited by any class that provides concrete implementations of both
len and getitem . For the purpose of illustration, we provide a sample94 Chapter2. Object-OrientedProgramming
1 from abc import ABCMeta, abstractmethod # need these deﬁnitions
2
3 class Sequence(metaclass=ABCMeta):
4 ”””Our own version of collections.Sequence abstract base class.”””
5
6 @abstractmethod
7 def len (self):
8 ”””Return the length of the sequence.”””
9
10 @abstractmethod
11 def getitem (self, j):
12 ”””Return the element at index j of the sequence.”””
13
14 def contains (self, val):
15 ”””Return True if val found in the sequence; False otherwise.”””
16 for j in range(len(self)):
17 if self[j] == val: # found match
18 return True
19 return False
20
21 def index(self, val):
22 ”””Return leftmost index at which val is found (or raise ValueError).”””
23 for j in range(len(self)):
24 if self[j] == val: # leftmost match
25 return j
26 raise ValueError( value not in sequence ) # never found a match
27
28 def count(self, val):
29 ”””Return the number of elements equal to given value.”””
30 k = 0
31 for j in range(len(self)):
32 if self[j] == val: # found a match
33 k += 1
34 return k
CodeFragment2.14: Anabstract baseclassakintocollections.Sequence.
ThisimplementationreliesontwoadvancedPythontechniques. Theﬁrstisthat
wedeclare theABCMetaclass of theabcmodule asametaclass ofour Sequence
class. A metaclass is different from a superclass, in that itprovides atemplate for
the class deﬁnition itself. Speciﬁcally, the ABCMeta declaration assures that the2.4. Inheritance 95
The second advanced technique is the use of the @abstractmethod decorator
immediately before the len and getitem methods are declared. That de-
clares thesetwoparticular methods tobeabstract, meaningthatwedonotprovide
animplementationwithinourSequencebaseclass,butthatweexpectanyconcrete
subclasses tosupportthosetwomethods. Pythonenforces thisexpectation, bydis-
allowing instantiation for any subclass that does not override the abstract methods
withconcrete implementations.
TherestoftheSequenceclassdeﬁnitionprovidestangibleimplementationsfor
other behaviors, under the assumption that the abstract len and getitem
methodswillexistinaconcretesubclass. Ifyoucarefullyexaminethesourcecode,
theimplementationsofmethods contains ,index,andcountdonotrelyonany
assumption about the self instances, other than that syntax len(self) and self[j] are
supported (by special methods len and getitem , respectively). Support
foriterationisautomaticaswell,asdescribed inSection2.3.4.
In the remainder of this book, we omit the formality of using the abcmodule.
Ifweneed an “abstract” base class, wesimply document the expectation thatsub-
classesprovideassumedfunctionality,withouttechnicaldeclarationofthemethods
as abstract. But we will make use of the wonderful abstract base classes that are
deﬁnedwithin thecollectionsmodule (such asSequence). Tousesuchaclass, we
needonlyrelyonstandard inheritance techniques.
Forexample, ourRangeclass, from Code Fragment2.6of Section 2.3.5, isan
example of a class that supports the len and getitem methods. But that
class doesnotsupport methodscountorindex. Hadweoriginally declared itwith
Sequence as a superclass, then it would also inherit thecount and indexmethods.
Thesyntaxforsuchadeclaration wouldbeginas:
class Range(collections.Sequence):
Finally, we emphasize that if a subclass provides its own implementation of
aninherited behaviors from abaseclass, thenewdeﬁnition overrides theinherited
one. This technique can be used when we have the ability to provide a more efﬁ-
cient implementation for a behavior than is achieved by the generic approach. As
an example, the general implementation of contains for a sequence is based
on a loop used to search for the desired value. For our Range class, there is an
opportunity for a more efﬁcient determination of containment. For example, it
is evident that the expression, 100000 in Range(0, 2000000, 100), should evalu-
ate toTrue, even without examining the individual elements ofthe range, because
the range starts with zero, has an increment of 100, and goes until 2 million; it
must include 100000, as that is a multiple of 100 that is between the start and
stop values. Exercise C-2.27 explores the goal of providingan implementation of96 Chapter2. Object-OrientedProgramming
2.5 Namespaces and Object-Orientation
Anamespaceisanabstractionthatmanagesalloftheidentiﬁersthataredeﬁnedin
aparticularscope,mappingeachnametoitsassociatedvalue. InPython,functions,
classes, and modules are all ﬁrst-class objects, and so the “value” associated with
anidentiﬁerinanamespace mayinfactbeafunction, class,ormodule.
InSection1.10weexplored Python’s useofnamespaces tomanageidentiﬁers
that are deﬁned with global scope, versus those deﬁned within the local scope of
a function call. In this section, we discuss the important role of namespaces in
Python’smanagementofobject-orientation.
2.5.1 Instance and Class Namespaces
We begin by exploring what is known as the instance namespace, which man-
ages attributes speciﬁc to an individual object. For example, each instance of our
CreditCardclassmaintains adistinct balance, adistinct account number, adistinct
creditlimit,andsoon(eventhoughsomeinstancesmaycoincidentally haveequiv-
alent balances, or equivalent credit limits). Each credit card will have a dedicated
instance namespacetomanagesuchvalues.
Thereisaseparate class namespace foreachclass that hasbeen deﬁned. This
namespace is used to manage members that are to be shared by all instances of
a class, or used without reference to any particular instance. For example, the
make payment method of the CreditCard class from Section 2.3 is not stored
independently by each instance of that class. That member function is stored
within the namespace ofthe CreditCardclass. Based on our deﬁnition from Code
Fragments 2.1 and 2.2, the CreditCard class namespace includes the functions:
init , get customer, get bank, get account, get balance, get limit, charge,
and make payment. Our PredatoryCreditCard class has its own namespace, con-
taining the three methods we deﬁned for that subclass: init , charge, and
process month.
Figure 2.8 provides a portrayal of three such namespaces: a class namespace
containing methods of the CreditCard class, another class namespace with meth-
ods of the PredatoryCreditCard class, and ﬁnally a single instance namespace for
a sample instance of the PredatoryCreditCard class. We note that there are two
different deﬁnitions of a function named charge, one in the CreditCard class, and
then the overriding method in the PredatoryCreditCard class. In similar fashion,
there are two distinct init implementations. However, process month is a
name that is only deﬁned within the scope of thePredatoryCreditCard class. The
instance namespace includes alldatamembers fortheinstance (including the apr2.5. NamespacesandObject-Orientation 97
function
John Bowman
function init
customer
California Savings
get customer
function bank
get bank 5391 0375 9387 5309
account
function
get account
1234.56 balance
function make payment
function limit
2500
get balance
function init apr
get limit function process month 0.0825
function
charge
charge
function function
(a) (b) (c)
Figure 2.8: Conceptual view of three namespaces: (a) the class namespace for
CreditCard; (b) the class namespace for PredatoryCreditCard; (c) the instance
namespace foraPredatoryCreditCardobject.
How Entries Are Established in a Namespace
It is important to understand why a member such as balance resides in a credit
card’s instance namespace, while a member such asmake payment resides in the
class namespace. The balance is established within the init method when a
new credit card instance is constructed. The original assignment uses the syntax,
self. balance = 0, where self is an identiﬁer for the newly constructed instance.
The use of self as a qualiﬁer for self. balance in such an assignment causes the
balanceidentiﬁertobeaddeddirectly totheinstance namespace.
Wheninheritance isused, thereisstillasingleinstance namespaceperobject.
For example, when an instance of the PredatoryCreditCard class is constructed,
the aprattribute aswellasattributes such as balanceand limitallreside inthat
instance’s namespace, because all are assigned using a qualiﬁed syntax, such as
self. apr.
A class namespace includes all declarations that are made directly within the
bodyoftheclassdeﬁnition. Forexample,ourCreditCardclassdeﬁnition included
thefollowingstructure:
class CreditCard:
def make payment(self, amount):
...
Becausethemake paymentfunctionisdeclaredwithinthescopeoftheCreditCard
class, that function becomes associated with the name make payment within the
CreditCard class namespace. Although member functions are the most typical
types of entries that are declared in a class namespace, we next discuss how other98 Chapter2. Object-OrientedProgramming
Class Data Members
A class-level data member is often used when there is some value, such as a con-
stant, that is to be shared by all instances of a class. In such a case, it would
be unnecessarily wasteful to have each instance store that value in its instance
namespace. Asanexample,werevisitthePredatoryCreditCardintroducedinSec-
tion 2.4.1. That class assesses a $5 fee if an attempted charge is denied because
of the credit limit. Our choice of $5 for the fee was somewhat arbitrary, and our
coding style would be better if we used a named variable rather than embedding
the literal value in our code. Often, the amount of such a fee is determined by the
bank’s policy and does not vary for each customer. In that case, we could deﬁne
anduseaclassdatamemberasfollows:
class PredatoryCreditCard(CreditCard):
OVERLIMIT FEE = 5 # this is a class-level member
def charge(self, price):
success = super().charge(price)
if not success:
self. balance += PredatoryCreditCard.OVERLIMIT FEE
return success
Thedatamember,OVERLIMIT FEE,isentered intothePredatoryCreditCard
class namespace because that assignment takes place withinthe immediate scope
oftheclassdeﬁnition, andwithoutanyqualifying identiﬁer.
Nested Classes
It is also possible to nest one class deﬁnition within the scope of another class.
This is a useful construct, which we will exploit several times in this book in the
implementation ofdatastructures. Thiscanbedonebyusingasyntaxsuchas
class A: # the outer class
class B: # the nested class
...
In this case, class B is the nested class. The identiﬁer B is entered into the name-
spaceofclassAassociatedwiththenewlydeﬁnedclass. Wenotethatthistechnique
isunrelated totheconceptofinheritance, asclassBdoesnotinheritfromclassA.
Nesting one class in the scope of another makes clear that the nested class
existsforsupportoftheouterclass. Furthermore,itcanhelpreducepotentialname
conﬂicts, because it allows for a similarly named class to exist in another context.
Forexample,wewilllaterintroduceadatastructureknownasalinkedlistandwill
deﬁne a nested node class to store the individual components of the list. We will2.5. NamespacesandObject-Orientation 99
node class. These twostructures rely on different node deﬁnitions, and bynesting
thosewithintherespectivecontainer classes, weavoidambiguity.
Another advantage of one class being nested as a member of another is that it
allows for a more advanced form of inheritance in which a subclass of the outer
classoverridesthedeﬁnitionofitsnestedclass. Wewillmakeuseofthattechnique
inSection11.2.1whenspecializing thenodesofatreestructure.
Dictionaries and the slots Declaration
Bydefault, Pythonrepresents eachnamespace withaninstance ofthebuilt-in dict
class(seeSection1.2.3)thatmapsidentifyingnamesinthatscopetotheassociated
objects. While a dictionary structure supports relatively efﬁcient name lookups,
it requires additional memory usage beyond the raw data that it stores (we will
explorethedatastructure usedtoimplementdictionaries inChapter10).
Pythonprovidesamoredirectmechanismforrepresentinginstancenamespaces
thatavoidstheuseofanauxiliarydictionary. Tousethestreamlinedrepresentation
for allinstances of aclass, that class deﬁnition mustprovide aclass-level member
named slots thatisassignedtoaﬁxedsequenceofstringsthatserveasnames
for instance variables. For example, with our CreditCard class, we would declare
thefollowing:
class CreditCard:
slots = _customer , _bank , _account , _balance , _limit
In this example, the right-hand side of the assignment is technically a tuple (see
discussion ofautomaticpacking oftuplesinSection1.9.3).
Wheninheritance isused, ifthebaseclassdeclares slots ,asubclass must
also declare slots to avoid creation of instance dictionaries. The declaration
inthesubclass shouldonlyincludenamesofsupplemental methodsthatarenewly
introduced. For example, our PredatoryCreditCard declaration would include the
followingdeclaration:
class PredatoryCreditCard(CreditCard):
slots = _apr # in addition to the inherited members
We could choose to use the slots declaration to streamline every class in
this book. However, we do not do so because such rigor would be atypical for
Python programs. With that said, there are a few classes in this book for which
we expect to have a large number of instances, each representing a lightweight
construct. For example, when discussing nested classes, we suggest linked lists
andtreesasdatastructuresthatareoftencomprisedofalargenumberofindividual
nodes. To promote greater efﬁciency in memory usage, we will use an explicit100 Chapter2. Object-OrientedProgramming
2.5.2 Name Resolution and Dynamic Dispatch
In the previous section, we discussed various namespaces, and the mechanism for
establishing entries in those namespaces. In this section, we examine the process
thatisused whenretrieving anameinPython’s object-oriented framework. When
the dot operator syntax is used to access an existing member,such as obj.foo, the
Pythoninterpreter beginsanameresolution process, described asfollows:
1. Theinstance namespaceissearched; ifthedesirednameisfound,itsassoci-
atedvalueisused.
2. Otherwise the class namespace, for the class to which the instance belongs,
issearched; ifthenameisfound,itsassociated valueisused.
3. Ifthenamewasnotfoundintheimmediateclassnamespace,thesearchcon-
tinues upward through the inheritance hierarchy, checking the class name-
spaceforeachancestor(commonlybycheckingthesuperclassclass,thenits
superclass class, and so on). The ﬁrst time the name is found, its associate
valueisused.
4. Ifthenamehasstillnotbeenfound, anAttributeErrorisraised.
As a tangible example, let us assume thatmycard identiﬁes an instance of the
PredatoryCreditCardclass. Considerthefollowingpossible usagepatterns.
• mycard. balance(orequivalently,self. balancefromwithinamethodbody):
the balancemethodisfoundwithintheinstance namespaceformycard.
• mycard.process month(): the search begins in the instance namespace, but
the name process month is not found in that namespace. As a result, the
PredatoryCreditCard class namespace is searched; in this case, the name is
foundandthatmethodiscalled.
• mycard.make payment(200): thesearchforthename,make payment,fails
in the instance namespace and in thePredatoryCreditCardnamespace. The
name is resolved in the namespace for superclass CreditCard and thus the
inherited methodiscalled.
• mycard.charge(50): the search for name charge fails in the instance name-
space. The next namespace checked is for the PredatoryCreditCard class,
becausethatisthetruetypeoftheinstance. Thereisadeﬁnitionforacharge
function inthatclass,andsothatistheonethatiscalled.
In the last case shown, notice that the existence of a charge function in the
PredatoryCreditCardclasshastheeffectofoverridingtheversion ofthatfunction
that exists in the CreditCard namespace. In traditional object-oriented terminol-
ogy, Python uses what is known as dynamic dispatch (or dynamic binding) to
determine, atrun-time, which implementation ofafunctiontocall based upon the
type of the object upon which it is invoked. This is in contrast to some languages
thatusestaticdispatching, makingacompile-time decision astowhichversionof2.6. ShallowandDeepCopying 101
2.6 Shallow and Deep Copying
In Chapter 1, we emphasized that an assignment statement foo = bar makes the
name foo an alias for the object identiﬁed as bar. In this section, we consider
the task of making a copy of an object, rather than an alias. This is necessary in
applications when we want to subsequently modify either theoriginal or the copy
inanindependent manner.
Considerascenarioinwhichwemanagevariouslistsofcolors,witheachcolor
represented by an instance ofa presumed color class. Welet identiﬁer warmtones
denote an existing list of such colors (e.g., oranges, browns). In this application,
wewishtocreate anewlist namedpalette,whichisacopyofthewarmtones list.
However, we want to subsequently be able to add additional colors to palette, or
tomodify orremove some ofthe existing colors, without affecting the contents of
warmtones. Ifweweretoexecutethecommand
palette = warmtones
this creates an alias, as shown in Figure 2.9. No new list is created; instead, the
newidentiﬁerpalettereferences theoriginal list.
warmtones palette
list
color color
249 red 169 red
124 green 163 green
43 blue 52 blue
Figure2.9: Twoaliasesforthesamelistofcolors.
Unfortunately, this does not meet our desired criteria, because if we subsequently
addorremovecolorsfrom“palette,” wemodifythelistidentiﬁed aswarmtones.
Wecaninsteadcreateanewinstanceofthelistclassbyusingthesyntax:
palette = list(warmtones)
Inthis case, weexplicitly callthelistconstructor, sending theﬁrstlistasaparam-
eter. This causes a new list to be created, as shown in Figure 2.10; however, it is
whatisknownasashallowcopy. Thenewlistisinitialized sothatitscontents are
preciselythesameastheoriginalsequence. However,Python’slistsarereferential
(seepage9ofSection1.2.3),andsothenewlistrepresentsasequenceofreferences102 Chapter2. Object-OrientedProgramming
warmtones palette
list list
color color
249 red 169 red
124 green 163 green
43 blue 52 blue
Figure2.10: Ashallowcopyofalistofcolors.
This is a better situation than our ﬁrst attempt, as we can legitimately add
or remove elements from palette without affecting warmtones. However, if we
edit a color instance from the palette list, we effectively change the contents of
warmtones. Although paletteandwarmtones aredistinct lists, there remainsindi-
rectaliasing,forexample,withpalette[0]andwarmtones[0]asaliasesforthesame
colorinstance.
We prefer that palette be what is known as a deep copy of warmtones. In a
deep copy, the new copy references its owncopies of those objects referenced by
theoriginalversion. (SeeFigure2.11.)
warmtones palette
list list
color color color color
249 red 169 red 249 red 169 red
124 green 163 green 124 green 163 green
43 blue 52 blue 43 blue 52 blue
Figure2.11: Adeepcopyofalistofcolors.
Python’s copy Module
To create a deep copy, we could populate our list by explicitly making copies of
the original color instances, but this requires that weknowhow to make copies of
colors (rather than aliasing). Python provides a very convenient module, named
copy,thatcanproducebothshallowcopiesanddeepcopiesofarbitraryobjects.
This module supports two functions: thecopy function creates a shallow copy
of its argument, and the deepcopy function creates a deep copy of its argument.
Afterimportingthemodule,wemaycreateadeepcopyforourexample,asshown
inFigure2.11,usingthecommand:2.7. Exercises 103
2.7 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-2.1 Givethreeexamplesoflife-critical softwareapplications.
R-2.2 Giveanexampleofasoftwareapplicationinwhichadaptabilitycanmean
thedifference betweenaprolonged lifetimeofsalesandbankruptcy.
R-2.3 Describe acomponent from atext-editor GUIand themethods that iten-
capsulates.
R-2.4 WriteaPythonclass,Flower,thathasthreeinstance variables oftypestr,
int,andﬂoat, thatrespectively represent the nameoftheﬂower, itsnum-
berofpetals, anditsprice. Yourclass mustinclude aconstructor method
thatinitializeseachvariabletoanappropriatevalue,andyourclassshould
includemethodsforsettingthevalueofeachtype,andretrievingthevalue
ofeachtype.
R-2.5 UsethetechniquesofSection1.7torevisethechargeandmake payment
methods of the CreditCard class to ensure that the caller sends a number
asaparameter.
R-2.6 If the parameter to the make payment method of the CreditCard class
wereanegative number, thatwouldhavetheeffectofraisingthebalance
ontheaccount. RevisetheimplementationsothatitraisesaValueErrorif
anegativevalueissent.
R-2.7 The CreditCard class of Section 2.3 initializes the balance of a new ac-
count to zero. Modify that class so that a new account can be given a
nonzero balance using an optional ﬁfthparameter totheconstructor. The
four-parameter constructor syntax should continue toproduce anaccount
withzerobalance.
R-2.8 Modify the declaration of the ﬁrst for loop in the CreditCard tests, from
CodeFragment2.3,sothatitwilleventuallycauseexactlyoneofthethree
creditcardstogooveritscreditlimit. Whichcreditcardisit?
R-2.9 Implement the sub method for the Vector class of Section 2.3.3, so
that the expression u−v returns a new vector instance representing the
difference betweentwovectors.
R-2.10 Implement the neg method for the Vector class of Section 2.3.3, so
that the expression −v returns a new vector instance whose coordinates104 Chapter2. Object-OrientedProgramming
R-2.11 In Section 2.3.3, we note that our Vector class supports a syntax such as
v = u + [5, 3, 10, −2, 1], in which the sum of a vector and list returns
a new vector. However, the syntax v = [5, 3, 10, −2, 1] + u is illegal.
Explain how theVector class deﬁnition canberevised sothat this syntax
generates anewvector.
R-2.12 Implement the mul method for the Vector class of Section 2.3.3, so
that the expression v 3 returns anew vector withcoordinates that are 3
timestherespectivecoordinates ofv.
R-2.13 Exercise R-2.12 asks for an implementation of mul , for the Vector
classofSection2.3.3,toprovidesupportforthesyntaxv 3. Implement
the rmul method,toprovideadditional support forsyntax3 v.
R-2.14 Implement the mul method for the Vector class of Section 2.3.3, so
thattheexpressionu vreturnsascalarthatrepresentsthedotproductof
thevectors, thatis,∑d u ·v.
i=1 i i
R-2.15 The Vector class of Section 2.3.3 provides a constructor that takes an in-
tegerd,andproducesad-dimensionalvectorwithallcoordinatesequalto
0. Anotherconvenientformforcreatinganewvectorwouldbetosendthe
constructoraparameterthatissomeiterabletyperepresenting asequence
of numbers, and to create a vector with dimension equal to thelength of
thatsequenceandcoordinates equaltothesequence values. Forexample,
Vector([4, 7, 5]) would produce a three-dimensional vector with coordi-
nates <4, 7, 5>. Modify the constructor so that either of these forms is
acceptable; that is, if a single integer is sent, it produces a vector of that
dimensionwithallzeros,butifasequenceofnumbersisprovided,itpro-
ducesavectorwithcoordinates basedonthatsequence.
R-2.16 OurRangeclass,fromSection2.3.5,reliesontheformula
max(0, (stop − start + step − 1) // step)
tocomputethenumberofelementsintherange. Itisnotimmediatelyev-
ident whythis formula provides the correct calculation, evenif assuming
apositivestepsize. Justifythisformula,inyourownwords.
R-2.17 Drawaclassinheritance diagramforthefollowingsetofclasses:
• Class Goat extends object and adds an instance variable tail and
methodsmilk()andjump().
• Class Pig extends object and adds an instance variable nose and
methodseat(food)andwallow().
• Class Horse extends object and adds instance variables heightand
color,andmethodsrun()andjump().
• ClassRacerextendsHorseandaddsamethodrace().
• ClassEquestrianextendsHorse,addinganinstancevariable weight2.7. Exercises 105
R-2.18 Give a short fragment of Python code that uses the progression classes
from Section 2.4.2 to ﬁnd the 8th value of a Fibonacci progression that
startswith2and2asitsﬁrsttwovalues.
R-2.19 When using the ArithmeticProgression class of Section 2.4.2 with an in-
crement of 128 and a start of 0, how many calls to next can we make
beforewereachanintegerof263 orlarger?
R-2.20 Whataresomepotential efﬁciencydisadvantages ofhaving verydeepin-
heritance trees, thatis,alargesetofclasses,A,B,C,andsoon,suchthat
Bextends A,CextendsB,DextendsC,etc.?
R-2.21 What are some potential efﬁciency disadvantages of having very shallow
inheritance trees, that is, a large set of classes, A, B, C, and so on, such
thatalloftheseclassesextendasingleclass,Z?
R-2.22 Thecollections.Sequenceabstractbaseclassdoesnotprovidesupportfor
comparing twosequences toeachother. ModifyourSequenceclassfrom
Code Fragment 2.14 to include a deﬁnition for the eq method, so
that expression seq1 == seq2 will return True precisely when the two
sequences areelementbyelementequivalent.
R-2.23 Insimilarspirittothepreviousproblem,augmenttheSequenceclasswith
method lt ,tosupportlexicographic comparisonseq1 < seq2.
Creativity
C-2.24 Supposeyouareonthedesignteamforanewe-bookreader. Whatarethe
primaryclassesandmethodsthatthePythonsoftwareforyourreaderwill
need? You should include an inheritance diagram for this code, but you
do not need to write any actual code. Your software architecture should
at least include ways for customers to buy new books, view their list of
purchased books, andreadtheirpurchased books.
C-2.25 ExerciseR-2.12usesthe mul methodtosupportmultiplyingaVector
byanumber, whileExerciseR-2.14usesthe mul methodtosupport
computing adot product oftwovectors. Giveasingle implementation of
Vector. mul thatusesrun-timetypecheckingtosupportbothsyntaxes
u vandu k,whereuandvdesignatevectorinstancesandkrepresents
anumber.
C-2.26 The SequenceIterator class ofSection 2.3.4 provides what is known as a
forwarditerator. ImplementaclassnamedReversedSequenceIteratorthat
servesasareverseiterator foranyPython sequence type. Theﬁrstcallto
nextshouldreturnthelastelementofthesequence,thesecondcalltonext106 Chapter2. Object-OrientedProgramming
C-2.27 In Section 2.3.5, we note that our version of the Range class has im-
plicit support for iteration, due to its explicit support of both len
and getitem . Theclassalsoreceivesimplicitsupport oftheBoolean
test, “k in r”for Range r. This test isevaluated based ona forward itera-
tion through the range, as evidenced by the relative quickness of the test
2 in Range(10000000) versus 9999999 in Range(10000000). Provide a
more efﬁcient implementation of the contains method to determine
whether aparticular value lies within agiven range. Therunning timeof
yourmethodshouldbeindependent ofthelengthoftherange.
C-2.28 ThePredatoryCreditCardclassofSection2.4.1providesaprocess month
method that models the completion of amonthly cycle. Modifythe class
sothatonceacustomerhasmadetencallstochargeinthecurrentmonth,
eachadditional calltothatfunctionresultsinanadditional $1surcharge.
C-2.29 Modify the PredatoryCreditCard class from Section 2.4.1 so that a cus-
tomer is assigned a minimum monthly payment, as a percentage of the
balance, and so that a late fee is assessed if the customer does not subse-
quently paythatminimumamountbeforethenextmonthlycycle.
C-2.30 AtthecloseofSection2.4.1,wesuggestamodelinwhichtheCreditCard
class supports a nonpublic method, set balance(b), that could be used
bysubclassestoaffectachangetothebalance, withoutdirectlyaccessing
the balance data member. Implement such a model, revising both the
CreditCardandPredatoryCreditCardclassesaccordingly.
C-2.31 WriteaPythonclassthatextends theProgressionclasssothateachvalue
intheprogression istheabsolute valueofthedifference betweenthepre-
vious two values. You should include a constructor that accepts a pair of
numbersastheﬁrsttwovalues,using2and200asthedefaults.
C-2.32 WriteaPythonclassthatextends theProgressionclasssothateachvalue
in the progression is the square root of the previous value. (Note that
you can no longer represent each value with an integer.) Your construc-
tor should accept an optional parameter specifying the start value, using
65,536asadefault.
Projects
P-2.33 Write a Python program that inputs a polynomial in standard algebraic
notation andoutputstheﬁrstderivativeofthatpolynomial.
P-2.34 Write a Python program that inputs a document and then outputs a bar-
chart plot of the frequencies of each alphabet character that appears in2.7. Exercises 107
P-2.35 Write a set of Python classes that can simulate an Internet application in
which one party, Alice, is periodically creating a set of packets that she
wantstosendtoBob. AnInternetprocessiscontinuallycheckingifAlice
hasanypacketstosend,andifso,itdeliversthemtoBob’scomputer,and
BobisperiodicallycheckingifhiscomputerhasapacketfromAlice,and,
ifso,hereadsanddeletesit.
P-2.36 Write a Python program to simulate an ecosystem containing two types
of creatures, bears and ﬁsh. The ecosystem consists of a river, which is
modeled as a relatively large list. Each element of the list should be a
Bearobject, aFishobject, orNone. Ineachtimestep,basedonarandom
process,eachanimaleitherattemptstomoveintoanadjacentlistlocation
orstaywhereitis. Iftwoanimalsofthesametypeareabout tocollidein
thesamecell,thentheystaywheretheyare,buttheycreateanewinstance
ofthattypeofanimal,whichisplacedinarandomempty(i.e.,previously
None) location in the list. If a bear and a ﬁsh collide, however, then the
ﬁshdies(i.e.,itdisappears).
P-2.37 Write a simulator, as in the previous project, but add a Boolean gender
ﬁeld and a ﬂoating-point strength ﬁeld to each animal, using an Animal
class as a base class. If two animals of the same type try to collide, then
theyonlycreateanewinstanceofthattypeofanimaliftheyareofdiffer-
entgenders. Otherwise,iftwoanimalsofthesametypeandgender tryto
collide, thenonlytheoneoflargerstrength survives.
P-2.38 Write a Python program that simulates a system that supports the func-
tions of an e-book reader. You should include methods for users of your
system to “buy” new books, view their list of purchased books, and read
their purchased books. Yoursystem should useactual books,which have
expired copyrights and are available on the Internet, to populate your set
ofavailablebooksforusersofyoursystem to“purchase” andread.
P-2.39 Develop an inheritance hierarchy based upon a Polygon class that has
abstract methods area() and perimeter(). Implement classes Triangle,
Quadrilateral, Pentagon, Hexagon, and Octagon that extend this base
class,withtheobviousmeaningsforthearea()andperimeter()methods.
Also implement classes, IsoscelesTriangle, EquilateralTriangle, Rectan-
gle, and Square, that have the appropriate inheritance relationships. Fi-
nally, write a simple program that allows users to create polygons of the
varioustypesandinputtheirgeometricdimensions, andtheprogramthen
outputs their area and perimeter. For extra effort, allow users to input
polygons by specifying their vertex coordinates and be ableto test if two108 Chapter2. Object-OrientedProgramming
Chapter Notes
Forabroadoverviewofdevelopmentsincomputerscienceandengineering,wereferthe
readerto The ComputerScience andEngineeringHandbook[96]. Formore information
abouttheTherac-25incident,pleaseseethepaperbyLevesonandTurner[69].
The reader interested in studyingobject-orientedprogrammingfurther, is referredto
the books by Booch [17], Budd [20], and Liskov and Guttag [71]. Liskov and Guttag
alsoprovideanicediscussionofabstractdatatypes,asdoesthesurveypaperbyCardelli
and Wegner [23] and the book chapter by Demurjian [33] in the The Computer Science
andEngineeringHandbook[96]. DesignpatternsaredescribedinthebookbyGammaet
al.[41].
Books with speciﬁc focus on object-oriented programming in Python include those
byGoldwasserandLetscher[43]attheintroductorylevel,andbyPhillips[83] atamoreChapter
3
Algorithm Analysis
Contents
3.1 Experimental Studies . . . . . . . . . . . . . . . . . . . . . 111
3.1.1 Moving Beyond Experimental Analysis . . . . . . . . . . . 113
3.2 The Seven Functions Used in This Book . . . . . . . . . . 115
3.2.1 Comparing Growth Rates . . . . . . . . . . . . . . . . . . 122
3.3 Asymptotic Analysis . . . . . . . . . . . . . . . . . . . . . . 123
3.3.1 The “Big-Oh” Notation . . . . . . . . . . . . . . . . . . . 123
3.3.2 Comparative Analysis . . . . . . . . . . . . . . . . . . . . 128
3.3.3 Examples of Algorithm Analysis . . . . . . . . . . . . . . 130
3.4 Simple Justiﬁcation Techniques . . . . . . . . . . . . . . . 137
3.4.1 By Example . . . . . . . . . . . . . . . . . . . . . . . . . 137
3.4.2 The “Contra” Attack . . . . . . . . . . . . . . . . . . . . 137
3.4.3 Induction and Loop Invariants . . . . . . . . . . . . . . . 138110 Chapter3. AlgorithmAnalysis
In a classic story, the famous mathematician Archimedes was asked to deter-
mine if a golden crown commissioned by the king was indeed pure gold, and not
partsilver, asaninformant hadclaimed. Archimedes discovered awaytoperform
thisanalysis whilestepping intoabath. Henotedthatwaterspilledoutofthebath
inproportion to theamount ofhim that wentin. Realizing theimplications of this
fact, he immediately got out of the bath and ran naked through the city shouting,
“Eureka, eureka!” for he had discovered an analysis tool (displacement), which,
when combined witha simple scale, could determine if the king’s new crown was
goodornot. Thatis,Archimedescoulddipthecrownandanequal-weight amount
of gold into a bowl of water to see if they both displaced the same amount. This
discovery was unfortunate for the goldsmith, however, for when Archimedes did
his analysis, the crown displaced more water than an equal-weight lump of pure
gold,indicating thatthecrownwasnot,infact,puregold.
Inthisbook,weareinterestedinthedesignof“good”datastructuresandalgo-
rithms. Simplyput, adatastructureisasystematic wayoforganizing andaccess-
ingdata,andanalgorithmisastep-by-step procedureforperformingsometaskin
aﬁniteamountoftime. Theseconcepts arecentral tocomputing, but tobeableto
classifysomedatastructuresandalgorithmsas“good,”wemusthavepreciseways
ofanalyzing them.
The primary analysis tool we will use in this book involves characterizing the
running times of algorithms and data structure operations, with space usage also
being ofinterest. Running timeisanatural measureof“goodness,” since timeisa
precious resource—computer solutions should run as fast aspossible. In general,
therunningtimeofanalgorithmordatastructureoperationincreaseswiththeinput
size, although itmayalso varyfordifferent inputs ofthesamesize. Also, the run-
ning time is affected by the hardware environment (e.g., theprocessor, clock rate,
memory,disk)andsoftwareenvironment(e.g.,theoperatingsystem,programming
language) in which the algorithm is implemented and executed. All other factors
beingequal,therunning timeofthesamealgorithm onthesameinputdatawillbe
smaller if the computer has, say, a much faster processor or if the implementation
is done in a program compiled into native machine code instead of an interpreted
implementation. We begin this chapter by discussing tools for performing exper-
imental studies, yet also limitations to the use of experiments as a primary means
forevaluating algorithm efﬁciency.
Focusingonrunningtimeasaprimarymeasureofgoodnessrequiresthatwebe
able to use a few mathematical tools. In spite of the possible variations that come
from different environmental factors, we would like to focus on the relationship
betweentherunningtimeofanalgorithmandthesizeofitsinput. Weareinterested
in characterizing an algorithm’s running time as a function of the input size. But
what is the proper way of measuring it? In this chapter, we “roll up our sleeves”3.1. ExperimentalStudies 111
3.1 Experimental Studies
Ifanalgorithm hasbeenimplemented, wecanstudy itsrunning timebyexecuting
it on various test inputs and recording the time spent during each execution. A
simple approach fordoing this inPython isby using thetimefunction ofthetime
module. Thisfunctionreportsthenumberofseconds,orfractionsthereof,thathave
elapsed since a benchmark time known as the epoch. The choice of the epoch is
not signiﬁcant to our goal, as we can determine theelapsed time by recording the
timejustbefore thealgorithm andthetimejustafterthealgorithm, andcomputing
theirdifference, asfollows:
from time import time
start time = time( ) # record the starting time
run algorithm
end time = time( ) # record the ending time
elapsed = end time − start time # compute the elapsed time
Wewilldemonstrateuseofthisapproach,inChapter5,togatherexperimentaldata
on the efﬁciency of Python’s list class. An elapsed time measured in this fashion
isadecentreﬂectionofthealgorithm efﬁciency,butitisbynomeansperfect. The
time function measures relative to what is known as the “wall clock.” Because
many processes share use of a computer’s central processing unit (or CPU), the
elapsed time will depend on what other processes are running on the computer
when the test is performed. A fairer metric is the number of CPU cycles that are
usedbythealgorithm. Thiscanbedeterminedusingtheclockfunctionofthetime
module, but even this measure might not be consistent if repeating the identical
algorithm ontheidenticalinput,anditsgranularity willdependuponthecomputer
system. Pythonincludes amoreadvanced module,namedtimeit,tohelpautomate
suchevaluations withrepetition toaccountforsuchvariance amongtrials.
Becauseweareinterestedinthegeneraldependenceofrunningtimeonthesize
and structure of the input, we should perform independent experiments on many
different test inputs of various sizes. We can then visualize the results by plotting
theperformance ofeach runofthealgorithm asapoint withx-coordinate equal to
theinputsize,n,andy-coordinate equaltotherunning time,t. Figure3.1displays
such hypothetical data. This visualization may provide some intuition regarding
the relationship between problem size and execution time for the algorithm. This
maylead toastatistical analysis that seeks toﬁtthe best function oftheinput size
to the experimental data. To be meaningful, this analysis requires that we choose
good sample inputs and test enough of them to be able to make sound statistical112 Chapter3. AlgorithmAnalysis
500
400
)
s
m
( 300
e
m
Ti
g
n
ni 200
n
u
R
100
0
0 5000 10000 15000
InputSize
Figure3.1: Results of an experimental study on the running time of an algorithm.
A dot with coordinates (n,t) indicates that on an input of size n, the running time
ofthealgorithm wasmeasuredast milliseconds (ms).
Challenges of Experimental Analysis
While experimental studies of running times are valuable, especially when ﬁne-
tuning production-quality code, there are three major limitations to their use for
algorithm analysis:
• Experimental running times of two algorithms are difﬁcult to directly com-
pareunlesstheexperimentsareperformedinthesamehardwareandsoftware
environments.
• Experiments can be done only on a limited set of test inputs; hence, they
leave out the running times of inputs not included in the experiment (and
theseinputsmaybeimportant).
• An algorithm must be fully implemented in order to execute it to study its
running timeexperimentally.
Thislastrequirementisthemostseriousdrawbacktotheuseofexperimentalstud-
ies. At early stages of design, when considering a choice of data structures or
algorithms,itwouldbefoolishtospendasigniﬁcantamountoftimeimplementing3.1. ExperimentalStudies 113
3.1.1 Moving Beyond Experimental Analysis
Ourgoalistodevelopanapproach toanalyzing theefﬁciencyofalgorithms that:
1. Allows us to evaluate the relative efﬁciency of any two algorithms in a way
thatisindependent ofthehardwareandsoftwareenvironment.
2. Is performed by studying a high-level description of the algorithm without
needforimplementation.
3. Takesintoaccount allpossible inputs.
Counting Primitive Operations
To analyze the running time of an algorithm without performing experiments, we
perform an analysis directly on a high-level description ofthe algorithm (either in
the form of an actual code fragment, or language-independent pseudo-code). We
deﬁneasetofprimitiveoperationssuchasthefollowing:
• Assigning anidentiﬁertoanobject
• Determining theobjectassociated withanidentiﬁer
• Performinganarithmeticoperation (forexample,addingtwonumbers)
• Comparingtwonumbers
• Accessing asingleelementofaPythonlistbyindex
• Callingafunction (excluding operations executedwithinthefunction)
• Returning fromafunction.
Formally, aprimitiveoperation corresponds toalow-levelinstruction withanexe-
cutiontimethatisconstant. Ideally,thismightbethetypeofbasicoperationthatis
executedbythehardware,althoughmanyofourprimitiveoperationsmaybetrans-
lated to asmall number of instructions. Instead oftrying todetermine the speciﬁc
execution time ofeach primitive operation, wewillsimply count how manyprim-
itive operations are executed, and use this number t as a measure of the running
timeofthealgorithm.
Thisoperation countwillcorrelate toanactualrunning timeinaspeciﬁccom-
puter,foreachprimitiveoperationcorrespondstoaconstantnumberofinstructions,
andthereareonlyaﬁxednumberofprimitiveoperations. Theimplicitassumption
in this approach is that the running times of different primitive operations will be
fairly similar. Thus, the number, t, of primitive operations an algorithm performs
willbeproportional totheactualrunning timeofthatalgorithm.
Measuring Operations as a Function of Input Size
To capture the order of growth of an algorithm’s running time, we will associate,
with each algorithm, a function f(n) that characterizes the number of primitive
operations that areperformed asafunction oftheinputsizen. Section3.2willin-
troducethesevenmostcommonfunctionsthatarise,andSection3.3willintroduce114 Chapter3. AlgorithmAnalysis
Focusing on the Worst-Case Input
Analgorithmmayrunfasteronsomeinputsthanitdoesonothersofthesamesize.
Thus, wemay wish to express the running time of an algorithm as the function of
the input size obtained by taking the average over all possible inputs of the same
size. Unfortunately, such an average-case analysis is typically quite challenging.
Itrequiresustodeﬁneaprobability distribution onthesetofinputs,whichisoften
adifﬁculttask. Figure3.2schematically showshow,depending ontheinputdistri-
bution, the running time of an algorithm can be anywhere between the worst-case
time and the best-case time. For example, what if inputs are really only of types
“A”or“D”?
An average-case analysis usually requires that we calculate expected running
times based on a given input distribution, which usually involves sophisticated
probability theory. Therefore, for the remainder of this book, unless we specify
otherwise,wewillcharacterize runningtimesintermsoftheworstcase,asafunc-
tionoftheinputsize,n,ofthealgorithm.
Worst-case analysis is much easier than average-case analysis, as it requires
only the ability to identify the worst-case input, which is often simple. Also, this
approachtypicallyleadstobetteralgorithms. Makingthestandardofsuccessforan
algorithm toperformwellintheworstcasenecessarily requiresthatitwilldowell
on every input. That is, designing for the worst case leads to stronger algorithmic
“muscles,”muchlikeatrackstarwhoalwayspractices byrunning upanincline.
(cid:3)
5ms worst-casetime
)
ms 4ms
average-casetime?
(
e
m
Ti 3ms
g
n best-casetime
ni
un 2ms
R
1ms
A B C D E F G
InputInstance
Figure3.2: Thedifference between best-case andworst-case time. Eachbarrepre-3.2. TheSevenFunctionsUsedinThisBook 115
3.2 The Seven Functions Used in This Book
In this section, we brieﬂy discuss the seven most important functions used in the
analysis of algorithms. We will use only these seven simple functions for almost
all the analysis we do in this book. In fact, a section that uses a function other
thanoneofthesesevenwillbemarkedwithastar((cid:2))toindicatethatitisoptional.
In addition to these seven fundamental functions, Appendix B contains a list of
other useful mathematical facts that apply in the analysis of data structures and
algorithms.
The Constant Function
Thesimplestfunctionwecanthinkofistheconstantfunction. Thisisthefunction,
f(n)=c,
for some ﬁxed constant c, such as c = 5, c = 27, or c = 210. That is, for any
argument n, theconstant function f(n)assigns the valuec. Inother words, itdoes
notmatterwhatthevalueofnis; f(n)willalwaysbeequaltotheconstantvaluec.
Becausewearemostinterestedinintegerfunctions,themostfundamentalcon-
stant function is g(n)=1, and this is the typical constant function we use in this
book. Notethatanyotherconstant function, f(n)=c,canbewrittenasaconstant
ctimesg(n). Thatis, f(n)=cg(n)inthiscase.
Assimpleasitis,theconstantfunctionisusefulinalgorithmanalysis,because
itcharacterizes the number of steps needed to doabasic operation on acomputer,
like adding two numbers, assigning a value to some variable, or comparing two
numbers.
The Logarithm Function
One of the interesting and sometimes even surprising aspects of the analysis of
datastructuresandalgorithmsistheubiquitouspresenceofthelogarithmfunction,
f(n)=log n,forsomeconstant b>1. Thisfunction isdeﬁnedasfollows:
b
x=log n ifandonlyif bx =n.
b
Bydeﬁnition, log 1=0. Thevaluebisknownasthebaseofthelogarithm.
b
The most common base for the logarithm function in computer science is 2,
as computers store integers in binary, and because a common operation in many
algorithms isto repeatedly divide an input in half. In fact,this base isso common
thatwewilltypically omititfromthenotation whenitis2. Thatis,forus,
logn=log n.116 Chapter3. AlgorithmAnalysis
We note that most handheld calculators have a button marked LOG, but this is
typically forcalculating thelogarithm base-10, notbase-two.
Computing the logarithm function exactly for any integer n involves the use
of calculus, but we can use an approximation that is good enough for our pur-
poses without calculus. In particular, we can easily compute the smallest integer
greater than orequal tolog n(itsso-called ceiling, (cid:13)log n(cid:14)). Forpositive integer,
b b
n, this value is equal to the number of times we can divide n by b before we get
a number less than or equal to 1. For example, the evaluation of (cid:13)log 27(cid:14) is 3,
3
because ((27/3)/3)/3 =1. Likewise, (cid:13)log 64(cid:14) is 3, because ((64/4)/4)/4 =1,
4
and(cid:13)log 12(cid:14)is4,because(((12/2)/2)/2)/2 =0.75≤1.
2
The following proposition describes several important identities that involve
logarithmsforanybasegreaterthan1.
Proposition 3.1 (Logarithm Rules): Givenrealnumbersa> 0,b >1,c> 0
andd>1,wehave:
1. log (ac)=log a+log c
b b b
2. log (a/c)=log a−log c
b b b
3. log (ac)=clog a
b b
4. log a=log a/log b
b d d
5. blogda=alogdb
By convention, the unparenthesized notation lognc denotes the value log(nc).
Weuseanotational shorthand, logcn,todenote thequantity,(logn)c,inwhichthe
resultofthelogarithm israisedtoapower.
Theaboveidentitiescanbederivedfromconverserulesforexponentiation that
wewillpresentonpage121. Weillustrate theseidentities withafewexamples.
Example 3.2: Wedemonstratebelowsomeinterestingapplicationsoftheloga-
rithmrulesfromProposition3.1(usingtheusualconventionthatthebaseofa
logarithmis2ifitisomitted).
• log(2n)=log2+logn=1+logn,byrule1
• log(n/2)=logn−log2=logn−1,byrule2
• logn3=3logn,byrule3
• log2n=nlog2=n·1=n,byrule3
• log n=(logn)/log4=(logn)/2,byrule4
4
• 2logn=nlog2=n1=n,byrule5.
Asapracticalmatter,wenotethatrule4givesusawaytocomputethebase-two
logarithmonacalculatorthathasabase-10logarithmbutton,LOG,for
log n=LOGn/LOG2.3.2. TheSevenFunctionsUsedinThisBook 117
The Linear Function
Anothersimpleyetimportantfunction isthelinearfunction,
f(n)=n.
Thatis,givenaninputvaluen,thelinearfunction f assigns thevaluenitself.
Thisfunctionarisesinalgorithmanalysisanytimewehavetodoasinglebasic
operation for each of n elements. For example, comparing a number x to each
element of a sequence of size n will require n comparisons. The linear function
alsorepresentsthebestrunningtimewecanhopetoachieveforanyalgorithm that
processeseachofnobjectsthatarenotalreadyinthecomputer’smemory,because
readinginthenobjectsalreadyrequiresnoperations.
N N
The -Log- Function
Thenextfunction wediscuss inthissection isthen-log-nfunction,
f(n)=nlogn,
that is, the function that assigns to an input n the value of n times the logarithm
base-twoofn. Thisfunctiongrowsalittlemorerapidlythanthelinearfunctionand
alotlessrapidly thanthequadratic function; therefore, wewouldgreatlypreferan
algorithmwitharunningtimethatisproportionaltonlogn,thanonewithquadratic
running time. Wewillseeseveralimportant algorithms thatexhibitarunning time
proportional to the n-log-n function. For example, the fastest possible algorithms
forsortingnarbitrary valuesrequiretimeproportional tonlogn.
The Quadratic Function
Anotherfunctionthatappearsofteninalgorithmanalysisisthequadraticfunction,
f(n)=n2.
That is, given an input value n, the function f assigns the product of n with itself
(inotherwords,“nsquared”).
The main reason why the quadratic function appears in the analysis of algo-
rithms is that there are many algorithms that have nested loops, where the inner
loop performs a linear number of operations and the outer loop is performed a
linear number of times. Thus, in such cases, the algorithm performs n·n = n2118 Chapter3. AlgorithmAnalysis
Nested Loops and the Quadratic Function
Thequadratic function canalso arise inthe context ofnested loops where the ﬁrst
iterationofaloopusesoneoperation,thesecondusestwooperations,thethirduses
threeoperations, andsoon. Thatis,thenumberofoperations is
1+2+3+···+(n−2)+(n−1)+n.
Inotherwords, thisisthetotalnumberofoperations thatwillbeperformed bythe
nestedloopifthenumberofoperationsperformedinsidetheloopincreasesbyone
witheachiterationoftheouterloop. Thisquantity alsohasaninteresting history.
In1787,aGermanschoolteacher decidedtokeephis9-and10-year-old pupils
occupied by adding up the integers from 1 to 100. But almost immediately one
of the children claimed to have the answer! The teacher was suspicious, for the
studenthadonlytheansweronhisslate. Buttheanswer,5050,wascorrectandthe
student, CarlGauss, grew upto be one ofthe greatest mathematicians of his time.
WepresumethatyoungGaussusedthefollowingidentity.
Proposition 3.3: Foranyintegern≥1,wehave:
n(n+1)
1+2+3+···+(n−2)+(n−1)+n= .
2
Wegivetwo“visual”justiﬁcations ofProposition 3.3inFigure3.3.
n+1
n n
... ...
3 3
2 2
1 1
0 1 2 3 n 0 1 2 n/2
(a) (b)
Figure3.3: Visual justiﬁcations ofProposition 3.3. Both illustrations visualize the
identity in terms of the total area covered by n unit-width rectangles with heights
1,2,...,n. In(a),therectanglesareshowntocoverabigtriangleofarean2/2(base
n and height n) plus n small triangles of area 1/2 each (base 1 and height 1). In
(b), which applies only when n is even, the rectangles are shown to cover a big3.2. TheSevenFunctionsUsedinThisBook 119
ThelessontobelearnedfromProposition3.3isthatifweperformanalgorithm
with nested loops such that the operations in the inner loop increase by one each
time, then the total number of operations is quadratic in the number of times, n,
we perform the outer loop. To be fair, the number of operations is n2/2 + n/2,
andsothis isjustoverhalf thenumber ofoperations than analgorithm that usesn
operations each time the inner loop is performed. But the order of growth is still
quadratic inn.
The Cubic Function and Other Polynomials
Continuing our discussion of functions that are powers of the input, we consider
thecubicfunction,
f(n)=n3,
whichassignstoaninputvaluentheproductofnwithitselfthreetimes. Thisfunc-
tion appears less frequently in the context of algorithm analysis than the constant,
linear, andquadratic functions previously mentioned, butitdoes appear fromtime
totime.
Polynomials
Most of the functions we have listed so far can each be viewed as being part of a
largerclassoffunctions, thepolynomials. Apolynomialfunctionhastheform,
f(n)=a +a n+a n2+a n3+···+a nd,
0 1 2 3 d
where a ,a ,...,a are constants, called the coefﬁcients of the polynomial, and
0 1 d
a (cid:15)=0. Integer d, which indicates the highest power in the polynomial, is called
d
thedegreeofthepolynomial.
Forexample,thefollowingfunctions areallpolynomials:
• f(n)=2+5n+n2
• f(n)=1+n3
• f(n)=1
• f(n)=n
• f(n)=n2
Therefore,wecouldarguethatthisbookpresentsjustfourimportantfunctionsused
inalgorithmanalysis,butwewillsticktosayingthatthereareseven,sincethecon-
stant, linear, and quadratic functions are too important tobe lumped in with other
polynomials. Running times that are polynomials with smalldegree are generally120 Chapter3. AlgorithmAnalysis
Summations
Anotation thatappearsagainandagainintheanalysis ofdatastructures andalgo-
rithmsisthesummation,whichisdeﬁnedasfollows:
b
∑ f(i)= f(a)+ f(a+1)+ f(a+2)+···+ f(b),
i=a
whereaandbareintegersanda≤b. Summationsariseindatastructure andalgo-
rithmanalysisbecausetherunningtimesofloopsnaturallygiverisetosummations.
Usingasummation, wecanrewritetheformulaofProposition3.3as
∑n i= n(n+1).
2
i=1
Likewise,wecanwriteapolynomial f(n)ofdegreedwithcoefﬁcientsa ,...,a as
0 d
d
f(n)= ∑ani.
i
i=0
Thus, the summation notation gives us a shorthand way of expressing sums of in-
creasing termsthathavearegularstructure.
The Exponential Function
Anotherfunctionusedintheanalysis ofalgorithms istheexponentialfunction,
f(n)=bn,
wherebisapositiveconstant, calledthebase,andtheargumentnistheexponent.
That is, function f(n) assigns to the input argument n the value obtained by mul-
tiplying the base b by itself n times. As was the case with the logarithm function,
themostcommonbasefortheexponential function inalgorithm analysis isb=2.
For example, an integer word containing n bits can represent all the nonnegative
integers less than 2n. If we have a loop that starts by performing one operation
andthendoubles thenumberofoperations performed witheach iteration, thenthe
numberofoperations performed inthenth iteration is2n.
We sometimes have other exponents besides n, however; hence, it is useful
for us to know a few handy rules for working with exponents. In particular, the3.2. TheSevenFunctionsUsedinThisBook 121
Proposition 3.4 (Exponent Rules): Givenpositiveintegersa,b,andc,wehave
1. (ba)c=bac
2. babc=ba+c
3. ba/bc =ba−c
Forexample,wehavethefollowing:
• 256=162=(24)2=24·2=28=256(Exponent Rule1)
• 243=35=32+3=3233=9·27=243(ExponentRule2)
• 16=1024/64=210/26 =210−6=24=16(Exponent Rule3)
We can extend the exponential function to exponents that arefractions or real
numbers and to negative exponents, as follows. Given a positive integer k, wede-
ﬁne b1/k to be kth root of b, that is, the number r such that rk =b. For example,
251/2 =5, since 52 =25. Likewise, 271/3 =3 and 161/4 =2. This approach al-
lows us to deﬁne any power whose exponent can be expressed as a fraction, for
ba/c =(ba)1/c, by Exponent Rule 1. For example, 93/2 =(93)1/2 =7291/2 =27.
Thus,ba/c isreallyjustthecth rootoftheintegralexponentba.
Wecanfurtherextendtheexponentialfunctiontodeﬁnebx foranyrealnumber
x,bycomputingaseriesofnumbersoftheformba/c forfractionsa/cthatgetpro-
gressivelycloserandclosertox. Anyrealnumberxcanbeapproximatedarbitrarily
closely by a fraction a/c; hence, we can use the fraction a/c as the exponent of b
to get arbitrarily close tobx. Forexample, the number 2π is well deﬁned. Finally,
givenanegativeexponentd,wedeﬁnebd =1/b−d,whichcorrespondstoapplying
ExponentRule3witha=0andc=−d. Forexample,2−3=1/23=1/8.
Geometric Sums
Supposewehavealoopforwhicheachiterationtakesamultiplicativefactorlonger
thantheprevious one. Thisloopcanbeanalyzed usingthefollowingproposition.
Proposition 3.5: Foranyintegern≥0andanyrealnumberasuchthata>0and
a(cid:15)=1,considerthesummation
n
∑ai=1+a+a2+···+an
i=0
(rememberingthata0=1ifa>0).Thissummationisequalto
an+1−1
.
a−1
SummationsasshowninProposition3.5arecalledgeometricsummations,be-
causeeachtermisgeometricallylargerthanthepreviousoneifa>1. Forexample,
everyoneworkingincomputingshouldknowthat
1+2+4+8+···+2n−1=2n−1,122 Chapter3. AlgorithmAnalysis
3.2.1 Comparing Growth Rates
Tosumup,Table3.1shows,inorder, eachofthesevencommonfunctions usedin
algorithm analysis.
constant logarithm linear n-log-n quadratic cubic exponential
1 logn n nlogn n2 n3 an
Table3.1: Classesoffunctions. Hereweassumethata>1isaconstant.
Ideally, we would like data structure operations to run in times proportional
to the constant or logarithm function, and we would like our algorithms to run in
linear or n-log-n time. Algorithms with quadratic or cubic running times are less
practical, and algorithms with exponential running times are infeasible for all but
thesmallestsizedinputs. Plotsofthesevenfunctions areshowninFigure3.4.
1044 Exponential
1040 Cubic
1036
Quadratic
1032
1028 N-Log-N
)n 1024 Linear
( 1020
f Logarithmic
1016
1012 Constant
108
104
100
100 101 102 103 104 105 106 107 108 109 1010 1011 1012 1013 1014 1015
n
Figure 3.4: Growth rates for the seven fundamental functions used in algorithm
analysis. Weusebasea=2fortheexponential function. Thefunctionsareplotted
on a log-log chart, to compare the growth rates primarily as slopes. Even so, the
exponential functiongrowstoofasttodisplay allitsvaluesonthechart.
The Ceiling and Floor Functions
One additional comment concerning the functions above is in order. When dis-
cussing logarithms, we noted that the value is generally not an integer, yet the
running timeofanalgorithm isusually expressed bymeansofaninteger quantity,
such as the number of operations performed. Thus, the analysis of an algorithm
may sometimes involve the use of the ﬂoor function and ceiling function, which
aredeﬁnedrespectively asfollows:
• (cid:16)x(cid:17)=thelargestintegerlessthanorequaltox.3.3. AsymptoticAnalysis 123
3.3 Asymptotic Analysis
Inalgorithmanalysis,wefocusonthegrowthrateoftherunningtimeasafunction
oftheinputsizen,takinga“big-picture”approach. Forexample,itisoftenenough
justtoknowthattherunningtimeofanalgorithmgrowsproportionally ton.
We analyze algorithms using a mathematical notation for functions that disre-
gards constant factors. Namely, we characterize the running times of algorithms
by using functions that map the size of the input, n, to values that correspond to
the main factor that determines the growth rate in terms of n. This approach re-
ﬂects that each basic step in a pseudo-code description or a high-level language
implementation may correspond to a small number of primitive operations. Thus,
wecan perform ananalysis ofanalgorithm byestimating thenumber ofprimitive
operations executed up to a constant factor, rather than getting bogged down in
language-speciﬁc or hardware-speciﬁc analysis of the exact number of operations
thatexecuteonthecomputer.
As a tangible example, we revisit the goal of ﬁnding the largest element of a
Python list; we ﬁrst used this example when introducing for loops on page 21 of
Section1.4.2. CodeFragment3.1presentsafunctionnamedﬁnd maxforthistask.
1 def ﬁnd max(data):
2 ”””Return the maximum element from a nonempty Python list.”””
3 biggest = data[0] # The initial value to beat
4 for val in data: # For each value:
5 if val > biggest # if it is greater than the best so far,
6 biggest = val # we have found a new best (so far)
7 return biggest # When loop ends, biggest is the max
CodeFragment3.1: Afunction thatreturnsthemaximumvalueofaPythonlist.
This is a classic example of an algorithm with a running time that grows pro-
portional to n, as the loop executes once for each data element, with some ﬁxed
number of primitive operations executing for each pass. In the remainder of this
section, weprovideaframeworktoformalizethisclaim.
3.3.1 The “Big-Oh” Notation
Let f(n)andg(n)befunctions mappingpositive integerstopositive realnumbers.
Wesaythat f(n)isO(g(n))ifthereisarealconstantc>0andanintegerconstant
n ≥1suchthat
0
f(n)≤cg(n), for n≥n .
0
Thisdeﬁnitionisoftenreferredtoasthe“big-Oh”notation,foritissometimespro-124 Chapter3. AlgorithmAnalysis
cg(n)
e
m
Ti f(n)
g 
n
ni
n
u
R
n
0 Input Size
Figure3.5: Illustrating the “big-Oh” notation. Thefunction f(n) isO(g(n)), since
f(n)≤c·g(n)whenn≥n .
0
Example 3.6: Thefunction8n+5isO(n).
Justiﬁcation: Bythebig-Ohdeﬁnition,weneedtoﬁndarealconstantc>0and
anintegerconstantn ≥1suchthat8n+5≤cnforeveryintegern≥n . Itiseasy
0 0
to see that a possible choice is c=9 and n =5. Indeed, this is one of inﬁnitely
0
manychoicesavailablebecausethereisatrade-offbetweencandn . Forexample,
0
wecouldrelyonconstantsc=13andn =1.
0
Thebig-Ohnotation allowsustosaythatafunction f(n)is“lessthanorequal
to” another function g(n) up to a constant factor and in the asymptotic sense as n
growstowardinﬁnity. Thisabilitycomesfromthefactthatthedeﬁnitionuses“≤”
tocompare f(n)toag(n)timesaconstant,c,fortheasymptoticcaseswhenn≥n .
0
However, it is considered poor taste to say “f(n) ≤ O(g(n)),” since the big-Oh
already denotes the “less-than-or-equal-to” concept. Likewise, although common,
itisnotfully correct tosay “f(n)=O(g(n)),” withthe usual understanding ofthe
“=” relation, because there is no way to make sense of the symmetric statement,
“O(g(n))= f(n).” Itisbesttosay,
“f(n)isO(g(n)).”
Alternatively, we can say “f(n) is order of g(n).” For the more mathematically
inclined,itisalsocorrecttosay,“f(n)∈O(g(n)),”forthebig-Ohnotation, techni-
callyspeaking, denotes awholecollection offunctions. Inthisbook, wewillstick
topresentingbig-Ohstatementsas“f(n)isO(g(n)).” Evenwiththisinterpretation,
thereisconsiderablefreedominhowwecanusearithmeticoperationswiththebig-3.3. AsymptoticAnalysis 125
Characterizing Running Times Using the Big-Oh Notation
Thebig-Ohnotationisusedwidelytocharacterizerunningtimesandspacebounds
intermsofsomeparametern,whichvariesfromproblemtoproblem,butisalways
deﬁned as a chosen measure of the “size” of the problem. For example, if we
are interested in ﬁnding the largest element in a sequence, as with the ﬁnd max
algorithm, weshouldletndenotethenumberofelementsinthatcollection. Using
the big-Oh notation, we can write the following mathematically precise statement
ontherunningtimeofalgorithmﬁnd max(CodeFragment3.1)foranycomputer.
Proposition 3.7: Thealgorithm,ﬁnd max,forcomputingthemaximumelement
ofalistofnnumbers,runsinO(n)time.
Justiﬁcation: The initialization before the loop begins requires only aconstant
numberofprimitiveoperations. Eachiterationoftheloopalsorequiresonlyacon-
stant number of primitive operations, and the loop executes n times. Therefore,
weaccount forthe number ofprimitive operations beingc(cid:2)+c(cid:2)(cid:2)·n forappropriate
(cid:2) (cid:2)(cid:2)
constants c and c that reﬂect, respectively, the work performed during initializa-
tionandtheloopbody. Becauseeachprimitiveoperationrunsinconstanttime,we
havethattherunning timeofalgorithmﬁnd maxonaninputofsizenisatmosta
constant timesn;that is,weconclude that therunning timeofalgorithmﬁnd max
isO(n).
Some Properties of the Big-Oh Notation
Thebig-Ohnotationallowsustoignoreconstantfactorsandlower-ordertermsand
focusonthemaincomponents ofafunction thataffectitsgrowth.
Example 3.8: 5n4+3n3+2n2+4n+1isO(n4).
Justiﬁcation: Notethat5n4+3n3+2n2+4n+1≤(5+3+2+4+1)n4=cn4,
forc=15,whenn≥n =1.
0
Infact,wecancharacterize thegrowthrateofanypolynomial function.
Proposition 3.9: If f(n)isapolynomialofdegreed,thatis,
f(n)=a +a n+···+a nd,
0 1 d
anda >0,then f(n)isO(nd).
d
Justiﬁcation: Notethat,forn≥1,wehave1≤n≤n2≤···≤nd;hence,
a +a n+a n2+···+a nd ≤(|a |+|a |+|a |+···+|a |)nd.
0 1 2 d 0 1 2 d
Weshowthat f(n)isO(nd)bydeﬁningc=|a |+|a |+···+|a |andn =1.126 Chapter3. AlgorithmAnalysis
Thus, the highest-degree term in a polynomial is the term that determines the
asymptoticgrowthrateofthatpolynomial. Weconsidersomeadditionalproperties
ofthebig-Ohnotationintheexercises. Letusconsidersomefurtherexampleshere,
focusing on combinations of the seven fundamental functions used in algorithm
design. Werelyonthemathematical factthatlogn≤nforn≥1.
Example 3.10: 5n2+3nlogn+2n+5isO(n2).
Justiﬁcation: 5n2+3nlogn+2n+5≤(5+3+2+5)n2=cn2,forc=15,when
n≥n =1.
0
Example 3.11: 20n3+10nlogn+5isO(n3).
Justiﬁcation: 20n3+10nlogn+5≤35n3,forn≥1.
Example 3.12: 3logn+2isO(logn).
Justiﬁcation: 3logn+2≤5logn, for n≥2. Note that logn is zero for n=1.
Thatiswhyweusen≥n =2inthiscase.
0
Example 3.13: 2n+2isO(2n).
Justiﬁcation: 2n+2=2n·22=4·2n;hence,wecantakec=4andn =1inthis
0
case.
Example 3.14: 2n+100lognisO(n).
Justiﬁcation: 2n+100logn≤102n,forn≥n =1;hence,wecantakec=102
0
inthiscase.
Characterizing Functions in Simplest Terms
Ingeneral, weshould use thebig-Ohnotation tocharacterize afunction asclosely
as possible. While it is true that the function f(n)=4n3+3n2 is O(n5) or even
O(n4), itis more accurate to say that f(n) is O(n3). Consider, by wayof analogy,
ascenariowhereahungrytravelerdrivingalongalongcountryroadhappensupon
a local farmer walking home from a market. If the traveler asks the farmer how
muchlonger hemustdrivebeforehecanﬁndsomefood, itmaybetruthful forthe
farmer to say, “certainly no longer than 12 hours,” but it is much more accurate
(andhelpful)forhimtosay,“youcanﬁndamarketjustafewminutesdriveupthis
road.” Thus, even with the big-Oh notation, we should striveas much as possible
totellthewholetruth.
Itisalsoconsideredpoortastetoincludeconstantfactorsandlower-orderterms
in the big-Oh notation. For example, it is not fashionable to say that the function
2n2 is O(4n2+6nlogn), although this is completely correct. We should strive3.3. AsymptoticAnalysis 127
Theseven functions listed in Section 3.2 are the most commonfunctions used
inconjunctionwiththebig-Ohnotationtocharacterizetherunningtimesandspace
usageofalgorithms. Indeed, wetypically usethenamesofthesefunctions torefer
totherunningtimesofthealgorithmstheycharacterize. So,forexample,wewould
saythatanalgorithm that runsinworst-case time4n2+nlognisaquadratic-time
algorithm, since it runs in O(n2) time. Likewise, an algorithm running in time at
most5n+20logn+4wouldbecalledalinear-timealgorithm.
Big-Omega
Justasthebig-Ohnotation providesanasymptotic wayofsayingthatafunctionis
“lessthanorequalto”anotherfunction, thefollowingnotationsprovideanasymp-
toticwayofsaying thatafunction growsataratethatis“greater thanorequal to”
thatofanother.
Let f(n)andg(n)befunctions mappingpositive integers topositiverealnum-
bers. Wesaythat f(n)isΩ(g(n)),pronounced“f(n)isbig-Omegaofg(n),”ifg(n)
isO(f(n)),thatis,thereisarealconstantc>0andanintegerconstantn ≥1such
0
that
f(n)≥cg(n), for n≥n .
0
This deﬁnition allows us to say asymptotically that one function is greater than or
equaltoanother, uptoaconstantfactor.
Example 3.15: 3nlogn−2nisΩ(nlogn).
Justiﬁcation: 3nlogn−2n=nlogn+2n(logn−1)≥nlogn for n≥2; hence,
wecantakec=1andn =2inthiscase.
0
Big-Theta
In addition, there is a notation that allows us to say that twofunctions grow at the
same rate, up to constant factors. We say that f(n) is Θ(g(n)), pronounced “f(n)
isbig-Thetaofg(n),”if f(n)isO(g(n))and f(n)isΩ(g(n)),thatis,therearereal
constantsc(cid:2)>0andc(cid:2)(cid:2)>0,andanintegerconstantn ≥1suchthat
0
c(cid:2)g(n)≤ f(n)≤c(cid:2)(cid:2)g(n), for n≥n .
0
Example 3.16: 3nlogn+4n+5lognisΘ(nlogn).128 Chapter3. AlgorithmAnalysis
3.3.2 Comparative Analysis
Suppose two algorithms solving the same problem are available: an algorithm A,
which has a running time of O(n), and an algorithm B, which has a running time
ofO(n2). Whichalgorithm isbetter? WeknowthatnisO(n2),whichimplies that
algorithm A is asymptotically better than algorithm B, although for a small value
ofn,BmayhavealowerrunningtimethanA.
We can use the big-Oh notation to order classes of functions by asymptotic
growth rate. Our seven functions are ordered by increasing growth rate in the fol-
lowingsequence,thatis,ifafunction f(n)precedesafunctiong(n)inthesequence,
then f(n)isO(g(n)):
1, logn, n, nlogn, n2, n3, 2n.
We illustrate the growth rates of the seven functions in Table 3.2. (See also
Figure3.4fromSection3.2.1.)
n logn n nlogn n2 n3 2n
8 3 8 24 64 512 256
16 4 16 64 256 4,096 65,536
32 5 32 160 1,024 32,768 4,294,967,296
64 6 64 384 4,096 262,144 1.84×1019
128 7 128 896 16,384 2,097,152 3.40×1038
256 8 256 2,048 65,536 16,777,216 1.15×1077
512 9 512 4,608 262,144 134,217,728 1.34×10154
Table3.2: Selectedvaluesoffundamental functions inalgorithm analysis.
We further illustrate the importance of the asymptotic viewpoint in Table 3.3.
This table explores the maximum size allowed for an input instance that is pro-
cessed byanalgorithm in1second, 1minute, and1hour. Itshowstheimportance
of good algorithm design, because an asymptotically slow algorithm is beaten in
the long run by an asymptotically faster algorithm, even if the constant factor for
theasymptotically fasteralgorithm isworse.
Running MaximumProblemSize(n)
Time(μs) 1second 1minute 1hour
400n 2,500 150,000 9,000,000
2n2 707 5,477 42,426
2n 19 25 31
Table 3.3: Maximum size of a problem that can be solved in 1 second, 1 minute,3.3. AsymptoticAnalysis 129
Theimportance ofgoodalgorithm designgoesbeyondjustwhatcanbesolved
effectively on a given computer, however. As shown in Table 3.4, even if we
achieve a dramatic speedup in hardware, we still cannot overcome the handicap
ofanasymptotically slowalgorithm. Thistableshowsthenewmaximumproblem
size achievable for any ﬁxed amount of time, assuming algorithms with the given
running timesarenowrunonacomputer256timesfasterthantheprevious one.
RunningTime NewMaximumProblemSize
400n 256m
2n2 16m
2n m+8
Table3.4: Increase inthemaximum sizeofaproblem thatcanbesolved inaﬁxed
amountoftime,byusingacomputerthatis256timesfasterthanthepreviousone.
Eachentryisafunction ofm,thepreviousmaximumproblemsize.
Some Words of Caution
A few words of caution about asymptotic notation are in orderat this point. First,
note that the use of the big-Oh and related notations can be somewhat misleading
should theconstant factors they“hide” bevery large. Forexample, whileitistrue
that the function 10100n is O(n), if this is the running time of an algorithm being
compared toonewhose running timeis10nlogn, weshould prefer theO(nlogn)-
timealgorithm,eventhoughthelinear-timealgorithmisasymptoticallyfaster. This
preference is because the constant factor, 10100, which is called “one googol,” is
believed by many astronomers to be an upper bound on the number of atoms in
theobservable universe. Soweareunlikely toeverhaveareal-world problem that
has this number as its input size. Thus, even when using the big-Oh notation, we
should atleastbesomewhat mindful oftheconstant factors and lower-order terms
weare“hiding.”
The observation above raises the issue of what constitutes a“fast” algorithm.
Generally speaking, any algorithm running in O(nlogn) time (with a reasonable
constant factor) should be considered efﬁcient. Even anO(n2)-time function may
befastenoughinsomecontexts, thatis,whennissmall. Butanalgorithmrunning
inO(2n)timeshouldalmostneverbeconsidered efﬁcient.
Exponential Running Times
Thereisafamousstoryabouttheinventorofthegameofchess. Heaskedonlythat
his king pay him 1 grain of rice for the ﬁrst square on the board, 2 grains for the
second, 4grains forthethird, 8forthefourth, andsoon. Itisaninteresting testof
programming skillstowriteaprogram tocomputeexactlythenumberofgrainsof130 Chapter3. AlgorithmAnalysis
If we must draw a line between efﬁcient and inefﬁcient algorithms, therefore,
it is natural to make this distinction be that between those algorithms running in
polynomial time and those running inexponential time. Thatis, make the distinc-
tionbetweenalgorithmswitharunningtimethatisO(nc),forsomeconstantc>1,
andthosewitharunningtimethatisO(bn),forsomeconstantb>1. Likesomany
notions wehavediscussed inthissection, thistooshould betakenwitha“grainof
salt,” for an algorithm running inO(n100) time should probably not be considered
“efﬁcient.” Evenso,thedistinctionbetweenpolynomial-timeandexponential-time
algorithms isconsidered arobustmeasureoftractability.
3.3.3 Examples of Algorithm Analysis
Nowthatwehavethebig-Ohnotationfordoingalgorithmanalysis,letusgivesome
examples by characterizing the running timeofsome simple algorithms using this
notation. Moreover, in keeping with our earlier promise, weillustrate below how
eachofthesevenfunctions givenearlierinthischaptercanbeusedtocharacterize
therunningtimeofanexamplealgorithm.
Rather than use pseudo-code in this section, we give complete Python imple-
mentations for our examples. Weuse Python’slistclass as the natural representa-
tionforan“array”ofvalues. InChapter5,wewillfullyexploretheunderpinnings
ofPython’slistclass,andtheefﬁciencyofthevariousbehaviorsthatitsupports. In
this section, we rely on just a few of its behaviors, discussing their efﬁciencies as
introduced.
Constant-Time Operations
Given an instance, named data, of the Python list class, a call to the function,
len(data), is evaluated in constant time. This is a very simple algorithm because
the list class maintains, for each list, an instance variable that records the current
length of thelist. Thisallows itto immediately report thatlength, rather than take
timetoiterativelycounteachoftheelementsinthelist. Usingasymptoticnotation,
wesaythatthisfunctionrunsinO(1)time;thatis,therunningtimeofthisfunction
isindependent ofthelength,n,ofthelist.
AnothercentralbehaviorofPython’slistclassisthatitallowsaccesstoanarbi-
traryelementofthelistusingsyntax,data[j],forintegerindexj. BecausePython’s
listsareimplemented asarray-based sequences,references toalist’selementsare
stored inaconsecutive block ofmemory. The jth element ofthelist canbefound,
not by iterating through the list one element atatime, but byvalidating the index,
andusingitasanoffsetintotheunderlying array. Inturn,computer hardwaresup-
ports constant-time access toan element based on its memoryaddress. Therefore,3.3. AsymptoticAnalysis 131
Revisiting the Problem of Finding the Maximum of a Sequence
For our next example, we revisit the ﬁnd max algorithm, given in Code Frag-
ment 3.1 on page 123, for ﬁnding the largest value in a sequence. Proposition 3.7
onpage125claimedanO(n)run-timefortheﬁnd maxalgorithm. Consistentwith
our earlier analysis of syntax data[0], the initialization uses O(1) time. The loop
executesntimes, andwithineach iteration, itperforms onecomparison andpossi-
blyoneassignmentstatement(aswellasmaintenanceoftheloopvariable). Finally,
we note that the mechanism for enacting areturn statement in Python uses O(1)
time. Combiningthesesteps,wehavethattheﬁnd maxfunctionrunsinO(n)time.
Further Analysis of the Maximum-Finding Algorithm
A more interesting question about ﬁnd max is how many times we might update
thecurrent“biggest”value. Intheworstcase,ifthedataisgiventousinincreasing
order, the biggest value is reassigned n−1 times. But what if the input is given
to us in random order, with all orders equally likely; what would be the expected
numberoftimesweupdatethebiggestvalueinthiscase? Toanswerthisquestion,
notethatweupdatethecurrentbiggestinaniterationofthelooponlyifthecurrent
element is bigger than all the elements that precede it. If the sequence is given to
us in random order, the probability that the jth element is the largest of the ﬁrst j
elements is 1/j (assuming uniqueness). Hence, the expected number of timeswe
update the biggest (including initialization) is H =∑n 1/j, which is known as
n j=1
the nth Harmonic number. It turns out (see Proposition B.16)that H isO(logn).
n
Therefore, theexpected numberoftimesthebiggest value isupdated byﬁnd max
onarandomlyorderedsequence isO(logn).
Preﬁx Averages
The next problem we consider is computing what are known as preﬁx averages
of a sequence of numbers. Namely, given a sequence S consisting of n num-
bers, we want to compute a sequence A such that A[j] is the average of elements
S[0],...,S[j],for j=0,...,n−1,thatis,
∑j S[i]
A[j]= i=0 .
j+1
Computing preﬁx averages hasmanyapplications ineconomics andstatistics. For
example, given the year-by-year returns of a mutual fund, ordered from recent to
past,aninvestorwilltypicallywanttoseethefund’saverageannualreturnsforthe
mostrecentyear,themostrecentthreeyears,themostrecentﬁveyears,andsoon.
Likewise, given a stream of daily Web usage logs, a Web site manager may wish
totrackaverageusagetrendsovervarioustimeperiods. Weanalyzethreedifferent132 Chapter3. AlgorithmAnalysis
A Quadratic-Time Algorithm
Ourﬁrstalgorithmforcomputingpreﬁxaverages,namedpreﬁx average1,isshown
in Code Fragment 3.2. It computes every element of A separately, using an inner
looptocomputethepartialsum.
1 def preﬁx average1(S):
2 ”””Return list such that, for all j, A[j] equals average of S[0], ..., S[j].”””
3 n = len(S)
4 A = [0] n # create new list of n zeros
5 for j in range(n):
6 total = 0 # begin computing S[0] + ... + S[j]
7 for i in range(j + 1):
8 total += S[i]
9 A[j] = total / (j+1) # record the average
10 return A
CodeFragment3.2: Algorithmpreﬁx average1.
In order to analyze the preﬁx average1 algorithm, we consider the various steps
thatareexecuted.
• The statement, n = len(S), executes in constant time, as described at the
beginning ofSection3.3.3.
• Thestatement,A = [0] n,causesthecreationandinitializationofaPython
list with length n, and with all entries equal to zero. This uses a constant
numberofprimitiveoperations perelement,andthusrunsinO(n)time.
• There are twonested forloops, which are controlled, respectively, by coun-
ters j and i. The body of the outer loop, controlled by counter j, is ex-
ecuted n times, for j = 0,...,n−1. Therefore, statements total = 0 and
A[j] = total / (j+1)are executed ntimes each. This implies that these two
statements,plusthemanagementofcounter jintherange,contributeanum-
berofprimitiveoperations proportional ton,thatis,O(n)time.
• Thebodyoftheinnerloop,whichiscontrolledbycounteri,isexecuted j+1
times,dependingonthecurrentvalueoftheouterloopcounter j. Thus,state-
ment total += S[i], in the inner loop, is executed 1+2+3+···+n times.
Byrecalling Proposition 3.3,weknowthat1+2+3+···+n=n(n+1)/2,
which implies that the statement in the inner loop contributes O(n2) time.
Asimilarargument canbedone fortheprimitive operations associated with
maintaining counteri,whichalsotakeO(n2)time.
The running time of implementation preﬁx average1 is given by the sum of three
terms. The ﬁrst and the second terms are O(n), and the third term is O(n2). By a3.3. AsymptoticAnalysis 133
Oursecond implementation forcomputing preﬁxaverages,preﬁx average2,is
presented inCodeFragment3.3.
1 def preﬁx average2(S):
2 ”””Return list such that, for all j, A[j] equals average of S[0], ..., S[j].”””
3 n = len(S)
4 A = [0] n # create new list of n zeros
5 for j in range(n):
6 A[j] = sum(S[0:j+1]) / (j+1) # record the average
7 return A
CodeFragment3.3: Algorithmpreﬁx average2.
This approach is essentially the same high-level algorithm as in preﬁx average1,
but we have replaced the inner loop by using the single expression sum(S[0:j+1])
tocomputethepartialsum,S[0]+···+S[j]. Whiletheuseofthatfunction greatly
simpliﬁes the presentation of the algorithm, it is worth asking how it affects the
efﬁciency. Asymptotically, this implementation is no better. Even though the ex-
pression, sum(S[0:j+1]), seems like a single command, it is a function call and
an evaluation of that function takesO(j+1)time in this context. Technically, the
computation of the slice, S[0:j+1], also uses O(j+1) time, as it constructs a new
list instance for storage. Sothe running time ofpreﬁx average2is still dominated
byaseriesofstepsthattaketimeproportionalto1+2+3+···+n,andthusO(n2).
A Linear-Time Algorithm
Ourﬁnalalgorithm, preﬁx averages3, isgiven inCodeFragment3.4. Just aswith
ourﬁrsttwoalgorithms, weareinterested incomputing, foreach j,thepreﬁxsum
S[0]+S[1]+···+S[j], denoted as total in our code, so that we can then compute
the preﬁx average A[j] =total / (j + 1). However, there is a key difference that
resultsinmuchgreaterefﬁciency.
1 def preﬁx average3(S):
2 ”””Return list such that, for all j, A[j] equals average of S[0], ..., S[j].”””
3 n = len(S)
4 A = [0] n # create new list of n zeros
5 total = 0 # compute preﬁx sum as S[0] + S[1] + ...
6 for j in range(n):
7 total += S[j] # update preﬁx sum to include S[j]
8 A[j] = total / (j+1) # compute average based on current sum
9 return A134 Chapter3. AlgorithmAnalysis
Inourﬁrsttwoalgorithms,thepreﬁxsumiscomputedanewforeachvalueof j.
That contributed O(j) time for each j, leading to the quadratic behavior. In algo-
rithmpreﬁx average3,wemaintainthecurrentpreﬁxsumdynamically, effectively
computing S[0]+S[1]+···+S[j]astotal + S[j],wherevaluetotalisequaltothe
sum S[0]+S[1]+···+S[j−1] computed by the previous pass of the loop over j.
Theanalysis oftherunning timeofalgorithmpreﬁx average3follows:
• Initializing variablesnandtotalusesO(1)time.
• Initializing thelistAusesO(n)time.
• Thereisasingleforloop,whichiscontrolledbycounter j. Themaintenance
ofthatcounterbytherangeiteratorcontributes atotalofO(n)time.
• The body of the loop is executed n times, for j=0,...,n−1. Thus, state-
ments total += S[j] and A[j] = total / (j+1) are executed n times each.
Since each of these statements uses O(1) time per iteration, their overall
contribution isO(n)time.
The running time of algorithm preﬁx average3 is given by the sum of the four
terms. TheﬁrstisO(1)andtheremaining three areO(n). Byasimpleapplication
of Proposition 3.9, the running time of preﬁx average3 is O(n), which is much
betterthanthequadratic timeofalgorithmspreﬁx average1andpreﬁx average2.
Three-Way Set Disjointness
Suppose we are given three sequences of numbers, A, B, andC. We will assume
that no individual sequence contains duplicate values, butthat there may be some
numbers that are in two or three of the sequences. Thethree-way set disjointness
problemistodetermineiftheintersection ofthethreesequences isempty,namely,
that there is no element x such that x ∈ A, x ∈ B, and x ∈C. A simple Python
function todeterminethispropertyisgiveninCodeFragment3.5.
1 def disjoint1(A, B, C):
2 ”””Return True if there is no element common to all three lists.”””
3 for a in A:
4 for b in B:
5 for c in C:
6 if a == b == c:
7 return False # we found a common value
8 return True # if we reach this, sets are disjoint
CodeFragment3.5: Algorithmdisjoint1fortesting three-waysetdisjointness.
This simple algorithm loops through each possible triple of values from the
three sets tosee if those values are equivalent. If each of the original sets has size3.3. AsymptoticAnalysis 135
We can improve upon the asymptotic performance with a simpleobservation.
OnceinsidethebodyoftheloopoverB,ifselected elementsaandbdonotmatch
each other, it is a waste of time to iterate through all values of C looking for a
matching triple. An improved solution to this problem, taking advantage of this
observation, ispresented inCodeFragment3.6.
1 def disjoint2(A, B, C):
2 ”””Return True if there is no element common to all three lists.”””
3 for a in A:
4 for b in B:
5 if a == b: # only check C if we found match from A and B
6 for c in C:
7 if a == c # (and thus a == b == c)
8 return False # we found a common value
9 return True # if we reach this, sets are disjoint
CodeFragment3.6: Algorithmdisjoint2fortesting three-waysetdisjointness.
Intheimprovedversion, itisnotsimplythat wesavetimeifwegetlucky. We
claim that the worst-case running time for disjoint2 is O(n2). There are quadrat-
ically many pairs (a,b) to consider. However, if A and B are each sets of distinct
elements, there can be at most O(n) such pairs with a equal to b. Therefore, the
innermostloop,overC,executesatmostntimes.
To account for the overall running time, we examine the time spent executing
each line of code. The management of the for loop over A requires O(n) time.
The management of the for loop over B accounts for a total of O(n2) time, since
that loop is executed n different times. The testa == b is evaluated O(n2)times.
Therestofthetimespent depends upon howmanymatching(a,b) pairsexist. As
we have noted, there are at most n such pairs, and so the management of the loop
overC, and the commands within the body of that loop, use at most O(n2) time.
Byourstandardapplication ofProposition 3.9,thetotaltimespentisO(n2).
Element Uniqueness
A problem that is closely related to the three-way set disjointness problem is the
elementuniquenessproblem. Intheformer,wearegiventhreecollections andwe
presumed that there were no duplicates within a single collection. In the element
uniqueness problem, we are given a single sequence S with n elements and asked
whetherallelementsofthatcollection aredistinctfromeachother.
Our ﬁrst solution to this problem uses a straightforward iterative algorithm.
Theunique1function, given inCodeFragment3.7, solvestheelement uniqueness136 Chapter3. AlgorithmAnalysis
1 def unique1(S):
2 ”””Return True if there are no duplicate elements in sequence S.”””
3 for j in range(len(S)):
4 for k in range(j+1, len(S)):
5 if S[j] == S[k]:
6 return False # found duplicate pair
7 return True # if we reach this, elements were unique
CodeFragment3.7: Algorithmunique1fortestingelementuniqueness.
thosepairsrefertoelementsthatareequivalenttoeachother. Itdoesthisusingtwo
nestedforloops,suchthattheﬁrstiterationoftheouterloopcausesn−1iterations
of the inner loop, the second iteration of the outer loop causes n−2 iterations of
the inner loop, and so on. Thus, the worst-case running time of this function is
proportional to
(n−1)+(n−2)+···+2+1,
whichwerecognize asthefamiliarO(n2)summationfromProposition 3.3.
Using Sorting as a Problem-Solving Tool
An even better algorithm for the element uniqueness problem is based on using
sortingasaproblem-solving tool. Inthiscase,bysortingthesequenceofelements,
we are guaranteed that any duplicate elements will be placed next to each other.
Thus, to determine if there are any duplicates, all we need todo is perform a sin-
gle pass over the sorted sequence, looking for consecutive duplicates. A Python
implementation ofthisalgorithm isasfollows:
1 def unique2(S):
2 ”””Return True if there are no duplicate elements in sequence S.”””
3 temp = sorted(S) # create a sorted copy of S
4 for j in range(1, len(temp)):
5 if S[j−1] == S[j]:
6 return False # found duplicate pair
7 return True # if we reach this, elements were unique
CodeFragment3.8: Algorithmunique2fortestingelementuniqueness.
Thebuilt-in function, sorted,asdescribed inSection1.5.2, produces acopyof
the original list with elements in sorted order. It guarantees a worst-case running
timeof O(nlogn); seeChapter 12for adiscussion ofcommon sorting algorithms.
Once the data is sorted, the subsequent loop runs in O(n) time, and so the entire3.4. SimpleJustiﬁcationTechniques 137
3.4 Simple Justiﬁcation Techniques
Sometimes,wewillwanttomakeclaimsaboutanalgorithm, suchasshowingthat
it is correct or that it runs fast. In order to rigorously makesuch claims, we must
usemathematicallanguage,andinordertobackupsuchclaims,wemustjustifyor
proveourstatements. Fortunately, thereareseveralsimplewaystodothis.
3.4.1 By Example
Some claims are of the generic form, “There is an element x in a set S that has
property P.” To justify such a claim, we only need to produce a particular x in S
thathaspropertyP. Likewise,somehard-to-believeclaimsareofthegenericform,
“EveryelementxinasetShaspropertyP.” Tojustifythatsuchaclaimisfalse,we
only need to produce aparticular x from S that does not have property P. Such an
instance iscalledacounterexample.
Example 3.17: ProfessorAmongusclaimsthateverynumberoftheform2i−1
isaprime,wheniisanintegergreaterthan1.ProfessorAmongusiswrong.
Justiﬁcation: ToproveProfessorAmongusiswrong,weﬁndacounterexample.
Fortunately, weneednotlooktoofar,for24−1=15=3·5.
3.4.2 The “Contra” Attack
Another set of justiﬁcation techniques involves the use of the negative. The two
primarysuchmethodsaretheuseofthecontrapositiveandthecontradiction. The
use of the contrapositive method is like looking through a negative mirror. To
justify thestatement “if pistrue, thenqistrue,” weestablish that“ifqisnottrue,
then p is not true” instead. Logically, these two statements are the same, but the
latter, whichiscalledthecontrapositiveoftheﬁrst,maybeeasiertothinkabout.
Example 3.18: Letaandbbeintegers.Ifabiseven,thenaisevenorbiseven.
Justiﬁcation: Tojustify thisclaim, consider thecontrapositive, “Ifaisoddand
bisodd,thenabisodd.” So,supposea=2j+1andb=2k+1,forsomeintegers
jandk. Thenab=4jk+2j+2k+1=2(2jk+ j+k)+1;hence,abisodd.
Besidesshowingauseofthecontrapositivejustiﬁcationtechnique,theprevious
example also contains an application ofDeMorgan’s Law. This law helps us deal
withnegations, foritstates thatthe negation ofastatement oftheform “porq”is
“not p and not q.” Likewise, it states that the negation of a statement of theform138 Chapter3. AlgorithmAnalysis
Contradiction
Another negative justiﬁcation technique is justiﬁcation by contradiction, which
also often involves using DeMorgan’s Law. In applying the justiﬁcation by con-
tradiction technique, we establish that a statement q is true by ﬁrst supposing that
q is false and then showing that this assumption leads to a contradiction (such as
2(cid:15)=2or1>3). Byreaching such acontradiction, weshow that noconsistent sit-
uationexistswithqbeingfalse, soqmustbetrue. Ofcourse, inordertoreachthis
conclusion, wemustbesureoursituationisconsistentbeforeweassumeqisfalse.
Example 3.19: Letaandbbeintegers.Ifabisodd,thenaisoddandbisodd.
Justiﬁcation: Let ab be odd. We wish to show that a is odd and b is odd. So,
with the hope of leading to a contradiction, let us assume the opposite, namely,
suppose a is even or b is even. In fact, without loss of generality, we can assume
that a is even (since the case for b is symmetric). Then a=2j for some integer
j. Hence, ab=(2j)b=2(jb), that is, ab is even. But this is a contradiction: ab
cannotsimultaneously beoddandeven. Therefore,aisoddandbisodd.
3.4.3 Induction and Loop Invariants
Mostoftheclaimswemakeaboutarunningtimeoraspaceboundinvolveaninte-
gerparametern(usually denotinganintuitivenotionofthe“size”oftheproblem).
Moreover,mostoftheseclaimsareequivalenttosayingsomestatementq(n)istrue
“for all n≥1.” Since this is making a claim about an inﬁnite set of numbers, we
cannotjustifythisexhaustively inadirectfashion.
Induction
We can often justify claims such as those above as true, however, by using the
techniqueofinduction. Thistechniqueamountstoshowingthat,foranyparticular
n≥1, there is a ﬁnite sequence of implications that starts withsomething known
tobetrueandultimatelyleadstoshowingthatq(n)istrue. Speciﬁcally,webegina
justiﬁcationbyinductionbyshowingthatq(n)istrueforn=1(andpossiblysome
othervaluesn=2,3,...,k,forsomeconstantk). Thenwejustifythattheinductive
“step” istrueforn>k,namely, weshow “ifq(j)istrueforall j<n,then q(n)is3.4. SimpleJustiﬁcationTechniques 139
Proposition 3.20: ConsidertheFibonaccifunctionF(n),whichisdeﬁnedsuch
thatF(1) =1,F(2) = 2,andF(n) = F(n−2)+F(n−1) forn > 2. (SeeSec-
tion1.8.)WeclaimthatF(n)<2n.
Justiﬁcation: Wewillshowourclaimiscorrectbyinduction.
Basecases: (n≤2). F(1)=1<2=21 andF(2)=2<4=22.
Induction step: (n>2). Suppose our claim is true for all n(cid:2) <n. Consider F(n).
Sincen>2,F(n)=F(n−2)+F(n−1). Moreover,sincebothn−2andn−1are
lessthann,wecanapplytheinductiveassumption(sometimescalledthe“inductive
hypothesis”) toimplythatF(n)<2n−2+2n−1,since
2n−2+2n−1<2n−1+2n−1=2·2n−1=2n.
Letusdoanother inductiveargument, thistimeforafactwehaveseenbefore.
Proposition 3.21: (whichisthesameasProposition3.3)
∑n i= n(n+1).
2
i=1
Justiﬁcation: Wewilljustifythisequality byinduction.
Basecase: n=1. Trivial,for1=n(n+1)/2,ifn=1.
Inductionstep: n≥2. Assumetheclaimistrueforn(cid:2)<n. Considern.
n n−1
∑i=n+ ∑i.
i=1 i=1
Bytheinduction hypothesis, then
∑n i=n+(n−1)n,
2
i=1
whichwecansimplifyas
(n−1)n 2n+n2−n n2+n n(n+1)
n+ = = = .
2 2 2 2
Wemaysometimes feel overwhelmed by the task of justifying something true
foralln≥1. Weshouldremember,however,theconcretenessoftheinductivetech-
nique. Itshows that, for anyparticular n, there is aﬁnite step-by-step sequence of
implications thatstartswithsomethingtrueandleadstothetruthaboutn. Inshort,140 Chapter3. AlgorithmAnalysis
Loop Invariants
Theﬁnaljustiﬁcationtechnique wediscussinthissectionistheloopinvariant. To
prove some statement L about a loop is correct, deﬁne L in terms of a series of
smallerstatementsL ,L ,...,L ,where:
0 1 k
1. Theinitialclaim,L ,istruebeforetheloopbegins.
0
2. IfLj−1 istruebeforeiteration j,thenL j willbetrueafteriteration j.
3. Theﬁnalstatement,L ,impliesthedesiredstatementLtobetrue.
k
Let us give a simple example of using a loop-invariant argument to justify the
correctness of an algorithm. In particular, we use a loop invariant to justify that
the function, ﬁnd (see Code Fragment 3.9), ﬁnds the smallest index at which ele-
mentvaloccursinsequenceS.
1 def ﬁnd(S, val):
2 ”””Return index j such that S[j] == val, or -1 if no such element.”””
3 n = len(S)
4 j = 0
5 while j < n:
6 if S[j] == val:
7 return j # a match was found at index j
8 j += 1
9 return −1
CodeFragment3.9: Algorithm for ﬁnding the ﬁrstindex atwhich agiven element
occursinaPythonlist.
To show that ﬁnd is correct, we inductively deﬁne a series of statements, L ,
j
that lead to the correctness of our algorithm. Speciﬁcally, we claim the following
istrueatthebeginning ofiteration jofthewhileloop:
L : val isnotequaltoanyoftheﬁrst jelementsofS.
j
This claim is true at the beginning of the ﬁrst iteration of the loop, because j is 0
and there are no elements among the ﬁrst 0 inS (this kind of atrivially true claim
is said to hold vacuously). In iteration j, we compare element val to element S[j]
andreturntheindex jifthesetwoelementsareequivalent, whichisclearlycorrect
and completes the algorithm in this case. If the two elements val and S[j] are not
equal, then we have found one more element not equal to val and we increment
the index j. Thus, the claim L will be true for this new value of j; hence, it is
j
true at the beginning of the next iteration. If the while loop terminates without
ever returning anindex inS, then wehave j=n. Thatis, L istrue—there are no
n
elementsofSequaltoval. Therefore,thealgorithmcorrectlyreturns−1toindicate3.5. Exercises 141
3.5 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-3.1 Graphthefunctions 8n,4nlogn,2n2,n3,and2n usingalogarithmicscale
for the x- and y-axes; that is, if the function value f(n) isy, plot this as a
pointwithx-coordinate atlognandy-coordinate atlogy.
R-3.2 Thenumber ofoperations executed byalgorithmsAandBis8nlognand
2n2,respectively. Determinen suchthatAisbetterthanBforn≥n .
0 0
R-3.3 The number of operations executed by algorithms A and B is 40n2 and
2n3,respectively. Determinen suchthatAisbetterthanBforn≥n .
0 0
R-3.4 Give an example of a function that is plotted the same on a log-log scale
asitisonastandard scale.
R-3.5 Explainwhytheplotofthefunctionnc isastraight linewithslopecona
log-logscale.
R-3.6 What is the sum of all the even numbers from 0 to 2n, for any positive
integern?
R-3.7 Showthatthefollowingtwostatementsareequivalent:
(a)TherunningtimeofalgorithmAisalwaysO(f(n)).
(b)Intheworstcase,therunningtimeofalgorithmAisO(f(n)).
R-3.8 Orderthefollowingfunctions byasymptotic growthrate.
4nlogn+2n 210 2logn
3n+100logn 4n 2n
n2+10n n3 nlogn
R-3.9 Show that if d(n) is O(f(n)), then ad(n) is O(f(n)), for any constant
a>0.
R-3.10 Showthatifd(n)isO(f(n))ande(n)isO(g(n)),thentheproductd(n)e(n)
isO(f(n)g(n)).
R-3.11 Show that if d(n) is O(f(n)) and e(n) is O(g(n)), t hend(n)+e(n) is
O(f(n)+g(n)).
R-3.12 Showthatifd(n)isO(f(n))and e(n)isO(g(n)), thend(n)−e(n) isnot
necessarilyO(f(n)−g(n)).
R-3.13 Showthatifd(n)isO(f(n))and f(n)isO(g(n)),thend(n)isO(g(n)).142 Chapter3. AlgorithmAnalysis
R-3.15 Showthat f(n)isO(g(n))ifandonlyifg(n)isΩ(f(n)).
R-3.16 Showthatif p(n)isapolynomial inn,thenlogp(n)isO(logn).
R-3.17 Showthat(n+1)5 isO(n5).
R-3.18 Showthat2n+1 isO(2n).
R-3.19 ShowthatnisO(nlogn).
R-3.20 Showthatn2 isΩ(nlogn).
R-3.21 ShowthatnlognisΩ(n).
R-3.22 Showthat(cid:13)f(n)(cid:14)isO(f(n)),if f(n)isapositivenondecreasing function
thatisalwaysgreaterthan1.
R-3.23 Give a big-Oh characterization, in terms of n, of the running time of the
example1functionshowninCodeFragment3.10.
R-3.24 Give a big-Oh characterization, in terms of n, of the running time of the
example2functionshowninCodeFragment3.10.
R-3.25 Give a big-Oh characterization, in terms of n, of the running time of the
example3functionshowninCodeFragment3.10.
R-3.26 Give a big-Oh characterization, in terms of n, of the running time of the
example4functionshowninCodeFragment3.10.
R-3.27 Give a big-Oh characterization, in terms of n, of the running time of the
example5functionshowninCodeFragment3.10.
R-3.28 For each function f(n) and time t in the following table, determine the
largest sizen ofa problem Pthat can besolved in timet ifthe algorithm
forsolvingPtakes f(n)microseconds (oneentryisalreadycompleted).
1Second 1Hour 1Month 1Century
logn ≈10300000
n
nlogn
n2
2n
R-3.29 Algorithm A executes an O(logn)-time computation for each entry of an
n-elementsequence. Whatisitsworst-case runningtime?
R-3.30 Given an n-element sequence S, Algorithm B chooses logn elements in
S at random and executes anO(n)-time calculation for each. What is the
worst-case runningtimeofAlgorithm B?
R-3.31 Given an n-element sequence S of integers, Algorithm C executes an
O(n)-time computation for each even number inS, and an O(logn)-time
computation foreachoddnumberinS. Whatarethebest-caseandworst-3.5. Exercises 143
1 def example1(S):
2 ”””Return the sum of the elements in sequence S.”””
3 n = len(S)
4 total = 0
5 for j in range(n): # loop from 0 to n-1
6 total += S[j]
7 return total
8
9 def example2(S):
10 ”””Return the sum of the elements with even index in sequence S.”””
11 n = len(S)
12 total = 0
13 for j in range(0, n, 2): # note the increment of 2
14 total += S[j]
15 return total
16
17 def example3(S):
18 ”””Return the sum of the preﬁx sums of sequence S.”””
19 n = len(S)
20 total = 0
21 for j in range(n): # loop from 0 to n-1
22 for k in range(1+j): # loop from 0 to j
23 total += S[k]
24 return total
25
26 def example4(S):
27 ”””Return the sum of the preﬁx sums of sequence S.”””
28 n = len(S)
29 preﬁx = 0
30 total = 0
31 for j in range(n):
32 preﬁx += S[j]
33 total += preﬁx
34 return total
35
36 def example5(A, B): # assume that A and B have equal length
37 ”””Return the number of elements in B equal to the sum of preﬁx sums in A.”””
38 n = len(A)
39 count = 0
40 for i in range(n): # loop from 0 to n-1
41 total = 0
42 for j in range(n): # loop from 0 to n-1
43 for k in range(1+j): # loop from 0 to j
44 total += A[k]
45 if B[i] == total:
46 count += 1
47 return count144 Chapter3. AlgorithmAnalysis
R-3.32 Given an n-element sequence S, Algorithm D calls Algorithm E on each
element S[i]. Algorithm E runs inO(i) time when it is called on element
S[i]. Whatistheworst-caserunning timeofAlgorithmD?
R-3.33 Al and Bob are arguing about their algorithms. Al claims hisO(nlogn)-
timemethodisalwaysfasterthanBob’sO(n2)-timemethod. Tosettlethe
issue, theyperform asetofexperiments. ToAl’sdismay, theyﬁndthatif
n<100, the O(n2)-time algorithm runs faster, and only whenn≥100 is
theO(nlogn)-timeonebetter. Explainhowthisispossible.
R-3.34 There is a well-known city (which will go nameless here) whose inhabi-
tants have the reputation of enjoying a meal only if that mealis the best
they have ever experienced in their life. Otherwise, they hate it. Assum-
ing meal quality is distributed uniformly across a person’s life, describe
theexpected numberoftimesinhabitants ofthiscityarehappywiththeir
meals?
Creativity
C-3.35 Assuming it is possible to sortnnumbers inO(nlogn) time, show that it
is possible to solve the three-way set disjointness problem in O(nlogn)
time.
C-3.36 Describe an efﬁcient algorithm for ﬁnding the ten largest elements in a
sequence ofsizen. Whatistherunningtimeofyouralgorithm?
C-3.37 Giveanexampleofapositivefunction f(n)suchthat f(n)isneitherO(n)
norΩ(n).
C-3.38 Showthat∑n i2 isO(n3).
i=1
C-3.39 Showthat∑n i/2i<2. (Hint: Trytoboundthissumtermbytermwith
i=1
ageometricprogression.)
C-3.40 Showthatlog f(n)isΘ(log f(n))ifb>1isaconstant.
b
C-3.41 Describe an algorithm for ﬁnding both the minimum and maximum of n
numbers using fewer than 3n/2 comparisons. (Hint: First, construct a
groupofcandidate minimumsandagroupofcandidate maximums.)
C-3.42 Bob built a Web site and gave the URL only to his n friends, which he
numbered from 1 to n. He told friend number i that he/she can visit the
Websiteatmostitimes. NowBobhas acounter,C, keeping track ofthe
totalnumberofvisitstothesite(butnottheidentitiesofwhovisits). What
istheminimumvalueforCsuchthatBobcanknowthatoneofhisfriends
hasvisitedhis/hermaximumallowednumberoftimes?
C-3.43 Draw a visual justiﬁcation of Proposition 3.3 analogous to that of Fig-3.5. Exercises 145
C-3.44 Communication security is extremely important in computer networks,
and one way manynetwork protocols achieve security is to encrypt mes-
sages. Typicalcryptographicschemesforthesecuretransmissionofmes-
sagesoversuchnetworksarebasedonthefactthatnoefﬁcientalgorithms
areknownforfactoringlargeintegers. Hence,ifwecanrepresentasecret
message by a large prime number p, we can transmit, over the network,
thenumberr= p·q,whereq> pisanotherlargeprimenumberthatacts
astheencryption key. Aneavesdropper whoobtainsthetransmittednum-
berronthenetworkwouldhavetofactorrinordertoﬁgureoutthesecret
message p.
Using factoring to ﬁgure out amessage is very difﬁcult without knowing
the encryption key q. To understand why, consider the following naive
factoring algorithm:
for p in range(2,r):
if r % p == 0: # if p divides r
return The secret message is p!
a. Suppose that the eavesdropper uses the above algorithm and has a
computer that can carry out in 1 microsecond (1 millionth of asec-
ond)adivisionbetweentwointegersofupto100bitseach. Givean
estimateofthetimethatitwilltakeintheworstcasetodecipherthe
secretmessage pifthetransmittedmessagerhas100bits.
b. What is the worst-case time complexity of the above algorithm?
Since the input to the algorithm is just one large number r, assume
thattheinputsizenisthenumberofbytesneeded tostorer,thatis,
n=(cid:16)(log r)/8(cid:17)+1,andthateachdivision takestimeO(n).
2
C-3.45 A sequence S contains n−1 unique integers in the range [0,n−1], that
is, there is one number from this range that is not inS. Design an O(n)-
timealgorithm forﬁndingthatnumber. YouareonlyallowedtouseO(1)
additional spacebesidesthesequenceSitself.
C-3.46 Alsayshecanprovethatallsheepinaﬂockarethesamecolor:
Basecase: Onesheep. Itisclearlythesamecolorasitself.
Induction step: A ﬂock of n sheep. Take a sheep, a, out. The remaining
n−1 are all the same color by induction. Now put sheep a back in and
take out a different sheep, b. By induction, the n−1 sheep (now witha)
are all the same color. Therefore, all the sheep in the ﬂock are the same
color. WhatiswrongwithAl’s“justiﬁcation”?
C-3.47 Let S be a set of n lines in the plane such that no two are parallel and
no three meet in the same point. Show, by induction, that the lines in S146 Chapter3. AlgorithmAnalysis
C-3.48 Consider the following “justiﬁcation” that the Fibonacci function, F(n)
(seeProposition 3.20)isO(n):
Basecase(n≤2): F(1)=1andF(2)=2.
Inductionstep(n>2): Assumeclaimtrueforn(cid:2)<n. Considern. F(n)=
F(n−2)+F(n−1). Byinduction, F(n−2) is O(n−2) and F(n−1) is
O(n−1). Then,F(n)isO((n−2)+(n−1)), bytheidentity presentedin
ExerciseR-3.11. Therefore,F(n)isO(n).
Whatiswrongwiththis“justiﬁcation”?
C-3.49 Consider the Fibonacci function, F(n) (see Proposition 3.20). Show by
induction thatF(n)isΩ((3/2)n).
C-3.50 Let p(x)beapolynomial ofdegreen,thatis, p(x)=∑n axi.
i=0 i
(a)DescribeasimpleO(n2)-timealgorithm forcomputing p(x).
(b)DescribeanO(nlogn)-timealgorithmforcomputing p(x),basedupon
amoreefﬁcientcalculation ofxi.
(c)Nowconsider arewritingof p(x)as
p(x)=a0+x(a1+x(a2+x(a3+···+x(an−1+xan)···))),
which isknownasHorner’s method. Using thebig-Oh notation, charac-
terizethenumberofarithmetic operations thismethodexecutes.
C-3.51 Showthatthesummation∑n logiisO(nlogn).
i=1
C-3.52 Showthatthesummation∑n logiisΩ(nlogn).
i=1
C-3.53 An evil king has n bottles of wine, and a spy has just poisoned one of
them. Unfortunately, theydonotknowwhichoneitis. Thepoisonisvery
deadly; just one drop diluted even abillion toone willstillkill. Evenso,
it takes a full month for the poison to take effect. Design a scheme for
determining exactly which one of the wine bottles was poisoned in just
onemonth’stimewhileexpendingO(logn)tastetesters.
C-3.54 AsequenceScontainsnintegerstakenfromtheinterval[0,4n],withrepe-
titionsallowed. Describeanefﬁcientalgorithmfordetermininganinteger
value k that occurs the most often inS. What isthe running timeof your
algorithm?
Projects
P-3.55 Performanexperimentalanalysisofthethreealgorithmspreﬁx average1,
preﬁx average2,andpreﬁx average3,fromSection3.3.3. Visualizetheir
running timesasafunction oftheinputsizewithalog-logchart.
P-3.56 PerformanexperimentalanalysisthatcomparestherelativerunningtimesChapterNotes 147
P-3.57 Perform experimental analysis totest the hypothesis that Python’s sorted
methodrunsinO(nlogn)timeonaverage.
P-3.58 For each of the three algorithms, unique1, unique2, and unique3, which
solve the element uniqueness problem, perform an experimental analysis
to determine the largest value of n such that the given algorithm runs in
oneminuteorless.
Chapter Notes
The big-Oh notation has prompted several comments about its proper use [19, 49, 63].
Knuth[64,63]deﬁnesitusingthenotation f(n)=O(g(n)),butsaysthis“equality”isonly
“oneway.” Wehavechosentotakeamorestandardviewofequalityandviewthebig-Oh
notationasaset, followingBrassard[19]. Thereaderinterestedinstudyingaverage-case
analysisis referredto the bookchapterby Vitter andFlajolet[101]. Forsome additionalChapter
4
Recursion
Contents
4.1 Illustrative Examples . . . . . . . . . . . . . . . . . . . . . . 150
4.1.1 The Factorial Function . . . . . . . . . . . . . . . . . . . 150
4.1.2 Drawing an English Ruler . . . . . . . . . . . . . . . . . . 152
4.1.3 Binary Search . . . . . . . . . . . . . . . . . . . . . . . . 155
4.1.4 File Systems . . . . . . . . . . . . . . . . . . . . . . . . . 157
4.2 Analyzing Recursive Algorithms . . . . . . . . . . . . . . . 161
4.3 Recursion Run Amok . . . . . . . . . . . . . . . . . . . . . 165
4.3.1 Maximum Recursive Depth in Python . . . . . . . . . . . 168
4.4 Further Examples of Recursion . . . . . . . . . . . . . . . . 169
4.4.1 Linear Recursion . . . . . . . . . . . . . . . . . . . . . . . 169
4.4.2 Binary Recursion . . . . . . . . . . . . . . . . . . . . . . 174
4.4.3 Multiple Recursion . . . . . . . . . . . . . . . . . . . . . 175
4.5 Designing Recursive Algorithms . . . . . . . . . . . . . . . 177
4.6 Eliminating Tail Recursion . . . . . . . . . . . . . . . . . . 178149
Oneway todescribe repetition within a computer program is the use ofloops,
suchasPython’swhile-loopandfor-loopconstructs described inSection1.4.2. An
entirelydifferentwaytoachieverepetitionisthroughaprocessknownasrecursion.
Recursion isatechnique bywhichafunction makesone ormorecalls toitself
during execution, or by which a data structure relies upon smaller instances of
the very same type of structure in its representation. Thereare many examples of
recursion inartandnature. Forexample,fractalpatterns arenaturally recursive. A
physicalexampleofrecursion usedinartisintheRussianMatryoshka dolls. Each
doll is either made of solid wood, or is hollow and contains another Matryoshka
dollinsideit.
In computing, recursion provides an elegant and powerful alternative for per-
forming repetitive tasks. In fact, a few programming languages (e.g., Scheme,
Smalltalk) do not explicitly support looping constructs and instead rely directly
on recursion to express repetition. Most modern programming languages support
functional recursion using the identical mechanism that is used to support tradi-
tional forms of function calls. When one invocation of the function make a recur-
sivecall,thatinvocation issuspended untiltherecursivecallcompletes.
Recursion is an important technique in the study of data structures and algo-
rithms. We will use it prominently in several later chapters of this book (most
notably, Chapters 8 and 12). In this chapter, we begin with the following four il-
lustrative examplesoftheuseofrecursion, providing aPythonimplementation for
each.
• The factorial function (commonly denoted as n!) is a classic mathematical
function thathasanaturalrecursive deﬁnition.
• AnEnglishrulerhasarecursivepatternthatisasimpleexampleofafractal
structure.
• Binary search is among the most important computer algorithms. It allows
us to efﬁciently locate a desired value in a data set with upwards of billions
ofentries.
• Theﬁlesystemfor acomputer has arecursive structure inwhichdirectories
can be nested arbitrarily deeply within other directories. Recursive algo-
rithmsarewidelyusedtoexploreandmanagetheseﬁlesystems.
We then describe how to perform a formal analysis of the running time of a
recursive algorithm and we discuss some potential pitfalls when deﬁning recur-
sions. Inthe balance of the chapter, weprovide many more examples ofrecursive150 Chapter4. Recursion
4.1 Illustrative Examples
4.1.1 The Factorial Function
To demonstrate the mechanics of recursion, we begin with a simple mathematical
example ofcomputing the value of thefactorial function. Thefactorial of aposi-
tive integer n, denoted n!, is deﬁned as the product of the integers from 1 ton. If
n=0,thenn!isdeﬁnedas1byconvention. Moreformally,foranyintegern≥0,
(cid:4)
1 ifn=0
n!=
n·(n−1)·(n−2)···3·2·1 ifn≥1.
Forexample, 5!=5·4·3·2·1 =120. Thefactorial function isimportant because
itisknown toequal thenumber ofwaysinwhichndistinct items can bearranged
into a sequence, that is, the number ofpermutations of n items. For example, the
three characters a, b, and c can be arranged in 3!=3·2·1=6 ways: abc, acb,
bac,bca,cab,andcba.
There is a natural recursive deﬁnition for the factorial function. To see this,
observe that 5!=5·(4·3·2·1) =5·4!. More generally, for a positive integer n,
wecandeﬁnen!toben·(n−1)!. Thisrecursivedeﬁnitioncanbeformalizedas
(cid:4)
1 ifn=0
n!=
n·(n−1)! ifn≥1.
This deﬁnition is typical of many recursive deﬁnitions. First, it contains one
or more base cases, which are deﬁned nonrecursively in terms of ﬁxed quantities.
In this case, n=0 is the base case. It also contains one or more recursive cases,
whicharedeﬁnedbyappealing tothedeﬁnitionofthefunctionbeingdeﬁned.
A Recursive Implementation of the Factorial Function
Recursion is not just a mathematical notation; we can use recursion to design a
Pythonimplementation ofafactorial function, asshowninCodeFragment4.1.
1 def factorial(n):
2 if n == 0:
3 return 1
4 else:
5 return n factorial(n−1)4.1. IllustrativeExamples 151
This function does not use any explicit loops. Repetition is provided by the
repeatedrecursiveinvocationsofthefunction. Thereisnocircularityinthisdeﬁni-
tion,becauseeachtimethefunctionisinvoked, itsargumentissmallerbyone,and
whenabasecaseisreached, nofurtherrecursive callsaremade.
Weillustratetheexecutionofarecursivefunctionusingarecursiontrace. Each
entry of the trace corresponds to a recursive call. Each new recursive function
call is indicated by a downward arrow to a new invocation. When the function
returns,anarrowshowingthisreturnisdrawnandthereturnvaluemaybeindicated
alongsidethisarrow. Anexampleofsuchatraceforthefactorialfunctionisshown
inFigure4.1.
return 4 6 = 24
factorial(4)
return 3 2 = 6
factorial(3)
return 2 1 = 2
factorial(2)
return 1 1 = 1
factorial(1)
return 1
factorial(0)
Figure4.1: Arecursion traceforthecallfactorial(5).
Arecursiontracecloselymirrorstheprogramminglanguage’s executionofthe
recursion. InPython,eachtimeafunction(recursiveorotherwise)iscalled,astruc-
ture known as an activation record or frame is created to store information about
the progress of that invocation of the function. This activation record includes a
namespace for storing the function call’s parameters and local variables (see Sec-
tion 1.10for adiscussion ofnamespaces), and information about whichcommand
inthebodyofthefunction iscurrently executing.
When the execution of a function leads to a nested function call, the execu-
tionoftheformercallissuspended anditsactivation record stores theplace inthe
source codeatwhichtheﬂowofcontrol shouldcontinue uponreturnofthenested
call. This process is used both in the standard case of one function calling a dif-
ferentfunction, orintherecursive caseinwhichafunctioninvokes itself. Thekey152 Chapter4. Recursion
4.1.2 Drawing an English Ruler
In the case of computing a factorial, there is no compelling reason for preferring
recursion over a direct iteration with a loop. As a more complex example of the
useofrecursion, consider howtodrawthemarkingsofatypicalEnglishruler. For
each inch, we place a tick with a numeric label. We denote the length of the tick
designating a whole inch as the major tick length. Between the marks for whole
inches, the ruler contains a series of minor ticks, placed at intervals of 1/2 inch,
1/4 inch, and so on. As the size of the interval decreases by half, the tick length
decreases by one. Figure 4.2 demonstrates several such rulers with varying major
ticklengths(although notdrawntoscale).
---- 0 ----- 0 --- 0
- - -
-- -- --
- - -
--- --- --- 1
- - -
-- -- --
- - -
---- 1 ---- --- 2
- - -
-- -- --
- - -
--- --- --- 3
- -
-- --
- -
---- 2 ----- 1
(a) (b) (c)
Figure 4.2: Three sample outputs of an English ruler drawing: (a) a 2-inch ruler
with major tick length 4; (b) a 1-inch ruler with major tick length 5; (c) a 3-inch
rulerwithmajorticklength3.
A Recursive Approach to Ruler Drawing
TheEnglish ruler pattern isasimple example ofafractal, that is, ashape that has
aself-recursive structure atvarious levelsofmagniﬁcation. Consider therulewith
major tick length 5 shown in Figure 4.2(b). Ignoring the lines containing 0 and 1,
let us consider how to draw the sequence of ticks lying between these lines. The
central tick (at1/2inch) haslength 4. Observe thatthetwopatterns ofticks above4.1. IllustrativeExamples 153
Ingeneral, anintervalwithacentralticklengthL≥1iscomposed of:
• AnintervalwithacentralticklengthL−1
• AsingletickoflengthL
• AnintervalwithacentralticklengthL−1
Although itis possible todraw such aruler using an iterative process (see Ex-
ercise P-4.25), the task is considerably easier to accomplish with recursion. Our
implementation consists of three functions, as shown in Code Fragment 4.2. The
main function, draw ruler, manages the construction of the entire ruler. Its argu-
mentsspecifythetotalnumberofinchesintherulerandthemajorticklength. The
utility function, draw line, draws a single tick with a speciﬁed number of dashes
(andanoptional stringlabel, thatisprintedafterthetick).
The interesting work is done by the recursive draw interval function. This
function draws the sequence of minor ticks within some interval, based upon the
lengthoftheinterval’scentraltick. Werelyontheintuitionshownatthetopofthis
page, andwithabasecasewhenL=0thatdrawsnothing. ForL≥1,theﬁrstand
last steps are performed by recursively calling draw interval(L−1). The middle
stepisperformedbycallingthefunctiondraw line(L).
1 def draw line(tick length, tick label= ):
2 ”””Draw one line with given tick length (followed by optional label).”””
3 line = - tick length
4 if tick label:
5 line += + tick label
6 print(line)
7
8 def draw interval(center length):
9 ”””Draw tick interval based upon a central tick length.”””
10 if center length > 0: # stop when length drops to 0
11 draw interval(center length − 1) # recursively draw top ticks
12 draw line(center length) # draw center tick
13 draw interval(center length − 1) # recursively draw bottom ticks
14
15 def draw ruler(num inches, major length):
16 ”””Draw English ruler with given number of inches, major tick length.”””
17 draw line(major length, 0 ) # draw inch 0 line
18 for j in range(1, 1 + num inches):
19 draw interval(major length − 1) # draw interior ticks for inch
20 draw line(major length, str(j)) # draw inch j line and label154 Chapter4. Recursion
Illustrating Ruler Drawing Using a Recursion Trace
Theexecutionoftherecursivedraw intervalfunctioncanbevisualized usingare-
cursiontrace. Thetracefordraw intervalismorecomplicated thaninthefactorial
example, however, because each instance makes two recursive calls. To illustrate
this,wewillshowtherecursiontraceinaformthatisreminiscent ofanoutlinefor
adocument. SeeFigure4.3.
Output
draw interval(3)
draw interval(2)
draw interval(1)
draw interval(0)
draw line(1)
draw interval(0)
draw line(2)
draw interval(1)
draw interval(0)
draw line(1)
draw interval(0)
draw line(3)
draw interval(2)
(previouspatternrepeats)
Figure 4.3: A partial recursion trace for the call draw interval(3). The second4.1. IllustrativeExamples 155
4.1.3 Binary Search
Inthissection,wedescribeaclassicrecursivealgorithm,binarysearch,thatisused
to efﬁciently locate a target value within a sorted sequence of n elements. This is
among the most important of computer algorithms, and it is the reason that we so
oftenstoredatainsortedorder(asinFigure4.4).
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
Figure4.4: Values stored in sorted order within an indexable sequence, such as a
Pythonlist. Thenumbersattoparetheindices.
When the sequence is unsorted, the standard approach to search for a target
value is to use a loop to examine every element, until either ﬁnding the target or
exhausting the data set. This is known as the sequential search algorithm. This
algorithm runs in O(n) time (i.e., linear time) since every element is inspected in
theworstcase.
When the sequence is sorted and indexable, there is a much more efﬁcient
algorithm. (For intuition, think about how you would accomplish this task by
hand!) For any index j, we know that all the values stored at indices 0,...,j−1
are less than or equal to the value at index j, and all the values stored at indices
j+1,...,n−1aregreater thanorequaltothatatindex j. Thisobservation allows
us to quickly “home in” on a search target using a variant of the children’s game
“high-low.” Wecallanelementofthesequence acandidateif,atthecurrent stage
of the search, we cannot rule out that this item matches the target. The algorithm
maintains two parameters, low and high, such that all the candidate entries have
index at least low and at most high. Initially, low=0 and high=n−1. We then
compare the target value to the median candidate, that is, the item data[mid] with
index
mid=(cid:16)(low+high)/2(cid:17).
Weconsiderthreecases:
• If the target equals data[mid], then we have found the item we are looking
for,andthesearchterminatessuccessfully.
• Iftarget < data[mid],thenwerecurontheﬁrsthalfofthesequence,thatis,
ontheintervalofindices fromlowtomid−1.
• Iftarget > data[mid],thenwerecuronthesecondhalfofthesequence,that
is,ontheintervalofindices frommid+1tohigh.156 Chapter4. Recursion
This algorithm is known as binary search. We give a Python implementation
inCodeFragment 4.3, and anillustration ofthe execution ofthealgorithm inFig-
ure 4.5. Whereas sequential search runs in O(n) time, the more efﬁcient binary
search runs in O(logn) time. This is a signiﬁcant improvement, given that if n
is one billion, logn is only 30. (We defer our formal analysis of binary search’s
running timetoProposition 4.2inSection4.2.)
1 def binary search(data, target, low, high):
2 ”””Return True if target is found in indicated portion of a Python list.
3
4 The search only considers the portion from data[low] to data[high] inclusive.
5 ”””
6 if low > high:
7 return False # interval is empty; no match
8 else:
9 mid = (low + high) // 2
10 if target == data[mid]: # found a match
11 return True
12 elif target < data[mid]:
13 # recur on the portion left of the middle
14 return binary search(data, target, low, mid − 1)
15 else:
16 # recur on the portion right of the middle
17 return binary search(data, target, mid + 1, high)
CodeFragment4.3: Animplementation ofthebinarysearchalgorithm.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
low mid high
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
low mid high
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
low midhigh
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
low=mid=high4.1. IllustrativeExamples 157
4.1.4 File Systems
Modernoperatingsystemsdeﬁneﬁle-systemdirectories(whicharealsosometimes
called “folders”) in a recursive way. Namely, a ﬁle system consists of a top-level
directory, and the contents of this directory consists of ﬁles and other directories,
which in turn can contain ﬁles and other directories, and so on. The operating
system allows directories to be nested arbitrarily deep (aslong as there is enough
space in memory), although there must necessarily be some base directories that
contain only ﬁles,not further subdirectories. Arepresentation ofaportion ofsuch
aﬁlesystemisgiveninFigure4.6.
/user/rt/courses/
cs016/ cs252/
grades grades
homeworks/ programs/ projects/
hw1 hw2 hw3 pr1 pr2 pr3
papers/ demos/
buylow sellhigh market
Figure4.6: Aportionofaﬁlesystem demonstrating anestedorganization.
Giventherecursivenatureoftheﬁle-systemrepresentation, itshouldnotcome
asasurprisethatmanycommonbehaviorsofanoperatingsystem,suchascopying
a directory or deleting a directory, are implemented with recursive algorithms. In
thissection,weconsideronesuchalgorithm: computingthetotaldiskusageforall
ﬁlesanddirectories nestedwithinaparticular directory.
For illustration, Figure 4.7 portrays the disk space being used by all entries in
oursampleﬁlesystem. Wedifferentiate betweentheimmediatediskspaceusedby
eachentryandthecumulativediskspaceusedbythatentryandallnestedfeatures.
For example, thecs016 directory uses only 2K of immediate space, but a total of158 Chapter4. Recursion
5124K
/user/rt/courses/
1K
249K 4874K
cs016/ cs252/
2K 1K
10K 229K 4870K
grades homeworks/ programs/ projects/ grades
8K 1K 1K 1K 3K
82K 4787K
hw1 hw2 hw3 pr1 pr2 pr3 papers/ demos/
3K 2K 4K 57K 97K 74K 1K 1K
buylow sellhigh market
26K 55K 4786K
Figure4.7:ThesameportionofaﬁlesystemgiveninFigure4.6,butwithadditional
annotations to describe the amount of disk space that is used. Within the icon for
each ﬁle or directory is the amount of space directly used by that artifact. Above
the icon for each directory is an indication of the cumulative disk space used by
thatdirectory andallits(recursive) contents.
Thecumulativediskspaceforanentrycanbecomputedwithasimplerecursive
algorithm. It is equal to the immediate disk space used by theentry plus the sum
of the cumulative disk space usage of any entries that are stored directly within
the entry. For example, the cumulative disk space for cs016 is 249K because it
uses 2K itself, 8K cumulatively ingrades, 10K cumulatively inhomeworks,and
229K cumulatively inprograms. Pseudo-code forthis algorithm isgiveninCode
Fragment4.4.
AlgorithmDiskUsage(path):
Input: Astringdesignating apathtoaﬁle-system entry
Output: Thecumulativediskspaceusedbythatentryandanynestedentries
total = size(path) {immediatediskspaceusedbytheentry}
ifpathrepresents adirectorythen
foreachchildentrystoredwithindirectorypathdo
total = total+DiskUsage(child) {recursivecall}
returntotal
CodeFragment4.4: An algorithm for computing the cumulative disk space usage
nested at a ﬁle-system entry. Functionsizereturns the immediate disk space of an4.1. IllustrativeExamples 159
Python’s os Module
To provide a Python implementation of a recursive algorithm for computing disk
usage, werely on Python’s os module, which provides robust tools for interacting
with the operating system during the execution of aprogram. This is an extensive
library, butwewillonlyneedthefollowingfourfunctions:
• os.path.getsize(path)
Returntheimmediatediskusage(measuredinbytes)fortheﬁleordirectory
thatisidentiﬁedbythestringpath(e.g.,/user/rt/courses).
• os.path.isdir(path)
ReturnTrueifentrydesignatedbystringpathisadirectory;Falseotherwise.
• os.listdir(path)
Return a list of strings that are the names of all entries within a directory
designated by string path. In our sample ﬁle system, if the parameter is
/user/rt/courses,thisreturns thelist[ cs016 , cs252 ].
• os.path.join(path, ﬁlename)
Compose thepathstring andﬁlenamestring using an appropriate operating
system separator between the two (e.g., the / character for a Unix/Linux
system, and the \ character for Windows). Return the string that represents
thefullpathtotheﬁle.
Python Implementation
Withuseoftheosmodule,wenowconvertthealgorithm fromCodeFragment4.4
intothePythonimplementation ofCodeFragment4.5.
1 import os
2
3 def disk usage(path):
4 ”””Return the number of bytes used by a ﬁle/folder and any descendents.”””
5 total = os.path.getsize(path) # account for direct usage
6 if os.path.isdir(path): # if this is a directory,
7 for ﬁlename in os.listdir(path): # then for each child:
8 childpath = os.path.join(path, ﬁlename) # compose full path to child
9 total += disk usage(childpath) # add child’s usage to total
10
11 print ( {0:<7} .format(total), path) # descriptive output (optional)
12 return total # return the grand total160 Chapter4. Recursion
Recursion Trace
To produce a different form of a recursion trace, we have included an extraneous
printstatementwithinourPythonimplementation (line11ofCodeFragment4.5).
The precise format of that output intentionally mirrors output that is produced by
a classic Unix/Linux utility nameddu (for “disk usage”). It reports the amount of
disk space used by a directory and all contents nested within, and can produce a
verbosereport, asgiveninFigure4.8.
Our implementation of the disk usage function produces an identical result,
when executed on the sample ﬁle system portrayed in Figure 4.7. During the ex-
ecution of the algorithm, exactly one recursive call is made for each entry in the
portion of the ﬁle system that is considered. Because the print statement is made
just before returning from a recursive call, the output shown in Figure 4.8 reﬂects
the order in which the recursive calls are completed. In particular, we begin and
end a recursive call for each entry that is nested below another entry, computing
thenestedcumulativediskspacebeforewecancomputeandreportthecumulative
disk space for the containing entry. For example, we do not know the cumulative
totalforentry/user/rt/courses/cs016untilaftertherecursive callsregarding
contained entriesgrades,homeworks,andprogramscomplete.
8 /user/rt/courses/cs016/grades
3 /user/rt/courses/cs016/homeworks/hw1
2 /user/rt/courses/cs016/homeworks/hw2
4 /user/rt/courses/cs016/homeworks/hw3
10 /user/rt/courses/cs016/homeworks
57 /user/rt/courses/cs016/programs/pr1
97 /user/rt/courses/cs016/programs/pr2
74 /user/rt/courses/cs016/programs/pr3
229 /user/rt/courses/cs016/programs
249 /user/rt/courses/cs016
26 /user/rt/courses/cs252/projects/papers/buylow
55 /user/rt/courses/cs252/projects/papers/sellhigh
82 /user/rt/courses/cs252/projects/papers
4786 /user/rt/courses/cs252/projects/demos/market
4787 /user/rt/courses/cs252/projects/demos
4870 /user/rt/courses/cs252/projects
3 /user/rt/courses/cs252/grades
4874 /user/rt/courses/cs252
5124 /user/rt/courses/
Figure 4.8: A report of the disk usage for the ﬁle system shown in Figure 4.7,
as generated by the Unix/Linux utility du (with command-line options -ak), or4.2. AnalyzingRecursiveAlgorithms 161
4.2 Analyzing Recursive Algorithms
In Chapter 3, we introduced mathematical techniques for analyzing the efﬁciency
ofanalgorithm, baseduponanestimateofthenumberofprimitiveoperations that
are executed by the algorithm. Weuse notations such asbig-Oh to summarize the
relationship betweenthenumberofoperations andtheinputsizeforaproblem. In
this section, we demonstrate how to perform this type of running-time analysis to
recursivealgorithms.
Witharecursivealgorithm,wewillaccountforeachoperationthatisperformed
basedupontheparticularactivationofthefunctionthatmanagestheﬂowofcontrol
at the time it is executed. Stated another way, for each invocation of the function,
weonlyaccountforthenumberofoperationsthatareperformedwithinthebodyof
that activation. We can then account for the overall number of operations that are
executed as part of the recursive algorithm by taking the sum, over all activations,
of the number of operations that take place during each individual activation. (As
an aside, this is also the way we analyze a nonrecursive function that calls other
functions fromwithinitsbody.)
To demonstrate this style of analysis, we revisit the four recursive algorithms
presented in Sections 4.1.1 through 4.1.4: factorial computation, drawing an En-
glish ruler, binary search, and computation of the cumulative size of aﬁlesystem.
Ingeneral, wemayrelyontheintuition afforded byarecursion traceinrecogniz-
ing how many recursive activations occur, and how the parameterization of each
activation can be used to estimate the number of primitive operations that occur
withinthebodyofthatactivation. However,eachoftheserecursivealgorithmshas
auniquestructure andform.
Computing Factorials
It is relatively easy to analyze the efﬁciency of our function for computing fac-
torials, as described in Section 4.1.1. A sample recursion trace for our factorial
function was given in Figure 4.1. To compute factorial(n), wesee that there are a
totalofn+1activations,astheparameterdecreasesfromnintheﬁrstcall,ton−1
inthesecondcall,andsoon,untilreachingthebasecasewithparameter0.
Itisalsoclear,givenanexaminationofthefunctionbodyinCodeFragment4.1,
that each individual activation of factorial executes a constant number of opera-
tions. Therefore, weconclude thattheoverallnumberofoperations forcomputing
factorial(n)isO(n),astherearen+1activations, eachofwhichaccountsforO(1)162 Chapter4. Recursion
Drawing an English Ruler
Inanalyzing theEnglishrulerapplication fromSection4.1.2,weconsiderthefun-
damentalquestionofhowmanytotallinesofoutputaregeneratedbyaninitialcall
todraw interval(c),wherecdenotesthecenterlength. Thisisareasonable bench-
markfortheoverallefﬁciencyofthealgorithmaseachlineofoutputisbasedupon
acalltothedraw lineutility,andeachrecursivecalltodraw intervalwithnonzero
parametermakesexactlyonedirectcalltodraw line.
Some intuition may be gained by examining the source code and the recur-
sion trace. We know that a call to draw interval(c) for c>0 spawns two calls to
draw interval(c−1)andasinglecalltodraw line. Wewillrelyonthisintuition to
provethefollowingclaim.
Proposition 4.1: Forc≥0,acalltodraw interval(c)resultsinprecisely2c−1
linesofoutput.
Justiﬁcation: We provide a formal proof of this claim by induction (see Sec-
tion 3.4.3). In fact, induction is a natural mathematical technique for proving the
correctness and efﬁciency of a recursive process. In the case of the ruler, we
notethatanapplication ofdraw interval(0)generates nooutput, andthat20−1=
1−1=0. Thisservesasabasecaseforourclaim.
More generally, the number of lines printed by draw interval(c) is one more
than twice the number generated by a call to draw interval(c−1), as one center
line is printed between two such recursive calls. By induction, we have that the
numberoflinesisthus1+2·(2c−1−1)=1+2c−2=2c−1.
This proof is indicative of a more mathematically rigorous tool, known as a
recurrence equation that can be used to analyze the running time of a recursive
algorithm. ThattechniqueisdiscussedinSection12.2.4,inthecontextofrecursive
sortingalgorithms.
Performing a Binary Search
Considering the running time of the binary search algorithm, as presented in Sec-
tion 4.1.3, weobserve thataconstant number ofprimitive operations are executed
at each recursive call of method of a binary search. Hence, the running time is
proportional tothenumberofrecursivecallsperformed. Wewillshowthatatmost
(cid:16)logn(cid:17)+1recursive calls aremade during abinary search ofasequence having n
elements, leadingtothefollowingclaim.
Proposition 4.2: ThebinarysearchalgorithmrunsinO(logn)timeforasorted4.2. AnalyzingRecursiveAlgorithms 163
Justiﬁcation: Toprove this claim, acrucial fact is that witheach recursive call
thenumberofcandidate entriesstilltobesearched isgivenbythevalue
high−low+1.
Moreover, thenumberofremainingcandidates isreduced byatleastonehalfwith
eachrecursive call. Speciﬁcally, fromthedeﬁnition ofmid,thenumberofremain-
ingcandidates iseither
(cid:5) (cid:6)
low+high high−low+1
(mid−1)−low+1= −low≤
2 2
(cid:5) (cid:6)
or low+high high−low+1
high−(mid+1)+1=high− ≤ .
2 2
Initially, thenumberofcandidates isn;aftertheﬁrstcallinabinarysearch, itisat
mostn/2;afterthesecondcall,itisatmostn/4;andsoon. Ingeneral,afterthe jth
call in abinary search, the number ofcandidate entries remaining isat mostn/2j.
Intheworstcase(anunsuccessfulsearch),therecursivecallsstopwhenthereareno
morecandidateentries. Hence,themaximumnumberofrecursivecallsperformed,
isthesmallestintegerrsuchthat
n
<1.
2r
In other words (recalling that we omit a logarithm’s base when it is 2), r>logn.
Thus,wehave r=(cid:16)logn(cid:17)+1,
whichimpliesthatbinarysearchrunsinO(logn)time.
Computing Disk Space Usage
Our ﬁnal recursive algorithm from Section 4.1 was that for computing the overall
disk space usage in aspeciﬁed portion ofaﬁlesystem. Tocharacterize the “prob-
lem size” forour analysis, weletndenote thenumber of ﬁle-system entries inthe
portionoftheﬁlesystemthatisconsidered. (Forexample,theﬁlesystemportrayed
inFigure4.6hasn=19entries.)
To characterize the cumulative time spent for an initial call to the disk usage
function, wemustanalyze thetotalnumberofrecursive invocations thataremade,
aswellasthenumberofoperations thatareexecutedwithinthoseinvocations.
We begin by showing that there are precisely n recursive invocations of the
function, inparticular, oneforeachentry intherelevant portion oftheﬁlesystem.
Intuitively, this is because a call to disk usage for a particular entry e of the ﬁle
systemisonlymadefromwithintheforloopofCodeFragment4.5whenprocess-
ing the entry for the unique directory that contains e, and that entry will only be164 Chapter4. Recursion
Toformalize this argument, wecan deﬁnethenestinglevelofeach entry such
that the entry on which webegin has nesting level 0, entries stored directly within
ithave nesting level1, entries stored withinthose entrieshave nesting level 2, and
so on. We can prove by induction that there is exactly one recursive invocation of
disk usageuponeachentryatnestinglevelk. Asabasecase,whenk=0,theonly
recursive invocation made is the initial one. As the inductive step, once we know
there is exactly one recursive invocation for each entry at nesting level k, we can
claim that there is exactly one invocation for each entrye at nesting level k, made
withintheforloopfortheentryatlevelkthatcontainse.
Having established that there is one recursive call for each entry of the ﬁle
system,wereturntothequestionoftheoverallcomputationtimeforthealgorithm.
ItwouldbegreatifwecouldarguethatwespendO(1)timeinanysingleinvocation
of the function, but that is not the case. While there are a constant number of
stepsreﬂectinthecalltoos.path.getsizetocomputethediskusagedirectlyatthat
entry, whentheentry isadirectory, thebodyofthedisk usagefunction includes a
forloopthatiterates overallentries thatarecontained withinthatdirectory. Inthe
worstcase,itispossible thatoneentryincludesn−1others.
Basedonthisreasoning, wecouldconclude thatthereareO(n)recursive calls,
each of which runs inO(n) time, leading to an overall running time that isO(n2).
While this upper bound is technically true, it is not a tight upper bound. Remark-
ably, we can prove the stronger bound that the recursive algorithm for disk usage
completes in O(n) time! The weaker bound was pessimistic because it assumed
a worst-case number of entries for each directory. While it is possible that some
directories contain a number of entries proportional to n, they cannot all contain
that many. Toprove the stronger claim, wechoose toconsiderthe overall number
ofiterations ofthe for loop across allrecursive calls. Weclaim there are precisely
n−1 such iteration of that loop overall. We base this claim on the fact that each
iterationofthatloopmakesarecursivecalltodisk usage,andyetwehavealready
concludedthatthereareatotalofncallstodisk usage(includingtheoriginalcall).
Wetherefore conclude thatthereareO(n)recursivecalls,eachofwhichusesO(1)
time outside the loop, and that the overall number of operations due to the loop
isO(n). Summingallofthesebounds, theoverallnumberofoperations isO(n).
The argument we have made is more advanced than with the earlier examples
of recursion. The idea that we can sometimes get a tighter bound on a series of
operations by considering the cumulative effect, rather than assuming that each
achieves a worst case is a technique called amortization; we will see a further
example of such analysis in Section 5.3. Furthermore, a ﬁle system is an implicit
exampleofadatastructure knownasatree, andourdiskusagealgorithm isreally
a manifestation of a more general algorithm known as atree traversal. Trees will
be the focus of Chapter 8, and our argument about the O(n) running time of the4.3. RecursionRunAmok 165
4.3 Recursion Run Amok
Althoughrecursionisaverypowerfultool,itcaneasilybemisusedinvariousways.
Inthissection,weexamineseveralproblemsinwhichapoorlyimplementedrecur-
sioncausesdrasticinefﬁciency,andwediscusssomestrategiesforrecognizingand
avoidsuchpitfalls.
We begin by revisiting the element uniqueness problem, deﬁned on page 135
of Section 3.3.3. We can use the following recursive formulation to determine if
allnelements ofasequence are unique. Asabasecase, whenn=1, theelements
aretriviallyunique. Forn≥2,theelementsareuniqueifandonlyiftheﬁrstn−1
elements areunique, thelastn−1itemsareunique, andtheﬁrstandlastelements
aredifferent (asthatistheonlypairthatwasnotalready checked asasubcase). A
recursiveimplementation basedonthisideaisgiveninCodeFragment4.6,named
unique3(todifferentiate itfromunique1andunique2fromChapter3).
1 def unique3(S, start, stop):
2 ”””Return True if there are no duplicate elements in slice S[start:stop].”””
3 if stop − start <= 1: return True # at most one item
4 elif not unique(S, start, stop−1): return False # ﬁrst part has duplicate
5 elif not unique(S, start+1, stop): return False # second part has duplicate
6 else: return S[start] != S[stop−1] # do ﬁrst and last diﬀer?
CodeFragment4.6: Recursiveunique3fortestingelementuniqueness.
Unfortunately, this is a terribly inefﬁcient use of recursion. The nonrecursive
partofeachcallusesO(1)time,sotheoverallrunningtimewillbeproportional to
thetotalnumberofrecursive invocations. Toanalyze theproblem, weletndenote
thenumberofentriesunderconsideration, thatis,letn=stop − start.
Ifn=1,thentherunning timeofunique3isO(1),sincetherearenorecursive
callsforthiscase. Inthegeneralcase,theimportantobservationisthatasinglecall
tounique3foraproblemofsizenmayresultintworecursivecallsonproblemsof
size n−1. Those two calls with size n−1 could in turn result in four calls (two
each) with a range of size n−2, and thus eight calls with size n−3 and so on.
Thus,intheworstcase,thetotalnumberoffunctioncallsisgivenbythegeometric
summation
1+2+4+···+2n−1,
which is equal to 2n−1 by Proposition 3.5. Thus, the running time of function
unique3 is O(2n). This is an incredibly inefﬁcient function for solving the ele-
ment uniqueness problem. Its inefﬁciency comes not from the fact that it uses
recursion—it comesfromthefactthatitusesrecursionpoorly, whichissomething166 Chapter4. Recursion
An Ineﬃcient Recursion for Computing Fibonacci Numbers
In Section 1.8, we introduced a process for generating the Fibonacci numbers,
whichcanbedeﬁnedrecursively asfollows:
F = 0
0
F = 1
1
Fn = Fn−2+Fn−1 forn>1.
Ironically, a direct implementation based on this deﬁnition results in the function
bad ﬁbonacci shown in Code Fragment 4.7, which computes the sequence of Fi-
bonaccinumbersbymakingtworecursivecallsineachnon-base case.
1 def bad ﬁbonacci(n):
2 ”””Return the nth Fibonacci number.”””
3 if n <= 1:
4 return n
5 else:
6 return bad ﬁbonacci(n−2) + bad ﬁbonacci(n−1)
CodeFragment4.7: Computingthenth Fibonaccinumberusingbinaryrecursion.
Unfortunately, such a direct implementation of the Fibonacci formula results
in a terribly inefﬁcient function. Computing thenth Fibonacci number in this way
requires an exponential number of calls to the function. Speciﬁcally, letc denote
n
thenumberofcallsperformedintheexecutionofbad ﬁbonacci(n). Then,wehave
thefollowingvaluesforthec ’s:
n
c = 1
0
c = 1
1
c = 1+c +c =1+1+1=3
2 0 1
c = 1+c +c =1+1+3=5
3 1 2
c = 1+c +c =1+3+5=9
4 2 3
c = 1+c +c =1+5+9=15
5 3 4
c = 1+c +c =1+9+15=25
6 4 5
c = 1+c +c =1+15+25=41
7 5 6
c = 1+c +c =1+25+41=67
8 6 7
Ifwefollowthepatternforward,weseethatthenumberofcallsmorethandoubles
foreachtwoconsecutive indices. Thatis,c ismorethantwicec ,c ismorethan
4 2 5
twice c , c is more than twice c , and so on. Thus, c >2n/2, which means that
3 6 4 n4.3. RecursionRunAmok 167
An Eﬃcient Recursion for Computing Fibonacci Numbers
Wewere tempted into using the bad recursion formulation because of the way the
nth Fibonaccinumber,Fn,depends onthetwoprevious values,Fn−2 andFn−1. But
noticethataftercomputingFn−2,thecalltocomputeFn−1requiresitsownrecursive
call to compute Fn−2, as it does not have knowledge of the value ofFn−2 that was
computedattheearlierlevelofrecursion. Thatisduplicativework. Worseyet,both
of those calls will need to (re)compute the value ofFn−3, as will the computation
of Fn−1. This snowballing effect is what leads to the exponential running time of
bad recursion.
WecancomputeF muchmoreefﬁcientlyusingarecursioninwhicheachinvo-
n
cationmakesonlyonerecursivecall. Todoso,weneedtoredeﬁnetheexpectations
ofthefunction. Ratherthan having thefunction return asingle value, whichisthe
nth Fibonacci number, we deﬁne a recursive function that returns a pair of con-
secutive Fibonacci numbers (Fn,Fn−1), using the convention F−1 =0. Although
it seems to be a greater burden to report two consecutive Fibonacci numbers in-
stead of one, passing this extra information from one level of the recursion to the
next makes it much easier to continue the process. (It allows us to avoid having
to recompute the second value that was already known within the recursion.) An
implementation basedonthisstrategyisgiveninCodeFragment4.8.
1 def good ﬁbonacci(n):
2 ”””Return pair of Fibonacci numbers, F(n) and F(n-1).”””
3 if n <= 1:
4 return (n,0)
5 else:
6 (a, b) = good ﬁbonacci(n−1)
7 return (a+b, a)
CodeFragment4.8: Computingthenth Fibonaccinumberusinglinearrecursion.
In terms of efﬁciency, the difference between the bad recursion and the good
recursion for this problem is like night and day. Thebad ﬁbonacci function uses
exponential time. Weclaimthattheexecutionoffunctiongood ﬁbonacci(n)takes
O(n) time. Each recursive call to good ﬁbonacci decreases the argument n by 1;
therefore,arecursiontraceincludesaseriesofnfunctioncalls. Becausethenonre-
cursive work for each call uses constant time, the overall computation executes in168 Chapter4. Recursion
4.3.1 Maximum Recursive Depth in Python
Another danger in the misuse of recursion is known asinﬁnite recursion. If each
recursivecallmakesanotherrecursivecall,withouteverreaching abasecase,then
we have an inﬁnite series of such calls. This is a fatal error. An inﬁnite recursion
can quickly swamp computing resources, not only due to rapid use of the CPU,
but because each successive call creates an activation record requiring additional
memory. Ablatant exampleofanill-formedrecursion isthefollowing:
def ﬁb(n):
return ﬁb(n) # ﬁb(n) equals ﬁb(n)
However, there are far more subtle errors that can lead to an inﬁnite recursion.
Revisiting our implementation of binary search in Code Fragment 4.3, in the ﬁnal
case (line 17) we make a recursive call on the right portion of the sequence, in
particular goingfromindexmid+1tohigh. Hadthatlineinstead beenwrittenas
return binary search(data, target, mid, high) # note the use of mid
this could result in an inﬁnite recursion. In particular, when searching a range of
twoelements, itbecomespossible tomakearecursivecallontheidenticalrange.
Aprogrammer should ensure thateach recursive callisinsomewayprogress-
ing toward a base case (for example, by having a parameter value that decreases
with each call). However, to combat against inﬁnite recursions, the designers of
Python made an intentional decision to limit the overall number of function acti-
vations that can be simultaneously active. The precise value of this limit depends
upon the Python distribution, but a typical default value is 1000. If this limit is
reached, the Python interpreter raises a RuntimeError with a message, maximum
recursion depth exceeded.
For many legitimate applications of recursion, a limit of 1000 nested function
callssufﬁces. Forexample,ourbinary searchfunction(Section4.1.3)hasO(logn)
recursive depth, and so for the default recursive limit to be reached, there would
need tobe21000 elements (far, farmorethan theestimated number ofatomsinthe
universe). However, in the next section we discuss several algorithms that have
recursive depth proportional to n. Python’s artiﬁcial limit on the recursive depth
coulddisruptsuchotherwise legitimatecomputations.
Fortunately, the Python interpreter can be dynamically reconﬁgured to change
thedefaultrecursivelimit. Thisisdonethroughuseofamodulenamedsys,which
supports a getrecursionlimit function and a setrecursionlimit. Sample usage of
thosefunctions isdemonstrated asfollows:
import sys
old = sys.getrecursionlimit( ) # perhaps 1000 is typical4.4. FurtherExamplesofRecursion 169
4.4 Further Examples of Recursion
In the remainder of this chapter, we provide additional examples of the use of re-
cursion. We organize our presentation by considering the maximum number of
recursivecallsthatmaybestartedfromwithinthebodyofasingleactivation.
• Ifarecursivecallstartsatmostoneother, wecallthisalinearrecursion.
• Ifarecursivecallmaystarttwoothers,wecallthisabinaryrecursion.
• Ifarecursivecallmaystartthreeormoreothers, thisismultiplerecursion.
4.4.1 Linear Recursion
If a recursive function is designed so that each invocation of the body makes at
mostonenewrecursivecall,thisisknowaslinearrecursion. Oftherecursionswe
have seen so far, the implementation of the factorial function (Section 4.1.1) and
the good ﬁbonacci function (Section 4.3) are clear examples of linear recursion.
More interestingly, the binary search algorithm (Section 4.1.3) is also an example
of linear recursion, despite the “binary” terminology in the name. The code for
binarysearch(CodeFragment4.3)includes acaseanalysis withtwobranches that
leadtorecursivecalls,butonlyoneofthosecallscanbereachedduringaparticular
executionofthebody.
A consequence of the deﬁnition of linear recursion is that any recursion trace
willappearasasinglesequenceofcalls,asweoriginallyportrayedforthefactorial
function in Figure 4.1 of Section 4.1.1. Note that the linear recursion terminol-
ogy reﬂects the structure of the recursion trace, not the asymptotic analysis of the
running time;forexample,wehaveseenthatbinarysearchrunsinO(logn)time.
Summing the Elements of a Sequence Recursively
Linear recursion can be a useful tool for processing a data sequence, such as a
Pythonlist. Suppose,forexample,thatwewanttocomputethesumofasequence,
S, of n integers. We can solve this summation problem using linear recursion by
observing that the sum of all n integers in S is trivially 0, if n=0, and otherwise
that it is the sum of the ﬁrst n−1 integers in S plus the last element in S. (See
Figure4.9.)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
4 3 6 2 8 9 3 2 8 5 1 7 2 8 3 7
Figure4.9:Computingthesumofasequencerecursively,byaddingthelastnumber170 Chapter4. Recursion
A recursive algorithm for computing the sum of a sequence of numbers based
onthisintuition isimplementedinCodeFragment4.9.
1 def linear sum(S, n):
2 ”””Return the sum of the ﬁrst n numbers of sequence S.”””
3 if n == 0:
4 return 0
5 else:
6 return linear sum(S, n−1) + S[n−1]
CodeFragment4.9: Summingtheelementsofasequence usinglinearrecursion.
A recursion trace of the linear sum function for a small example is given in
Figure4.10. Foraninput ofsizen,thelinear sumalgorithm makesn+1function
calls. Hence, it will take O(n) time, because it spends a constant amount of time
performing the nonrecursive part of each call. Moreover, wecan also see that the
memoryspaceusedbythealgorithm(inadditiontothesequenceS)isalsoO(n),as
weuseaconstantamountofmemoryspaceforeachofthen+1activationrecords
inthetraceatthetimewemaketheﬁnalrecursivecall(withn=0).
return 15 + S[4] = 15 + 8 = 23
linear sum(S, 5)
return 13 + S[3] = 13 + 2 = 15
linear sum(S, 4)
return 7 + S[2] = 7 + 6 = 13
linear sum(S, 3)
return 4 + S[1] = 4 + 3 = 7
linear sum(S, 2)
return 0 + S[0] = 0 + 4 = 4
linear sum(S, 1)
return 0
linear sum(S, 0)
Figure 4.10: Recursion trace for an execution of linear sum(S, 5) with input pa-4.4. FurtherExamplesofRecursion 171
Reversing a Sequence with Recursion
Next, let us consider the problem of reversing then elements of a sequence, S, so
that the ﬁrst element becomes the last, the second element becomes second to the
last,andsoon. Wecansolvethisproblemusinglinearrecursion, byobservingthat
the reversal ofa sequence can be achieved by swapping the ﬁrst and last elements
and then recursively reversing the remaining elements. We present an implemen-
tation of this algorithm in Code Fragment 4.10, using the convention that the ﬁrst
timewecallthisalgorithm wedosoasreverse(S, 0, len(S)).
1 def reverse(S, start, stop):
2 ”””Reverse elements in implicit slice S[start:stop].”””
3 if start < stop − 1: # if at least 2 elements:
4 S[start], S[stop−1] = S[stop−1], S[start] # swap ﬁrst and last
5 reverse(S, start+1, stop−1) # recur on rest
CodeFragment4.10: Reversingtheelementsofasequence usinglinearrecursion.
Notethattherearetwoimplicit basecasescenarios: Whenstart == stop,the
implicit range is empty, and when start == stop−1, the implicit range has only
one element. In either of these cases, there is no need for action, as a sequence
withzeroelementsoroneelementistriviallyequaltoitsreversal. Whenotherwise
invoking recursion, we are guaranteed to make progress towards a base case, as
the difference, stop−start, decreases by two witheach call (see Figure 4.11). Ifn
is even, we will eventually reach the start == stop case, and if n is odd, we will
eventually reachthestart == stop − 1case.
Theaboveargumentimpliesthattherecursi(cid:7)ve(cid:8)algorithmofCodeFragment4.10
is guaranteed to terminate after a total of 1+ n recursive calls. Since each call
2
involves aconstant amountofwork,theentireprocessrunsinO(n)time.
0 1 2 3 4 5 6
4 3 6 2 8 9 5
5 3 6 2 8 9 4
5 9 6 2 8 3 4
5 9 8 2 6 3 4
5 9 8 2 6 3 4
Figure4.11: Atrace ofthe recursion forreversing asequence. Theshadedportion172 Chapter4. Recursion
Recursive Algorithms for Computing Powers
Asanotherinterestingexampleoftheuseoflinearrecursion,weconsidertheprob-
lem of raising a number x to an arbitrary nonnegative integer, n. That is, we wish
to compute the power function, deﬁned as power(x,n) =xn. (We use the name
“power”forthisdiscussion,todifferentiatefromthebuilt-infunctionpowthatpro-
videssuchfunctionality.) Wewillconsidertwodifferentrecursiveformulationsfor
theproblem thatleadtoalgorithms withverydifferent performance.
Atrivialrecursivedeﬁnition followsfromthefactthatxn=x·xn−1 forn>0.
(cid:4)
1 ifn=0
power(x,n)=
x·power(x,n−1) otherwise.
Thisdeﬁnition leadstoarecursivealgorithm showninCodeFragment4.11.
1 def power(x, n):
2 ”””Compute the value x n for integer n.”””
3 if n == 0:
4 return 1
5 else:
6 return x power(x, n−1)
CodeFragment4.11: Computingthepowerfunction usingtrivialrecursion.
A recursive call to this version of power(x,n) runs in O(n) time. Its recursion
trace has structure very similar to that of the factorial function from Figure 4.1,
withtheparameterdecreasing byonewitheachcall,andconstant workperformed
ateachofn+1levels.
However, there is a much faster way to compute the power fun(cid:7)cti(cid:8)on using an
alternative deﬁnition that employs a squaring technique. Let k = n denote the
2
ﬂoor of the division (expressed as n // 2 in Python). We consider the expression
(cid:11) (cid:12)
(cid:9) (cid:10) (cid:7) (cid:8) (cid:9) (cid:10)
xk 2. Whenniseven, n = n andtherefore xk 2= xn2 2=xn. Whennisodd,
(cid:7) (cid:8) (cid:9) (cid:10) 2 2 (cid:9) (cid:10)
n = n−1 and xk 2=xn−1, and therefore xn=x· xk 2, just as 213 =2·26·26.
2 2
Thisanalysis leadstothefollowingrecursivedeﬁnition:
⎧
⎪⎨ 1 ifn=0
(cid:9) (cid:9) (cid:7) (cid:8)(cid:10)(cid:10)
power(x,n)= x· power x, n 2 ifn>0isodd
⎪⎩ (cid:9) (cid:9) (cid:7) (cid:8)(cid:10)2(cid:10)
power x, n 2 ifn>0iseven
2
If we(cid:7)we(cid:8)re to implem(cid:7)ent(cid:8)this recursion makingtworecursive calls to compute
power(x, n )·power(x, n ), a trace of the recursion would demonstrate O(cid:7)(n(cid:8))
2 2
calls. We can perform signiﬁcantly fewer operations by computing power(x, n )
2
as a partial result, and then multiplying it by itself. An implementation based on4.4. FurtherExamplesofRecursion 173
1 def power(x, n):
2 ”””Compute the value x n for integer n.”””
3 if n == 0:
4 return 1
5 else:
6 partial = power(x, n // 2) # rely on truncated division
7 result = partial partial
8 if n % 2 == 1: # if n odd, include extra factor of x
9 result = x
10 return result
CodeFragment4.12: Computingthepowerfunction usingrepeated squaring.
To illustrate the execution of our improved algorithm, Figure 4.12 provides a
recursion traceofthecomputationpower(2, 13).
return 64 64 2 = 8192
power(2, 13)
return 8 8 = 64
power(2, 6)
return 2 2 2 = 8
power(2, 3)
return 1 1 2 = 2
power(2, 1)
return 1
power(2, 0)
Figure4.12: Recursion traceforanexecution ofpower(2, 13).
Toanalyzetherunningtimeoftherevisedalgorithm,weobservethattheexpo-
nent in each recursive call of function power(x,n) is at most half of the preceding
exponent. Aswe saw with the analysis of binary search, the number of times that
wecandivideninhalfbeforegettingtooneorlessisO(logn). Therefore,ournew
formulation ofthepowerfunction resultsinO(logn)recursivecalls. Eachindivid-
ual activation of the function usesO(1) operations (excluding the recursive calls),
and so the total number of operations for computing power(x,n) is O(logn). This
isasigniﬁcant improvementovertheoriginalO(n)-timealgorithm.
Theimprovedversion alsoprovides signiﬁcant savinginreducing thememory
usage. TheﬁrstversionhasarecursivedepthofO(n),andthereforeO(n)activation
records are simultaneous stored in memory. Because the recursive depth of the174 Chapter4. Recursion
4.4.2 Binary Recursion
When a function makes two recursive calls, we say that it uses binary recursion.
We have already seen several examples of binary recursion, most notably when
drawing theEnglish ruler (Section 4.1.2), orinthebad ﬁbonaccifunction ofSec-
tion 4.3. As another application of binary recursion, let us revisit the problem of
summing thenelements ofasequence, S, ofnumbers. Computing the sum ofone
or zero elements is trivial. With two or more elements, we can recursively com-
pute the sum of the ﬁrst half, and the sum of the second half, and add these sums
together. Our implementation of such an algorithm, in Code Fragment 4.13, is
initially invoked asbinary sum(A, 0, len(A)).
1 def binary sum(S, start, stop):
2 ”””Return the sum of the numbers in implicit slice S[start:stop].”””
3 if start >= stop: # zero elements in slice
4 return 0
5 elif start == stop−1: # one element in slice
6 return S[start]
7 else: # two or more elements in slice
8 mid = (start + stop) // 2
9 return binary sum(S, start, mid) + binary sum(S, mid, stop)
CodeFragment4.13: Summingtheelementsofasequence usingbinaryrecursion.
To analyze algorithm binary sum, we consider, for simplicity, the case where
n is a power of two. Figure 4.13 shows the recursion trace of an execution of
binary sum(0, 8). We label each box with the values of parameters start:stop
for that call. The size of the range is divided in half at each recursive call, and
so the depth of the recursion is 1+log n. Therefore, binary sum uses O(logn)
2
amount of additional space, which isabig improvement over the O(n) space used
by the linear sum function of Code Fragment 4.9. However, the running time of
binary sumisO(n),asthereare2n−1functioncalls,eachrequiringconstanttime.
0:8
0:4 4:8
0:2 2:4 4:6 6:8
0:1 1:2 2:3 3:4 4:5 5:6 6:7 7:84.4. FurtherExamplesofRecursion 175
4.4.3 Multiple Recursion
Generalizing from binary recursion, we deﬁne multiple recursion as a process in
which a function may make more than two recursive calls. Our recursion for an-
alyzing the disk space usage of a ﬁle system (see Section 4.1.4) is an example of
multiplerecursion, because thenumberofrecursive callsmadeduringoneinvoca-
tionwasequaltothenumberofentrieswithinagivendirectoryoftheﬁlesystem.
Anothercommonapplicationofmultiplerecursioniswhenwewanttoenumer-
ate various conﬁgurations in order to solve a combinatorial puzzle. For example,
thefollowingareallinstances ofwhatareknownassummationpuzzles:
pot + pan = bib
dog+cat = pig
boy+girl = baby
Tosolvesuchapuzzle, weneedtoassignauniquedigit(thatis,0,1,...,9)toeach
letter inthe equation, inorder tomake the equation true. Typically, wesolve such
a puzzle by using our human observations of the particular puzzle we are trying
to solve to eliminate conﬁgurations (that is, possible partial assignments of digits
toletters) until wecan workthough thefeasible conﬁgurations left, testing for the
correctness ofeachone.
If the number of possible conﬁgurations is not too large, however, we can use
a computer to simply enumerate all the possibilities and test each one, without
employinganyhumanobservations. Inaddition,suchanalgorithmcanusemultiple
recursiontoworkthroughtheconﬁgurationsinasystematicway. Weshowpseudo-
codeforsuchanalgorithminCodeFragment4.14. Tokeepthedescriptiongeneral
enough to be used with other puzzles, the algorithm enumerates and tests all k-
length sequences without repetitions of the elements of a given universe U. We
buildthesequences ofkelementsbythefollowingsteps:
1. Recursively generating thesequences ofk−1elements
2. Appending toeachsuchsequence anelementnotalreadycontained init.
Throughout the execution of the algorithm, we use a set U to keep track of the
elements not contained in the current sequence, so that an element e has not been
usedyetifandonlyifeisinU.
Anotherwaytolookatthealgorithm ofCodeFragment4.14isthatitenumer-
ates every possible size-k ordered subset of U, and tests each subset for being a
possible solutiontoourpuzzle.
For summation puzzles,U ={0,1,2,3,4,5,6,7,8,9} and each position in the
sequence corresponds to a given letter. Forexample, the ﬁrst position could stand176 Chapter4. Recursion
AlgorithmPuzzleSolve(k,S,U):
Input: Anintegerk,sequenceS,andsetU
Output: An enumeration of all k-length extensions to S using elements in U
withoutrepetitions
foreacheinUdo
AddetotheendofS
RemoveefromU {eisnowbeingused}
ifk==1then
TestwhetherSisaconﬁguration thatsolvesthepuzzle
ifSsolvesthepuzzlethen
return“Solution found: ” S
else
PuzzleSolve(k−1,S,U) {arecursivecall}
RemoveefromtheendofS
AddebacktoU {eisnowconsidered asunused}
Code Fragment 4.14: Solving a combinatorial puzzle by enumerating and testing
allpossibleconﬁgurations.
In Figure 4.14, we show a recursion trace of a call to PuzzleSolve(3,S,U),
where S is empty and U = {a,b,c}. During the execution, all the permutations
of the three characters are generated and tested. Note that the initial call makes
three recursive calls, each of which in turn makes two more. If we had executed
PuzzleSolve(3,S,U) on a setU consisting of four elements, the initial call would
have made four recursive calls, each of which would have a trace looking like the
oneinFigure4.14.
initialcall
PuzzleSolve(3,(),{a,b,c})
PuzzleSolve(2,a,{b,c}) PuzzleSolve(2,b,{a,c}) PuzzleSolve(2,c,{a,b})
PuzzleSolve(1,ab,{c}) PuzzleSolve(1,ba,{c}) PuzzleSolve(1,ca,{b})
abc bac cab
PuzzleSolve(1,ac,{b}) PuzzleSolve(1,bc,{a}) PuzzleSolve(1,cb,{a})
acb bca cba
Figure 4.14: Recursion trace for an execution of PuzzleSolve(3,S,U), where S is
emptyandU={a,b,c}. Thisexecutiongeneratesandtestsallpermutationsofa,b,4.5. DesigningRecursiveAlgorithms 177
4.5 Designing Recursive Algorithms
Ingeneral, analgorithm thatusesrecursion typically hasthefollowingform:
• Testforbasecases. Webeginbytestingforasetofbasecases(thereshould
be at least one). These base cases should be deﬁned so that every possible
chainofrecursivecallswilleventuallyreachabasecase,andthehandlingof
eachbasecaseshouldnotuserecursion.
• Recur. Ifnotabasecase,weperformoneormorerecursivecalls. Thisrecur-
sive step may involve a test that decides which of several possible recursive
callstomake. Weshoulddeﬁneeachpossible recursive callsothatitmakes
progress towardsabasecase.
Parameterizing a Recursion
To design a recursive algorithm for a given problem, it is useful to think of the
different ways we might deﬁne subproblems that have the same general structure
astheoriginalproblem. Ifonehasdifﬁcultyﬁndingtherepetitivestructure needed
todesign arecursive algorithm, itis sometimes useful towork out theproblem on
afewconcreteexamplestoseehowthesubproblems shouldbedeﬁned.
Asuccessful recursive design sometimes requires that weredeﬁne theoriginal
problem to facilitate similar-looking subproblems. Often, this involved reparam-
eterizing the signature of the function. For example, when performing a binary
search in a sequence, a natural function signature for a caller would appear as
binary search(data, target). However, in Section 4.1.3, we deﬁned our function
withcalling signaturebinary search(data, target, low, high),using theadditional
parameters todemarcate sublists astherecursion proceeds. Thischange inparam-
eterization iscritical forbinary search. Ifwehadinsisted onthecleaner signature,
binary search(data, target),theonlywaytoinvoke asearchonhalfthelistwould
have been tomakeanew listinstance withonly those elementstosend asthe ﬁrst
parameter. However, making acopy of half the list would already take O(n) time,
negatingthewholebeneﬁtofthebinarysearchalgorithm.
If we wished to provide a cleaner public interface to an algorithm like bi-
nary search, without bothering a user with the extra parameters, a standard tech-
nique is to make one function for public use with the cleaner interface, such as
binary search(data, target), and then having its body invoke a nonpublic utility
function havingthedesiredrecursiveparameters.
Youwillseethatwesimilarlyreparameterizedtherecursioninseveralotherex-
amples of this chapter (e.g.,reverse, linear sum, binary sum). Wesaw a different
approach to redeﬁning a recursion in our good ﬁbonacci implementation, by in-
tentionallystrengtheningtheexpectationofwhatisreturned(inthatcase,returning178 Chapter4. Recursion
4.6 Eliminating Tail Recursion
Themainbeneﬁt ofarecursive approach toalgorithm design isthatitallowsusto
succinctly take advantage of a repetitive structure present in many problems. By
makingouralgorithmdescriptionexploittherepetitivestructureinarecursiveway,
we can often avoid complex case analyses and nested loops. This approach can
leadtomorereadable algorithm descriptions, whilestillbeingquiteefﬁcient.
However,theusefulness ofrecursion comesatamodestcost. Inparticular, the
Python interpreter must maintain activation records that keep track of the state of
each nested call. When computer memory is at a premium, it is useful in some
casestobeabletoderivenonrecursive algorithms fromrecursiveones.
In general, we can use the stack data structure, which we will introduce in
Section6.1,toconvertarecursivealgorithmintoanonrecursivealgorithmbyman-
aging the nesting of the recursive structure ourselves, rather than relying on the
interpreter to do so. Although this only shifts the memory usage from the inter-
pretertoourstack,wemaybeabletoreducethememoryusagebystoringonlythe
minimalinformation necessary.
Even better, some forms of recursion can be eliminated without any use of
axillary memory. A notable such form is known as tail recursion. A recursion
is a tail recursion if any recursive call that is made from one context is the very
last operation in that context, with the return value of the recursive call (if any)
immediately returned by the enclosing recursion. By necessity, a tail recursion
mustbealinear recursion (since thereisnowaytomakeasecond recursive callif
youmustimmediatelyreturntheresultoftheﬁrst).
Oftherecursivefunctionsdemonstratedinthischapter,thebinary searchfunc-
tion of Code Fragment 4.3 and the reverse function of Code Fragment 4.10 are
examples of tail recursion. Several others of our linear recursions are almost like
tail recursion, but not technically so. For example, ourfactorial function of Code
Fragment4.1isnotatailrecursion. Itconcludes withthecommand:
return n factorial(n−1)
This is not a tail recursion because an additional multiplication is performed after
the recursive call is completed. For similar reasons, the linear sum function of
Code Fragment 4.9 and the good ﬁbonacci function of Code Fragment 4.7 fail to
betailrecursions.
Anytailrecursion canbereimplemented nonrecursively byenclosing thebody
in a loop for repetition, and replacing a recursive call with new parameters by a
reassignmentoftheexistingparameterstothosevalues. Asatangibleexample,our
binary search function can be reimplemented as shown in Code Fragment 4.15.
We initialize variables low and high, just prior to our while loop, to represent the4.6. EliminatingTailRecursion 179
1 def binary search iterative(data, target):
2 ”””Return True if target is found in the given Python list.”””
3 low = 0
4 high = len(data)−1
5 while low <= high:
6 mid = (low + high) // 2
7 if target == data[mid]: # found a match
8 return True
9 elif target < data[mid]:
10 high = mid − 1 # only consider values left of mid
11 else:
12 low = mid + 1 # only consider values right of mid
13 return False # loop ended without success
CodeFragment4.15: Anonrecursive implementation ofbinarysearch.
the target, or we narrow the range of the candidate subsequence. Where we made
therecursivecallbinary search(data, target, low, mid −1)intheoriginalversion,
we simply replace high = mid − 1 in our new version and then continue to the
next iteration of the loop. Our original base case condition of low > high has
simply been replaced by the opposite loop condition while low <= high. In our
new implementation, wereturn Falsetodesignate afailed search ifthe whileloop
ends(thatis,withouthaving everreturnedTruefromwithin).
Wecansimilarlydevelopanonrecursiveimplementation(CodeFragment4.16)
oftheoriginal recursivereversemethodofCodeFragment4.10.
1 def reverse iterative(S):
2 ”””Reverse elements in sequence S.”””
3 start, stop = 0, len(S)
4 while start < stop − 1:
5 S[start], S[stop−1] = S[stop−1], S[start] # swap ﬁrst and last
6 start, stop = start + 1, stop − 1 # narrow the range
CodeFragment4.16: Reversingtheelementsofasequenceusingiteration.
Inthisnewversion,weupdatethevaluesstartandstopduringeachpassofthe
loop,exitingoncewereachthecaseofhavingoneorlesselementsinthatrange.
Many other linear recursions can be expressed quite efﬁciently with iteration,
even if they were not formally tail recursions. For example, there are trivial non-
recursive implementations for computing factorials, summing elements of a se-
quence, or computing Fibonacci numbers efﬁciently. In fact, our implementation
ofaFibonaccigenerator,fromSection1.8,produceseachsubsequentvalueinO(1)180 Chapter4. Recursion
4.7 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-4.1 Describe arecursive algorithm for ﬁnding the maximum element in ase-
quence,S,ofnelements. Whatisyourrunningtimeandspaceusage?
R-4.2 Draw the recursion trace for the computation of power(2,5), using the
traditional functionimplemented inCodeFragment4.11.
R-4.3 Draw the recursion trace for the computation of power(2,18), using the
repeated squaring algorithm, asimplementedinCodeFragment4.12.
R-4.4 Draw the recursion trace for the execution of function reverse(S, 0, 5)
(CodeFragment4.10)onS = [4, 3, 6, 2, 6].
R-4.5 DrawtherecursiontracefortheexecutionoffunctionPuzzleSolve(3,S,U)
(CodeFragment4.14),whereSisemptyandU ={a,b,c,d}.
R-4.6 Describe a recursive function for computing the nth Harmonic number,
H =∑n 1/i.
n i=1
R-4.7 Describe a recursive function for converting astring of digits into the in-
tegeritrepresents. Forexample, 13531 represents theinteger13,531.
R-4.8 IsabelhasaninterestingwayofsummingupthevaluesinasequenceAof
nintegers,wherenisapoweroftwo. ShecreatesanewsequenceBofhalf
thesizeofAandsetsB[i]=A[2i]+A[2i+1],fori=0,1,...,(n/2)−1. If
Bhassize1,thensheoutputsB[0]. Otherwise,shereplacesAwithB,and
repeatstheprocess. Whatistherunning timeofheralgorithm?
Creativity
C-4.9 Writeashortrecursive Pythonfunction thatﬁndstheminimumandmax-
imumvaluesinasequence withoutusinganyloops.
C-4.10 Describearecursivealgorithmtocomputetheintegerpartofthebase-two
logarithm ofnusingonlyadditionandintegerdivision.
C-4.11 Describe an efﬁcient recursive function for solving the element unique-
ness problem, which runs in time that is at mostO(n2) in the worst case
withoutusingsorting.
C-4.12 Givearecursivealgorithmtocomputetheproductoftwopositiveintegers,4.7. Exercises 181
C-4.13 In Section 4.2 we prove by induction that the number oflines printed by
a call to draw interval(c) is 2c−1. Another interesting question is how
many dashes are printed during that process. Prove by induction that the
numberofdashesprintedbydraw interval(c)is2c+1−c−2.
C-4.14 IntheTowersofHanoipuzzle,wearegivenaplatformwiththreepegs,a,
b,andc,stickingoutofit. Onpegaisastackofndisks,eachlargerthan
thenext,sothatthesmallestisonthetopandthelargestisonthebottom.
Thepuzzle isto moveallthe disks from pegato pegc, moving onedisk
at a time, so that we never place a larger disk on top of a smaller one.
See Figure 4.15 for an example of the case n=4. Describe a recursive
algorithm forsolving theTowersofHanoipuzzle forarbitrary n. (Hint:
Considerﬁrstthesubproblem ofmovingallbutthenth diskfrompegato
anotherpegusingthethirdas“temporarystorage.”)
Figure4.15: Anillustration oftheTowersofHanoipuzzle.
C-4.15 Write a recursive function that will output all the subsets of a set of n
elements(withoutrepeating anysubsets).
C-4.16 Writeashortrecursive Pythonfunction thattakesacharacter stringsand
outputs its reverse. For example, the reverse of pots&pans would be
snap&stop .
C-4.17 Write a short recursive Python function that determines if a string s is a
palindrome,thatis,itisequaltoitsreverse. Forexample, racecar and
gohangasalamiimalasagnahog arepalindromes.
C-4.18 Userecursion towrite a Python function for determining ifastring s has
morevowelsthanconsonants.
C-4.19 Write a short recursive Python function that rearranges a sequence of in-
tegervaluessothatalltheevenvaluesappearbeforealltheoddvalues.
C-4.20 Given an unsorted sequence, S, of integers and an integer k, describe a
recursive algorithm for rearranging the elements inS so that all elements
less than or equal to k come before any elements larger than k. What is182 Chapter4. Recursion
C-4.21 Suppose you are given an n-element sequence, S, containing distinct in-
tegers that are listed in increasing order. Given a number k, describe a
recursive algorithm to ﬁnd two integers inS that sum to k, if such a pair
exists. Whatistherunningtimeofyouralgorithm?
C-4.22 Develop a nonrecursive implementation of the version of power from
CodeFragment4.12thatusesrepeated squaring.
Projects
P-4.23 Implement a recursive function with signature ﬁnd(path, ﬁlename) that
reports all entries of the ﬁle system rooted at the given path having the
givenﬁlename.
P-4.24 Writeaprogram forsolving summationpuzzlesbyenumerating andtest-
ing all possible conﬁgurations. Using your program, solve the three puz-
zlesgiveninSection4.4.3.
P-4.25 Provide a nonrecursive implementation of the draw interval function for
theEnglishrulerprojectofSection4.1.2. Thereshouldbeprecisely2c−1
linesofoutputifcrepresentsthelengthofthecentertick. Ifincrementing
acounterfrom0to2c−2,thenumberofdashes foreachticklineshould
be exactly one more than the number of consecutive 1’s at the end of the
binaryrepresentation ofthecounter.
P-4.26 Write a program that can solve instances of the Towerof Hanoiproblem
(fromExerciseC-4.14).
P-4.27 Python’s os module provides a function with signature walk(path) that
is a generator yielding the tuple (dirpath, dirnames, ﬁlenames) for each
subdirectory of the directory identiﬁed by string path, such that string
dirpathisthefullpathtothesubdirectory, dirnamesisalistofthenames
of the subdirectories within dirpath, and ﬁlenames is a list of the names
ofnon-directory entriesofdirpath. Forexample,whenvisitingthecs016
subdirectory oftheﬁlesystem showninFigure4.6,thewalkwouldyield
( /user/rt/courses/cs016 , [ homeworks , programs ], [ grades ]).
Giveyourownimplementation ofsuchawalkfunction.
Chapter Notes
Theuseofrecursioninprogramsbelongstothefolkoreofcomputerscience(forexample,
seethearticleofDijkstra[36]). Itisalsoattheheartoffunctionalprogramminglanguages
(forexample,seetheclassicbookbyAbelson,Sussman,andSussman[1]). Interestingly,
binary search was ﬁrst published in 1946, but was not published in a fully correct form
until1962. For furtherdiscussionsonlessons learned,please see papersbyBentley [14]Chapter
5
Array-Based Sequences
Contents
5.1 Python’s Sequence Types . . . . . . . . . . . . . . . . . . . 184
5.2 Low-Level Arrays . . . . . . . . . . . . . . . . . . . . . . . . 185
5.2.1 Referential Arrays . . . . . . . . . . . . . . . . . . . . . . 187
5.2.2 Compact Arrays in Python . . . . . . . . . . . . . . . . . 190
5.3 Dynamic Arrays and Amortization . . . . . . . . . . . . . . 192
5.3.1 Implementing a Dynamic Array . . . . . . . . . . . . . . . 195
5.3.2 Amortized Analysis of Dynamic Arrays . . . . . . . . . . . 197
5.3.3 Python’s List Class . . . . . . . . . . . . . . . . . . . . . 201
5.4 Eﬃciency of Python’s Sequence Types . . . . . . . . . . . 202
5.4.1 Python’s List and Tuple Classes . . . . . . . . . . . . . . 202
5.4.2 Python’s String Class . . . . . . . . . . . . . . . . . . . . 208
5.5 Using Array-Based Sequences . . . . . . . . . . . . . . . . 210
5.5.1 Storing High Scores for a Game . . . . . . . . . . . . . . 210
5.5.2 Sorting a Sequence . . . . . . . . . . . . . . . . . . . . . 214
5.5.3 Simple Cryptography . . . . . . . . . . . . . . . . . . . . 216
5.6 Multidimensional Data Sets. . . . . . . . . . . . . . . . . . 219184 Chapter5. Array-BasedSequences
5.1 Python’s Sequence Types
In this chapter, we explore Python’s various “sequence” classes, namely the built-
in list, tuple, and str classes. There is signiﬁcant commonality between these
classes, mostnotably: each supports indexing toaccess an individual element ofa
sequence, using a syntax such asseq[k], and each uses alow-level concept known
asanarraytorepresent thesequence. However,therearesigniﬁcantdifferences in
the abstractions that these classes represent, and in the waythat instances of these
classes are represented internally by Python. Because these classes are used so
widely in Python programs, and because they will become building blocks upon
whichwewilldevelopmorecomplexdatastructures,itisimperativethatweestab-
lish a clear understanding of both the public behavior and inner workings of these
classes.
Public Behaviors
A proper understanding of the outward semantics for a class is a necessity for a
good programmer. While the basic usage of lists, strings, and tuples may seem
straightforward, there are several important subtleties regarding the behaviors as-
sociatedwiththeseclasses(suchaswhatitmeanstomakeacopyofasequence,or
totake aslice ofasequence). Having amisunderstanding ofabehavior caneasily
lead to inadvertent bugs in a program. Therefore, we establish an accurate men-
tal model for each of these classes. These images will help when exploring more
advanced usage,suchasrepresenting amultidimensional datasetasalistoflists.
Implementation Details
A focus on the internal implementations of these classes seems to go against our
statedprinciplesofobject-oriented programming. InSection2.1.2,weemphasized
theprinciple ofencapsulation, noting thattheuserofaclassneednotknowabout
the internal details of the implementation. While it is true that one only needs to
understandthesyntaxandsemanticsofaclass’spublicinterfaceinordertobeable
to write legal and correct code that uses instances of the class, the efﬁciency of a
program dependsgreatly ontheefﬁciencyofthecomponents uponwhichitrelies.
Asymptotic and Experimental Analyses
In describing the efﬁciency of various operations for Python’s sequence classes,
wewill rely on the formal asymptotic analysis notations established in Chapter 3.
We will also perform experimental analyses of the primary operations to provide5.2. Low-LevelArrays 185
5.2 Low-Level Arrays
To accurately describe the way in which Python represents the sequence types,
we must ﬁrst discuss aspects of the low-level computer architecture. The primary
memory of a computer is composed of bits of information, and those bits are typ-
ically grouped into larger units that depend upon the precise system architecture.
Suchatypicalunitisabyte,whichisequivalent to8bits.
A computer system will have a huge number of bytes of memory, and to keep
track of what information is stored in what byte, the computer uses an abstraction
known as a memory address. In effect, each byte of memory is associated with a
unique number that serves as its address (more formally, thebinary representation
of the number serves as the address). In this way, the computer system can refer
tothedatain“byte #2150” versus thedatain“byte#2157,” forexample. Memory
addressesaretypicallycoordinatedwiththephysicallayoutofthememorysystem,
and so we often portray the numbers in sequential fashion. Figure 5.1 provides
suchadiagram, withthedesignated memoryaddress foreachbyte.
4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
Figure5.1: A representation of aportion of acomputer’s memory, with individual
byteslabeledwithconsecutive memoryaddresses.
Despite the sequential nature of the numbering system, computer hardware is
designed,intheory,sothatanybyteofthemainmemorycanbeefﬁcientlyaccessed
baseduponitsmemoryaddress. Inthissense,wesaythatacomputer’smainmem-
oryperformsasrandomaccessmemory(RAM).Thatis,itisjustaseasytoretrieve
byte #8675309 as it is to retrieve byte #309. (In practice, there are complicating
factorsincludingtheuseofcachesandexternalmemory;weaddresssomeofthose
issues in Chapter 15.) Using the notation for asymptotic analysis, wesay that any
individual byteofmemorycanbestoredorretrieved inO(1)time.
In general, a programming language keeps track of the association between
an identiﬁer and the memory address in which the associated value is stored. For
example,identiﬁerxmightbeassociated withonevaluestoredinmemory,whiley
is associated with another value stored in memory. A common programming task
istokeeptrackofasequenceofrelatedobjects. Forexample,wemaywantavideo
gametokeeptrackofthetoptenscoresforthatgame. Ratherthanusetendifferent
variables for thistask, wewouldprefer touseasingle nameforthe group and use186 Chapter5. Array-BasedSequences
A group of related variables can be stored one after another in a contiguous
portion of the computer’s memory. We will denote such a representation as an
array. As a tangible example, a text string is stored as an ordered sequence of
individual characters. In Python, each character is represented using the Unicode
character set, and on most computing systems, Python internally represents each
Unicodecharacterwith16bits(i.e.,2bytes). Therefore,asix-characterstring,such
as SAMPLE ,wouldbestored in12consecutive bytes ofmemory,asdiagrammed
inFigure5.2.
4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
S A M P L E
0 1 2 3 4 5
Figure5.2: A Python string embedded as an array of characters in the computer’s
memory. We assume that each Unicode character of the string requires two bytes
ofmemory. Thenumbersbelowtheentriesareindicesintothestring.
Wedescribethisasanarrayofsixcharacters, eventhoughitrequires 12bytes
ofmemory. Wewillrefertoeachlocationwithinanarrayasacell,andwillusean
integerindextodescribe itslocation withinthearray, withcellsnumberedstarting
with0,1,2,andsoon. Forexample,inFigure5.2,thecellofthearraywithindex4
hascontentsLandisstoredinbytes2154and2155ofmemory.
Each cell of an array must use the same number of bytes. This requirement is
what allows an arbitrary cell of the array to be accessed in constant time based on
its index. In particular, if one knows the memory address at which an array starts
(e.g., 2146 in Figure 5.2), the number of bytes per element (e.g., 2 for a Unicode
character), and a desired index within the array, the appropriate memory address
can be computed using the calculation, start + cellsize index. By this formula,
thecellatindex0beginspreciselyatthestartofthearray,thecellatindex1begins
precisely cellsize bytes beyond the start of the array, and so on. As an example,
cell4ofFigure5.2beginsatmemorylocation 2146+2·4=2146+8=2154.
Ofcourse,thearithmeticforcalculatingmemoryaddresseswithinanarraycan
be handled automatically. Therefore, a programmer can envision a more typical
high-level abstraction ofanarrayofcharacters asdiagrammedinFigure5.3.
S A M P L E
0 1 2 3 4 55.2. Low-LevelArrays 187
5.2.1 Referential Arrays
Asanothermotivatingexample,assumethatwewantamedicalinformationsystem
to keep track of the patients currently assigned to beds in a certain hospital. If we
assume that the hospital has 200 beds, and conveniently that those beds are num-
beredfrom 0to199, wemightconsider usinganarray-based structure tomaintain
thenamesofthepatients currently assigned tothosebeds. Forexample, inPython
wemightusealistofnames,suchas:
[ Rene , Joseph , Janet , Jonas , Helen , Virginia , ... ]
To represent such a list with an array, Python must adhere to the requirement that
each cell of the array use the same number of bytes. Yet the elements are strings,
andstringsnaturallyhavedifferentlengths. Pythoncouldattempttoreserveenough
space for each cell to hold the maximum length string (not just of currently stored
strings, butofanystringwemighteverwanttostore), butthatwouldbewasteful.
Instead, Python represents a list or tuple instance using an internal storage
mechanism of an array of object references. At the lowest level, what is stored
is a consecutive sequence of memory addresses at which the elements of the se-
quencereside. Ahigh-leveldiagram ofsuchalistisshowninFigure5.4.
Janet Jonas
Joseph Helen
Rene Virginia
0 1 2 3 4 5
Figure5.4: Anarraystoringreferences tostrings.
Although the relative size of the individual elements may vary, the number of
bits used to store the memory address of each element is ﬁxed (e.g., 64-bits per
address). In this way, Python can support constant-time access to a list or tuple
elementbasedonitsindex.
InFigure5.4,wecharacterize alistofstringsthatarethenamesofthepatients
in a hospital. It is more likely that a medical information system would manage
more comprehensive information on each patient, perhaps represented as an in-
stanceofaPatientclass. Fromtheperspectiveofthelistimplementation,thesame
principle applies: The list will simply keep a sequence of references to those ob-
jects. Note as well that a reference to theNone object can be used as an element188 Chapter5. Array-BasedSequences
The fact that lists and tuples are referential structures is signiﬁcant to the se-
mantics of these classes. A single list instance may include multiple references
to the same object as elements of the list, and it is possible for a single object to
be an element of two or more lists, as those lists simply store references back to
that object. Asan example, when you compute a slice of alist,the result isa new
list instance, but that new list has references to the same elements that are in the
original list,asportrayed inFigure5.5.
0 1 2
temp:
2 3 5 7 11 13 17 19
primes:
0 1 2 3 4 5 6 7
Figure5.5: Theresultofthecommandtemp = primes[3:6].
When the elements of the list are immutable objects, as with the integer in-
stances in Figure 5.5, the fact that the two lists share elements is not that signiﬁ-
cant,asneitherofthelistscancauseachangetothesharedobject. If,forexample,
the command temp[2] = 15 were executed from this conﬁguration, that does not
changetheexistingintegerobject;itchangesthereferenceincell2ofthetemplist
toreference adifferent object. Theresulting conﬁguration isshowninFigure5.6.
0 1 2
temp: 15
2 3 5 7 11 13 17 19
primes:
0 1 2 3 4 5 6 7
Figure5.6: The result of the command temp[2] = 15 upon the conﬁguration por-
trayedinFigure5.5.
The same semantics is demonstrated when making a new list as a copy of an
existing one, with a syntax such as backup = list(primes). This produces a new
listthatisashallow copy(seeSection 2.6),inthatitreferences thesameelements
as in the ﬁrst list. With immutable elements, this point is moot. If the contents of
thelistwereofamutabletype,adeepcopy,meaninganewlistwithnewelements,5.2. Low-LevelArrays 189
As a more striking example, it is a common practice in Python to initialize an
array ofintegers using asyntax such ascounters = [0] 8. Thissyntax produces
a list of length eight, with all eight elements being the value zero. Technically, all
eightcellsofthelistreference thesameobject, asportrayed inFigure5.7.
0
counters:
0 1 2 3 4 5 6 7
Figure5.7: Theresultofthecommanddata = [0] 8.
At ﬁrst glance, the extreme level of aliasing in this conﬁguration may seem
alarming. However, we rely on the fact that the referenced integer is immutable.
Evenacommandsuch ascounters[2] += 1does nottechnically change thevalue
oftheexistingintegerinstance. Thiscomputesanewinteger,withvalue0+1,and
sets cell 2 to reference the newly computed value. The resulting conﬁguration is
showninFigure5.8.
1
0
counters:
0 1 2 3 4 5 6 7
Figure5.8: Theresultofcommanddata[2] += 1uponthelistfromFigure5.7.
Asaﬁnalmanifestationofthereferentialnatureoflists,wenotethattheextend
command is used to add all elements from one list to the end of another list. The
extended list does not receive copies of those elements, it receives references to
thoseelements. Figure5.9portrays theeffectofacalltoextend.
0 1 2
extras:
2 3 5 7 11 13 17 19 23 29 31
primes:
0 1 2 3 4 5 6 7 8 9 10190 Chapter5. Array-BasedSequences
5.2.2 Compact Arrays in Python
Intheintroductiontothissection,weemphasizedthatstringsarerepresentedusing
anarrayofcharacters(notanarrayofreferences). Wewillrefertothismoredirect
representationasacompactarraybecausethearrayisstoringthebitsthatrepresent
theprimarydata(characters, inthecaseofstrings).
S A M P L E
0 1 2 3 4 5
Compact arrays have several advantages over referential structures in terms
of computing performance. Most signiﬁcantly, the overall memory usage will be
much lower for a compact structure because there is no overhead devoted to the
explicit storage of the sequence of memory references (in addition to the primary
data). That is, a referential structure will typically use 64-bits for the memory
addressstoredinthearray,ontopofwhatevernumberofbitsareusedtorepresent
the object that is considered the element. Also, each Unicode character stored in
a compact array within a string typically requires 2 bytes. If each character were
stored independently as a one-character string, there would be signiﬁcantly more
bytesused.
As another case study, suppose we wish to store a sequence of one million,
64-bit integers. Intheory, wemighthopetouseonly64millionbits. However,we
estimatethataPythonlistwillusefourtoﬁvetimesasmuchmemory. Eachelement
ofthelistwillresult ina64-bit memoryaddress beingstored intheprimaryarray,
andanintinstancebeingstoredelsewhereinmemory. Pythonallowsyoutoquery
the actual number of bytes being used for the primary storage of any object. This
is done using thegetsizeof function of thesys module. On our system, the size of
a typical int object requires 14 bytes of memory (well beyond the 4 bytes needed
forrepresenting theactual64-bitnumber). Inall,thelistwillbeusing18bytesper
entry,ratherthanthe4bytesthatacompactlistofintegerswouldrequire.
Anotherimportantadvantagetoacompactstructureforhigh-performancecom-
puting isthat the primary data are stored consecutively inmemory. Notewell that
this is not the case for areferential structure. That is, even though alist maintains
carefulorderingofthesequenceofmemoryaddresses,wherethoseelementsreside
inmemoryisnotdetermined bythelist. Becauseoftheworkings ofthecacheand
memory hierarchies of computers, it is often advantageous to have data stored in
memorynearotherdatathatmightbeusedinthesamecomputations.
Despite the apparent inefﬁciencies of referential structures, we will generally
becontentwiththeconvenience ofPython’s listsandtuplesinthisbook. Theonly
place in which we consider alternatives will be in Chapter 15, which focuses on
the impact of memory usage on data structures and algorithms. Python provides5.2. Low-LevelArrays 191
Primary support for compact arrays is in a module namedarray. That module
deﬁnesaclass,alsonamedarray,providingcompactstorageforarraysofprimitive
datatypes. Aportrayal ofsuchanarrayofintegersisshowninFigure5.10.
2 3 5 7 11 13 17 19
0 1 2 3 4 5 6 7
Figure5.10: IntegersstoredcompactlyaselementsofaPythonarray.
ThepublicinterfaceforthearrayclassconformsmostlytothatofaPythonlist.
However,theconstructorforthearrayclassrequiresatypecodeasaﬁrstparameter,
whichisacharacter thatdesignates thetypeofdatathatwillbestoredinthearray.
Asatangibleexample,thetypecode, i ,designatesanarrayof(signed)integers,
typicallyrepresentedusingatleast16-bitseach. Wecandeclarethearrayshownin
Figure5.10as,
primes = array( i , [2, 3, 5, 7, 11, 13, 17, 19])
The type code allows the interpreter to determine precisely how many bits are
needed per element of the array. The type codes supported by the array module,
as shown in Table 5.1, are formally based upon the native data types used by the
C programming language (the language in which the the most widely used distri-
bution ofPython isimplemented). Theprecise numberofbitsfortheCdatatypes
issystem-dependent, buttypical rangesareshowninthetable.
Code CDataType TypicalNumberofBytes
b signedchar 1
B unsigned char 1
u Unicodechar 2or4
h signedshortint 2
H unsigned shortint 2
i signedint 2or4
I unsigned int 2or4
l signedlongint 4
L unsigned longint 4
f ﬂoat 4
d ﬂoat 8
Table5.1: Typecodessupported bythearraymodule.
Thearraymoduledoesnotprovidesupportformakingcompactarraysofuser-
deﬁneddatatypes. Compactarraysofsuchstructurescanbecreatedwiththelower-
levelsupportofamodulenamedctypes. (SeeSection5.3.1formorediscussion of192 Chapter5. Array-BasedSequences
5.3 Dynamic Arrays and Amortization
Whencreatingalow-levelarrayinacomputersystem,theprecisesizeofthatarray
mustbeexplicitlydeclaredinorderforthesystemtoproperlyallocateaconsecutive
piece of memory for its storage. Forexample, Figure 5.11 displays an array of 12
bytesthatmightbestoredinmemorylocations 2146through2157.
4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
Figure5.11:Anarrayof12bytesallocatedinmemorylocations2146through2157.
Because the system might dedicate neighboring memory locations to store other
data, the capacity of an array cannot trivially be increasedby expanding into sub-
sequent cells. In the context of representing a Python tuple or str instance, this
constraint is no problem. Instances of those classes are immutable, so the correct
sizeforanunderlying arraycanbeﬁxedwhentheobjectisinstantiated.
Python’slistclasspresentsamoreinteresting abstraction. Althoughalisthasa
particular length when constructed, the class allows us to add elements to the list,
withnoapparentlimitontheoverallcapacityofthelist. Toprovidethisabstraction,
Pythonreliesonanalgorithmic sleightofhandknownasadynamicarray.
Theﬁrstkeytoprovidingthesemanticsofadynamicarrayisthatalistinstance
maintainsanunderlyingarraythatoftenhasgreatercapacitythanthecurrentlength
of the list. For example, while a user may have created a list with ﬁve elements,
the system may have reserved an underlying array capable of storing eight object
references (rather than only ﬁve). This extra capacity makes it easy to append a
newelementtothelistbyusingthenextavailable cellofthearray.
If a user continues to append elements to a list, any reserved capacity will
eventuallybeexhausted. Inthatcase,theclassrequestsanew,largerarrayfromthe
system, and initializes the new array so that its preﬁx matches that of the existing
smaller array. At that point in time, the old array is no longer needed, so it is
reclaimed by the system. Intuitively, this strategy is much like that of the hermit
crab,whichmovesintoalarger shellwhenitoutgrowsitsprevious one.
We give empirical evidence that Python’s list class is based upon such a strat-
egy. Thesource codeforourexperiment isdisplayed inCodeFragment5.1, anda
sample output of that program is given in Code Fragment 5.2. We rely on a func-
tion named getsizeof that is available from the sys module. This function reports
the number of bytes that are being used to store an object in Python. For a list, it
reportsthenumberofbytesdevotedtothearrayandotherinstancevariablesofthe5.3. DynamicArraysandAmortization 193
1 import sys # provides getsizeof function
2 data = [ ]
3 for k in range(n): # NOTE: must ﬁx choice of n
4 a = len(data) # number of elements
5 b = sys.getsizeof(data) # actual size in bytes
6 print( Length: {0:3d}; Size in bytes: {1:4d} .format(a, b))
7 data.append(None) # increase length by one
Code Fragment 5.1: An experiment to explore the relationship between a list’s
lengthanditsunderlying sizeinPython.
Length: 0; Size in bytes: 72
Length: 1; Size in bytes: 104
Length: 2; Size in bytes: 104
Length: 3; Size in bytes: 104
Length: 4; Size in bytes: 104
Length: 5; Size in bytes: 136
Length: 6; Size in bytes: 136
Length: 7; Size in bytes: 136
Length: 8; Size in bytes: 136
Length: 9; Size in bytes: 200
Length: 10; Size in bytes: 200
Length: 11; Size in bytes: 200
Length: 12; Size in bytes: 200
Length: 13; Size in bytes: 200
Length: 14; Size in bytes: 200
Length: 15; Size in bytes: 200
Length: 16; Size in bytes: 200
Length: 17; Size in bytes: 272
Length: 18; Size in bytes: 272
Length: 19; Size in bytes: 272
Length: 20; Size in bytes: 272
Length: 21; Size in bytes: 272
Length: 22; Size in bytes: 272
Length: 23; Size in bytes: 272
Length: 24; Size in bytes: 272
Length: 25; Size in bytes: 272
Length: 26; Size in bytes: 352194 Chapter5. Array-BasedSequences
Inevaluatingtheresultsoftheexperiment,wedrawattentiontotheﬁrstlineof
outputfromCodeFragment5.2. Weseethatanemptylistinstancealreadyrequires
a certain number of bytes of memory (72 on our system). In fact, each object in
Pythonmaintainssomestate, forexample,areference todenotetheclasstowhich
itbelongs. Although wecannot directly access private instance variables foralist,
wecanspeculate thatinsomeformitmaintainsstateinformation akinto:
n Thenumberofactualelementscurrently storedinthelist.
capacity Themaximumnumberofelementsthatcouldbestoredinthe
currently allocated array.
A Thereferencetothecurrentlyallocatedarray(initiallyNone).
As soon as the ﬁrst element is inserted into the list, we detect a change in the
underlying size of the structure. In particular, we see the number of bytes jump
from 72 to 104, an increase of exactly 32 bytes. Our experiment was run on a
64-bitmachinearchitecture, meaningthateachmemoryaddressisa64-bitnumber
(i.e., 8 bytes). We speculate that the increase of 32 bytes reﬂects the allocation of
an underlying array capable of storing four object references. This hypothesis is
consistent with the fact that we do not see any underlying change in the memory
usageafterinserting thesecond, third,orfourthelementintothelist.
Aftertheﬁfthelementhasbeenaddedtothelist,weseethememoryusagejump
from 104 bytes to 136 bytes. Ifweassume the original base usage of 72 bytes for
thelist,thetotalof136suggestsanadditional64=8×8bytesthatprovidecapacity
for up to eight object references. Again, this is consistent with the experiment, as
the memory usage does not increase again until the ninth insertion. At that point,
the200bytescanbeviewedastheoriginal 72plusanadditional 128-byte arrayto
store 16 object references. The 17th insertion pushes the overall memory usage to
272=72+200=72+25×8,henceenoughtostoreupto25elementreferences.
Becausealistisareferential structure, theresultofgetsizeofforalistinstance
onlyincludesthesizeforrepresenting itsprimarystructure;itdoesnotaccountfor
memory used by the objects that are elements of the list. In our experiment, we
repeatedly append Nonetothe list, because wedo notcare about thecontents, but
wecouldappendanytypeofobjectwithoutaffectingthenumberofbytesreported
bygetsizeof(data).
If we were to continue such an experiment for further iterations, we might try
to discern the pattern for how large of an array Python creates each time the ca-
pacity oftheprevious array isexhausted (seeExercises R-5.2andC-5.13). Before
exploring the precise sequence of capacities used by Python, we continue in this
sectionbydescribing ageneralapproach forimplementing dynamicarraysandfor5.3. DynamicArraysandAmortization 195
5.3.1 Implementing a Dynamic Array
Although the Python list class provides a highly optimized implementation of dy-
namicarrays,uponwhichwerelyfortheremainderofthisbook,itisinstructiveto
seehowsuchaclassmightbeimplemented.
The key is to provide means to grow the array A that stores the elements of a
list. Of course, we cannot actually grow that array, as its capacity is ﬁxed. If an
elementisappendedtoalistatatimewhentheunderlyingarrayisfull,weperform
thefollowingsteps:
1. AllocateanewarrayBwithlargercapacity.
2. SetB[i]=A[i],fori=0,...,n−1,wherendenotescurrentnumberofitems.
3. SetA=B,thatis,wehenceforth useBasthearraysupporting thelist.
4. Insertthenewelementinthenewarray.
Anillustration ofthisprocessisshowninFigure5.12.
A A
B B A
(a) (b) (c)
Figure5.12: An illustration of the three steps for “growing” a dynamic array: (a)
createnewarrayB;(b)storeelementsofAinB;(c)reassignreferenceAtothenew
array. Not shown is the future garbage collection of the old array, or the insertion
ofthenewelement.
Theremaining issue toconsider ishow large ofanew array tocreate. Acom-
monlyusedruleisforthenewarraytohavetwicethecapacityoftheexistingarray
that has been ﬁlled. In Section 5.3.2, we will provide a mathematical analysis to
justifysuchachoice.
In Code Fragment 5.3, we offer a concrete implementation of dynamic arrays
in Python. Our DynamicArray class is designed using ideas described in this sec-
tion. While consistent with the interface of a Python list class, we provide only
limitedfunctionality intheformofanappendmethod, andaccessors len and
getitem . Supportforcreatinglow-levelarraysisprovidedbyamodulenamed
ctypes. Because wewillnottypically usesuchalow-levelstructure intheremain-
der of this book, we omit a detailed explanation of the ctypes module. Instead,
we wrap the necessary command for declaring the raw array within a private util-
ity method make array. The hallmark expansion procedure is performed in our196 Chapter5. Array-BasedSequences
1 import ctypes # provides low-level arrays
2
3 class DynamicArray:
4 ”””A dynamic array class akin to a simpliﬁed Python list.”””
5
6 def init (self):
7 ”””Create an empty array.”””
8 self. n = 0 # count actual elements
9 self. capacity = 1 # default array capacity
10 self. A = self. make array(self. capacity) # low-level array
11
12 def len (self):
13 ”””Return number of elements stored in the array.”””
14 return self. n
15
16 def getitem (self, k):
17 ”””Return element at index k.”””
18 if not 0 <= k < self. n:
19 raise IndexError( invalid index )
20 return self. A[k] # retrieve from array
21
22 def append(self, obj):
23 ”””Add object to end of the array.”””
24 if self. n == self. capacity: # not enough room
25 self. resize(2 self. capacity) # so double capacity
26 self. A[self. n] = obj
27 self. n += 1
28
29 def resize(self, c): # nonpublic utitity
30 ”””Resize internal array to capacity c.”””
31 B = self. make array(c) # new (bigger) array
32 for k in range(self. n): # for each existing value
33 B[k] = self. A[k]
34 self. A = B # use the bigger array
35 self. capacity = c
36
37 def make array(self, c): # nonpublic utitity
38 ”””Return new array with capacity c.”””
39 return (c ctypes.py object)( ) # see ctypes documentation
CodeFragment5.3: AnimplementationofaDynamicArrayclass,usingarawarray5.3. DynamicArraysandAmortization 197
5.3.2 Amortized Analysis of Dynamic Arrays
Inthissection, weperformadetailedanalysis oftherunningtimeofoperations on
dynamicarrays. Weusethebig-OmeganotationintroducedinSection3.3.1togive
anasymptoticlowerboundontherunning timeofanalgorithmorstepwithinit.
The strategy of replacing an array with a new, larger array might at ﬁrst seem
slow, because asingle append operation mayrequireΩ(n) timetoperform, where
nisthecurrent numberofelements inthearray. However,notice that bydoubling
the capacity during an array replacement, our new array allows us to add n new
elements before the array must be replaced again. In this way, there are many
simpleappendoperationsforeachexpensiveone(seeFigure5.13). Thisfactallows
us to show that performing a series of operations on an initially empty dynamic
arrayisefﬁcientintermsofitstotalrunningtime.
Usinganalgorithmicdesignpatterncalledamortization,wecanshowthatper-
formingasequenceofsuchappendoperationsonadynamicarrayisactuallyquite
efﬁcient. Toperformanamortizedanalysis,weuseanaccountingtechniquewhere
we view the computer as a coin-operated appliance that requires the payment of
one cyber-dollar for a constant amount of computing time. When an operation
is executed, we should have enough cyber-dollars available in our current “bank
account” topayforthatoperation’s running time. Thus,thetotalamountofcyber-
dollarsspentforanycomputationwillbeproportionaltothetotaltimespentonthat
computation. The beauty of using this analysis method is that we can overcharge
someoperations inordertosaveupcyber-dollars topayforothers.
d
n
e
p
p
a
n 
a
r 
o
f
s 
n
o
ti
a
r
e
p
o
e 
v
ti
mi
ri
p
1 2 3 4 5 6 7 8 9 10111213141516
current number of elements198 Chapter5. Array-BasedSequences
Proposition 5.1: LetSbeasequenceimplementedbymeansofadynamicarray
withinitialcapacityone,usingthestrategyofdoublingthearraysizewhenfull.
ThetotaltimetoperformaseriesofnappendoperationsinS,startingfromSbeing
empty,isO(n).
Justiﬁcation: Letusassumethatonecyber-dollarisenoughtopayfortheexecu-
tionofeachappend operation inS,excluding thetimespentforgrowingthearray.
Also, let us assume that growing the array from sizek to size 2k requires k cyber-
dollars for the time spent initializing the new array. We shall charge each append
operationthreecyber-dollars. Thus,weoverchargeeachappendoperationthatdoes
notcauseanoverﬂowbytwocyber-dollars. Thinkofthetwocyber-dollarsproﬁted
inaninsertionthatdoesnotgrowthearrayasbeing“stored”withthecellinwhich
theelementwasinserted. AnoverﬂowoccurswhenthearrayShas2i elements,for
someinteger i≥0, and thesize ofthe array used bythe array representing Sis2i.
Thus,doublingthesizeofthearraywillrequire2i cyber-dollars. Fortunately,these
cyber-dollars can be found stored in cells 2i−1 through 2i−1. (See Figure 5.14.)
Note that the previous overﬂow occurred when the number of elements became
larger than 2i−1 for the ﬁrst time, and thus the cyber-dollars stored in cells 2i−1
through 2i−1 have not yet been spent. Therefore, we have a valid amortization
schemeinwhicheach operation ischarged three cyber-dollars andallthecomput-
ing time is paid for. That is, we can pay for the execution ofn append operations
using3ncyber-dollars. Inotherwords,theamortized runningtimeofeachappend
operation isO(1);hence, thetotalrunningtimeofnappend operations isO(n).
$ $ $ $
$ $ $ $
(a)
0 1 2 3 4 5 6 7
$
$
(b)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
Figure5.14: Illustrationofaseriesofappendoperationsonadynamicarray: (a)an
8-cell array is full, with two cyber-dollars “stored” at cells 4 through 7; (b) an
appendoperationcausesanoverﬂowandadoublingofcapacity. Copyingtheeight
old elements tothe new array ispaid for by thecyber-dollars already stored inthe
table. Inserting the new element is paid for by one of the cyber-dollars charged to5.3. DynamicArraysandAmortization 199
Geometric Increase in Capacity
Although the proof of Proposition 5.1 relies on the array being doubled each time
we expand, the O(1) amortized bound per operation can be proven for any geo-
metricallyincreasingprogressionofarraysizes(seeSection2.4.2fordiscussionof
geometric progressions). When choosing the geometric base, there exists a trade-
offbetweenrun-timeefﬁciencyandmemoryusage. Withabaseof2(i.e.,doubling
the array), if the last insertion causes a resize event, the array essentially ends up
twice as large as it needs to be. If we instead increase the array by only 25% of
its current size (i.e., a geometric base of 1.25), we do not risk wasting as much
memory in the end, but there will be more intermediate resize events along the
way. Still it is possible to prove anO(1) amortized bound, using a constant factor
greater than the 3 cyber-dollars per operation used in the proof of Proposition 5.1
(seeExerciseC-5.15). Thekeytotheperformance isthattheamountofadditional
spaceisproportional tothecurrent sizeofthearray.
Beware of Arithmetic Progression
To avoid reserving too much space at once, it might be tempting to implement a
dynamic array with a strategy in which a constant number of additional cells are
reserved each time an array is resized. Unfortunately, the overall performance of
such a strategy is signiﬁcantly worse. At an extreme, an increase of only one cell
causes each append operation to resize the array, leading toa familiar 1+2+3+
···+n summation and Ω(n2) overall cost. Using increases of 2 or 3 at a time is
slightly better,asportrayed inFigure5.13,buttheoverallcostremainsquadratic.
d d
n n
e e
p p
p p
a a
n  n 
a a
r  r 
o o
ns f ns f
o o
ati ati
r r
e e
p p
o o
e  e 
v v
miti miti
ri ri
p p
1 2 3 4 5 6 7 8 9 10111213141516 1 2 3 4 5 6 7 8 9 10111213141516
current number of elements current number of elements
(a) (b)
Figure 5.15: Running times of a series of append operations on a dynamic array
using arithmetic progression of sizes. (a) Assumes increase of 2 in size of the200 Chapter5. Array-BasedSequences
Using a ﬁxed increment for each resize, and thus an arithmetic progression of
intermediate array sizes, results in an overall time that is quadratic in the number
of operations, as shown in the following proposition. Intuitively, even an increase
in1000cellsperresizewillbecomeinsigniﬁcant forlargedatasets.
Proposition 5.2: Performingaseriesofnappendoperationsonaninitiallyempty
dynamicarrayusingaﬁxedincrementwitheachresizetakesΩ(n2)time.
Justiﬁcation: Letc>0representtheﬁxedincrementincapacitythatisusedfor
each resize event. During the series of n append operations, time will have been
spent initializing arrays of size c,2c,3c,...,mc for m=(cid:13)n/c(cid:14), and therefore, the
overall time would be proportional toc+2c+3c+···+mc. By Proposition 3.3,
thissumis
∑m ci =c·∑m i =cm(m+1) ≥cnc(nc+1) ≥ n2.
2 2 2c
i=1 i=1
Therefore, performing thenappendoperations takesΩ(n2)time.
AlessontobelearnedfromPropositions5.1and5.2isthatasubtledifferencein
analgorithmdesigncanproducedrasticdifferencesintheasymptoticperformance,
and that acareful analysis can provide important insights into the design of a data
structure.
Memory Usage and Shrinking an Array
Anotherconsequence oftheruleofageometricincreaseincapacitywhenappend-
ingtoadynamicarrayisthattheﬁnalarraysizeisguaranteedtobeproportionalto
theoverallnumberofelements. Thatis,thedatastructureusesO(n)memory. This
isaverydesirable property foradatastructure.
Ifacontainer, suchasaPythonlist,providesoperations thatcausetheremoval
ofoneormoreelements,greatercaremustbetakentoensurethatadynamicarray
guarantees O(n)memoryusage. Theriskisthatrepeated insertions maycausethe
underlyingarraytogrowarbitrarilylarge,andthattherewillnolongerbeapropor-
tional relationship between the actual number of elements and the array capacity
aftermanyelementsareremoved.
A robust implementation of such a data structure will shrink the underlying
array, onoccasion, while maintaining theO(1)amortized bound onindividual op-
erations. However, care must be taken to ensure that the structure cannot rapidly
oscillate between growing and shrinking the underlying array, in which case the
amortizedboundwouldnotbeachieved. InExerciseC-5.16,weexploreastrategy
in which the array capacity is halved whenever the number of actual element falls
belowonefourthofthatcapacity, therebyguaranteeing thatthearraycapacityisat
mostfourtimesthenumberofelements;weexploretheamortizedanalysisofsuch5.3. DynamicArraysandAmortization 201
5.3.3 Python’s List Class
The experiments of Code Fragment 5.1 and 5.2, at the beginning of Section 5.3,
provideempiricalevidencethatPython’slistclassisusingaformofdynamicarrays
for itsstorage. Yet, acareful examination of theintermediate array capacities (see
Exercises R-5.2 and C-5.13) suggests that Python is not using a pure geometric
progression, norisitusinganarithmetic progression.
With that said, it is clear that Python’s implementation of the append method
exhibits amortized constant-time behavior. We can demonstrate this fact experi-
mentally. Asingle append operation typically executes soquickly thatitwouldbe
difﬁcult forus to accurately measure the timeelapsed atthat granularity, although
we should notice some of the more expensive operations in which a resize is per-
formed. We can get a more accurate measure of the amortized cost per operation
by performing aseries ofn append operations on an initially empty list and deter-
miningtheaverage costofeach. Afunction toperformthatexperiment isgivenin
CodeFragment5.4.
1 from time import time # import time function from time module
2 def compute average(n):
3 ”””Perform n appends to an empty list and return average time elapsed.”””
4 data = [ ]
5 start = time( ) # record the start time (in seconds)
6 for k in range(n):
7 data.append(None)
8 end = time( ) # record the end time (in seconds)
9 return (end − start) / n # compute average per operation
CodeFragment5.4: MeasuringtheamortizedcostofappendforPython’slistclass.
Technically, the time elapsed between the start and end includes the time to
managetheiteration oftheforloop, inaddition totheappendcalls. Theempirical
resultsoftheexperiment,forincreasinglylargevaluesofn,areshowninTable5.2.
Weseehigheraveragecostforthesmallerdatasets,perhapsinpartduetotheover-
head of the loop range. There is also natural variance in measuring the amortized
costinthisway,because oftheimpactoftheﬁnalresizeeventrelativeton. Taken
as a whole, there seems clear evidence that the amortized time for each appendis
independent ofn.
n 100 1,000 10,000 100,000 1,000,000 10,000,000 100,000,000
μs 0.219 0.158 0.164 0.151 0.147 0.147 0.149
Table5.2: Averagerunningtimeofappend,measuredinmicroseconds,asobserved202 Chapter5. Array-BasedSequences
5.4 Eﬃciency of Python’s Sequence Types
In the previous section, we began to explore the underpinnings of Python’s list
class, in terms of implementation strategies and efﬁciency. We continue in this
sectionbyexaminingtheperformance ofallofPython’ssequencetypes.
5.4.1 Python’s List and Tuple Classes
The nonmutating behaviors of the list class are precisely those that are supported
by the tuple class. We note that tuples are typically more memory efﬁcient than
lists because they are immutable; therefore, there is no need for an underlying
dynamic array with surplus capacity. We summarize the asymptotic efﬁciency of
thenonmutatingbehaviorsofthelistandtupleclassesinTable5.3. Anexplanation
ofthisanalysisfollows.
Operation RunningTime
len(data) O(1)
data[j] O(1)
data.count(value) O(n)
data.index(value) O(k+1)
value in data O(k+1)
data1 == data2
O(k+1)
(similarly!=,<,<=,>,>=)
data[j:k] O(k− j+1)
data1 + data2 O(n +n )
1 2
c data O(cn)
Table 5.3: Asymptotic performance of the nonmutating behaviors of the list and
tuple classes. Identiﬁers data, data1, and data2 designate instances of the list or
tuple class, and n, n , and n their respective lengths. For the containment check
1 2
and indexmethod, k represents the index of theleftmost occurrence (withk=nif
there is no occurrence). Forcomparisons between two sequences, we let k denote
theleftmostindexatwhichtheydisagree orelsek=min(n ,n ).
1 2
Constant-Time Operations
Thelengthofaninstanceisreturnedinconstanttimebecauseaninstanceexplicitly
maintains such state information. Theconstant-time efﬁciency ofsyntax data[j]is5.4. EfﬁciencyofPython’sSequenceTypes 203
Searching for Occurrences of a Value
Each of the count, index, and contains methods proceed through iteration
of the sequence from left to right. In fact, Code Fragment 2.14 of Section 2.4.3
demonstrates how those behaviors might be implemented. Notably, the loop for
computing the count must proceed through the entire sequence, while the loops
for checking containment of an element or determining the index of an element
immediately exit once they ﬁnd the leftmost occurrence of the desired value, if
one exists. So while count always examines the n elements of the sequence,
index and contains examine n elements in the worst case, but may be faster.
Empirical evidence can be found by setting data = list(range(10000000)) and
then comparing the relative efﬁciency of the test, 5 in data, relative to the test,
9999995 in data,oreventhefailedtest,−5 in data.
Lexicographic Comparisons
Comparisons between two sequences are deﬁned lexicographically. In the worst
case, evaluating such a condition requires an iteration taking time proportional
to the length of the shorter of the two sequences (because when one sequence
ends, the lexicographic result can be determined). However, in some cases the
result of the test can be evaluated more efﬁciently. For example, if evaluating
[7, 3, ...] < [7, 5, ...], it is clear that the result is True without examining the re-
mainders of those lists, because the second element of the left operand is strictly
lessthanthesecondelementoftherightoperand.
Creating New Instances
Theﬁnalthreebehaviors inTable5.3arethosethatconstruct anewinstancebased
on one or more existing instances. In all cases, the running time depends on the
construction and initialization of the new result, and therefore the asymptotic be-
havior is proportional to the length of the result. Therefore, we ﬁnd that slice
data[6000000:6000008]canbeconstructedalmostimmediatelybecauseithasonly
eight elements, while slice data[6000000:7000000] has one million elements, and
thusismoretime-consuming tocreate.
Mutating Behaviors
TheefﬁciencyofthemutatingbehaviorsofthelistclassaredescribedinTable5.3.
The simplest of those behaviors has syntax data[j] = val, and is supported by the
special setitem method. Thisoperation hasworst-caseO(1)runningtimebe-
cause itsimply replaces one elementofalistwithanewvalue. Noother elements
are affected and the size ofthe underlying array does not change. Themore inter-204 Chapter5. Array-BasedSequences
Operation RunningTime
data[j] = val O(1)
data.append(value) O(1)∗
data.insert(k, value) O(n−k+1)∗
data.pop() O(1)∗
data.pop(k)
O(n−k)∗
del data[k]
data.remove(value) O(n)∗
data1.extend(data2)
O(n )∗
2
data1 += data2
data.reverse() O(n)
data.sort() O(nlogn)
∗
amortized
Table5.4: Asymptoticperformanceofthemutatingbehaviorsofthelistclass. Iden-
tiﬁersdata,data1,anddata2designateinstancesofthelistclass,andn,n ,andn
1 2
theirrespective lengths.
Adding Elements to a List
InSection 5.3 wefully explored theappendmethod. Inthe worstcase, itrequires
Ω(n)timebecausetheunderlyingarrayisresized,butitusesO(1)timeintheamor-
tizedsense. Listsalsosupportamethod,withsignatureinsert(k, value),thatinserts
agivenvalueintothelistatindex0≤k≤nwhileshiftingallsubsequent elements
backoneslottomakeroom. Forthepurposeofillustration,CodeFragment5.5pro-
vides animplementation ofthatmethod, inthecontext ofourDynamicArrayclass
introduced inCodeFragment5.3. Therearetwocomplicatingfactors inanalyzing
theefﬁciency ofsuch anoperation. First, wenote thatthe addition ofoneelement
mayrequirearesizingofthedynamicarray. ThatportionoftheworkrequiresΩ(n)
worst-case time but only O(1) amortized time, as per append. The other expense
for insert is the shifting of elements to make room for the new item. The time for
1 def insert(self, k, value):
2 ”””Insert value at index k, shifting subsequent values rightward.”””
3 # (for simplicity, we assume 0 <= k <= n in this verion)
4 if self. n == self. capacity: # not enough room
5 self. resize(2 self. capacity) # so double capacity
6 for j in range(self. n, k, −1): # shift rightmost ﬁrst
7 self. A[j] = self. A[j−1]
8 self. A[k] = value # store newest element
9 self. n += 15.4. EfﬁciencyofPython’sSequenceTypes 205
0 1 2 k n−1
Figure5.16: Creatingroomtoinsertanewelementatindexkofadynamicarray.
that process depends upon the index of the new element, and thus the number of
other elements that must be shifted. That loop copies the reference that had been
at index n−1 to index n, then the reference that had been at index n−2 to n−1,
continuing until copying the reference that had been at index k to k+1, as illus-
trated inFigure5.16. Overallthisleads toanamortizedO(n−k+1)performance
forinserting atindexk.
When exploring the efﬁciency of Python’s append method in Section 5.3.3,
we performed an experiment that measured the average cost of repeated calls on
varyingsizesoflists(seeCodeFragment5.4andTable5.2). Wehaverepeatedthat
experimentwiththeinsertmethod,tryingthreedifferentaccesspatterns:
• Intheﬁrstcase,werepeatedly insertatthebeginning ofalist,
for n in range(N):
data.insert(0, None)
• Inasecondcase,werepeatedly insertnearthemiddleofalist,
for n in range(N):
data.insert(n // 2, None)
• Inathirdcase,werepeatedly insertattheendofthelist,
for n in range(N):
data.insert(n, None)
TheresultsofourexperimentaregiveninTable5.5,reportingtheaveragetimeper
operation(notthetotaltimefortheentireloop). Asexpected,weseethatinserting
at the beginning of a list is most expensive, requiring linear time per operation.
Inserting at the middle requires about half the time as inserting at the beginning,
yetisstillΩ(n)time. Inserting attheenddisplaysO(1)behavior, akintoappend.
N
100 1,000 10,000 100,000 1,000,000
k=0 0.482 0.765 4.014 36.643 351.590
k=n//2 0.451 0.577 2.191 17.873 175.383
k=n 0.420 0.422 0.395 0.389 0.397
Table 5.5: Average running time of insert(k, val), measured in microseconds, as
observed over a sequence of N calls, starting with an empty list. We let n denote206 Chapter5. Array-BasedSequences
Removing Elements from a List
Python’s list class offers several ways to remove an element from a list. A call to
pop()removesthelastelementfromalist. Thisismostefﬁcient,becauseallother
elements remain in their original location. This is effectively an O(1) operation,
buttheboundisamortizedbecause Pythonwilloccasionallyshrinktheunderlying
dynamicarraytoconservememory.
Theparameterized version,pop(k), removestheelement that isatindexk<n
of a list, shifting all subsequent elements leftward to ﬁll the gap that results from
theremoval. Theefﬁciencyofthisoperation isO(n−k),astheamountofshifting
dependsuponthechoiceofindexk,asillustratedinFigure5.17. Notewellthatthis
implies that pop(0) is the most expensive call, using Ω(n) time. (see experiments
inExerciseR-5.8.)
0 1 2 k n−1
Figure5.17: Removinganelementatindexkofadynamicarray.
The list class offers another method, named remove, that allows the caller to
specify the value that should be removed (not the index at which it resides). For-
mally, it removes only the ﬁrst occurrence of such a value from a list, or raises a
ValueErrorifnosuchvalueisfound. Animplementation ofsuchbehaviorisgiven
inCodeFragment5.6,againusingourDynamicArrayclassforillustration.
Interestingly, there is no “efﬁcient” case for remove; every call requires Ω(n)
time. Onepartoftheprocesssearchesfromthebeginninguntilﬁndingthevalueat
indexk,whiletherestiteratesfromktotheendinordertoshiftelementsleftward.
Thislinearbehavior canbeobservedexperimentally (seeExerciseC-5.24).
1 def remove(self, value):
2 ”””Remove ﬁrst occurrence of value (or raise ValueError).”””
3 # note: we do not consider shrinking the dynamic array in this version
4 for k in range(self. n):
5 if self. A[k] == value: # found a match!
6 for j in range(k, self. n − 1): # shift others to ﬁll gap
7 self. A[j] = self. A[j+1]
8 self. A[self. n − 1] = None # help garbage collection
9 self. n −= 1 # we have one less item
10 return # exit immediately
11 raise ValueError( value not found ) # only reached if no match5.4. EfﬁciencyofPython’sSequenceTypes 207
Extending a List
Pythonprovidesamethodnamedextendthatisusedtoaddallelementsofonelist
totheendofasecondlist. Ineffect,acalltodata.extend(other)producesthesame
outcomeasthecode,
for element in other:
data.append(element)
In either case, the running time is proportional to the length of the other list, and
amortized because the underlying array for the ﬁrst list maybe resized to accom-
modatetheadditional elements.
Inpractice,theextendmethodispreferabletorepeatedcallstoappendbecause
theconstantfactorshiddenintheasymptoticanalysisaresigniﬁcantlysmaller. The
greater efﬁciency of extend is threefold. First, there is always some advantage to
usinganappropriatePythonmethod,becausethosemethodsareoftenimplemented
natively in a compiled language (rather than as interpretedPython code). Second,
thereislessoverheadtoasinglefunctioncallthataccomplishesallthework,versus
manyindividual function calls. Finally, increased efﬁciencyofextendcomesfrom
thefactthattheresultingsizeoftheupdatedlistcanbecalculatedinadvance. Ifthe
second datasetisquite large, there issomeriskthat theunderlying dynamic array
mightberesizedmultipletimeswhenusingrepeatedcallstoappend. Withasingle
call to extend, at most one resize operation will be performed. Exercise C-5.22
explorestherelativeefﬁciencyofthesetwoapproaches experimentally.
Constructing New Lists
Thereareseveralsyntaxesforconstructingnewlists. Inalmostallcases,theasymp-
toticefﬁciencyofthebehaviorislinearinthelengthofthelistthatiscreated. How-
ever, as with the case in the preceding discussion of extend, there are signiﬁcant
differences inthepracticalefﬁciency.
Section 1.9.2 introduces the topic of list comprehension, using an example
suchassquares = [ k k for k in range(1, n+1) ]asashorthand for
squares = [ ]
for k in range(1, n+1):
squares.append(k k)
Experiments should show that the list comprehension syntaxissigniﬁcantly faster
thanbuilding thelistbyrepeatedly appending (seeExerciseC-5.23).
Similarly, it is a common Python idiom to initialize a list of constant values
using the multiplication operator, as in [0] n to produce a list of length n with
all values equal to zero. Not only is this succinct for the programmer; it is more208 Chapter5. Array-BasedSequences
5.4.2 Python’s String Class
Strings are very important in Python. We introduced their use in Chapter 1, with
a discussion of various operator syntaxes in Section 1.3. A comprehensive sum-
mary of the named methods of the class is given in Tables A.1 through A.4 of
Appendix A. We will not formally analyze the efﬁciency of each of those behav-
iorsinthissection,butwedowishtocommentonsomenotableissues. Ingeneral,
weletndenotethelengthofastring. Foroperations thatrelyonasecondstringas
apattern, weletmdenotethelengthofthatpatternstring.
The analysis for many behaviors is quite intuitive. For example, methods that
produce a new string (e.g., capitalize, center, strip) require time that is linear in
the length of the string that is produced. Many of the behaviors that test Boolean
conditionsofastring(e.g.,islower)takeO(n)time,examiningallncharactersinthe
worstcase,butshortcircuitingassoonastheanswerbecomesevident(e.g.,islower
can immediately returnFalseifthe ﬁrst character isuppercased). Thecomparison
operators (e.g.,==,<)fallintothiscategoryaswell.
Pattern Matching
Someofthemostinterestingbehaviors,fromanalgorithmicpointofview,arethose
that in some way depend upon ﬁnding a string pattern within a larger string; this
goal is at the heart of methods such as contains , ﬁnd, index, count, replace,
and split. String algorithms will be the topic of Chapter 13, and this particular
problemknownaspatternmatchingwillbethefocusofSection13.2. Anaiveim-
plementation runsinO(mn)timecase,becauseweconsider then−m+1possible
starting indices for the pattern, and we spend O(m) time at each starting position,
checking if the pattern matches. However, in Section 13.2, we will develop an al-
gorithm forﬁndingapattern oflengthmwithinalongerstring oflengthninO(n)
time.
Composing Strings
Finally,wewishtocommentonseveralapproachesforcomposinglargestrings. As
anacademicexercise,assumethatwehavealargestringnameddocument,andour
goalistoproduceanewstring,letters,thatcontains onlythealphabetic characters
oftheoriginalstring(e.g.,withspaces,numbers,andpunctuationremoved). Itmay
betemptingtocomposearesultthroughrepeated concatenation, asfollows.
# WARNING: do not do this
letters = # start with empty string
for c in document:
if c.isalpha():5.4. EfﬁciencyofPython’sSequenceTypes 209
While the preceding code fragment accomplishes the goal, it may be terribly
inefﬁcient. Because strings are immutable, the command, letters += c, would
presumably compute the concatenation, letters + c, as a new string instance and
then reassign the identiﬁer, letters, to that result. Constructing that new string
wouldrequiretimeproportionaltoitslength. Iftheﬁnalresulthasncharacters,the
series of concatenations would take time proportional to the familiar sum 1+2+
3+···+n,andthereforeO(n2)time.
Inefﬁcient code of this type is widespread in Python, perhaps because of the
somewhat natural appearance of the code, and mistaken presumptions about how
the += operator is evaluated with strings. Some later implementations of the
Python interpreter have developed anoptimization toallowsuch code tocomplete
in linear time, but this is not guaranteed for all Python implementations. The op-
timization is as follows. The reason that a command, letters += c, causes a new
string instance to be created is that the original string must be left unchanged if
another variable in a program refers to that string. On the other hand, if Python
knew that there were no other references to the string in question, it could imple-
ment+=moreefﬁciently bydirectly mutating thestring(asadynamic array). As
it happens, the Python interpreter already maintains what are known as reference
counts for each object; this count is used in part to determine if an object can be
garbage collected. (SeeSection15.1.2.) Butinthiscontext, itprovides ameansto
detectwhennootherreferencesexisttoastring,therebyallowingtheoptimization.
AmorestandardPythonidiomtoguaranteelineartimecomposition ofastring
is to use a temporary list to store individual pieces, and then to rely on the join
method of the str class to compose the ﬁnal result. Using this technique with our
previous examplewouldappearasfollows:
temp = [ ] # start with empty list
for c in document:
if c.isalpha():
temp.append(c) # append alphabetic character
letters = .join(temp) # compose overall result
This approach is guaranteed to run in O(n) time. First, we note that the series of
up to n append calls will require a total of O(n) time, as per the deﬁnition of the
amortized cost of that operation. The ﬁnalcall tojoin also guarantees that ittakes
timethatislinearintheﬁnallengthofthecomposed string.
As we discussed at the end of the previous section, we can further improve
the practical execution time by using a list comprehension syntax to build up the
temporarylist,ratherthanbyrepeatedcallstoappend. Thatsolution appearsas,
letters = .join([c for c in document if c.isalpha()])
Betteryet,wecanentirelyavoidthetemporarylistwithageneratorcomprehension:210 Chapter5. Array-BasedSequences
5.5 Using Array-Based Sequences
5.5.1 Storing High Scores for a Game
Theﬁrstapplicationwestudyisstoringasequenceofhighscoreentriesforavideo
game. This is representative of many applications in which asequence of objects
mustbestored. Wecouldjustaseasilyhavechosen tostorerecords forpatients in
ahospital orthenamesofplayersonafootball team. Nevertheless, letusfocuson
storinghighscoreentries,whichisasimpleapplication thatisalreadyrichenough
topresent someimportant data-structuring concepts.
To begin, we consider what information to include in an object representing a
high score entry. Obviously, one component to include is an integer representing
the score itself, which we identify as score. Another useful thing to include is
the name of the person earning this score, which weidentify as name. Wecould
go onfrom here, adding ﬁelds representing the date the scorewasearned or game
statistics thatledtothatscore. However,weomitsuchdetailstokeepourexample
simple. A Python class, GameEntry, representing a game entry, is given in Code
Fragment5.7.
1 class GameEntry:
2 ”””Represents one entry of a list of high scores.”””
3
4 def init (self, name, score):
5 self. name = name
6 self. score = score
7
8 def get name(self):
9 return self. name
10
11 def get score(self):
12 return self. score
13
14 def str (self):
15 return ({0}, {1}) .format(self. name, self. score) # e.g., (Bob, 98)
CodeFragment5.7: PythoncodeforasimpleGameEntryclass. Weinclude meth-
ods for returning the name and score for a game entry object, as well as a method5.5. UsingArray-BasedSequences 211
A Class for High Scores
To maintain a sequence of high scores, we develop a class named Scoreboard. A
scoreboardislimitedtoacertainnumberofhighscoresthatcanbesaved;oncethat
limitisreached, anewscoreonlyqualiﬁesforthescoreboard ifitisstrictly higher
thanthelowest“highscore”ontheboard. Thelengthofthedesiredscoreboardmay
dependonthegame,perhaps10,50,or500. Sincethatlimitmayvarydependingon
thegame,weallowittobespeciﬁedasaparametertoourScoreboardconstructor.
Internally, we will use a Python list named board in order to manage the
GameEntry instances that represent the high scores. Since we expect the score-
board to eventually reach full capacity, we initialize the list to be large enough to
hold the maximum number of scores, but we initially set all entries to None. By
allocating thelistwithmaximumcapacityinitially, itneverneedstoberesized. As
entries are added, we will maintain them from highest to lowest score, starting at
index0ofthelist. Weillustrate atypicalstateofthedatastructure inFigure5.18.
Rob 750 Anna 660 Jack 510
Mike 1105 Paul 720 Rose 590
0 1 2 3 4 5 6 7 8 9
Figure5.18:Anillustrationofanorderedlistoflengthten,storingreferencestosix
GameEntryobjectsinthecellsfromindex0to5,withtherestbeingNone.
A complete Python implementation of the Scoreboard class is given in Code
Fragment5.8. Theconstructor israthersimple. Thecommand
self. board = [None] capacity
creates a list with the desired length, yet all entries equal to None. We maintain
an additional instance variable, n, that represents the number of actual entries
currentlyinourtable. Forconvenience,ourclasssupportsthe getitem method
toretrieveanentryatagivenindexwithasyntaxboard[i](orNoneifnosuchentry
exists),andwesupportasimple str methodthatreturnsastringrepresentation212 Chapter5. Array-BasedSequences
1 class Scoreboard:
2 ”””Fixed-length sequence of high scores in nondecreasing order.”””
3
4 def init (self, capacity=10):
5 ”””Initialize scoreboard with given maximum capacity.
6
7 All entries are initially None.
8 ”””
9 self. board = [None] capacity # reserve space for future scores
10 self. n = 0 # number of actual entries
11
12 def getitem (self, k):
13 ”””Return entry at index k.”””
14 return self. board[k]
15
16 def str (self):
17 ”””Return string representation of the high score list.”””
18 return \n .join(str(self. board[j]) for j in range(self. n))
19
20 def add(self, entry):
21 ”””Consider adding entry to high scores.”””
22 score = entry.get score()
23
24 # Does new entry qualify as a high score?
25 # answer is yes if board not full or score is higher than last entry
26 good = self. n < len(self. board) or score > self. board[−1].get score()
27
28 if good:
29 if self. n < len(self. board): # no score drops from list
30 self. n += 1 # so overall number increases
31
32 # shift lower scores rightward to make room for new entry
33 j = self. n − 1
34 while j > 0 and self. board[j−1].get score( ) < score:
35 self. board[j] = self. board[j−1] # shift entry from j-1 to j
36 j −= 1 # and decrement j
37 self. board[j] = entry # when done, add new entry
CodeFragment5.8: Python code for aScoreboard class that maintains an ordered5.5. UsingArray-BasedSequences 213
Adding an Entry
The most interesting method of the Scoreboard class is add, which is responsible
for considering the addition of a new entry to the scoreboard. Keep in mind that
everyentry willnotnecessarily qualify asahigh score. Iftheboard isnotyetfull,
anynewentrywillberetained. Oncetheboardisfull, anewentryisonlyretained
ifitisstrictly better thanone oftheother scores, inparticular, thelast entry ofthe
scoreboard, whichisthelowestofthehighscores.
When anewscore isconsidered, webegin by determining whether itqualiﬁes
as a high score. If so, we increase the count of active scores, n, unless the board
isalready atfullcapacity. Inthatcase, adding anewhighscore causes someother
entry tobe dropped from the scoreboard, so the overall number of entries remains
thesame.
To correctly place a new entry within the list, the ﬁnal task is to shift any in-
ferior scores one spot lower (with the least score being dropped entirely when the
scoreboardisfull). Thisprocessisquitesimilartotheimplementation oftheinsert
methodofthelistclass,asdescribedonpages204–205. Inthecontextofourscore-
board,thereisnoneedtoshiftanyNonereferencesthatremainneartheendofthe
array,sotheprocesscanproceedasdiagrammedinFigure5.19.
Jill 740
Rob 750 Anna 660 Jack 510
Mike 1105 Paul 720 Rose 590
0 1 2 3 4 5 6 7 8 9
Figure5.19: Adding anewGameEntryforJill tothescoreboard. Inorder tomake
room for the new reference, we have to shift the references for game entries with
smallerscoresthanthenewonetotherightbyonecell. Thenwecaninsertthenew
entrywithindex2.
To implement the ﬁnal stage, we begin by considering index j = self. n − 1,
whichistheindexatwhichthelastGameEntryinstancewillreside,aftercomplet-
ingtheoperation. Either jisthecorrect indexforthenewestentry, oroneormore
immediately before itwillhavelesser scores. Thewhileloop atline34checks the
compound condition, shifting references rightward and decrementing j,aslong as214 Chapter5. Array-BasedSequences
5.5.2 Sorting a Sequence
Intheprevioussubsection,weconsideredanapplicationforwhichweaddedanob-
jecttoasequenceatagivenpositionwhileshiftingotherelementssoastokeepthe
previousorderintact. Inthissection,weuseasimilartechniquetosolvethesorting
problem, that is, starting with an unordered sequence of elements and rearranging
themintonondecreasing order.
The Insertion-Sort Algorithm
We study several sorting algorithms in this book, most of which are described in
Chapter 12. As a warm-up, in this section we describe a nice, simple sorting al-
gorithm known asinsertion-sort. The algorithm proceeds as follows for an array-
based sequence. Westart withthe ﬁrstelement inthe array. Oneelement byitself
is already sorted. Then we consider the next element in the array. If it is smaller
than the ﬁrst, we swap them. Next we consider the third element in the array. We
swap it leftward until it is in its proper order with the ﬁrst two elements. Wethen
considerthefourthelement,andswapitleftwarduntilitisintheproperorderwith
the ﬁrstthree. Wecontinue inthis manner with theﬁfthelement, the sixth, and so
on, until the whole array is sorted. We can express the insertion-sort algorithm in
pseudo-code, asshowninCodeFragment5.9.
AlgorithmInsertionSort(A):
Input: AnarrayAofncomparable elements
Output: ThearrayAwithelementsrearranged innondecreasing order
forkfrom1ton − 1do
InsertA[k]atitsproperlocation withinA[0],A[1],...,A[k].
CodeFragment5.9: High-leveldescription oftheinsertion-sort algorithm.
This is a simple, high-level description of insertion-sort. If we look back to
Code Fragment 5.8 of Section 5.5.1, we see that the task of inserting a new en-
try into the list of high scores is almost identical to the task of inserting a newly
considered element in insertion-sort (except that game scores were ordered from
high tolow). Weprovide aPython implementation ofinsertion-sort inCodeFrag-
ment 5.10, using an outer loop to consider each element in turn, and an inner
loop that moves a newly considered element to its proper location relative to the
(sorted)subarrayofelementsthataretoitsleft. Weillustrateanexamplerunofthe
insertion-sort algorithm inFigure5.20.
The nested loops of insertion-sort lead to an O(n2) running time in the worst
case. The most work is done if the array is initially in reverse order. Onthe other
hand, if the initial array is nearly sorted or perfectly sorted, insertion-sort runs in5.5. UsingArray-BasedSequences 215
1 def insertion sort(A):
2 ”””Sort list of comparable elements into nondecreasing order.”””
3 for k in range(1, len(A)): # from 1 to n-1
4 cur = A[k] # current element to be inserted
5 j = k # ﬁnd correct index j for current
6 while j > 0 and A[j−1] > cur: # element A[j-1] must be after current
7 A[j] = A[j−1]
8 j −= 1
9 A[j] = cur # cur is now in the right place
CodeFragment5.10: Pythoncodeforperforminginsertion-sort onalist.
cur nomove
C B C D A E H G F
0 1 2 3 4 5 6 7
nomove
D B C D A E H G F
0 1 2 3 4 5 6 7
A insert
move move move
A B C D E H G F B C D E H G F B C D E H G F
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
nomove
E A B C D E H G F
0 1 2 3 4 5 6 7
nomove
H A B C D E H G F
0 1 2 3 4 5 6 7 G
move nomove insert
G A B C D E H F A B C D E H F
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 F
move move nomove insert
F A B C D E G H A B C D E G H A B C D E G H
0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
Done!
A B C D E F G H
0 1 2 3 4 5 6 7
Figure5.20: Execution of the insertion-sort algorithm on an array of eight charac-
ters. Each row corresponds to an iteration of the outer loop,and each copy of the
sequenceinarowcorrespondstoaniterationoftheinnerloop. Thecurrentelement216 Chapter5. Array-BasedSequences
5.5.3 Simple Cryptography
Aninterestingapplication ofstringsandlistsiscryptography, thescienceofsecret
messages and their applications. This ﬁeld studies ways of performing encryp-
tion, which takes a message, called theplaintext, and converts it into ascrambled
message, calledtheciphertext. Likewise,cryptography alsostudiescorresponding
ways of performing decryption, which takes a ciphertext and turns it back into its
original plaintext.
Arguably theearliest encryption schemeistheCaesar cipher, whichisnamed
after Julius Caesar, who used this scheme to protect important military messages.
(All of Caesar’s messages were written in Latin, of course, which already makes
them unreadable for most of us!) The Caesar cipher is a simpleway to obscure a
messagewritteninalanguagethatformswordswithanalphabet.
TheCaesarcipherinvolvesreplacingeachletterinamessagewiththeletterthat
isacertainnumberoflettersafteritinthealphabet. So,inanEnglishmessage,we
mightreplaceeachAwithD,eachBwithE,eachCwithF,andsoon,ifshiftingby
threecharacters. Wecontinue thisapproach allthewayuptoW,whichisreplaced
with Z. Then, we let the substitution pattern wrap around, so that we replace X
withA,YwithB,andZwithC.
Converting Between Strings and Character Lists
Giventhat strings are immutable, wecannot directly edit aninstance toencrypt it.
Instead, ourgoal willbetogenerate anewstring. Aconvenient technique forper-
forming string transformations is tocreate an equivalent listof characters, edit the
list, andthenreassemble a(new)string basedonthelist. Theﬁrststepcanbeper-
formedbysending thestringasaparameter totheconstructor ofthelistclass. For
example, the expression list( bird ) produces the result [ b , i , r , d ].
Conversely, we can use a list of characters to build a string by invoking the join
method onanemptystring, withthe listofcharacters asthe parameter. Forexam-
ple,thecall .join([ b , i , r , d ])returnsthestring bird .
Using Characters as Array Indices
If we were to number our letters like array indices, so that A is 0, B is 1, C is 2,
and so on, then we can write the Caesar cipher with a rotation of r as a simple
formula: Replace each letter i with the letter (i+r) mod 26, where mod is the
modulooperator, whichreturnstheremainderafterperforminganintegerdivision.
This operator is denoted with % in Python, and it is exactly the operator we need
to easily perform the wrap around at the end of the alphabet. For 26 mod 26 is
0, 27 mod26 is 1, and 28 mod26 is 2. The decryption algorithm for the Caesar
cipher is just the opposite—we replace each letter with the one r places before it,5.5. UsingArray-BasedSequences 217
Wecanrepresent areplacement ruleusing another string todescribe thetrans-
lation. Asaconcrete example, suppose weare using aCaesar cipher withathree-
character rotation. We can precompute a string that represents the replacements
that should be used for each character from A to Z. For example, A should be re-
placed by D, B replaced by E, and so on. The 26 replacement characters in order
are DEFGHIJKLMNOPQRSTUVWXYZABC . Wecansubsequently usethistranslation
string asaguide toencrypt amessage. Theremaining challenge ishow toquickly
locatethereplacement foreachcharacteroftheoriginalmessage.
Fortunately, wecan rely onthe fact that characters are represented in Unicode
by integer code points, and the code points for the uppercase letters of the Latin
alphabet are consecutive (for simplicity, we restrict our encryption to uppercase
letters). Python supports functions that convert between integer code points and
one-character strings. Speciﬁcally, thefunctionord(c)takes aone-character string
asaparameterandreturnstheintegercodepointforthatcharacter. Conversely, the
functionchr(j)takesanintegerandreturnsitsassociated one-character string.
In order to ﬁnda replacement for a character in our Caesar cipher, weneed to
map the characters A to Z to the respective numbers 0to 25. Theformula for
doing that conversion is j = ord(c) − ord( A ). As a sanity check, if character c
is A ,wehavethat j=0. Whencis B ,wewillﬁndthatitsordinalvalueispre-
cisely one morethanthat for A , sotheirdifference is1. Ingeneral, the integer j
that results from such a calculation can be used as an index into our precomputed
translation string,asillustrated inFigure5.21.
encoderarray
D E F G H I J K L M N O P Q R S T U V W X Y Z A B C
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
ord( T ) − ord( A )
Using T asanindex
= 84 − 65 Hereisthe
InUnicode replacementfor T
= 19
Figure5.21: Illustrating the use of uppercase characters as indices, inthis case to
perform thereplacement ruleforCaesarcipherencryption.
In Code Fragment 5.11, we develop a Python class for performing the Caesar
cipherwithanarbitrary rotational shift,anddemonstrateitsuse. Whenwerunthis
program (toperform asimpletest),wegetthefollowingoutput.
Secret: WKH HDJOH LV LQ SODB; PHHW DW MRH’V.
Message: THE EAGLE IS IN PLAY; MEET AT JOE’S.
Theconstructorfortheclassbuildstheforwardandbackwardtranslationstringsfor
the given rotation. With those in hand, the encryption and decryption algorithms
are essentially the same, and so we perform both by means of a nonpublic utility218 Chapter5. Array-BasedSequences
1 class CaesarCipher:
2 ”””Class for doing encryption and decryption using a Caesar cipher.”””
3
4 def init (self, shift):
5 ”””Construct Caesar cipher using given integer shift for rotation.”””
6 encoder = [None] 26 # temp array for encryption
7 decoder = [None] 26 # temp array for decryption
8 for k in range(26):
9 encoder[k] = chr((k + shift) % 26 + ord( A ))
10 decoder[k] = chr((k − shift) % 26 + ord( A ))
11 self. forward = .join(encoder) # will store as string
12 self. backward = .join(decoder) # since ﬁxed
13
14 def encrypt(self, message):
15 ”””Return string representing encripted message.”””
16 return self. transform(message, self. forward)
17
18 def decrypt(self, secret):
19 ”””Return decrypted message given encrypted secret.”””
20 return self. transform(secret, self. backward)
21
22 def transform(self, original, code):
23 ”””Utility to perform transformation based on given code string.”””
24 msg = list(original)
25 for k in range(len(msg)):
26 if msg[k].isupper():
27 j = ord(msg[k]) − ord( A ) # index from 0 to 25
28 msg[k] = code[j] # replace this character
29 return .join(msg)
30
31 if name == __main__ :
32 cipher = CaesarCipher(3)
33 message = "THE EAGLE IS IN PLAY; MEET AT JOE S."
34 coded = cipher.encrypt(message)
35 print( Secret: , coded)
36 answer = cipher.decrypt(coded)
37 print( Message: , answer)5.6. MultidimensionalDataSets 219
5.6 Multidimensional Data Sets
Lists, tuples, and strings in Python are one-dimensional. Weuse a single index to
access each element of the sequence. Many computer applications involve mul-
tidimensional data sets. For example, computer graphics are often modeled in
either two or three dimensions. Geographic information may be naturally repre-
sented in two dimensions, medical imaging may provide three-dimensional scans
of a patient, and a company’s valuation is often based upon a high number of in-
dependent ﬁnancial measures that can be modeled as multidimensional data. A
two-dimensional arrayissometimesalsocalledamatrix. Wemayusetwoindices,
say i and j, to refer to the cells in the matrix. The ﬁrst index usually refers to a
row number and the second to a column number, and these are traditionally zero-
indexed in computer science. Figure 5.22 illustrates a two-dimensional data set
with integer values. This data might, for example, represent the number of stores
invarious regionsofManhattan.
0 1 2 3 4 5 6 7 8 9
0 22 18 709 5 33 10 4 56 82 440
1 45 32 830 120 750 660 13 77 20 105
2 4 880 45 66 61 28 650 7 510 67
3 940 12 36 3 20 100 306 590 0 500
4 50 65 42 49 88 25 70 126 83 288
5 398 233 5 83 59 232 49 8 365 90
6 33 58 632 87 94 5 59 204 120 829
7 62 394 3 4 102 140 183 390 16 26
Figure 5.22: Illustration of a two-dimensional integer data set, which has 8 rows
and 10 columns. The rows and columns are zero-indexed. If this data set were
namedstores,thevalueofstores[3][5]is100andthevalueofstores[6][2]is632.
A common representation for a two-dimensional data set in Python is as a list
of lists. In particular, we can represent a two-dimensional array as a list of rows,
witheachrowitselfbeingalistofvalues. Forexample,thetwo-dimensional data
22 18 709 5 33
45 32 830 120 750
4 880 45 66 61
mightbestoredinPythonasfollows.
data = [ [22, 18, 709, 5, 33], [45, 32, 830, 120, 750], [4, 880, 45, 66, 61] ]
An advantage of this representation is that we can naturally use a syntax such
as data[1][3] to represent the value that has row index 1 and column index 3, as220 Chapter5. Array-BasedSequences
Constructing a Multidimensional List
To quickly initialize a one-dimensional list, we generallyrely on a syntax such as
data = [0] n to create a list of n zeros. On page 189, we emphasized that from
a technical perspective, this creates a list of length n with all entries referencing
the same integer instance, but that there was no meaningful consequence of such
aliasing becauseoftheimmutability oftheintclassinPython.
We have to be considerably more careful when creating a list of lists. If our
goalweretocreatetheequivalentofatwo-dimensional listofintegers,withrrows
and c columns, and to initialize all values to zero, a ﬂawed approach might be to
trythecommand
data = ([0] c) r # Warning: this is a mistake
While([0] c)isindeedalistofczeros,multiplyingthatlistbyrunfortunatelycre-
atesasinglelistwithlengthr·c,justas[2,4,6] 2resultsinlist[2, 4, 6, 2, 4, 6].
Abetter,yetstillﬂawedattemptistomakealistthatcontainsthelistofczeros
as its only element, and then to multiply that list by r. That is, we could try the
command
data = [ [0] c ] r # Warning: still a mistake
Thisismuchcloser,asweactuallydohaveastructurethatisformallyalistoflists.
Theproblemisthatallrentriesofthelistknownasdataarereferencestothesame
instance ofalistofczeros. Figure5.23provides aportrayal ofsuchaliasing.
0 0 0 0 0 0
0 1 2 3 4 5
data:
0 1 2
Figure5.23:Aﬂawedrepresentationofa3×6datasetasalistoflists,createdwith
thecommanddata = [ [0] 6 ] 3. (Forsimplicity, weoverlookthefactthatthe
valuesinthesecondary listarereferential.)
This is truly a problem. Setting an entry such as data[2][0] = 100 would change
the ﬁrst entry of the secondary list to reference a new value, 100. Yet that cell of
the secondary list also represents the value data[0][0], because “row” data[0] and5.6. MultidimensionalDataSets 221
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 3 4 5 0 1 2 3 4 5 0 1 2 3 4 5
data:
0 1 2
Figure5.24: Avalidrepresentation ofa3×6datasetasalistoflists. (Forsimplic-
ity,weoverlookthefactthatthevaluesinthesecondary listsarereferential.)
To properly initialize a two-dimensional list, we must ensure that each cell of
the primary list refers to an independent instance of a secondary list. This can be
accomplished throughtheuseofPython’slistcomprehension syntax.
data = [ [0] c for j in range(r) ]
This command produces a valid conﬁguration, similar to the one shown in Fig-
ure 5.24. By using list comprehension, the expression [0] c is reevaluated for
eachpassoftheembeddedforloop. Therefore,wegetrdistinctsecondarylists,as
desired. (Wenotethatthevariable jinthatcommandisirrelevant; wesimplyneed
aforloopthatiteratesrtimes.)
Two-Dimensional Arrays and Positional Games
Many computer games, be they strategy games, simulation games, or ﬁrst-person
conﬂictgames,involveobjectsthatresideinatwo-dimensionalspace. Softwarefor
suchpositionalgamesneedawayofrepresentingsuchatwo-dimensional“board,”
andinPythonthelistoflistsisanaturalchoice.
Tic-Tac-Toe
As most school children know, Tic-Tac-Toe is a game played in a three-by-three
board. Two players—X and O—alternate in placing their respective marks in the
cellsofthisboard, starting withplayerX.Ifeitherplayersucceeds ingettingthree
ofhisorhermarksinarow,column,ordiagonal, thenthatplayerwins.
This is admittedly not a sophisticated positional game, and it’s not even that
muchfuntoplay,sinceagoodplayerOcanalwaysforceatie. Tic-Tac-Toe’ssaving
grace isthatitisanice, simple exampleshowing howtwo-dimensional arrays can
be used for positional games. Software for more sophisticated positional games,
suchascheckers,chess,orthepopularsimulationgames,areallbasedonthesame222 Chapter5. Array-BasedSequences
Our representation of a 3×3 board will be a list of lists of characters, with
X or O designating a player’s move, or designating an empty space. For
example,theboardconﬁguration
O X O
X
O X
willbestoredinternally as
[ [ O , X , O ], [ , X , ], [ , O , X ] ]
We develop a complete Python class for maintaining a Tic-Tac-Toe board for
two players. That class will keep track of the moves and report a winner, but it
does not perform any strategy or allow someone to play Tic-Tac-Toe against the
computer. The details of such aprogram are beyond the scope of this chapter, but
itmightnonetheless makeagoodcourseproject (seeExerciseP-8.68).
Before presenting the implementation of the class, we demonstrate its public
interface withasimpletestinCodeFragment5.12.
1 game = TicTacToe()
2 # X moves: # O moves:
3 game.mark(1, 1); game.mark(0, 2)
4 game.mark(2, 2); game.mark(0, 0)
5 game.mark(0, 1); game.mark(2, 1)
6 game.mark(1, 2); game.mark(1, 0)
7 game.mark(2, 0)
8
9 print(game)
10 winner = game.winner()
11 if winner is None:
12 print( Tie )
13 else:
14 print(winner, wins )
CodeFragment5.12: AsimpletestforourTic-Tac-Toeclass.
The basic operations are that a new game instance represents an empty board,
that the mark(i,j) method adds a mark at the given position for the current player
(withthesoftware managing thealternating ofturns), andthatthegameboard can
beprintedandthewinnerdetermined. ThecompletesourcecodefortheTicTacToe
class is given in Code Fragment 5.13. Our mark method performs error checking
to make sure that valid indices are sent, that the position isnot already occupied,5.6. MultidimensionalDataSets 223
1 class TicTacToe:
2 ”””Management of a Tic-Tac-Toe game (does not do strategy).”””
3
4 def init (self):
5 ”””Start a new game.”””
6 self. board = [ [ ] 3 for j in range(3) ]
7 self. player = X
8
9 def mark(self, i, j):
10 ”””Put an X or O mark at position (i,j) for next players turn.”””
11 if not (0 <= i <= 2and 0 <= j <= 2):
12 raise ValueError( Invalid board position )
13 if self. board[i][j] != :
14 raise ValueError( Board position occupied )
15 if self.winner( ) is not None:
16 raise ValueError( Game is already complete )
17 self. board[i][j] = self. player
18 if self. player == X :
19 self. player = O
20 else:
21 self. player = X
22
23 def is win(self, mark):
24 ”””Check whether the board conﬁguration is a win for the given player.”””
25 board = self. board # local variable for shorthand
26 return (mark == board[0][0] == board[0][1] == board[0][2]or # row 0
27 mark == board[1][0] == board[1][1] == board[1][2]or # row 1
28 mark == board[2][0] == board[2][1] == board[2][2]or # row 2
29 mark == board[0][0] == board[1][0] == board[2][0]or # column 0
30 mark == board[0][1] == board[1][1] == board[2][1]or # column 1
31 mark == board[0][2] == board[1][2] == board[2][2]or # column 2
32 mark == board[0][0] == board[1][1] == board[2][2]or # diagonal
33 mark == board[0][2] == board[1][1] == board[2][0]) # rev diag
34
35 def winner(self):
36 ”””Return mark of winning player, or None to indicate a tie.”””
37 for mark in XO :
38 if self. is win(mark):
39 return mark
40 return None
41
42 def str (self):
43 ”””Return string representation of current game board.”””
44 rows = [ | .join(self. board[r]) for r in range(3)]
45 return \n-----\n .join(rows)224 Chapter5. Array-BasedSequences
5.7 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-5.1 Executetheexperiment fromCodeFragment5.1andcomparetheresults
onyoursystemtothosewereportinCodeFragment5.2.
R-5.2 InCodeFragment5.1,weperformanexperimenttocomparethelengthof
a Python list to its underlying memory usage. Determining the sequence
ofarray sizes requires amanual inspection ofthe output of thatprogram.
Redesigntheexperimentsothattheprogram outputsonlythosevaluesof
k at which the existing capacity is exhausted. For example, on a system
consistent with the results of Code Fragment 5.2, your program should
outputthatthesequence ofarraycapacities are0,4,8,16,25,....
R-5.3 Modify the experiment from Code Fragment 5.1 in order to demonstrate
thatPython’slistclassoccasionallyshrinksthesizeofitsunderlyingarray
whenelementsarepopped fromalist.
R-5.4 OurDynamicArrayclass,asgiveninCodeFragment5.3,doesnotsupport
use of negative indices with getitem . Update that method to better
matchthesemanticsofaPythonlist.
R-5.5 Redo the justiﬁcation of Proposition 5.1 assuming that the the cost of
growing the array from size k to size 2k is 3k cyber-dollars. How much
shouldeachappendoperationbechargedtomaketheamortizationwork?
R-5.6 Our implementation of insert for the DynamicArray class, as given in
CodeFragment5.5,hasthefollowinginefﬁciency. Inthecasewhenare-
size occurs, the resize operation takes time to copy all the elements from
an old array to a new array, and then the subsequent loop in thebody of
insert shifts many of those elements. Give an improved implementation
of the insert method, so that, in the case of a resize, the elements are
shiftedintotheirﬁnalpositionduringthatoperation, therebyavoiding the
subsequent shifting.
R-5.7 LetAbeanarrayofsizen≥2containing integers from1ton−1,inclu-
sive, with exactly one repeated. Describe a fast algorithm for ﬁnding the
integerinAthatisrepeated.
R-5.8 Experimentally evaluate theefﬁciency ofthepopmethod ofPython’slist
class when using varying indices as a parameter, as we did forinsert on5.7. Exercises 225
R-5.9 Explain the changes that would have to be made to the program of Code
Fragment 5.11 so that it could perform the Caesar cipher for messages
thatarewritteninanalphabet-based language otherthanEnglish,suchas
Greek,Russian,orHebrew.
R-5.10 The constructor for the CaesarCipher class in Code Fragment 5.11 can
be implemented with a two-line body by building the forward and back-
ward strings using a combination of the join method and an appropriate
comprehension syntax. Givesuchanimplementation.
R-5.11 Use standard control structures to compute the sum of all numbers in an
n×ndataset,represented asalistoflists.
R-5.12 Describe how the built-in sum function can be combined with Python’s
comprehension syntaxtocomputethesumofallnumbersinann×ndata
set,represented asalistoflists.
Creativity
C-5.13 In the experiment of Code Fragment 5.1, we begin with an emptylist. If
datawereinitially constructed withnonempty length, doesthisaffectthe
sequence of values at which the underlying array is expanded? Perform
yourownexperiments,andcommentonanyrelationshipyouseebetween
theinitiallengthandtheexpansion sequence.
C-5.14 The shuﬄe method, supported by the random module, takes a Python
list and rearranges it so that every possible ordering is equally likely.
Implement your own version of such a function. You may rely on the
randrange(n) function of the random module, which returns a random
numberbetween0andn−1inclusive.
C-5.15 Consider an implementation of a dynamic array, but instead of copying
theelementsintoanarrayofdoublethesize(thatis,fromN to2N)when
its capacity is reached, we copy the elements into an array with (cid:13)N/4(cid:14)
additionalcells,goingfromcapacityN tocapacityN+(cid:13)N/4(cid:14). Provethat
performing a sequence of n append operations still runs in O(n) time in
thiscase.
C-5.16 ImplementapopmethodfortheDynamicArrayclass,giveninCodeFrag-
ment 5.3, that removes the last element of the array, and thatshrinks the
capacity, N, of the array by half any time the number of elements in the
arraygoesbelowN/4.
C-5.17 Prove that when using a dynamic array that grows and shrinks as in the
previous exercise, the following series of 2n operations takes O(n) time:
nappendoperations onaninitially emptyarray, followed bynpopoper-226 Chapter5. Array-BasedSequences
C-5.18 Give a formal proof that any sequence of n appendor pop operations on
an initially empty dynamic array takes O(n) time, if using the strategy
described inExerciseC-5.16.
C-5.19 Consider avariant ofExercise C-5.16, inwhich anarray ofcapacity N is
resized tocapacity precisely thatofthenumberofelements, anytimethe
number of elements in the array goes strictly below N/4. Give a formal
proof that any sequence of n append or pop operations on an initially
emptydynamicarraytakesO(n)time.
C-5.20 ConsideravariantofExerciseC-5.16,inwhichanarrayofcapacity N,is
resized tocapacity precisely thatofthenumberofelements, anytimethe
numberofelements inthearraygoesstrictly belowN/2. Showthatthere
existsasequence ofnoperations thatrequiresΩ(n2)timetoexecute.
C-5.21 In Section 5.4.2, we described four different ways to compose a long
string: (1) repeated concatenation, (2) appending to a temporary list and
thenjoining,(3)usinglistcomprehensionwithjoin,and(4)usinggenera-
torcomprehension withjoin. Developanexperimenttotesttheefﬁciency
ofallfouroftheseapproaches andreportyourﬁndings.
C-5.22 Develop an experiment to compare the relative efﬁciency of the extend
method of Python’s list class versus using repeated calls to append to
accomplish theequivalent task.
C-5.23 Based on the discussion of page 207, develop an experiment tocompare
the efﬁciency ofPython’s list comprehension syntax versusthe construc-
tionofalistbymeansofrepeatedcallstoappend.
C-5.24 Perform experiments to evaluate the efﬁciency of the remove method of
Python’slistclass,aswedidforinsertonpage205. Useknownvaluesso
that all removals occur either at the beginning, middle, or end of the list.
ReportyourresultsakintoTable5.5.
C-5.25 Thesyntaxdata.remove(value)forPythonlistdataremovesonlytheﬁrst
occurrence of element value from the list. Give an implementation of a
function, withsignatureremove all(data, value),thatremovesalloccur-
rences of valuefrom the given list, such that the worst-case running time
ofthefunctionisO(n)onalistwithnelements. Notthatitisnotefﬁcient
enoughingeneraltorelyonrepeated callstoremove.
C-5.26 LetBbeanarrayofsizen≥6containing integers from1ton−5,inclu-
sive,withexactlyﬁverepeated. Describeagoodalgorithmforﬁndingthe
ﬁveintegersinBthatarerepeated.
C-5.27 Given a Python list L of n positive integers, each represented with k =
(cid:13)logn(cid:14)+1 bits, describe anO(n)-time method for ﬁnding ak-bit integer
notinL.ChapterNotes 227
C-5.29 Ausefuloperation indatabases isthenaturaljoin. Ifweviewadatabase
as a list of ordered pairs of objects, then the natural join of databases A
and B is the list of all ordered triples (x,y,z) such that the pair (x,y) isin
A and the pair (y,z) is in B. Describe and analyze an efﬁcient algorithm
forcomputingthenaturaljoinofalistAofnpairsandalistBofmpairs.
C-5.30 WhenBobwantstosendAliceamessageM ontheInternet, hebreaksM
into n data packets, numbers the packets consecutively, and injects them
into the network. When the packets arrive at Alice’s computer, they may
beoutoforder,soAlicemustassemblethesequenceofnpacketsinorder
before she can be sure she has the entire message. Describe an efﬁcient
schemeforAlicetodothis,assumingthatsheknowsthevalueofn. What
istherunning timeofthisalgorithm?
C-5.31 Describe a way to use recursion to add all the numbers in an n×n data
set,represented asalistoflists.
Projects
P-5.32 Write a Python function that takes two three-dimensional numeric data
setsandaddsthemcomponentwise.
P-5.33 WriteaPythonprogram foramatrixclassthatcanaddandmultiplytwo-
dimensional arraysofnumbers, assuming thedimensions agreeappropri-
atelyfortheoperation.
P-5.34 WriteaprogramthatcanperformtheCaesarcipherforEnglishmessages
thatinclude bothupper-andlowercasecharacters.
P-5.35 Implement a class, SubstitutionCipher, with a constructor that takes a
string withthe 26uppercase letters inan arbitrary order and uses that for
the forward mapping for encryption (akin to the self. forward string in
our CaesarCipher class of Code Fragment 5.11). You should derive the
backwardmappingfromtheforwardversion.
P-5.36 Redesign the CaesarCipher class as a subclass of the SubstitutionCipher
fromtheprevious problem.
P-5.37 Design a RandomCipher class as a subclass of the SubstitutionCipher
fromExerciseP-5.35,sothateachinstanceoftheclassreliesonarandom
permutation oflettersforitsmapping.
Chapter Notes
Thefundamentaldatastructuresofarraysbelongtothefolkloreofcomputerscience. They
were ﬁrst chronicled in the computer science literature by Knuth in his seminal book onChapter
6
Stacks, Queues, and Deques
Contents
6.1 Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
6.1.1 The Stack Abstract Data Type . . . . . . . . . . . . . . . 230
6.1.2 Simple Array-Based Stack Implementation . . . . . . . . . 231
6.1.3 Reversing Data Using a Stack . . . . . . . . . . . . . . . 235
6.1.4 Matching Parentheses and HTML Tags . . . . . . . . . . 236
6.2 Queues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
6.2.1 The Queue Abstract Data Type . . . . . . . . . . . . . . 240
6.2.2 Array-Based Queue Implementation . . . . . . . . . . . . 241
6.3 Double-Ended Queues . . . . . . . . . . . . . . . . . . . . . 247
6.3.1 The Deque Abstract Data Type . . . . . . . . . . . . . . 247
6.3.2 Implementing a Deque with a Circular Array . . . . . . . . 248
6.3.3 Deques in the Python Collections Module . . . . . . . . . 2496.1. Stacks 229
6.1 Stacks
A stack is a collection of objects that are inserted and removed according to the
last-in, ﬁrst-out (LIFO) principle. A user may insert objects into a stack at any
time,butmayonlyaccessorremovethemostrecentlyinsertedobjectthatremains
(attheso-called“top”ofthestack). Thename“stack”isderivedfromthemetaphor
of a stack of plates in a spring-loaded, cafeteria plate dispenser. In this case, the
fundamentaloperationsinvolvethe“pushing”and“popping”ofplatesonthestack.
Whenweneedanewplatefromthedispenser, we“pop”thetopplateoffthestack,
and when we add a plate, we “push” it down on the stack to become the new top
plate. Perhaps an even more amusing example is a PEZ® candy dispenser, which
storesmintcandies inaspring-loaded container that“pops”outthetopmostcandy
in the stack when the top of the dispenser is lifted (see Figure 6.1). Stacks are
a fundamental data structure. They are used in many applications, including the
following.
Example 6.1: InternetWebbrowsersstoretheaddressesofrecentlyvisitedsites
inastack.Eachtimeauservisitsanewsite,thatsite’saddressis“pushed”ontothe
stackofaddresses. Thebrowserthenallowstheuserto“pop”backtopreviously
visitedsitesusingthe“back”button.
Example 6.2: Texteditorsusuallyprovidean“undo”mechanismthatcancelsre-
centeditingoperationsandrevertstoformerstatesofadocument.Thisundooper-
ationcanbeaccomplishedbykeepingtextchangesinastack.
Figure6.1: A schematic drawing of a PEZ® dispenser; a physical implementation230 Chapter6. Stacks,Queues,andDeques
6.1.1 The Stack Abstract Data Type
Stacks are the simplest of all data structures, yet they are also among the most
important. Theyareusedinahostofdifferent applications, andasatoolformany
more sophisticated data structures and algorithms. Formally, astack isan abstract
datatype(ADT)suchthataninstanceSsupports thefollowingtwomethods:
S.push(e): AddelementetothetopofstackS.
S.pop(): RemoveandreturnthetopelementfromthestackS;
anerroroccursifthestackisempty.
Additionally, letusdeﬁnethefollowingaccessor methodsforconvenience:
S.top(): Returnareference tothetopelementofstackS,without
removingit;anerroroccursifthestackisempty.
S.is empty(): ReturnTrueifstackSdoesnotcontain anyelements.
len(S): ReturnthenumberofelementsinstackS;inPython,we
implementthiswiththespecial method len .
Byconvention, weassumethatanewlycreated stackisempty,andthatthereisno
a priori bound on the capacity of the stack. Elements added tothe stack can have
arbitrary type.
Example 6.3: Thefollowingtableshowsaseriesofstackoperationsandtheir
effectsonaninitiallyemptystackSofintegers.
Operation ReturnValue StackContents
S.push(5) – [5]
S.push(3) – [5, 3]
len(S) 2 [5, 3]
S.pop() 3 [5]
S.is empty() False [5]
S.pop() 5 [ ]
S.is empty() True [ ]
S.pop() “error” [ ]
S.push(7) – [7]
S.push(9) – [7, 9]
S.top() 9 [7, 9]
S.push(4) – [7, 9, 4]
len(S) 3 [7, 9, 4]
S.pop() 4 [7, 9]
S.push(6) – [7, 9, 6]
S.push(8) – [7, 9, 6, 8]6.1. Stacks 231
6.1.2 Simple Array-Based Stack Implementation
WecanimplementastackquiteeasilybystoringitselementsinaPythonlist. The
list class already supports adding an element to the end with theappend method,
andremovingthelastelementwiththepopmethod,soitisnaturaltoalignthetop
ofthestackattheendofthelist,asshowninFigure6.2.
A B C D E F G K L M
0 1 2 top
Figure6.2: Implementing a stack with aPython list, storing the top element in the
rightmostcell.
Although a programmer could directly use the list class in place of a formal
stack class, lists also include behaviors (e.g., adding or removing elements from
arbitrarypositions) thatwouldbreaktheabstraction thatthestackADTrepresents.
Also,theterminologyusedbythelistclassdoesnotpreciselyalignwithtraditional
nomenclature for a stack ADT, in particular the distinction between append and
push. Instead,wedemonstratehowtousealistforinternalstoragewhileproviding
apublicinterface consistent withastack.
The Adapter Pattern
The adapter design pattern applies to any context where we effectively want to
modifyanexisting class sothatitsmethods matchthose ofarelated, butdifferent,
class or interface. One general way to apply the adapter pattern is to deﬁne a new
class in such a way that it contains an instance of the existing class as a hidden
ﬁeld, and then to implement each method of the new class using methods of this
hidden instance variable. By applying the adapter pattern in this way, we have
created a new class that performs some of the same functions as an existing class,
butrepackaged inamoreconvenient way. InthecontextofthestackADT,wecan
adaptPython’slistclassusingthecorrespondences showninTable6.1.
StackMethod Realization withPythonlist
S.push(e) L.append(e)
S.pop() L.pop()
S.top() L[−1]
S.is empty() len(L) == 0
len(S) len(L)232 Chapter6. Stacks,Queues,andDeques
Implementing a Stack Using a Python List
We use the adapter design pattern to deﬁne an ArrayStack class that uses an un-
derlying Python list for storage. (We choose the name ArrayStack to emphasize
thattheunderlying storageisinherently arraybased.) Onequestionthatremainsis
what our code should do if a user calls pop or top when the stack is empty. Our
ADT suggests that an error occurs, but we must decide what type of error. When
popis called on an empty Python list, it formally raises an IndexError, as lists are
index-based sequences. That choice does not seem appropriate for a stack, since
thereisnoassumptionofindices. Instead,wecandeﬁneanewexceptionclassthat
is more appropriate. Code Fragment 6.1 deﬁnes such an Empty class as a trivial
subclass ofthePythonExceptionclass.
class Empty(Exception):
”””Error attempting to access an element from an empty container.”””
pass
CodeFragment6.1: DeﬁnitionforanEmptyexception class.
Theformal deﬁnition for ourArrayStackclass is given in CodeFragment 6.2.
Theconstructorestablishesthememberself. dataasaninitiallyemptyPythonlist,
forinternal storage. Therest ofthepublic stack behaviorsareimplemented, using
thecorresponding adaptation thatwasoutlined inTable6.1.
Example Usage
Below, we present an example of the use of our ArrayStack class, mirroring the
operations atthebeginning ofExample6.3onpage230.
S = ArrayStack( ) # contents: [ ]
S.push(5) # contents: [5]
S.push(3) # contents: [5, 3]
print(len(S)) # contents: [5, 3]; outputs 2
print(S.pop()) # contents: [5]; outputs 3
print(S.is empty()) # contents: [5]; outputs False
print(S.pop()) # contents: [ ]; outputs 5
print(S.is empty()) # contents: [ ]; outputs True
S.push(7) # contents: [7]
S.push(9) # contents: [7, 9]
print(S.top()) # contents: [7, 9]; outputs 9
S.push(4) # contents: [7, 9, 4]
print(len(S)) # contents: [7, 9, 4]; outputs 3
print(S.pop()) # contents: [7, 9]; outputs 46.1. Stacks 233
1 class ArrayStack:
2 ”””LIFO Stack implementation using a Python list as underlying storage.”””
3
4 def init (self):
5 ”””Create an empty stack.”””
6 self. data = [ ] # nonpublic list instance
7
8 def len (self):
9 ”””Return the number of elements in the stack.”””
10 return len(self. data)
11
12 def is empty(self):
13 ”””Return True if the stack is empty.”””
14 return len(self. data) == 0
15
16 def push(self, e):
17 ”””Add element e to the top of the stack.”””
18 self. data.append(e) # new item stored at end of list
19
20 def top(self):
21 ”””Return (but do not remove) the element at the top of the stack.
22
23 Raise Empty exception if the stack is empty.
24 ”””
25 if self.is empty():
26 raise Empty( Stack is empty )
27 return self. data[−1] # the last item in the list
28
29 def pop(self):
30 ”””Remove and return the element from the top of the stack (i.e., LIFO).
31
32 Raise Empty exception if the stack is empty.
33 ”””
34 if self.is empty():
35 raise Empty( Stack is empty )
36 return self. data.pop( ) # remove last item from list234 Chapter6. Stacks,Queues,andDeques
Analyzing the Array-Based Stack Implementation
Table 6.2 shows the running times for our ArrayStack methods. The analysis di-
rectly mirrors the analysis of the list class given in Section 5.3. The implementa-
tionsfortop,is empty,andlenuseconstant timeintheworstcase. TheO(1)time
for pushand popare amortized bounds (see Section 5.3.2); atypical call to either
of these methods uses constant time, but there is occasionally an O(n)-time worst
case, where n is the current number of elements in the stack, when an operation
causesthelisttoresizeitsinternalarray. ThespaceusageforastackisO(n).
Operation RunningTime
S.push(e) O(1)∗
S.pop() O(1)∗
S.top() O(1)
S.is empty() O(1)
len(S) O(1)
∗
amortized
Table 6.2: Performance of our array-based stack implementation. The bounds for
push and pop are amortized due to similar bounds for the list class. The space
usageisO(n),wherenisthecurrent numberofelementsinthestack.
Avoiding Amortization by Reserving Capacity
Insomecontexts,theremaybeadditionalknowledgethatsuggestsamaximumsize
thatastackwillreach. OurimplementationofArrayStackfromCodeFragment6.2
begins with an empty list and expands as needed. In the analysis of lists from
Section 5.4.1, weemphasized that itismoreefﬁcient in practice toconstruct alist
with initial length n than it is to start with an empty list and append n items (even
thoughbothapproaches runinO(n)time).
As an alternate model for a stack, wemight wish for the constructor to accept
aparameterspecifying themaximumcapacityofastackandtoinitializethe data
member to a list of that length. Implementing such a model requires signiﬁcant
changes relative to Code Fragment 6.2. The size of the stack would no longer be
synonymouswiththelengthofthelist,andpushesandpopsofthestackwouldnot
require changing the length of the list. Instead, wesuggestmaintaining aseparate
integer as an instance variable that denotes the current number of elements in the6.1. Stacks 235
6.1.3 Reversing Data Using a Stack
As a consequence of the LIFO protocol, a stack can be used as a general tool to
reverse a data sequence. For example, if the values 1, 2, and 3are pushed onto a
stackinthatorder, theywillbepoppedfromthestackintheorder3,2,andthen1.
This idea can be applied in a variety of settings. For example, we might wish
to print lines of a ﬁle in reverse order in order to display a data set in decreasing
order rather than increasing order. This can be accomplished by reading each line
andpushing itontoastack,andthenwritingthelinesintheordertheyarepopped.
Animplementation ofsuchaprocess isgiveninCodeFragment6.3.
1 def reverse ﬁle(ﬁlename):
2 ”””Overwrite given ﬁle with its contents line-by-line reversed.”””
3 S = ArrayStack()
4 original = open(ﬁlename)
5 for line in original:
6 S.push(line.rstrip( \n )) # we will re-insert newlines when writing
7 original.close()
8
9 # now we overwrite with contents in LIFO order
10 output = open(ﬁlename, w ) # reopening ﬁle overwrites original
11 while not S.is empty():
12 output.write(S.pop( ) + \n ) # re-insert newline characters
13 output.close()
CodeFragment6.3: Afunction thatreversestheorderoflinesinaﬁle.
Onetechnicaldetailworthnotingisthatweintentionallystriptrailingnewlines
fromlinesastheyareread,andthenre-insertnewlinesaftereachlinewhenwriting
theresulting ﬁle. Ourreason fordoing thisistohandle aspecial caseinwhichthe
originalﬁledoesnothaveatrailingnewlinefortheﬁnalline. Ifweexactlyechoed
thelinesreadfromtheﬁleinreverseorder,thentheoriginallastlinewouldbefol-
lowed(withoutnewline)bytheoriginalsecond-to-lastline. Inourimplementation,
weensurethattherewillbeaseparating newlineintheresult.
The idea of using a stack to reverse a data set can be applied toother types of
sequences. Forexample, Exercise R-6.5 explores the use of astack to provide yet
anothersolution forreversingthecontents ofaPythonlist(arecursivesolution for
this goal was discussed in Section 4.4.1). A more challenging task is to reverse
the order in which elements are stored within a stack. If we were to move them
from one stack to another, they would be reversed, but if we were to then replace
themintotheoriginalstack,theywouldbereversedagain,therebyrevertingtotheir236 Chapter6. Stacks,Queues,andDeques
6.1.4 Matching Parentheses and HTML Tags
In this subsection, we explore two related applications of stacks, both of which
involvetestingforpairsofmatchingdelimiters. Inourﬁrstapplication,weconsider
arithmeticexpressionsthatmaycontainvariouspairsofgroupingsymbols,suchas
• Parentheses: “(”and“)”
• Braces: “{”and“}”
• Brackets: “[”and“]”
Eachopeningsymbolmustmatchitscorrespondingclosingsymbol. Forexample,a
leftbracket,“[,”mustmatchacorrespondingrightbracket,“],”asintheexpression
[(5+x)-(y+z)]. Thefollowingexamplesfurtherillustratethisconcept:
• Correct: ()(()){([()])}
• Correct: ((()(()){([()])}))
• Incorrect: )(()){([()])}
• Incorrect: ({[])}
• Incorrect: (
WeleavetheprecisedeﬁnitionofamatchinggroupofsymbolstoExerciseR-6.6.
An Algorithm for Matching Delimiters
An important task when processing arithmetic expressions is to make sure their
delimiting symbols match up correctly. Code Fragment 6.4 presents a Python im-
plementation ofsuchanalgorithm. Adiscussion ofthecodefollows.
1 def is matched(expr):
2 ”””Return True if all delimiters are properly match; False otherwise.”””
3 lefty = ({[ # opening delimiters
4 righty = )}] # respective closing delims
5 S = ArrayStack()
6 for c in expr:
7 if c in lefty:
8 S.push(c) # push left delimiter on stack
9 elif c in righty:
10 if S.is empty():
11 return False # nothing to match with
12 if righty.index(c) != lefty.index(S.pop()):
13 return False # mismatched
14 return S.is empty( ) # were all symbols matched?6.1. Stacks 237
We assume the input is a sequence of characters, such as [(5+x)-(y+z)] .
Weperformaleft-to-rightscanoftheoriginalsequence,usingastackStofacilitate
the matching of grouping symbols. Each time we encounter an opening symbol,
wepushthatsymbolontoS,andeachtimeweencounter aclosingsymbol,wepop
a symbol from the stack S (assuming S is not empty), and check that these two
symbols form a valid pair. If we reach the end of the expression and the stack is
empty, then the original expression was properly matched. Otherwise, there must
beanopening delimiteronthestackwithoutamatchingsymbol.
If the length of the original expression is n, the algorithm will make at most
ncallstopushandncallstopop. ThosecallsruninatotalofO(n)time,evencon-
sideringtheamortizednatureoftheO(1)timeboundforthosemethods. Giventhat
our selection of possible delimiters, ({[, has constant size, auxiliary tests such as
c in lefty and righty.index(c) each run inO(1) time. Combining these operations,
thematchingalgorithm onasequence oflengthnrunsinO(n)time.
Matching Tags in a Markup Language
Anotherapplicationofmatchingdelimitersisinthevalidationofmarkuplanguages
such asHTMLorXML.HTMListhestandard formatforhyperlinked documents
on the Internet and XML is an extensible markup language used for a variety of
structured datasets. WeshowasampleHTMLdocument andapossible rendering
inFigure6.3.
<body>
<center>
The Little Boat
<h1> The Little Boat </h1>
</center>
<p> The storm tossed the little The storm tossed the little boat
boat like a cheap sneaker in an like a cheap sneaker in an
old washing machine. The three
old washing machine. The three
drunken fishermen were used to
drunken ﬁshermen were used to
such treatment, of course, but
suchtreatment,ofcourse,butnot
not the tree salesman, who even as
the tree salesman, who even as
a stowaway now felt that he
had overpaid for the voyage. </p> a stowaway now felt that he had
<ol> overpaidforthevoyage.
<li> Will the salesman die? </li> 1. Willthesalesmandie?
<li> What color is the boat? </li>
2. Whatcoloristheboat?
<li> And what about Naomi? </li>
3. AndwhataboutNaomi?
</ol>
</body>
(a) (b)238 Chapter6. Stacks,Queues,andDeques
InanHTMLdocument,portionsoftextaredelimitedbyHTMLtags. Asimple
opening HTMLtag has the form “<name>”and the corresponding closing tag has
the form “</name>”. For example, we see the <body> tag on the ﬁrst line of
Figure 6.3(a), and the matching</body>tag at the close ofthat document. Other
commonlyusedHTMLtagsthatareusedinthisexampleinclude:
• body: document body
• h1: sectionheader
• center: centerjustify
• p: paragraph
• ol: numbered(ordered) list
• li: listitem
Ideally, an HTML document should have matching tags, although most browsers
tolerate a certain number of mismatching tags. In Code Fragment 6.5, we give a
PythonfunctionthatmatchestagsinastringrepresentinganHTMLdocument. We
makealeft-to-right passthroughtherawstring, usingindexjtotrackourprogress
andtheﬁndmethodofthestrclasstolocatethe < and > charactersthatdeﬁne
thetags. Openingtagsarepushed ontothestack, andmatchedagainstclosing tags
astheyarepoppedfromthestack,justaswedidwhenmatchingdelimitersinCode
Fragment6.4. Bysimilaranalysis, thisalgorithm runsinO(n)time,wherenisthe
numberofcharacters intherawHTMLsource.
1 def is matched html(raw):
2 ”””Return True if all HTML tags are properly match; False otherwise.”””
3 S = ArrayStack()
4 j = raw.ﬁnd( < ) # ﬁnd ﬁrst ’<’ character (if any)
5 while j != −1:
6 k = raw.ﬁnd( > , j+1) # ﬁnd next ’>’ character
7 if k == −1:
8 return False # invalid tag
9 tag = raw[j+1:k] # strip away < >
10 if not tag.startswith( / ): # this is opening tag
11 S.push(tag)
12 else: # this is closing tag
13 if S.is empty():
14 return False # nothing to match with
15 if tag[1:] != S.pop():
16 return False # mismatched delimiter
17 j = raw.ﬁnd( < , k+1) # ﬁnd next ’<’ character (if any)
18 return S.is empty( ) # were all opening tags matched?6.2. Queues 239
6.2 Queues
Anotherfundamentaldatastructureisthequeue. Itisaclose“cousin”ofthestack,
asaqueue isacollection ofobjects thatareinserted andremovedaccording tothe
ﬁrst-in, ﬁrst-out (FIFO) principle. That is, elements can be inserted at any time,
butonlytheelementthathasbeeninthequeuethelongestcanbenextremoved.
We usually say that elements enter a queue at the back and are removed from
the front. A metaphor for this terminology is aline ofpeoplewaiting to get on an
amusement park ride. People waiting for such a ride enter at the back of the line
and get on the ride from the front of the line. There are many other applications
of queues (see Figure 6.4). Stores, theaters, reservation centers, and other similar
services typically process customer requests according to the FIFO principle. A
queue would therefore be a logical choice for a data structure to handle calls to a
customerservicecenter,orawait-listatarestaurant. FIFOqueuesarealsousedby
manycomputing devices, such asanetworked printer, oraWebserver responding
torequests.
Tickets
(a)
C all C e nter
Call Queue
(b)
Figure6.4: Real-worldexamplesofaﬁrst-in,ﬁrst-outqueue. (a)Peoplewaitingin240 Chapter6. Stacks,Queues,andDeques
6.2.1 The Queue Abstract Data Type
Formally, the queue abstract data type deﬁnes a collection that keeps objects in a
sequence, where element access and deletion are restricted to the ﬁrst element in
the queue, and element insertion is restricted to the back of the sequence. This
restriction enforces the rule that items are inserted and deleted in a queue accord-
ing to the ﬁrst-in, ﬁrst-out (FIFO) principle. Thequeue abstract data type (ADT)
supports thefollowingtwofundamental methodsforaqueueQ:
Q.enqueue(e): AddelementetothebackofqueueQ.
Q.dequeue(): RemoveandreturntheﬁrstelementfromqueueQ;
anerroroccursifthequeueisempty.
The queue ADT also includes the following supporting methods (with ﬁrst being
analogous tothestack’stopmethod):
Q.ﬁrst(): ReturnareferencetotheelementatthefrontofqueueQ,
withoutremovingit;anerroroccursifthequeueisempty.
Q.is empty(): ReturnTrueifqueueQdoesnotcontainanyelements.
len(Q): Return the number of elements in queue Q; in Python,
weimplementthiswiththespecialmethod len .
Byconvention, weassume that anewly created queue is empty,and that there
isnoaprioriboundonthecapacity ofthequeue. Elementsaddedtothequeuecan
havearbitrary type.
Example 6.4: Thefollowingtableshowsaseriesofqueueoperationsandtheir
effectsonaninitiallyemptyqueueQofintegers.
Operation ReturnValue ﬁrst←Q←last
Q.enqueue(5) – [5]
Q.enqueue(3) – [5, 3]
len(Q) 2 [5, 3]
Q.dequeue() 5 [3]
Q.is empty() False [3]
Q.dequeue() 3 [ ]
Q.is empty() True [ ]
Q.dequeue() “error” [ ]
Q.enqueue(7) – [7]
Q.enqueue(9) – [7, 9]
Q.ﬁrst() 7 [7, 9]
Q.enqueue(4) – [7, 9, 4]
len(Q) 3 [7, 9, 4]6.2. Queues 241
6.2.2 Array-Based Queue Implementation
For the stack ADT, we created a very simple adapter class that used a Python list
as the underlying storage. It may be very tempting to use a similar approach for
supporting the queue ADT. We could enqueue element e by calling append(e) to
addittotheendofthelist. Wecould usethesyntaxpop(0),asopposed topop(),
tointentionally removetheﬁrstelementfromthelistwhendequeuing.
As easy as this would be to implement, it is tragically inefﬁcient. As we dis-
cussed in Section 5.4.1, when pop is called on a list with a non-default index, a
loopisexecutedtoshiftallelementsbeyondthespeciﬁedindextotheleft,soasto
ﬁllthehole inthesequence caused bythepop. Therefore, acalltopop(0)always
causestheworst-casebehavior ofΘ(n)time.
We can improve on the above strategy by avoiding the call topop(0) entirely.
WecanreplacethedequeuedentryinthearraywithareferencetoNone,andmain-
tain an explicit variable f to store the index of the element that is currently at the
front of the queue. Such an algorithm fordequeue would run in O(1) time. After
severaldequeueoperations,thisapproachmightleadtotheconﬁgurationportrayed
inFigure6.5.
E F G K L M
0 1 2 f
Figure6.5: Allowingthefrontofthequeuetodriftawayfromindex0.
Unfortunately, there remains a drawback to the revised approach. In the case
ofastack, thelengthofthelistwasprecisely equaltothesizeofthestack(evenif
theunderlying arrayforthelistwasslightlylarger). Withthequeuedesignthatwe
areconsidering, thesituationisworse. Wecanbuildaqueuethathasrelativelyfew
elements,yetwhicharestoredinanarbitrarilylargelist. Thisoccurs,forexample,
if we repeatedly enqueue a new element and then dequeue another (allowing the
front to drift rightward). Over time, the size of the underlying list would grow to
O(m)where m is the total number of enqueue operations since the creation of the
queue, ratherthanthecurrent numberofelementsinthequeue.
This design would have detrimental consequences in applications in which
queues have relatively modest size, but which are used for long periods of time.
For example, the wait-list for a restaurant might never have more than 30 entries
atonetime,butoverthecourse ofaday(oraweek), theoverallnumberofentries242 Chapter6. Stacks,Queues,andDeques
Using an Array Circularly
Indevelopingamorerobustqueueimplementation,weallowthefrontofthequeue
todriftrightward,andweallowthecontentsofthequeueto“wraparound”theend
of an underlying array. We assume that our underlying array has ﬁxed length N
that is greater that the actual number of elements in the queue. New elements
are enqueued toward the “end” of the current queue, progressing from the front to
index N−1 and continuing at index 0, then 1. Figure 6.6 illustrates such a queue
withﬁrstelementEandlastelementM.
I J K L M E F G H
0 1 2 f N−1
Figure6.6: Modelingaqueuewithacircular arraythatwrapsaroundtheend.
Implementing this circular view is notdifﬁcult. Whenwedequeue anelement
andwantto“advance”thefrontindex,weusethearithmeticf = (f + 1) % N. Re-
callthatthe%operatorinPythondenotesthemodulooperator, whichiscomputed
bytakingtheremainderafteranintegraldivision. Forexample,14dividedby3has
aquotient of4withremainder2,thatis, 14 =42. SoinPython,14 // 3evaluates
3 3
tothequotient4,while14 % 3evaluatestotheremainder2. Themodulooperator
is ideal for treating an array circularly. As a concrete example, if we have a list
oflength 10,andafrontindex 7,wecanadvance thefrontbyformally computing
(7+1) % 10, which is simply 8, as 8 divided by 10 is 0 with a remainder of 8.
Similarly,advancingindex8resultsinindex9. Butwhenweadvancefromindex9
(thelastoneinthearray),wecompute(9+1) % 10,whichevaluatestoindex0(as
10dividedby10hasaremainderofzero).
A Python Queue Implementation
Acompleteimplementation ofaqueueADTusingaPythonlistincircularfashion
is presented in Code Fragments 6.6 and 6.7. Internally, the queue class maintains
thefollowingthreeinstance variables:
data: isareference toalistinstance withaﬁxedcapacity.
size: is an integer representing the current number of elements stored
inthequeue(asopposed tothelengthofthe datalist).
front: is an integer that represents the index within data of the ﬁrst
elementofthequeue(assuming thequeueisnotempty).
We initially reserve a list of moderate size for storing data, although the queue
formallyhassizezero. Asatechnicality, weinitialize the frontindextozero.
When front or dequeue are called with no elements in the queue, we raise an6.2. Queues 243
1 class ArrayQueue:
2 ”””FIFO queue implementation using a Python list as underlying storage.”””
3 DEFAULT CAPACITY = 10 # moderate capacity for all new queues
4
5 def init (self):
6 ”””Create an empty queue.”””
7 self. data = [None] ArrayQueue.DEFAULT CAPACITY
8 self. size = 0
9 self. front = 0
10
11 def len (self):
12 ”””Return the number of elements in the queue.”””
13 return self. size
14
15 def is empty(self):
16 ”””Return True if the queue is empty.”””
17 return self. size == 0
18
19 def ﬁrst(self):
20 ”””Return (but do not remove) the element at the front of the queue.
21
22 Raise Empty exception if the queue is empty.
23 ”””
24 if self.is empty():
25 raise Empty( Queue is empty )
26 return self. data[self. front]
27
28 def dequeue(self):
29 ”””Remove and return the ﬁrst element of the queue (i.e., FIFO).
30
31 Raise Empty exception if the queue is empty.
32 ”””
33 if self.is empty():
34 raise Empty( Queue is empty )
35 answer = self. data[self. front]
36 self. data[self. front] = None # help garbage collection
37 self. front = (self. front + 1) % len(self. data)
38 self. size −= 1
39 return answer
Code Fragment 6.6: Array-based implementation of a queue (continued in Code244 Chapter6. Stacks,Queues,andDeques
40 def enqueue(self, e):
41 ”””Add an element to the back of queue.”””
42 if self. size == len(self. data):
43 self. resize(2 len(self.data)) # double the array size
44 avail = (self. front + self. size) % len(self. data)
45 self. data[avail] = e
46 self. size += 1
47
48 def resize(self, cap): # we assume cap >= len(self)
49 ”””Resize to a new list of capacity >= len(self).”””
50 old = self. data # keep track of existing list
51 self. data = [None] cap # allocate list with new capacity
52 walk = self. front
53 for k in range(self. size): # only consider existing elements
54 self. data[k] = old[walk] # intentionally shift indices
55 walk = (1 + walk) % len(old) # use old size as modulus
56 self. front = 0 # front has been realigned
CodeFragment6.7: Array-basedimplementation ofaqueue(continued fromCode
Fragment6.6).
The implementation of len and is empty are trivial, given knowledge of
the size. The implementation of the front method is also simple, as the front
index tells us precisely where the desired element is located within the data list,
assumingthatlistisnotempty.
Adding and Removing Elements
Thegoal oftheenqueuemethod istoadd anewelement tothe back ofthequeue.
Weneedtodeterminetheproperindexatwhichtoplacethenewelement. Although
we do not explicitly maintain an instance variable for the back of the queue, we
computethelocationofthenextopening basedontheformula:
avail = (self. front + self. size) % len(self. data)
Notethatweareusing thesizeofthequeue asitexistsprior totheaddition ofthe
new element. Forexample, consider a queue with capacity 10,current size 3, and
ﬁrstelementatindex5. Thethreeelementsofsuchaqueuearestoredatindices5,
6, and 7. The new element should be placed at index(front+size)=8. In a case
with wrap-around, the use of the modular arithmetic achieves the desired circular
semantics. Forexample, if our hypothetical queue had 3 elements with the ﬁrst at
index 8,our computation of(8+3) % 10evaluates to1,which isperfect since the6.2. Queues 245
Whenthedequeuemethodiscalled, thecurrent valueofself. frontdesignates
the index of the value that is to be removed and returned. We keep a local refer-
ence to the element that will be returned, setting answer = self. data[self. front]
justpriortoremovingthereferencetothatobjectfromthelist,withtheassignment
self. data[self. front] = None. Our reason for the assignment to None relates to
Python’s mechanism for reclaiming unused space. Internally, Python maintains a
count of the number of references that exist to each object. If that count reaches
zero, theobject iseffectively inaccessible, thusthe system mayreclaim that mem-
ory for future use. (For more details, see Section 15.1.2.) Since we are no longer
responsible forstoringadequeuedelement,weremovethereferencetoitfromour
listsoastoreducethatelement’s referencecount.
The second signiﬁcant responsibility of the dequeue method is to update the
value of frontto reﬂect the removal of the element, and the presumed promotion
of the second element to become the new ﬁrst. In most cases, we simply want
to increment the index by one, but because of the possibility of a wrap-around
conﬁguration, werelyonmodulararithmetic asoriginally described onpage242.
Resizing the Queue
Whenenqueueiscalled atatimewhenthesizeofthequeueequals thesizeofthe
underlyinglist,werelyonastandardtechniqueofdoublingthestoragecapacityof
the underlying list. In this way, our approach is similar to the one used when we
implementedaDynamicArrayinSection5.3.1.
However,morecareisneeded inthequeue’s resizeutilitythanwasneeded in
the corresponding method of the DynamicArray class. After creating a temporary
reference to the old list of values, we allocate a new list that is twice the size and
copyreferencesfromtheoldlisttothenewlist. Whiletransferringthecontents,we
intentionally realignthefrontofthequeuewithindex0inthenewarray,asshown
in Figure 6.7. This realignment is not purely cosmetic. Since the modular arith-
meticdependsonthesizeofthearray,ourstatewouldbeﬂawedhadwetransferred
eachelementtoitssameindexinthenewarray.
f
I J K E F G H
E F G H I J K
f=0 1 2246 Chapter6. Stacks,Queues,andDeques
Shrinking the Underlying Array
Adesirable property ofaqueue implementation istohaveitsspace usagebeΘ(n)
where n is the current number of elements in the queue. Our ArrayQueue imple-
mentation, as given in Code Fragments 6.6 and 6.7, does not have this property.
It expands the underlying array when enqueue is called with the queue at full ca-
pacity, but the dequeue implementation never shrinks the underlying array. As a
consequence, the capacity of theunderlying array isproportional to themaximum
numberofelementsthathaveeverbeenstoredinthequeue,notthecurrentnumber
ofelements.
Wediscussedthisveryissueonpage200,inthecontextofdynamicarrays,and
insubsequent Exercises C-5.16through C-5.20ofthat chapter. Arobust approach
is to reduce the array to half of its current size, whenever the number of elements
storedinitfallsbelowonefourthofitscapacity. Wecanimplementthisstrategyby
adding the following two lines of code in ourdequeue method, just after reducing
self. sizeatline38ofCodeFragment6.6,toreﬂectthelossofanelement.
if 0 < self. size < len(self. data) // 4:
self. resize(len(self. data) // 2)
Analyzing the Array-Based Queue Implementation
Table6.3describestheperformanceofourarray-basedimplementationofthequeue
ADT, assuming the improvement described above for occasionally shrinking the
size of the array. With the exception of the resize utility, all of the methods rely
on a constant number of statements involving arithmetic operations, comparisons,
and assignments. Therefore, each method runs in worst-case O(1) time, except
forenqueueanddequeue,whichhaveamortizedboundsofO(1)time,forreasons
similartothosegiveninSection5.3.
Operation RunningTime
Q.enqueue(e) O(1)∗
Q.dequeue() O(1)∗
Q.ﬁrst() O(1)
Q.is empty() O(1)
len(Q) O(1)
∗
amortized
Table6.3: Performance of an array-based implementation of a queue. Thebounds
forenqueueanddequeueareamortized duetotheresizing ofthearray. Thespace6.3. Double-EndedQueues 247
6.3 Double-Ended Queues
We next consider a queue-like data structure that supports insertion and deletion
at both the front and the back of the queue. Such a structure is called a double-
ended queue, or deque, which is usually pronounced “deck” to avoid confusion
with the dequeue method of the regular queue ADT,which ispronounced like the
abbreviation “D.Q.”
Thedequeabstract datatypeismoregeneral thanboththestackandthequeue
ADTs. The extra generality can be useful in some applications. For example, we
described arestaurant using aqueue tomaintain awaitlist. Occassionally, the ﬁrst
personmightberemovedfromthequeueonlytoﬁndthatatablewasnotavailable;
typically, therestaurantwillre-insertthepersonattheﬁrstpositioninthequeue. It
mayalsobethatacustomer attheendofthequeue maygrow impatient andleave
the restaurant. (We will need an even more general data structure if we want to
modelcustomersleaving thequeuefromotherpositions.)
6.3.1 The Deque Abstract Data Type
To provide a symmetrical abstraction, the deque ADT is deﬁned so that deque D
supports thefollowingmethods:
D.add ﬁrst(e): AddelementetothefrontofdequeD.
D.add last(e): AddelementetothebackofdequeD.
D.delete ﬁrst(): RemoveandreturntheﬁrstelementfromdequeD;
anerroroccursifthedequeisempty.
D.delete last(): RemoveandreturnthelastelementfromdequeD;
anerroroccursifthedequeisempty.
Additionally, thedequeADTwillincludethefollowingaccessors:
D.ﬁrst(): Return(butdonotremove)theﬁrstelementofdequeD;
anerroroccursifthedequeisempty.
D.last(): Return (but donot remove) the last element ofdequeD;
anerroroccursifthedequeisempty.
D.is empty(): ReturnTrueifdequeDdoesnotcontainanyelements.
len(D): Return the number of elements in deque D; in Python,248 Chapter6. Stacks,Queues,andDeques
Example 6.5: Thefollowingtableshowsaseriesofoperationsandtheireffects
onaninitiallyemptydequeDofintegers.
Operation ReturnValue Deque
D.add last(5) – [5]
D.add ﬁrst(3) – [3, 5]
D.add ﬁrst(7) – [7, 3, 5]
D.ﬁrst() 7 [7, 3, 5]
D.delete last() 5 [7, 3]
len(D) 2 [7, 3]
D.delete last() 3 [7]
D.delete last() 7 [ ]
D.add ﬁrst(6) – [6]
D.last() 6 [6]
D.add ﬁrst(8) – [8, 6]
D.is empty() False [8, 6]
D.last() 6 [8, 6]
6.3.2 Implementing a Deque with a Circular Array
WecanimplementthedequeADTinmuchthesamewayastheArrayQueueclass
providedinCodeFragments6.6and6.7ofSection6.2.2(somuchsothatweleave
thedetails ofanArrayDequeimplementation toExerciseP-6.32). Werecommend
maintaining the samethreeinstance variables: data, size, and front. Whenever
we need to know the index of the back of the deque, or the ﬁrst available slot
beyondthebackofthedeque, weusemodulararithmeticforthecomputation. For
example,ourimplementation ofthelast()methodusestheindex
back = (self. front + self. size − 1) % len(self. data)
OurimplementationoftheArrayDeque.add lastmethodisessentiallythesame
as that for ArrayQueue.enqueue, including the reliance on a resize utility. Like-
wise, the implementation of the ArrayDeque.delete ﬁrst method is the same as
ArrayQueue.dequeue. Implementations of add ﬁrst and delete last use similar
techniques. One subtlety is that a call to add ﬁrst may need to wrap around the
beginning of the array, so we rely on modular arithmetic to circularly decrement
theindex,as
self. front = (self. front − 1) % len(self. data) # cyclic shift
The efﬁciency of an ArrayDeque is similar to that of an ArrayQueue, with all
operations having O(1) running time, but withthat bound being amortized for op-6.3. Double-EndedQueues 249
6.3.3 Deques in the Python Collections Module
An implementation of a deque class is available in Python’s standard collections
module. Asummaryofthemostcommonlyusedbehaviorsofthecollections.deque
classisgiveninTable6.4. Itusesmoreasymmetricnomenclature thanourADT.
OurDequeADT collections.deque Description
len(D) len(D) numberofelements
D.add ﬁrst() D.appendleft() addtobeginning
D.add last() D.append() addtoend
D.delete ﬁrst() D.popleft() removefrombeginning
D.delete last() D.pop() removefromend
D.ﬁrst() D[0] accessﬁrstelement
D.last() D[−1] accesslastelement
D[j] accessarbitrary entrybyindex
D[j] = val modifyarbitrary entrybyindex
D.clear() clearallcontents
D.rotate(k) circularly shiftrightward ksteps
D.remove(e) removeﬁrstmatchingelement
D.count(e) countnumberofmatchesfore
Table6.4: ComparisonofourdequeADTandthecollections.dequeclass.
The collections.deque interface was chosen to be consistent with established
namingconventionsofPython’slistclass,forwhichappendandpoparepresumed
to act atthe end of the list. Therefore, appendleftand popleftdesignate an opera-
tionatthebeginning ofthelist. Thelibrarydequealsomimicsalistinthatitisan
indexedsequence, allowingarbitrary accessormodiﬁcation usingtheD[j]syntax.
The library deque constructor also supports an optional maxlen parameter to
force a ﬁxed-length deque. However, if a call to append at either end is invoked
whenthedeque isfull,itdoesnotthrowanerror; instead, itcauses oneelementto
be dropped from the opposite side. That is, calling appendleft when the deque is
fullcausesanimplicitpopfromtherightsidetomakeroomforthenewelement.
ThecurrentPythondistributionimplementscollections.dequewithahybridap-
proachthatusesaspectsofcirculararrays,butorganized intoblocksthatarethem-
selves organized in a doubly linked list (a data structure that we will introduce in
thenextchapter). Thedequeclassisformallydocumented toguaranteeO(1)-time
operations at either end, but O(n)-time worst-case operations when using index250 Chapter6. Stacks,Queues,andDeques
6.4 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-6.1 Whatvaluesarereturnedduringthefollowingseriesofstackoperations,if
executeduponaninitiallyemptystack? push(5),push(3),pop(),push(2),
push(8),pop(),pop(),push(9),push(1),pop(),push(7),push(6),pop(),
pop(),push(4),pop(),pop().
R-6.2 Suppose aninitially emptystackShas executed atotalof25pushopera-
tions, 12topoperations, and10popoperations, 3ofwhichraisedEmpty
errorsthatwerecaughtandignored. WhatisthecurrentsizeofS?
R-6.3 Implement a function with signature transfer(S, T)that transfers all ele-
ments from stackSonto stackT, sothat theelement that starts atthe top
of S is the ﬁrst to be inserted onto T, and the element at the bottom ofS
endsupatthetopofT.
R-6.4 Givearecursivemethodforremovingalltheelementsfromastack.
R-6.5 Implementafunctionthatreversesalistofelementsbypushingthemonto
astackinoneorder, andwritingthembacktothelistinreversedorder.
R-6.6 Give a precise and complete deﬁnition of the concept of matching for
grouping symbols in an arithmetic expression. Your deﬁnition may be
recursive.
R-6.7 What values are returned during the following sequence of queue opera-
tions, if executed on an initially empty queue? enqueue(5), enqueue(3),
dequeue(), enqueue(2), enqueue(8), dequeue(), dequeue(), enqueue(9),
enqueue(1), dequeue(), enqueue(7), enqueue(6), dequeue(),dequeue(),
enqueue(4), dequeue(),dequeue().
R-6.8 Suppose an initially empty queue Q has executed a total of 32 enqueue
operations, 10 ﬁrst operations, and 15 dequeue operations, 5 of which
raised Empty errors that were caught and ignored. What is the current
sizeofQ?
R-6.9 Had the queue of the previous problem been an instance of ArrayQueue
thatusedaninitialarrayofcapacity30,andhaditssizeneverbeengreater
than30,whatwouldbetheﬁnalvalueofthe frontinstance variable?
R-6.10 Consider what happens if the loop in the ArrayQueue. resize method at
lines53–55ofCodeFragment6.7hadbeenimplementedas:
for k in range(self. size):
self. data[k] = old[k] # rather than old[walk]6.4. Exercises 251
R-6.11 Give a simple adapter that implements our queue ADT while using a
collections.dequeinstanceforstorage.
R-6.12 WhatvaluesarereturnedduringthefollowingsequenceofdequeADTop-
erations,oninitiallyemptydeque? add ﬁrst(4),add last(8),add last(9),
add ﬁrst(5), back(), delete ﬁrst(), delete last(), add last(7), ﬁrst(),
last(),add last(6),delete ﬁrst(),delete ﬁrst().
R-6.13 Suppose youhave adeque Dcontaining the numbers(1,2,3,4,5,6,7,8),
in this order. Suppose further that you have an initially empty queue Q.
GiveacodefragmentthatusesonlyDandQ(andnoothervariables) and
resultsinDstoringtheelementsintheorder(1,2,3,5,4,6,7,8).
R-6.14 Repeat the previous problem using the deque D and an initially empty
stackS.
Creativity
C-6.15 Suppose Alice has picked three distinct integers and placed them into a
stackSinrandomorder. Writeashort, straight-line pieceofpseudo-code
(with no loops or recursion) that uses only one comparison and only one
variablex, yetthatresults invariablexstoring thelargest ofAlice’sthree
integerswithprobability 2/3. Arguewhyyourmethodiscorrect.
C-6.16 ModifytheArrayStackimplementationsothatthestack’scapacityislim-
ited to maxlen elements, where maxlen is an optional parameter to the
constructor (that defaults toNone). If pushis called when the stack is at
fullcapacity, throwaFullexception(deﬁnedsimilarlytoEmpty).
C-6.17 In the previous exercise, we assume that the underlying list is initially
empty. Redo that exercise, this time preallocating an underlying list with
lengthequaltothestack’smaximumcapacity.
C-6.18 Show how to use the transfer function, described in Exercise R-6.3, and
twotemporarystacks,toreplacethecontentsofagivenstackSwiththose
sameelements,butinreversedorder.
C-6.19 In Code Fragment 6.5 we assume that opening tags in HTML have form
<name>,aswith<li>. Moregenerally, HTMLallowsoptional attributes
to be expressed as part of an opening tag. The general form used is
<name attribute1="value1" attribute2="value2">;forexample,
atable canbegivenaborder andadditional padding byusing anopening
tag of <table border="3" cellpadding="5">. Modify Code Frag-
ment 6.5 so that it can properly match tags, even when an opening tag
mayinclude oneormoresuchattributes.
C-6.20 Describeanonrecursivealgorithmforenumeratingallpermutationsofthe252 Chapter6. Stacks,Queues,andDeques
C-6.21 ShowhowtouseastackSandaqueue Qtogenerate allpossible subsets
ofann-elementsetT nonrecursively.
C-6.22 Postﬁx notation is an unambiguous way of writing an arithmetic expres-
sion without parentheses. It is deﬁned so that if “(exp )op(exp )” is a
1 2
normal, fully parenthesized expression whoseoperation isop,thepostﬁx
version of this is “pexp pexp op”, where pexp isthe postﬁx version of
1 2 1
exp andpexp isthepostﬁxversionofexp . Thepostﬁxversionofasin-
1 2 2
gle number or variable is just that number or variable. For example, the
postﬁxversionof“((5+2)∗(8−3))/4”is“52+83−∗ 4/”. Describe
anonrecursive wayofevaluatinganexpression inpostﬁxnotation.
C-6.23 SupposeyouhavethreenonemptystacksR,S,andT. Describeasequence
ofoperationsthatresultsinSstoringallelementsoriginallyinT belowall
ofS’soriginal elements, withboth setsofthose elements intheiroriginal
order. The ﬁnal conﬁguration for R should be the same as its original
conﬁguration. Forexample, ifR=[1,2,3], S=[4,5], and T =[6,7,8,9],
theﬁnalconﬁguration shouldhaveR=[1,2,3]andS=[6,7,8,9,4,5].
C-6.24 Describe how to implement the stack ADT using a single queue as an
instance variable, and only constant additional local memory within the
method bodies. Whatisthe running timeofthepush(), pop(), and top()
methodsforyourdesign?
C-6.25 Describe how to implement the queue ADT using two stacks as instance
variables, such that all queue operations execute in amortized O(1) time.
Giveaformalproofoftheamortizedbound.
C-6.26 Describehowtoimplementthedouble-endedqueueADTusingtwostacks
asinstancevariables. Whataretherunning timesofthemethods?
C-6.27 Suppose you have a stack S containing n elements and a queue Q that is
initiallyempty. DescribehowyoucanuseQtoscanStoseeifitcontainsa
certain elementx, withtheadditional constraint that your algorithm must
return theelements back toSintheir original order. Youmayonly useS,
Q,andaconstant numberofothervariables.
C-6.28 Modify the ArrayQueue implementation so that the queue’s capacity is
limitedtomaxlenelements,wheremaxlenisanoptional parametertothe
constructor (that defaults to None). If enqueue is called when the queue
isatfullcapacity, throwaFullexception (deﬁnedsimilarlytoEmpty).
C-6.29 In certain applications of the queue ADT, it is common to repeatedly
dequeue an element, process it in some way, and then immediately en-
queue the same element. Modify the ArrayQueue implementation to in-
clude a rotate() method that has semantics identical to the combina-
tion, Q.enqueue(Q.dequeue()). However, your implementation should
be more efﬁcient than making two separate calls (for example, because6.4. Exercises 253
C-6.30 Alicehastwoqueues,QandR,whichcanstoreintegers. BobgivesAlice
50 odd integers and 50 even integers and insists that she store all 100
integers in Q and R. They then play a game where Bob picks Q or R
at random and then applies the round-robin scheduler, described in the
chapter,tothechosenqueuearandomnumberoftimes. Ifthelastnumber
to be processed at the end of this game was odd, Bob wins. Otherwise,
Alice wins. How can Alice allocate integers to queues to optimize her
chances ofwinning? Whatisherchanceofwinning?
C-6.31 SupposeBobhasfourcowsthathewantstotakeacrossabridge,butonly
one yoke, which can hold up to two cows, side by side, tied to the yoke.
The yoke is too heavy for him to carry across the bridge, but he can tie
(anduntie) cowstoitinnotimeatall. Ofhisfour cows,Maziecancross
the bridge in 2 minutes, Daisy can cross it in 4 minutes, Crazycan cross
it in 10 minutes, and Lazy can cross it in 20 minutes. Of course, when
twocowsaretiedtotheyoke,theymustgoatthespeedoftheslowercow.
DescribehowBobcangetallhiscowsacrossthebridgein34minutes.
Projects
P-6.32 Give a complete ArrayDeque implementation of the double-ended queue
ADTassketched inSection6.3.2.
P-6.33 Giveanarray-based implementation of adouble-ended queuesupporting
all of the public behaviors shown in Table 6.4 for the collections.deque
class, including use of the maxlen optional parameter. When a length-
limited deque is full, provide semantics similar to the collections.deque
class,wherebyacalltoinsertanelementononeendofadequecausesan
elementtobelostfromtheopposite side.
P-6.34 Implementaprogramthatcaninputanexpressioninpostﬁxnotation(see
ExerciseC-6.22)andoutput itsvalue.
P-6.35 Theintroduction ofSection6.1notesthatstacksareoftenusedtoprovide
“undo” support in applications like a Web browser or text editor. While
support for undo can be implemented with an unbounded stack, many
applications provideonlylimitedsupport forsuchanundohistory, witha
ﬁxed-capacitystack. Whenpushisinvokedwiththestackatfullcapacity,
rather than throwing a Full exception (as described in Exercise C-6.16),
a more typical semantic is to accept the pushed element at thetop while
“leaking” theoldestelementfromthebottomofthestacktomakeroom.
GiveanimplementationofsuchaLeakyStackabstraction,usingacircular
array with appropriate storage capacity. This class should have a public
interface similar to the bounded-capacity stack in Exercise C-6.16, but254 Chapter6. Stacks,Queues,andDeques
P-6.36 When a share of common stock of some company is sold, the capital
gain (or, sometimes, loss) is the difference between the share’s selling
price and the price originally paid to buy it. This rule is easy to under-
stand for a single share, but if we sell multiple shares of stock bought
over a long period of time, then we must identify the shares actually be-
ing sold. Astandard accounting principle foridentifying which shares of
a stock were sold in such a case is to use a FIFO protocol—the shares
sold are the ones that have been held the longest (indeed, this is the de-
fault method built into several personal ﬁnance software packages). For
example, suppose we buy 100 shares at $20 each on day 1, 20 shares at
$24onday2,200sharesat$36onday3,andthensell150sharesonday
4 at $30 each. Then applying the FIFO protocol means that of the 150
shares sold, 100 werebought on day 1, 20 were bought on day 2, and 30
were bought on day 3. The capital gain in this case would therefore be
100·10+20·6+30·(−6), or $940. Write aprogram that takes asinput
asequence oftransactions oftheform“buy x share(s) at y each”
or“sell x share(s) at y each,”assumingthatthetransactions oc-
cur on consecutive days and the values x and y are integers. Given this
inputsequence, theoutputshouldbethetotalcapitalgain(orloss)forthe
entiresequence, usingtheFIFOprotocoltoidentifyshares.
P-6.37 Design an ADT for a two-color, double-stack ADT that consists of two
stacks—one “red”andone“blue”—and hasasitsoperations color-coded
versions of the regular stack ADT operations. For example, this ADT
shouldsupportbotharedpushoperation andabluepushoperation. Give
an efﬁcient implementation of this ADT using a single array whose ca-
pacity isset atsome valueN that is assumed to always be larger than the
sizesoftheredandbluestackscombined.
Chapter Notes
WewereintroducedtotheapproachofdeﬁningdatastructuresﬁrstintermsoftheirADTs
andthenintermsofconcreteimplementationsbytheclassicbooksbyAho,Hopcroft,and
Ullman[5,6]. ExercisesC-6.30,andC-6.31aresimilarto interviewquestionssaidto be
fromawell-knownsoftwarecompany. Forfurtherstudyofabstractdatatypes,seeLiskovChapter
7
Linked Lists
Contents
7.1 Singly Linked Lists . . . . . . . . . . . . . . . . . . . . . . . 256
7.1.1 Implementing a Stack with a Singly Linked List . . . . . . 261
7.1.2 Implementing a Queue with a Singly Linked List . . . . . . 264
7.2 Circularly Linked Lists . . . . . . . . . . . . . . . . . . . . . 266
7.2.1 Round-Robin Schedulers . . . . . . . . . . . . . . . . . . 267
7.2.2 Implementing a Queue with a Circularly Linked List . . . . 268
7.3 Doubly Linked Lists . . . . . . . . . . . . . . . . . . . . . . 270
7.3.1 Basic Implementation of a Doubly Linked List . . . . . . . 273
7.3.2 Implementing a Deque with a Doubly Linked List . . . . . 275
7.4 The Positional List ADT . . . . . . . . . . . . . . . . . . . 277
7.4.1 The Positional List Abstract Data Type . . . . . . . . . . 279
7.4.2 Doubly Linked List Implementation . . . . . . . . . . . . . 281
7.5 Sorting a Positional List . . . . . . . . . . . . . . . . . . . . 285
7.6 Case Study: Maintaining Access Frequencies . . . . . . . . 286
7.6.1 Using a Sorted List . . . . . . . . . . . . . . . . . . . . . 286
7.6.2 Using a List with the Move-to-Front Heuristic . . . . . . . 289
7.7 Link-Based vs. Array-Based Sequences . . . . . . . . . . . 292256 Chapter7. LinkedLists
In Chapter 5 we carefully examined Python’s array-based list class, and in
Chapter 6 we demonstrated use of that class in implementing the classic stack,
queue, and dequeue ADTs. Python’s list class is highly optimized, and often a
greatchoiceforstorage. Withthatsaid,therearesomenotable disadvantages:
1. The length of a dynamic array might be longer than the actual number of
elementsthatitstores.
2. Amortizedboundsforoperations maybeunacceptable inreal-timesystems.
3. Insertions anddeletions atinteriorpositions ofanarrayareexpensive.
In this chapter, we introduce a data structure known as a linked list, which
provides an alternative to an array-based sequence (such as a Python list). Both
array-based sequences and linked lists keep elements in a certain order, but us-
ing a very different style. An array provides the more centralized representation,
with one large chunk of memory capable of accommodating references to many
elements. A linked list, in contrast, relies on a more distributed representation in
which a lightweight object, known as anode, is allocated for each element. Each
nodemaintainsareferencetoitselementandoneormorereferencestoneighboring
nodesinordertocollectively representthelinearorderofthesequence.
We will demonstrate a trade-off of advantages and disadvantages when con-
trasting array-based sequences andlinked lists. Elementsofalinked listcannot be
efﬁciently accessed by a numeric index k, and we cannot tell just by examining a
node if it is the second, ﬁfth, or twentieth node in the list. However, linked lists
avoidthethreedisadvantages notedaboveforarray-based sequences.
7.1 Singly Linked Lists
A singly linked list, in its simplest form, is a collection of nodes that collectively
formalinearsequence. Eachnodestoresareferencetoanobjectthatisanelement
of the sequence, as well as areference to the next node of the list (see Figures 7.1
and7.2).
MSP
element next
Figure7.1: Example of anode instance that forms part of asingly linked list. The
node’s element memberreferences anarbitrary object thatisanelement ofthese-
quence(theairportcodeMSP,inthisexample),whilethenextmemberreferences7.1. SinglyLinkedLists 257
LAX MSP ATL BOS
head tail
Figure 7.2: Example of a singly linked list whose elements are strings indicating
airport codes. The list instance maintains a member named head that identiﬁes
the ﬁrstnode ofthe list, and in someapplications another member named tailthat
identiﬁesthelastnodeofthelist. TheNoneobjectisdenoted asØ.
The ﬁrst and last node of a linked list are known as the head and tail of the
list, respectively. By starting at the head, and moving from one node to another
by following each node’s next reference, we can reach the tail of the list. We can
identify the tail as the node having None as its next reference. This process is
commonly known as traversing the linked list. Because the next reference of a
node can be viewed as alink or pointer to another node, the process of traversing
alistisalsoknownaslinkhoppingorpointerhopping.
A linked list’s representation in memory relies on the collaboration of many
objects. Each node is represented as a unique object, with that instance storing a
referencetoitselementandareferencetothenextnode(orNone). Anotherobject
represents the linked list asawhole. Minimally, thelinkedlist instance mustkeep
a reference to the head of the list. Without an explicit reference to the head, there
would be no way to locate that node (or indirectly, any others). There is not an
absolute need tostore adirect reference tothe tailofthe list, asitcould otherwise
be located by starting at the head and traversing the rest of the list. However,
storing an explicit reference to the tail node is a common convenience to avoid
suchatraversal. Insimilarregard,itiscommonforthelinked listinstance tokeep
acountofthetotalnumberofnodesthatcomprisethelist(commonlydescribedas
thesizeofthelist),toavoidtheneedtotraverse thelisttocountthenodes.
For the remainder of this chapter, we continue to illustrate nodes as objects,
andeach node’s “next” reference asapointer. However,forthesake ofsimplicity,
we illustrate a node’s element embedded directly within the node structure, even
though the element is, infact, an independent object. Forexample, Figure 7.3is a
morecompactillustration ofthelinkedlistfromFigure7.2.
LAX MSP ATL BOS
head tail
Figure7.3: A compact illustration of a singly linked list, with elements embedded258 Chapter7. LinkedLists
Inserting an Element at the Head of a Singly Linked List
Animportantpropertyofalinkedlististhatitdoesnothaveapredetermined ﬁxed
size; ituses space proportionally to its current number of elements. When using a
singlylinkedlist,wecaneasilyinsertanelementattheheadofthelist,asshownin
Figure 7.4, and described withpseudo-code inCode Fragment7.1. Themain idea
isthatwecreateanewnode,setitselementtothenewelement,setitsnextlinkto
refertothecurrenthead,andthensetthelist’sheadtopointtothenewnode.
head
MSP ATL BOS
(a)
newest head
LAX MSP ATL BOS
(b)
newest head
LAX MSP ATL BOS
(c)
Figure 7.4: Insertion of an element at the head of a singly linked list: (a) before
the insertion; (b) after creation of a new node; (c) after reassignment of the head
reference.
Algorithmadd ﬁrst(L,e):
newest = Node(e) {createnewnodeinstance storingreference toelemente}
newest.next = L.head {setnewnode’s nexttoreference theoldheadnode}
L.head = newest {setvariableheadtoreference thenewnode}
L.size = L.size+1 {incrementthenodecount}
Code Fragment 7.1: Inserting a new element at the beginning of a singly linked
listL.Notethatwesetthenextpointerofthenewnodebeforewereassignvariable
L.head to it. If the list were initially empty (i.e., L.head is None), then a natural7.1. SinglyLinkedLists 259
Inserting an Element at the Tail of a Singly Linked List
We can also easily insert an element at the tail of the list, provided we keep a
reference to the tail node, as shown in Figure 7.5. In this case, we create a new
node,assignitsnextreferencetoNone,setthenextreferenceofthetailtopointto
this new node, and then update the tail reference itself to this new node. We give
thedetailsinCodeFragment7.2.
tail
MSP ATL BOS
(a)
tail newest
MSP ATL BOS MIA
(b)
tail newest
MSP ATL BOS MIA
(c)
Figure 7.5: Insertion at the tail of a singly linked list: (a) before the insertion;
(b) after creation of a new node; (c) after reassignment of the tail reference. Note
thatwemustsetthenextlinkofthetailin(b)before weassign thetailvariable to
pointtothenewnodein(c).
Algorithmadd last(L,e):
newest = Node(e) {createnewnodeinstance storingreference toelemente}
newest.next = None {setnewnode’snexttoreference theNoneobject}
L.tail.next = newest {makeoldtailnodepointtonewnode}
L.tail = newest {setvariabletailtoreference thenewnode}
L.size = L.size+1 {incrementthenodecount}
Code Fragment 7.2: Inserting a new node at the end of a singly linked list. Note
thatwesetthenextpointer fortheoldtailnodebeforewemakevariabletailpoint
tothe new node. Thiscode would need tobe adjusted for inserting onto an empty260 Chapter7. LinkedLists
Removing an Element from a Singly Linked List
Removinganelementfromtheheadofasinglylinkedlistisessentiallythereverse
operation of inserting a new element at the head. This operation is illustrated in
Figure7.6andgivenindetailinCodeFragment7.3.
head
LAX MSP ATL BOS
(a)
head
LAX MSP ATL BOS
(b)
head
MSP ATL BOS
(c)
Figure7.6: Removalofanelementattheheadofasinglylinkedlist: (a)beforethe
removal;(b)after“linking out”theoldhead;(c)ﬁnalconﬁguration.
Algorithmremove ﬁrst(L):
ifL.headisNonethen
Indicate anerror: thelistisempty.
L.head = L.head.next {makeheadpointtonextnode(orNone)}
L.size = L.size−1 {decrementthenodecount}
CodeFragment7.3: Removingthenodeatthebeginning ofasinglylinkedlist.
Unfortunately,wecannoteasilydeletethelastnodeofasinglylinkedlist. Even
ifwemaintain atailreference directly tothe last node ofthe list, wemustbe able
to access the node before the last node in order to remove the last node. But we
cannotreachthenodebeforethetailbyfollowingnextlinksfromthetail. Theonly
way to access this node is to start from the head of the list andsearch all the way
through thelist. Butsuch asequence oflink-hopping operations could take along
time. Ifwewanttosupportsuchanoperation efﬁciently,wewillneedtomakeour7.1. SinglyLinkedLists 261
7.1.1 Implementing a Stack with a Singly Linked List
In this section, wedemonstrate use ofasingly linked list byproviding acomplete
Python implementation of the stack ADT (see Section 6.1). Indesigning such an
implementation,weneedtodecidewhethertomodelthetopofthestackatthehead
oratthetailofthelist. Thereisclearlyabestchoicehere;wecanefﬁcientlyinsert
and delete elements in constant time only at the head. Since all stack operations
affectthetop,weorientthetopofthestackattheheadofourlist.
Torepresentindividualnodesofthelist,wedevelopalightweight Nodeclass.
This class will never be directly exposed to the user of our stack class, so we will
formally deﬁne it as a nonpublic, nested class of our eventual LinkedStack class
(see Section 2.5.1 for discussion of nested classes). The deﬁnition of the Node
classisshowninCodeFragment7.4.
class Node:
”””Lightweight, nonpublic class for storing a singly linked node.”””
slots = _element , _next # streamline memory usage
def init (self, element, next): # initialize node’s ﬁelds
self. element = element # reference to user’s element
self. next = next # reference to next node
CodeFragment7.4: Alightweight Nodeclassforasinglylinkedlist.
A node has only two instance variables: element and next. We intentionally
deﬁne slots tostreamlinethememoryusage(seepage99ofSection2.5.1for
discussion), because there maypotentially bemanynode instances in asingle list.
Theconstructor ofthe Nodeclassisdesigned forourconvenience, allowingusto
specifyinitialvaluesforbothﬁeldsofanewlycreatednode.
A complete implementation of our LinkedStack class is given in Code Frag-
ments 7.5 and 7.6. Each stack instance maintains twovariables. The headmem-
berisareferencetothenodeattheheadofthelist(orNone,ifthestackisempty).
We keep track of the current number of elements with the size instance variable,
for otherwise wewould beforced totraverse theentire listto count the number of
elementswhenreporting thesizeofthestack.
The implementation of push essentially mirrors the pseudo-code for insertion
attheheadofasinglylinkedlistasoutlinedinCodeFragment7.1. Whenwepush
anewelementeontothestack,weaccomplishthenecessary changestothelinked
structure byinvoking theconstructor ofthe Nodeclassasfollows:
self. head = self. Node(e, self. head) # create and link a new node
Note that the next ﬁeld of the new node is set to the existing top node, and then262 Chapter7. LinkedLists
1 class LinkedStack:
2 ”””LIFO Stack implementation using a singly linked list for storage.”””
3
4 #-------------------------- nested Node class --------------------------
5 class Node:
6 ”””Lightweight, nonpublic class for storing a singly linked node.”””
7 slots = _element , _next # streamline memory usage
8
9 def init (self, element, next): # initialize node’s ﬁelds
10 self. element = element # reference to user’s element
11 self. next = next # reference to next node
12
13 #------------------------------- stack methods -------------------------------
14 def init (self):
15 ”””Create an empty stack.”””
16 self. head = None # reference to the head node
17 self. size = 0 # number of stack elements
18
19 def len (self):
20 ”””Return the number of elements in the stack.”””
21 return self. size
22
23 def is empty(self):
24 ”””Return True if the stack is empty.”””
25 return self. size == 0
26
27 def push(self, e):
28 ”””Add element e to the top of the stack.”””
29 self. head = self. Node(e, self. head) # create and link a new node
30 self. size += 1
31
32 def top(self):
33 ”””Return (but do not remove) the element at the top of the stack.
34
35 Raise Empty exception if the stack is empty.
36 ”””
37 if self.is empty():
38 raise Empty( Stack is empty )
39 return self. head. element # top of stack is at head of list
CodeFragment7.5: ImplementationofastackADTusingasinglylinkedlist(con-7.1. SinglyLinkedLists 263
40 def pop(self):
41 ”””Remove and return the element from the top of the stack (i.e., LIFO).
42
43 Raise Empty exception if the stack is empty.
44 ”””
45 if self.is empty():
46 raise Empty( Stack is empty )
47 answer = self. head. element
48 self. head = self. head. next # bypass the former top node
49 self. size −= 1
50 return answer
CodeFragment7.6: ImplementationofastackADTusingasinglylinkedlist(con-
tinuedfromCodeFragment7.5).
When implementing the top method, the goal is to return the element that is
at the top of the stack. When the stack is empty, we raise anEmpty exception, as
originallydeﬁnedinCodeFragment6.1ofChapter6. Whenthestackisnonempty,
self. headisareference totheﬁrstnodeofthelinkedlist. Thetopelement canbe
identiﬁedasself. head. element.
Ourimplementation ofpopessentially mirrors the pseudo-code given inCode
Fragment7.3,exceptthatwemaintainalocalreferencetotheelementthatisstored
atthenodethatisbeingremoved,andwereturnthatelementtothecallerofpop.
The analysis of our LinkedStack operations is given in Table 7.1. We see that
all of the methods complete in worst-case constant time. This is in contrast to the
amortizedbounds fortheArrayStackthatweregiveninTable6.2.
Operation RunningTime
S.push(e) O(1)
S.pop() O(1)
S.top() O(1)
len(S) O(1)
S.is empty() O(1)
Table7.1: PerformanceofourLinkedStackimplementation. Allbounds areworst-
caseandourspaceusageisO(n),wherenisthecurrentnumberofelementsinthe264 Chapter7. LinkedLists
7.1.2 Implementing a Queue with a Singly Linked List
As we did for the stack ADT, we can use a singly linked list to implement the
queueADTwhilesupporting worst-caseO(1)-timeforalloperations. Becausewe
need to perform operations on both ends of the queue, wewill explicitly maintain
both a head reference and a tail reference as instance variables for each queue.
Thenaturalorientationforaqueueistoalignthefrontofthequeuewiththeheadof
thelist, andthebackofthequeuewiththetailofthelist,because wemustbeable
to enqueue elements at the back, and dequeue them from the front. (Recall from
the introduction of Section 7.1 that we are unable to efﬁciently remove elements
fromthetailofasinglylinkedlist.) Ourimplementation ofaLinkedQueueclassis
giveninCodeFragments7.7and7.8.
1 class LinkedQueue:
2 ”””FIFO queue implementation using a singly linked list for storage.”””
3
4 class Node:
5 ”””Lightweight, nonpublic class for storing a singly linked node.”””
6 (omitted here; identical to that of LinkedStack. Node)
7
8 def init (self):
9 ”””Create an empty queue.”””
10 self. head = None
11 self. tail = None
12 self. size = 0 # number of queue elements
13
14 def len (self):
15 ”””Return the number of elements in the queue.”””
16 return self. size
17
18 def is empty(self):
19 ”””Return True if the queue is empty.”””
20 return self. size == 0
21
22 def ﬁrst(self):
23 ”””Return (but do not remove) the element at the front of the queue.”””
24 if self.is empty():
25 raise Empty( Queue is empty )
26 return self. head. element # front aligned with head of list
Code Fragment 7.7: Implementation of a queue ADT using a singly linked list7.1. SinglyLinkedLists 265
27 def dequeue(self):
28 ”””Remove and return the ﬁrst element of the queue (i.e., FIFO).
29
30 Raise Empty exception if the queue is empty.
31 ”””
32 if self.is empty():
33 raise Empty( Queue is empty )
34 answer = self. head. element
35 self. head = self. head. next
36 self. size −= 1
37 if self.is empty(): # special case as queue is empty
38 self. tail = None # removed head had been the tail
39 return answer
40
41 def enqueue(self, e):
42 ”””Add an element to the back of queue.”””
43 newest = self. Node(e, None) # node will be new tail node
44 if self.is empty():
45 self. head = newest # special case: previously empty
46 else:
47 self. tail. next = newest
48 self. tail = newest # update reference to tail node
49 self. size += 1
Code Fragment 7.8: Implementation of a queue ADT using a singly linked list
(continued fromCodeFragment7.7).
Many aspects of our implementation are similar to that of the LinkedStack
class, such as the deﬁnition of the nested Node class. Our implementation of
dequeueforLinkedQueueissimilartothatofpopforLinkedStack,asbothremove
theheadofthelinked list. However,thereisasubtledifference because ourqueue
must accurately maintain the tail reference (no such variable was maintained for
our stack). In general, an operation at the head has no effecton the tail, but when
dequeueisinvoked onaqueuewithoneelement, wearesimultaneouslyremoving
thetailofthelist. Wetherefore setself. tailtoNoneforconsistency.
Thereisasimilarcomplication inourimplementation ofenqueue. Thenewest
nodealwaysbecomesthenewtail. Yetadistinction ismadedepending onwhether
thatnewnodeistheonlynodeinthelist. Inthatcase,italsobecomesthenewhead;
otherwisethenewnodemustbelinked immediatelyaftertheexistingtailnode.
Intermsofperformance, theLinkedQueueissimilartotheLinkedStackinthat
all operations run in worst-case constant time, and the space usage is linear in the266 Chapter7. LinkedLists
7.2 Circularly Linked Lists
In Section 6.2.2, we introduced the notion of a “circular” array and demonstrated
itsuseinimplementingthequeueADT.Inreality,thenotionofacirculararraywas
artiﬁcial, in that there was nothing about the representation of the array itself that
was circular in structure. It was our use of modular arithmetic when “advancing”
anindexfromthelastslottotheﬁrstslotthatprovidedsuchanabstraction.
Inthecaseoflinked lists, there isamoretangible notion ofacircularly linked
list,aswecanhavethetailofthelistuseitsnextreferencetopointbacktothehead
ofthelist,asshowninFigure7.7. Wecallsuchastructureacircularlylinkedlist.
LAX MSP ATL BOS
head tail
Figure7.7: Exampleofasinglylinkedlistwithcircular structure.
A circularly linked list provides a more general model than a standard linked
listfordatasetsthatarecyclic,thatis,whichdonothaveanyparticularnotionofa
beginning and end. Figure 7.8 provides amore symmetric illustration of the same
circularliststructure asFigure7.7.
LAX
MSP BOS
current
ATL
Figure7.8: Exampleofacircularlinkedlist,withcurrentdenoting areferencetoa
selectnode.
A circular view similar to Figure 7.8 could be used, for example, to describe
theorderoftrainstopsintheChicagoloop,ortheorderinwhichplayerstaketurns
during a game. Even though a circularly linked list has no beginning or end, per
se, we must maintain a reference to a particular node in order to make use of the
list. We use the identiﬁer current to describe such a designated node. By setting7.2. CircularlyLinkedLists 267
7.2.1 Round-Robin Schedulers
Tomotivatetheuseofacircularlylinkedlist,weconsideraround-robinscheduler,
whichiteratesthrough acollection ofelementsinacircular fashionand“services”
each element by performing a given action on it. Such a scheduler is used, for
example,tofairlyallocatearesourcethatmustbesharedbyacollection ofclients.
Forinstance,round-robinschedulingisoftenusedtoallocateslicesofCPUtimeto
variousapplications running concurrently onacomputer.
A round-robin scheduler could be implemented with the general queue ADT,
byrepeatedly performing thefollowingstepsonqueueQ(seeFigure7.9):
1. e=Q.dequeue()
2. Serviceelemente
3. Q.enqueue(e)
The Queue
1. Deque the 2. Service the 3. Enqueue the
next element next element serviced element
Shared
Service
Figure7.9: Thethreeiterativestepsforround-robin scheduling usingaqueue.
If we use of the LinkedQueue class of Section 7.1.2 for such an application,
thereisunnecessaryeffortinthecombinationofadequeueoperationfollowedsoon
after by an enqueue of the sameelement. One node is removed from the list, with
appropriateadjustmentstotheheadofthelistandthesizedecremented, andthena
newnodeiscreatedtoreinsert atthetailofthelistandthesizeisincremented.
Ifusingacircularlylinkedlist,theeffectivetransferofanitemfromthe“head”
of the list to the “tail” of the list can be accomplished by advancing a reference
that marks the boundary of the queue. We will next provide an implementation
of a CircularQueueclass that supports the entire queue ADT, together with an ad-
ditional method, rotate(), that moves the ﬁrst element of the queue to the back.
(Asimilarmethodissupported bythedequeclassofPython’scollectionsmodule;
seeTable6.4.) Withthisoperation, around-robin schedulecanmoreefﬁcientlybe
implementedbyrepeatedly performing thefollowingsteps:
1. ServiceelementQ.front()268 Chapter7. LinkedLists
7.2.2 Implementing a Queue with a Circularly Linked List
ToimplementthequeueADTusingacircularlylinkedlist,werelyontheintuition
ofFigure7.7,inwhichthequeuehasaheadandatail,butwiththenextreferenceof
thetaillinkedtothehead. Givensuchamodel,thereisnoneedforustoexplicitly
storereferences toboththehead andthetail;aslongaswekeepareference tothe
tail,wecanalwaysﬁndtheheadbyfollowingthetail’snextreference.
Code Fragments 7.9 and 7.10 provide an implementation of a CircularQueue
class based on this model. The only two instance variables are tail, which is a
reference to the tail node (or None when empty), and size, which is the current
number of elements in the queue. When an operation involves the front of the
queue, we recognize self. tail. next as the head of the queue. When enqueue is
called, anewnode isplacedjustafterthetailbutbefore thecurrent head, andthen
thenewnodebecomesthetail.
Inadditiontothetraditionalqueueoperations,theCircularQueueclasssupports
arotatemethodthatmoreefﬁcientlyenactsthecombinationofremovingthefront
elementandreinsertingitatthebackofthequeue. Withthecircularrepresentation,
wesimplysetself. tail = self. tail. nexttomaketheoldheadbecomethenewtail
(withthenodeaftertheoldheadbecoming thenewhead).
1 class CircularQueue:
2 ”””Queue implementation using circularly linked list for storage.”””
3
4 class Node:
5 ”””Lightweight, nonpublic class for storing a singly linked node.”””
6 (omitted here; identical to that of LinkedStack. Node)
7
8 def init (self):
9 ”””Create an empty queue.”””
10 self. tail = None # will represent tail of queue
11 self. size = 0 # number of queue elements
12
13 def len (self):
14 ”””Return the number of elements in the queue.”””
15 return self. size
16
17 def is empty(self):
18 ”””Return True if the queue is empty.”””
19 return self. size == 0
Code Fragment 7.9: Implementation of a CircularQueue class, using a circularly7.2. CircularlyLinkedLists 269
20 def ﬁrst(self):
21 ”””Return (but do not remove) the element at the front of the queue.
22
23 Raise Empty exception if the queue is empty.
24 ”””
25 if self.is empty():
26 raise Empty( Queue is empty )
27 head = self. tail. next
28 return head. element
29
30 def dequeue(self):
31 ”””Remove and return the ﬁrst element of the queue (i.e., FIFO).
32
33 Raise Empty exception if the queue is empty.
34 ”””
35 if self.is empty():
36 raise Empty( Queue is empty )
37 oldhead = self. tail. next
38 if self. size == 1: # removing only element
39 self. tail = None # queue becomes empty
40 else:
41 self. tail. next = oldhead. next # bypass the old head
42 self. size −= 1
43 return oldhead. element
44
45 def enqueue(self, e):
46 ”””Add an element to the back of queue.”””
47 newest = self. Node(e, None) # node will be new tail node
48 if self.is empty():
49 newest. next = newest # initialize circularly
50 else:
51 newest. next = self. tail. next # new node points to head
52 self. tail. next = newest # old tail points to new node
53 self. tail = newest # new node becomes the tail
54 self. size += 1
55
56 def rotate(self):
57 ”””Rotate front element to the back of the queue.”””
58 if self. size > 0:
59 self. tail = self. tail. next # old head becomes new tail
Code Fragment7.10: Implementation of a CircularQueue class, using a circularly270 Chapter7. LinkedLists
7.3 Doubly Linked Lists
Inasingly linked list, eachnode maintains areference tothenode thatisimmedi-
ately after it. We have demonstrated the usefulness of such arepresentation when
managing a sequence of elements. However, there are limitations that stem from
the asymmetry of a singly linked list. In the opening of Section 7.1, we empha-
sized that we can efﬁciently insert a node at either end of a singly linked list, and
candeleteanodeattheheadofalist,butweareunabletoefﬁcientlydeleteanode
atthetailofthelist. Moregenerally, wecannotefﬁcientlydeleteanarbitrary node
from an interior position of the list if only given a reference to that node, because
we cannot determine the node that immediately precedes the node to be deleted
(yet,thatnodeneedstohaveitsnextreference updated).
Toprovide greater symmetry, wedeﬁnealinked listinwhicheach nodekeeps
anexplicitreference tothenodebeforeitandareference tothenodeafterit. Such
a structure is known as a doubly linked list. These lists allow a greater variety of
O(1)-time update operations, including insertions and deletions at arbitrary posi-
tions within the list. We continue to use the term “next” for the reference to the
nodethatfollowsanother,andweintroducetheterm“prev”forthereferencetothe
nodethatprecedesit.
Header and Trailer Sentinels
Inordertoavoidsomespecialcaseswhenoperatingneartheboundariesofadoubly
linkedlist,ithelpstoaddspecialnodesatbothendsofthelist: aheadernodeatthe
beginningofthelist,andatrailernodeattheendofthelist. These“dummy”nodes
are known as sentinels (or guards), and they do not store elements of the primary
sequence. Adoubly linkedlistwithsuchsentinels isshowninFigure7.10.
header trailer
next next next next
JFK PVD SFO
prev prev prev prev
Figure 7.10: A doubly linked list representing the sequence { JFK, PVD, SFO },
usingsentinelsheaderandtrailertodemarcatetheendsofthelist.
When using sentinel nodes, anempty list isinitialized so that the next ﬁeldof
theheaderpoints tothetrailer, andtheprevﬁeldofthetrailerpoints totheheader;
the remaining ﬁelds of the sentinels are irrelevant (presumably None, in Python).
For a nonempty list, the header’s next will refer to a node containing the ﬁrst real
element of a sequence, just as the trailer’s prev references the node containing the7.3. DoublyLinkedLists 271
Advantage of Using Sentinels
Although we could implement a doubly linked list without sentinel nodes (as we
did withour singly linked list inSection 7.1), the slight extra space devoted tothe
sentinelsgreatlysimpliﬁesthelogicofouroperations. Mostnotably,theheaderand
trailer nodes never change—only the nodes between them change. Furthermore,
wecan treat allinsertions in auniﬁed manner, because anew node will always be
placedbetweenapairofexistingnodes. Insimilarfashion,everyelementthatisto
bedeletedisguaranteed tobestoredinanodethathasneighbors oneachside.
Forcontrast,lookbackatourLinkedQueueimplementationfromSection7.1.2.
Its enqueue method, given in Code Fragment 7.8, adds a new node to the end of
the list. However, itsimplementation required aconditional tomanage the special
case of inserting into an empty list. In the general case, the new node was linked
after the existing tail. But when adding to an empty list, there is no existing tail;
instead itisnecessary toreassignself. headtoreference thenewnode. Theuseof
a sentinel node in that implementation would eliminate the special case, as there
wouldalwaysbeanexistingnode(possibly theheader)beforeanewnode.
Inserting and Deleting with a Doubly Linked List
Every insertion into our doubly linked list representation will take place between
apair ofexisting nodes, as diagrammed in Figure 7.11. Forexample, when anew
element is inserted at the front of the sequence, we will simply add the new node
betweentheheaderandthenodethatiscurrentlyaftertheheader. (SeeFigure7.12.)
header trailer
BWI JFK SFO
(a)
header trailer
BWI JFK PVD SFO
(b)
header trailer
BWI JFK PVD SFO
(c)
Figure7.11: Addinganelement toadoubly linked listwithheader andtrailer sen-
tinels: (a)beforetheoperation;(b)aftercreatingthenewnode;(c)afterlinkingthe272 Chapter7. LinkedLists
header trailer
BWI JFK SFO
(a)
header trailer
PVD BWI JFK SFO
(b)
header trailer
PVD BWI JFK SFO
(c)
Figure 7.12: Adding an element to the front of a sequence represented by a dou-
bly linked list with header and trailer sentinels: (a) before the operation; (b) after
creating thenewnode;(c)afterlinkingtheneighbors tothenewnode.
Thedeletionofanode,portrayedinFigure7.13,proceedsintheoppositefash-
ionofaninsertion. Thetwoneighbors ofthenodetobedeletedarelinkeddirectly
to each other, thereby bypassing the original node. As a result, that node will no
longerbeconsideredpartofthelistanditcanbereclaimedbythesystem. Because
ofouruseofsentinels,thesameimplementationcanbeusedwhendeletingtheﬁrst
orthelastelement ofasequence, because evensuchanelement willbestored ata
nodethatliesbetweentwoothers.
header trailer
BWI JFK PVD SFO
(a)
header trailer
BWI JFK PVD SFO
(b)
header trailer
BWI JFK SFO
(c)
Figure 7.13: Removing the element PVD from a doubly linked list: (a) before
the removal; (b) after linking out the old node; (c) after theremoval (and garbage7.3. DoublyLinkedLists 273
7.3.1 Basic Implementation of a Doubly Linked List
Webeginbyprovidingapreliminary implementation ofadoublylinkedlist,inthe
form of a class named DoublyLinkedBase. We intentionally name the class with
a leading underscore because we do not intend for it to provide a coherent public
interfaceforgeneraluse. Wewillseethatlinkedlistscansupportgeneralinsertions
and deletions in O(1) worst-case time, but only if the location of an operation
can be succinctly identiﬁed. With array-based sequences, an integer index was a
convenient means for describing a position within a sequence. However, an index
isnotconvenient forlinkedlistsasthereisnoefﬁcientwaytoﬁndthe jth element;
itwouldseemtorequire atraversalofaportionofthelist.
When working with a linked list, the most direct way to describe the location
of an operation is by identifying a relevant node of the list. However, we prefer
to encapsulate the inner workings of our data structure to avoid having users di-
rectly access nodes of a list. In the remainder of this chapter, we will develop
twopublic classes thatinherit from our DoublyLinkedBaseclass toprovide more
coherent abstractions. Speciﬁcally, in Section 7.3.2, we provide a LinkedDeque
classthatimplementsthedouble-ended queueADTintroduced inSection6.3;that
class only supports operations at the ends of the queue, so there is no need for a
user to identify an interior position within the list. In Section 7.4, we introduce a
newPositionalListabstraction thatprovides apublicinterfacethatallowsarbitrary
insertions anddeletions fromalist.
Ourlow-level DoublyLinkedBaseclassreliesontheuseofanonpublic Node
class that is similar to that for a singly linked list, as given in Code Fragment 7.4,
except that the doubly linked version includes a prev attribute, in addition to the
nextand elementattributes, asshowninCodeFragment7.11.
class Node:
”””Lightweight, nonpublic class for storing a doubly linked node.”””
slots = _element , _prev , _next # streamline memory
def init (self, element, prev, next): # initialize node’s ﬁelds
self. element = element # user’s element
self. prev = prev # previous node reference
self. next = next # next node reference
CodeFragment7.11: APython Nodeclassforuseinadoublylinkedlist.
Theremainderofour DoublyLinkedBaseclassisgiveninCodeFragment7.12.
Theconstructor instantiates the twosentinel nodes andlinks them directly toeach
other. We maintain a size member and provide public support for len and274 Chapter7. LinkedLists
1 class DoublyLinkedBase:
2 ”””A base class providing a doubly linked list representation.”””
3
4 class Node:
5 ”””Lightweight, nonpublic class for storing a doubly linked node.”””
6 (omitted here; see previous code fragment)
7
8 def init (self):
9 ”””Create an empty list.”””
10 self. header = self. Node(None, None, None)
11 self. trailer = self. Node(None, None, None)
12 self. header. next = self. trailer # trailer is after header
13 self. trailer. prev = self. header # header is before trailer
14 self. size = 0 # number of elements
15
16 def len (self):
17 ”””Return the number of elements in the list.”””
18 return self. size
19
20 def is empty(self):
21 ”””Return True if list is empty.”””
22 return self. size == 0
23
24 def insert between(self, e, predecessor, successor):
25 ”””Add element e between two existing nodes and return new node.”””
26 newest = self. Node(e, predecessor, successor) # linked to neighbors
27 predecessor. next = newest
28 successor. prev = newest
29 self. size += 1
30 return newest
31
32 def delete node(self, node):
33 ”””Delete nonsentinel node from the list and return its element.”””
34 predecessor = node. prev
35 successor = node. next
36 predecessor. next = successor
37 successor. prev = predecessor
38 self. size −= 1
39 element = node. element # record deleted element
40 node. prev = node. next = node. element = None # deprecate node
41 return element # return deleted element7.3. DoublyLinkedLists 275
Theothertwomethodsofourclassarethenonpublicutilities, insert between
and delete node. These provide generic support for insertions and deletions, re-
spectively, butrequire oneormorenodereferences asparameters. Theimplemen-
tationofthe insert betweenmethodismodeleduponthealgorithmthatwasprevi-
ouslyportrayedinFigure7.11. Itcreatesanewnode,withthatnode’sﬁeldsinitial-
ized tolink to the speciﬁed neighboring nodes. Thenthe ﬁelds ofthe neighboring
nodesareupdated toinclude thenewestnodeinthelist. Forlaterconvenience, the
methodreturns areference tothenewlycreated node.
Theimplementationofthe delete nodemethodismodeleduponthealgorithm
portrayedinFigure7.13. Theneighborsofthenodetobedeletedarelinkeddirectly
to each other, thereby bypassing the deleted node from the list. As a formality,
we intentionally reset the prev, next, and element ﬁelds of the deleted node to
None (after recording the element tobe returned). Although the deleted node will
be ignored by the rest of the list, setting its ﬁelds to None is advantageous as it
may help Python’s garbage collection, since unnecessary links to the other nodes
and the stored element are eliminated. We will also rely on this conﬁguration to
recognize anodeas“deprecated” whenitisnolongerpartofthelist.
7.3.2 Implementing a Deque with a Doubly Linked List
The double-ended queue (deque) ADT was introduced in Section 6.3. With an
array-basedimplementation,weachievealloperationsinamortizedO(1)time,due
to the occasional need to resize the array. With an implementation based upon a
doublylinkedlist,wecanachievealldequeoperation inworst-case O(1)time.
We provide an implementation of a LinkedDeque class (Code Fragment 7.13)
that inherits from the DoublyLinkedBase class of the preceding section. We do
notprovideanexplicit init methodfortheLinkedDequeclass,astheinherited
version of that method sufﬁces to initialize a new instance. We also rely on the
inherited methods len andis emptyinmeetingthedequeADT.
With the use of sentinels, the key to our implementation is to remember that
theheaderdoesnotstoretheﬁrstelementofthedeque—itisthenodejustafterthe
header that stores the ﬁrst element (assuming the deque is nonempty). Similarly,
thenodejustbeforethetrailerstoresthelastelementofthedeque.
We use the inherited insert between method to insert at either end of the
deque. To insert an element at the front of the deque, we place it immediately
between the header and the node just after the header. An insertion at the end of
deque is placed immediately before the trailer node. Note that these operations
succeed, evenwhenthedequeisempty;insuchasituation, thenewnodeisplaced
between thetwosentinels. Whendeleting anelement from anonempty deque, we
rely upon the inherited delete nodemethod, knowing that the designated node is276 Chapter7. LinkedLists
1 class LinkedDeque( DoublyLinkedBase): # note the use of inheritance
2 ”””Double-ended queue implementation based on a doubly linked list.”””
3
4 def ﬁrst(self):
5 ”””Return (but do not remove) the element at the front of the deque.”””
6 if self.is empty():
7 raise Empty("Deque is empty")
8 return self. header. next. element # real item just after header
9
10 def last(self):
11 ”””Return (but do not remove) the element at the back of the deque.”””
12 if self.is empty():
13 raise Empty("Deque is empty")
14 return self. trailer. prev. element # real item just before trailer
15
16 def insert ﬁrst(self, e):
17 ”””Add an element to the front of the deque.”””
18 self. insert between(e, self. header, self. header. next) # after header
19
20 def insert last(self, e):
21 ”””Add an element to the back of the deque.”””
22 self. insert between(e, self. trailer. prev, self. trailer) # before trailer
23
24 def delete ﬁrst(self):
25 ”””Remove and return the element from the front of the deque.
26
27 Raise Empty exception if the deque is empty.
28 ”””
29 if self.is empty():
30 raise Empty("Deque is empty")
31 return self. delete node(self. header. next) # use inherited method
32
33 def delete last(self):
34 ”””Remove and return the element from the back of the deque.
35
36 Raise Empty exception if the deque is empty.
37 ”””
38 if self.is empty():
39 raise Empty("Deque is empty")
40 return self. delete node(self. trailer. prev) # use inherited method
CodeFragment7.13: ImplementationofaLinkedDequeclassthatinheritsfromthe7.4. ThePositionalListADT 277
7.4 The Positional List ADT
The abstract data types that we have considered thus far, namely stacks, queues,
and double-ended queues, only allow update operations thatoccur at one end of a
sequence or the other. We wish to have a more general abstraction. For example,
although we motivated the FIFO semantics of a queue as a model for customers
who are waiting to speak with a customer service representative, or fans who are
waiting in line to buy tickets to a show, the queue ADT is too limiting. What if
a waiting customer decides to hang up before reaching the front of the customer
service queue? Or what if someone who is waiting in line to buy tickets allows a
friend to “cut” into line at that position? Wewould like to design an abstract data
typethatprovidesauserawaytorefertoelementsanywhereinasequence, andto
perform arbitraryinsertions anddeletions.
When working with array-based sequences (such as a Pythonlist), integer in-
dices provide an excellent means for describing the location of an element, or the
location atwhichaninsertion ordeletion should take place. However,numeric in-
dicesarenotagoodchoicefordescribing positionswithinalinkedlistbecausewe
cannot efﬁciently access an entry knowing only its index; ﬁnding an element at a
given index within a linked list requires traversing the list incrementally from its
beginning orend,counting elementsaswego.
Furthermore, indices are not a good abstraction for describing a local position
insomeapplications, becausetheindexofanentrychangesovertimeduetoinser-
tions or deletions that happen earlier in the sequence. For example, it may not be
convenienttodescribethelocationofapersonwaitinginlinebyknowingprecisely
howfarawaythatperson isfromthefrontoftheline. Weprefer anabstraction, as
characterized in Figure 7.14, in which there is some other means for describing
a position. We then wish to model situations such as when an identiﬁed person
leavesthelinebeforereachingthefront,orinwhichanewpersonisaddedtoaline
immediatelybehindanother identiﬁedperson.
me
Tickets
Figure7.14:Wewishtobeabletoidentifythepositionofanelementinasequence278 Chapter7. LinkedLists
As another example, a text document can be viewed as a long sequence of
characters. Awordprocessorusestheabstractionofacursortodescribeaposition
within the document without explicit use of an integer index, allowing operations
such as“delete thecharacter atthe cursor” or“insert anew character justafter the
cursor.” Furthermore, wemaybeabletorefertoaninherentposition withinadoc-
ument,suchasthebeginningofaparticular section,withoutrelyingonacharacter
index(orevenasectionnumber)thatmaychangeasthedocumentevolves.
A Node Reference as a Position?
One of the great beneﬁts of a linked list structure is that it is possible to perform
O(1)-time insertions and deletions at arbitrary positions of the list, as long as we
are given a reference to a relevant node of the list. It is therefore very tempting to
developanADTinwhichanodereferenceservesasthemechanismfordescribing
a position. In fact, our DoublyLinkedBase class of Section 7.3.1 has methods
insert betweenand delete nodethatacceptnodereferences asparameters.
However, such direct use of nodes would violate the object-oriented design
principlesofabstractionandencapsulationthatwereintroducedinChapter2. There
areseveralreasons topreferthatweencapsulate thenodesofalinkedlist,forboth
oursakeandforthebeneﬁtofusersofourabstraction.
• Itwillbesimplerforusersofourdatastructure iftheyarenotbotheredwith
unnecessary details of our implementation, such as low-level manipulation
of nodes, orour reliance on theuse of sentinel nodes. Noticethat touse the
insert between method of our DoublyLinkedBase class to add a node at
thebeginningofasequence, theheadersentinelmustbesentasaparameter.
• We can provide a more robust data structure if we do not permit users to
directly access or manipulate the nodes. In that way, we ensure that users
cannot invalidate the consistency of a list by mismanaging the linking of
nodes. A more subtle problem arises if a user were allowed to call the
insert between or delete node method of our DoublyLinkedBase class,
sendinganodethatdoesnotbelongtothegivenlistasaparameter. (Goback
andlookatthatcodeandseewhyitcausesaproblem!)
• By better encapsulating the internal details of our implementation, we have
greaterﬂexibilitytoredesignthedatastructureandimproveitsperformance.
In fact, with a well-designed abstraction, we can provide a notion of a non-
numericposition, evenifusinganarray-based sequence.
For these reasons, instead of relying directly on nodes, we introduce an inde-
pendent position abstraction todenote thelocation ofanelement withinalist, and
then a complete positional list ADT that can encapsulate a doubly linked list (or7.4. ThePositionalListADT 279
7.4.1 The Positional List Abstract Data Type
To provide for a general abstraction of a sequence of elements with the ability to
identify the location of an element, we deﬁne a positional list ADT as well as a
simpler position abstract data type to describe a location within a list. A position
acts as a marker or token within the broader positional list. A position p is unaf-
fected by changes elsewhere in a list; the only way in which a position becomes
invalidisifanexplicitcommandisissuedtodeleteit.
Apositioninstance isasimpleobject, supporting onlythefollowingmethod:
p.element(): Returntheelementstoredatpositionp.
In the context of the positional list ADT, positions serve as parameters to some
methodsandasreturn valuesfromothermethods. Indescribing thebehaviors ofa
positional list,webeingbypresenting theaccessor methodssupported byalistL:
L.ﬁrst(): ReturnthepositionoftheﬁrstelementofL,orNoneifLisempty.
L.last(): ReturnthepositionofthelastelementofL,orNoneifLisempty.
L.before(p): Return the position of Limmediately before position p, or None
ifpistheﬁrstposition.
L.after(p): Return theposition ofLimmediately after positionp,orNoneif
pisthelastposition.
L.is empty(): ReturnTrueiflistLdoesnotcontainanyelements.
len(L): Returnthenumberofelementsinthelist.
iter(L): Return a forward iterator for the elements of the list. See Sec-
tion1.8fordiscussion ofiteratorsinPython.
Thepositional listADTalsoincludes thefollowingupdatemethods:
L.add ﬁrst(e): InsertanewelementeatthefrontofL,returningtheposition
ofthenewelement.
L.add last(e): InsertanewelementeatthebackofL,returningtheposition
ofthenewelement.
L.add before(p, e): Insert anew elementejust before position pinL, returning
theposition ofthenewelement.
L.add after(p, e): Insert a new element e just after position p in L, returning
theposition ofthenewelement.
L.replace(p, e): Replace the element at position p with element e, returning
theelementformerlyatpositionp.
L.delete(p): Removeandreturn theelementatposition pinL,invalidat-
ingtheposition.
Forthose methodsoftheADTthataccept apositionpasaparameter, anerror280 Chapter7. LinkedLists
Note well that the ﬁrst() and last() methods of the positional list ADT return
theassociated positions, nottheelements. (Thisisincontrast tothecorresponding
ﬁrst and last methods of the deque ADT.) The ﬁrst element of a positional list
can be determined bysubsequently invoking theelement method on that position,
as L.ﬁrst().element(). The advantage of receiving a position as a return value is
that we can use that position to navigate the list. For example, the following code
fragmentprintsallelementsofapositional listnameddata.
cursor = data.ﬁrst()
while cursor is not None:
print(cursor.element()) # print the element stored at the position
cursor = data.after(cursor) # advance to the next position (if any)
This code relies on the stated convention that the None object is returned when
after is called upon the last position. That return value is clearly distinguishable
from any legitimate position. The positional list ADT similarly indicates that the
Nonevalueisreturnedwhenthebeforemethodisinvokedatthefrontofthelist,or
whenﬁrstorlastmethodsarecalleduponanemptylist. Therefore,theabovecode
fragmentworkscorrectly evenifthedatalistisempty.
Because the ADT includes support for Python’s iter function, users may rely
onthetraditional for-loop syntaxforsuchaforwardtraversalofalistnameddata.
for e in data:
print(e)
MoregeneralnavigationalandupdatemethodsofthepositionallistADTareshown
inthefollowingexample.
Example 7.1: Thefollowingtableshowsaseriesofoperationsonaninitially
emptypositionallistL.Toidentifypositioninstances,weusevariablessuchasp
andq. Foreaseofexposition,whendisplayingthelistcontents,weusesubscript
notationtodenoteitspositions.
Operation ReturnValue L
L.add last(8) p 8p
L.ﬁrst() p 8p
L.add after(p, 5) q 8p,5q
L.before(q) p 8p,5q
L.add before(q, 3) r 8p,3r,5q
r.element() 3 8p,3r,5q
L.after(p) r 8p,3r,5q
L.before(p) None 8p,3r,5q
L.add ﬁrst(9) s 9s,8p,3r,5q
L.delete(L.last()) 5 9s,8p,3r7.4. ThePositionalListADT 281
7.4.2 Doubly Linked List Implementation
In this section, we present a complete implementation of a PositionalList class
usingadoublylinkedlistthatsatisﬁesthefollowingimportantproposition.
Proposition 7.2: EachmethodofthepositionallistADTrunsinworst-caseO(1)
timewhenimplementedwithadoublylinkedlist.
We rely on the DoublyLinkedBase class from Section 7.3.1 for our low-level
representation; the primary responsibility of our new class is to provide a public
interface inaccordance withthepositional list ADT.Webegin ourclass deﬁnition
inCodeFragment7.14withthedeﬁnitionofthepublicPositionclass,nestedwithin
our PositionalListclass. Position instances will be used to represent the locations
ofelementswithinthelist. OurvariousPositionalListmethodsmayendupcreating
redundantPositioninstancesthatreferencethesameunderlyingnode(forexample,
when ﬁrst and last are the same). For that reason, our Position class deﬁnes the
eq and ne special methods so that a test such as p == q evaluates to
Truewhentwopositions refertothesamenode.
Validating Positions
Each time a method of the PositionalList class accepts a position as a parameter,
we want to verify that the position is valid, and if so, to determine the underlying
node associated with the position. This functionality is implemented by a non-
public method named validate. Internally, aposition maintains areference to the
associated node ofthelinked list, andalsoareference tothelistinstance thatcon-
tainsthespeciﬁednode. Withthecontainerreference, wecanrobustlydetectwhen
acallersendsapositioninstance thatdoesnotbelongtotheindicated list.
We are also able to detect a position instance that belongs to the list, but that
refers to a node that is no longer part of that list. Recall that the delete node of
the base class sets the previous and next references ofa deleted node to None; we
canrecognize thatcondition todetectadeprecated node.
Access and Update Methods
The access methods of the PositionalList class are given in Code Fragment 7.15
and the update methods are given in Code Fragment 7.16. All ofthese methods
triviallyadapttheunderlyingdoublylinkedlistimplementationtosupportthepub-
licinterface ofthepositional listADT.Thosemethods relyonthe validateutility
to “unwrap” any position that is sent. They also rely on a make position utility
to “wrap” nodes as Position instances to return to the user, making sure never to
return a position referencing a sentinel. For convenience, we have overridden the
inherited insert between utility method so that ours returns aposition associated282 Chapter7. LinkedLists
1 class PositionalList( DoublyLinkedBase):
2 ”””A sequential container of elements allowing positional access.”””
3
4 #-------------------------- nested Position class --------------------------
5 class Position:
6 ”””An abstraction representing the location of a single element.”””
7
8 def init (self, container, node):
9 ”””Constructor should not be invoked by user.”””
10 self. container = container
11 self. node = node
12
13 def element(self):
14 ”””Return the element stored at this Position.”””
15 return self. node. element
16
17 def eq (self, other):
18 ”””Return True if other is a Position representing the same location.”””
19 return type(other) is type(self) and other. node is self. node
20
21 def ne (self, other):
22 ”””Return True if other does not represent the same location.”””
23 return not (self == other) # opposite of eq
24
25 #------------------------------- utility method -------------------------------
26 def validate(self, p):
27 ”””Return positions node, or raise appropriate error if invalid.”””
28 if not isinstance(p, self.Position):
29 raise TypeError( p must be proper Position type )
30 if p. container is not self:
31 raise ValueError( p does not belong to this container )
32 if p. node. next is None: # convention for deprecated nodes
33 raise ValueError( p is no longer valid )
34 return p. node
CodeFragment7.14: APositionalListclassbasedonadoublylinkedlist. (Contin-7.4. ThePositionalListADT 283
35 #------------------------------- utility method -------------------------------
36 def make position(self, node):
37 ”””Return Position instance for given node (or None if sentinel).”””
38 if node is self. header or node is self. trailer:
39 return None # boundary violation
40 else:
41 return self.Position(self, node) # legitimate position
42
43 #------------------------------- accessors -------------------------------
44 def ﬁrst(self):
45 ”””Return the ﬁrst Position in the list (or None if list is empty).”””
46 return self. make position(self. header. next)
47
48 def last(self):
49 ”””Return the last Position in the list (or None if list is empty).”””
50 return self. make position(self. trailer. prev)
51
52 def before(self, p):
53 ”””Return the Position just before Position p (or None if p is ﬁrst).”””
54 node = self. validate(p)
55 return self. make position(node. prev)
56
57 def after(self, p):
58 ”””Return the Position just after Position p (or None if p is last).”””
59 node = self. validate(p)
60 return self. make position(node. next)
61
62 def iter (self):
63 ”””Generate a forward iteration of the elements of the list.”””
64 cursor = self.ﬁrst()
65 while cursor is not None:
66 yield cursor.element()
67 cursor = self.after(cursor)
CodeFragment7.15: APositionalListclassbasedonadoublylinkedlist. (Contin-284 Chapter7. LinkedLists
68 #------------------------------- mutators -------------------------------
69 # override inherited version to return Position, rather than Node
70 def insert between(self, e, predecessor, successor):
71 ”””Add element between existing nodes and return new Position.”””
72 node = super(). insert between(e, predecessor, successor)
73 return self. make position(node)
74
75 def add ﬁrst(self, e):
76 ”””Insert element e at the front of the list and return new Position.”””
77 return self. insert between(e, self. header, self. header. next)
78
79 def add last(self, e):
80 ”””Insert element e at the back of the list and return new Position.”””
81 return self. insert between(e, self. trailer. prev, self. trailer)
82
83 def add before(self, p, e):
84 ”””Insert element e into list before Position p and return new Position.”””
85 original = self. validate(p)
86 return self. insert between(e, original. prev, original)
87
88 def add after(self, p, e):
89 ”””Insert element e into list after Position p and return new Position.”””
90 original = self. validate(p)
91 return self. insert between(e, original, original. next)
92
93 def delete(self, p):
94 ”””Remove and return the element at Position p.”””
95 original = self. validate(p)
96 return self. delete node(original) # inherited method returns element
97
98 def replace(self, p, e):
99 ”””Replace the element at Position p with e.
100
101 Return the element formerly at Position p.
102 ”””
103 original = self. validate(p)
104 old value = original. element # temporarily store old element
105 original. element = e # replace with new element
106 return old value # return the old element value
CodeFragment7.16: APositionalListclassbasedonadoublylinkedlist. (Contin-7.5. SortingaPositionalList 285
7.5 Sorting a Positional List
In Section 5.5.2, we introduced the insertion-sort algorithm, in the context of an
array-based sequence. Inthissection, wedevelop animplementation thatoperates
onaPositionalList,relyingonthesamehigh-levelalgorithminwhicheachelement
isplacedrelativetoagrowingcollection ofpreviously sortedelements.
Wemaintain avariable namedmarkerthatrepresents therightmost position of
thecurrentlysortedportionofalist. Duringeachpass,weconsiderthepositionjust
pastthemarkerasthepivotandconsiderwherethepivot’selementbelongsrelative
tothesorted portion; weuseanother variable, namedwalk,tomoveleftward from
themarker,aslongasthereremainsaprecedingelementwithvaluelargerthanthe
pivot’s. Atypicalconﬁguration ofthesevariablesisdiagrammedinFigure7.15. A
Pythonimplementation ofthisstrategy isgiveninCode7.17.
walk pivot
15 22 25 29 36 23 53 11 42
marker
Figure 7.15: Overview of one step of our insertion-sort algorithm. The shaded
elements, those uptoandincludingmarker,have already beensorted. Inthisstep,
thepivot’selementshouldberelocated immediatelybeforethewalkposition.
1 def insertion sort(L):
2 ”””Sort PositionalList of comparable elements into nondecreasing order.”””
3 if len(L) > 1: # otherwise, no need to sort it
4 marker = L.ﬁrst()
5 while marker != L.last():
6 pivot = L.after(marker) # next item to place
7 value = pivot.element()
8 if value > marker.element(): # pivot is already sorted
9 marker = pivot # pivot becomes new marker
10 else: # must relocate pivot
11 walk = marker # ﬁnd leftmost item greater than value
12 while walk != L.ﬁrst( ) and L.before(walk).element( ) > value:
13 walk = L.before(walk)
14 L.delete(pivot)
15 L.add before(walk, value) # reinsert value before walk286 Chapter7. LinkedLists
7.6 Case Study: Maintaining Access Frequencies
Thepositional listADTisuseful in anumber ofsettings. Forexample, aprogram
that simulates a game of cards could model each person’s handas a positional list
(ExerciseP-7.47). Sincemostpeoplekeepcardsofthesamesuittogether,inserting
andremovingcardsfromaperson’shandcouldbeimplementedusingthemethods
of the positional list ADT, with the positions being determined by a natural order
ofthesuits. Likewise,asimpletexteditorembedsthenotionofpositionalinsertion
and deletion, since such editors typically perform all updates relative to a cursor,
whichrepresents thecurrentposition inthelistofcharacters oftextbeingedited.
Inthissection,weconsidermaintainingacollectionofelementswhilekeeping
trackofthenumberoftimeseachelementisaccessed. Keepingsuchaccesscounts
allowsus toknow whichelements areamong the mostpopular. Examples ofsuch
scenarios include aWebbrowserthatkeeps track ofauser’s mostaccessed URLs,
or a music collection that maintains a list of the most frequently played songs for
a user. We model this with a new favorites list ADT that supports the len and
is emptymethodsaswellasthefollowing:
access(e): Accesstheelemente,incrementing itsaccesscount, and
adding ittothefavorites listifitisnotalreadypresent.
remove(e): Removeelementefromthefavorites list,ifpresent.
top(k): Returnaniteration ofthekmostaccessed elements.
7.6.1 Using a Sorted List
Our ﬁrst approach for managing a list of favorites is to store elements in a linked
list, keeping them in nonincreasing order of access counts. We access or remove
an element by searching the list from the most frequently accessed to the least
frequently accessed. Reporting the top k most accessed elements is easy, as they
aretheﬁrstkentriesofthelist.
To maintain the invariant that elements are stored in nonincreasing order of
accesscounts,wemustconsiderhowasingleaccessoperationmayaffecttheorder.
The accessed element’s count increases by one, and so it may become larger than
oneormoreofitspreceding neighbors inthelist,thereby violating theinvariant.
Fortunately, wecanreestablish thesortedinvariantusingatechniquesimilarto
asinglepassoftheinsertion-sort algorithm,introducedintheprevioussection. We
canperform abackward traversal ofthe list, starting attheposition oftheelement
whose access count has increased, until we locate a valid position after which the7.6. CaseStudy:MaintainingAccessFrequencies 287
Using the Composition Pattern
WewishtoimplementafavoriteslistbymakinguseofaPositionalListforstorage.
If elements of the positional list were simply elements of the favorites list, we
would be challenged to maintain access counts and to keep theproper count with
the associated element as the contents of the list are reordered. We use a general
object-orienteddesignpattern,thecompositionpattern,inwhichwedeﬁneasingle
object that is composed of two or more other objects. Speciﬁcally, we deﬁne a
nonpublic nested class, Item, that stores the element and its access count as a
single instance. We then maintain our favorites list as a PositionalList of item
instances, sothattheaccess count forauser’s elementisembedded alongside itin
ourrepresentation. (An ItemisneverexposedtoauserofaFavoritesList.)
1 class FavoritesList:
2 ”””List of elements ordered from most frequently accessed to least.”””
3
4 #------------------------------ nested Item class ------------------------------
5 class Item:
6 slots = _value , _count # streamline memory usage
7 def init (self, e):
8 self. value = e # the user s element
9 self. count = 0 # access count initially zero
10
11 #------------------------------- nonpublic utilities -------------------------------
12 def ﬁnd position(self, e):
13 ”””Search for element e and return its Position (or None if not found).”””
14 walk = self. data.ﬁrst()
15 while walk is not None and walk.element(). value != e:
16 walk = self. data.after(walk)
17 return walk
18
19 def move up(self, p):
20 ”””Move item at Position p earlier in the list based on access count.”””
21 if p != self. data.ﬁrst(): # consider moving...
22 cnt = p.element(). count
23 walk = self. data.before(p)
24 if cnt > walk.element(). count: # must shift forward
25 while (walk != self. data.ﬁrst( ) and
26 cnt > self. data.before(walk).element(). count):
27 walk = self. data.before(walk)
28 self. data.add before(walk, self. data.delete(p)) # delete/reinsert288 Chapter7. LinkedLists
29 #------------------------------- public methods -------------------------------
30 def init (self):
31 ”””Create an empty list of favorites.”””
32 self. data = PositionalList( ) # will be list of Item instances
33
34 def len (self):
35 ”””Return number of entries on favorites list.”””
36 return len(self. data)
37
38 def is empty(self):
39 ”””Return True if list is empty.”””
40 return len(self. data) == 0
41
42 def access(self, e):
43 ”””Access element e, thereby increasing its access count.”””
44 p = self. ﬁnd position(e) # try to locate existing element
45 if p is None:
46 p = self. data.add last(self. Item(e)) # if new, place at end
47 p.element(). count += 1 # always increment count
48 self. move up(p) # consider moving forward
49
50 def remove(self, e):
51 ”””Remove element e from the list of favorites.”””
52 p = self. ﬁnd position(e) # try to locate existing element
53 if p is not None:
54 self. data.delete(p) # delete, if found
55
56 def top(self, k):
57 ”””Generate sequence of top k elements in terms of access count.”””
58 if not 1 <= k <= len(self):
59 raise ValueError( Illegal value for k )
60 walk = self. data.ﬁrst()
61 for j in range(k):
62 item = walk.element( ) # element of list is Item
63 yield item. value # report user’s element
64 walk = self. data.after(walk)7.6. CaseStudy:MaintainingAccessFrequencies 289
7.6.2 Using a List with the Move-to-Front Heuristic
The previous implementation of a favorites list performs the access(e) method in
time proportional to the index ofe in the favorites list. That is, ife is the kth most
popular element in the favorites list, then accessing it takes O(k) time. In many
real-life access sequences (e.g., Web pages visited by a user), once an element is
accessed it is more likely to be accessed again in the near future. Such scenarios
aresaidtopossesslocalityofreference.
Aheuristic, orruleofthumb, thatattemptstotakeadvantage ofthelocality of
reference that is present in an access sequence is the move-to-front heuristic. To
apply this heuristic, each time weaccess an element wemoveit all the wayto the
front ofthelist. Ourhope, ofcourse, isthat thiselement willbeaccessed againin
thenearfuture. Consider,forexample,ascenarioinwhichwehavenelementsand
thefollowingseriesofn2 accesses:
• element1isaccessedntimes
• element2isaccessedntimes
• ···
• elementnisaccessedntimes.
If we store the elements sorted by their access counts, inserting each element the
ﬁrsttimeitisaccessed, then
• eachaccesstoelement1runsinO(1)time
• eachaccesstoelement2runsinO(2)time
• ···
• eachaccesstoelementnrunsinO(n)time.
Thus,thetotaltimeforperformingtheseriesofaccesses isproportional to
n(n+1)
n+2n+3n+···+n·n=n(1+2+3+···+n)=n· ,
2
whichisO(n3).
Ontheotherhand,ifweusethemove-to-frontheuristic,insertingeachelement
theﬁrsttimeitisaccessed, then
• eachsubsequent accesstoelement1takesO(1)time
• eachsubsequent accesstoelement2takesO(1)time
• ···
• eachsubsequent accesstoelementnrunsinO(1)time.
So the running time for performing all the accesses in this case is O(n2). Thus,
the move-to-front implementation has faster access times for this scenario. Still,
themove-to-frontapproachisjustaheuristic, forthereareaccesssequenceswhere
using the move-to-front approach is slower than simply keeping the favorites list290 Chapter7. LinkedLists
The Trade-Oﬀs with the Move-to-Front Heuristic
If we no longer maintain the elements of the favorites list ordered by their access
counts,whenweareaskedtoﬁndthekmostaccessed elements,weneedtosearch
forthem. Wewillimplementthetop(k)methodasfollows:
1. Wecopyallentriesofourfavorites listintoanotherlist,namedtemp.
2. Wescanthetemplistktimes. Ineachscan,weﬁndtheentrywiththelargest
accesscount, removethisentryfromtemp,andreportitintheresults.
Thisimplementation ofmethodtoptakes O(kn)time. Thus, whenk isaconstant,
method topruns in O(n)time. This occurs, for example, when wewant toget the
“topten”list. However,ifkisproportional ton,thentop runs inO(n2)time. This
occurs, forexample, whenwewanta“top25%”list.
InChapter9wewillintroduce adatastructure thatwillallowustoimplement
top in O(n+klogn) time (see Exercise P-9.54), and more advanced techniques
couldbeusedtoperformtopinO(n+klogk)time.
Wecould easily achieveO(nlogn)timeifweuseastandard sorting algorithm
to reorder the temporary list before reporting the top k (see Chapter 12); this ap-
proach would be preferred to the original in the case that k is Ω(logn). (Recall
the big-Omega notation introduced in Section 3.3.1 to give an asymptotic lower
bound on the running time of an algorithm.) There is a more specialized sorting
algorithm(seeSection12.4.2)thatcantakeadvantageofthefactthataccesscounts
areintegersinordertoachieveO(n)timefortop,foranyvalueofk.
Implementing the Move-to-Front Heuristic in Python
We give an implementation of a favorites list using the move-to-front heuristic in
Code Fragment 7.20. The new FavoritesListMTF class inherits most of its func-
tionality fromtheoriginalFavoritesListasabaseclass.
Byouroriginal design, theaccessmethodoftheoriginal class reliesonanon-
publicutilitynamed move uptoenactthepotentialshiftingofanelementforward
in the list, after its access count had been incremented. Therefore, we implement
themove-to-frontheuristicbysimplyoverridingthe move upmethodsothateach
accessedelementismoveddirectlytothefrontofthelist(ifnotalreadythere). This
actioniseasilyimplemented bymeansofthepositional listADT.
ThemorecomplexportionofourFavoritesListMTFclassisthenewdeﬁnition
forthetopmethod. Werelyontheﬁrstoftheapproachesoutlinedabove,inserting
copiesoftheitemsintoatemporarylistandthenrepeatedlyﬁnding,reporting, and7.6. CaseStudy:MaintainingAccessFrequencies 291
1 class FavoritesListMTF(FavoritesList):
2 ”””List of elements ordered with move-to-front heuristic.”””
3
4 # we override move up to provide move-to-front semantics
5 def move up(self, p):
6 ”””Move accessed item at Position p to front of list.”””
7 if p != self. data.ﬁrst():
8 self. data.add ﬁrst(self. data.delete(p)) # delete/reinsert
9
10 # we override top because list is no longer sorted
11 def top(self, k):
12 ”””Generate sequence of top k elements in terms of access count.”””
13 if not 1 <= k <= len(self):
14 raise ValueError( Illegal value for k )
15
16 # we begin by making a copy of the original list
17 temp = PositionalList()
18 for item in self. data: # positional lists support iteration
19 temp.add last(item)
20
21 # we repeatedly ﬁnd, report, and remove element with largest count
22 for j in range(k):
23 # ﬁnd and report next highest from temp
24 highPos = temp.ﬁrst()
25 walk = temp.after(highPos)
26 while walk is not None:
27 if walk.element(). count > highPos.element(). count:
28 highPos = walk
29 walk = temp.after(walk)
30 # we have found the element with highest count
31 yield highPos.element(). value # report element to user
32 temp.delete(highPos) # remove from temp list
Code Fragment 7.20: Class FavoritesListMTF implementing the move-to-front
heuristic. This class extends FavoritesList (Code Fragments 7.18 and 7.19) and292 Chapter7. LinkedLists
7.7 Link-Based vs. Array-Based Sequences
We close this chapter by reﬂecting on the relative pros and cons of array-based
and link-based data structures that have been introduced thus far. The dichotomy
between these approaches presents a common design decision when choosing an
appropriate implementation of a data structure. There is not a one-size-ﬁts-all so-
lution, aseachoffersdistinctadvantages anddisadvantages.
Advantages of Array-Based Sequences
• Arrays provide O(1)-time access to an element based on an integer index.
The ability to access the kth element for any k in O(1) time is a hallmark
advantage of arrays (see Section 5.2). In contrast, locating the kth element
in a linked list requires O(k) time to traverse the list from the beginning,
or possibly O(n−k) time, if traversing backward from the end of a doubly
linkedlist.
• Operationswithequivalentasymptoticboundstypicallyrunaconstantfactor
more efﬁciently with an array-based structure versus a linked structure. As
an example, consider the typical enqueue operation for a queue. Ignoring
the issue of resizing an array, this operation for the ArrayQueue class (see
Code Fragment 6.7) involves an arithmetic calculation of the new index, an
increment of an integer, and storing a reference to the element in the array.
Incontrast, theprocessforaLinkedQueue(seeCodeFragment7.8)requires
the instantiation of a node, appropriate linking of nodes, and an increment
of an integer. While this operation completes inO(1) time in either model,
the actual number of CPU operations will be more in the linked version,
especially giventheinstantiation ofthenewnode.
• Array-based representations typically use proportionally less memory than
linkedstructures. Thisadvantagemayseemcounterintuitive,especiallygiven
thatthelengthofadynamicarraymaybelongerthanthenumberofelements
thatitstores. Botharray-basedlistsandlinkedlistsarereferentialstructures,
sotheprimarymemoryforstoring theactualobjects thatareelements isthe
same for either structure. What differs is the auxiliary amounts of memory
that are used by the two structures. For an array-based container of n ele-
ments,atypical worstcasemaybethatarecently resizeddynamicarrayhas
allocated memory for 2n object references. With linked lists, memory must
be devoted not only to store a reference to each contained object, but also
explicit references that link the nodes. So a singly linked list of length n
already requires 2n references (an element reference and next reference for7.7. Link-Basedvs.Array-BasedSequences 293
Advantages of Link-Based Sequences
• Link-based structures provide worst-case time bounds for their operations.
Thisis incontrast to theamortized bounds associated withtheexpansion or
contraction ofadynamicarray(seeSection5.3).
When many individual operations are part of a larger computation, and we
only care about the total time ofthat computation, an amortized bound isas
goodasaworst-caseboundpreciselybecauseitgivesaguaranteeonthesum
ofthetimespentontheindividual operations.
However,ifdatastructureoperationsareusedinareal-timesystemthatisde-
signedtoprovidemoreimmediateresponses(e.g.,anoperatingsystem,Web
server,airtrafﬁccontrolsystem),alongdelaycausedbyasingle(amortized)
operation mayhaveanadverseeffect.
• Link-based structures support O(1)-time insertions and deletions at arbi-
trary positions. The ability to perform a constant-time insertion or deletion
with the PositionalList class, by using a Position to efﬁciently describe the
location of the operation, is perhaps the most signiﬁcant advantage of the
linkedlist.
This is in stark contrast to an array-based sequence. Ignoring the issue of
resizing an array, inserting or deleting an element from theend of an array-
basedlistcanbedoneinconstanttime. However,moregeneralinsertionsand
deletions areexpensive. Forexample, withPython’s array-based listclass, a
calltoinsertorpopwithindexkusesO(n−k+1)timebecause oftheloop
toshiftallsubsequent elements(seeSection5.4).
Asanexample application, consider atext editor that maintains adocument
as a sequence of characters. Although users often add characters to the end
ofthedocument,itisalsopossibletousethecursortoinsertordeleteoneor
more characters at an arbitrary position within the document. If the charac-
ter sequence werestored inan array-based sequence (such asa Pythonlist),
each such edit operation mayrequire linearly many characters tobe shifted,
leading toO(n)performance for each edit operation. With a linked-list rep-
resentation, an arbitrary edit operation (insertion or deletion of a character
at the cursor) can be performed in O(1) worst-case time, assuming we are294 Chapter7. LinkedLists
7.8 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-7.1 Give an algorithm for ﬁnding the second-to-last node in a singly linked
listinwhichthelastnodeisindicated byanextreferenceofNone.
R-7.2 Describeagoodalgorithm forconcatenating twosinglylinkedlistsLand
(cid:2)
M,given only references tothe ﬁrstnode ofeach list, into asingle list L
thatcontains allthenodesofLfollowedbyallthenodesofM.
R-7.3 Describearecursivealgorithmthatcountsthenumberofnodesinasingly
linkedlist.
R-7.4 Describe indetail howtoswaptwonodesxand y(andnot just theircon-
tents) in a singly linked list L given references only to x and y. Repeat
thisexerciseforthecasewhenLisadoubly linked list. Whichalgorithm
takesmoretime?
R-7.5 Implement a function that counts the number of nodes in a circularly
linkedlist.
R-7.6 Suppose that x and y are references to nodes of circularly linked lists,
althoughnotnecessarilythesamelist. Describeafastalgorithmfortelling
ifxandybelongtothesamelist.
R-7.7 OurCircularQueueclassofSection7.2.2providesarotate()methodthat
has semantics equivalent to Q.enqueue(Q.dequeue()), for a nonempty
queue. Implement such a method for the LinkedQueue class of Sec-
tion7.1.2withoutthecreation ofanynewnodes.
R-7.8 Describe a nonrecursive method for ﬁnding, by link hopping, the middle
node of a doubly linked list with header and trailer sentinels. In the case
of an even number of nodes, report the node slightly left of center as the
“middle.” (Note: Thismethodmustonlyuselinkhopping;itcannotusea
counter.) Whatistherunningtimeofthismethod?
R-7.9 Give a fast algorithm for concatenating two doubly linked lists L and M,
(cid:2)
withheaderandtrailersentinel nodes,intoasinglelistL.
R-7.10 There seems to be some redundancy in the repertoire of the positional
list ADT, as the operation L.add ﬁrst(e) could be enacted by the alter-
native L.add before(L.ﬁrst(), e). Likewise, L.add last(e) might be per-
formed as L.add after(L.last(), e). Explain why the methods add ﬁrst7.8. Exercises 295
R-7.11 Implement a function, with calling syntax max(L), that returns the max-
imum element from a PositionalList instance L containing comparable
elements.
R-7.12 Redo the previously problem withmaxas amethod of the PositionalList
class,sothatcallingsyntaxL.max()issupported.
R-7.13 Update the PositionalList class to support an additional method ﬁnd(e),
whichreturnsthepositionofthe(ﬁrstoccurrence of)elementeinthelist
(orNoneifnotfound).
R-7.14 Repeat the previous process using recursion. Your method should not
contain any loops. Howmuch space does your method use in addition to
thespaceusedforL?
R-7.15 Providesupportfora reversed methodofthePositionalListclassthat
is similar to the given iter , but that iterates the elements inreversed
order.
R-7.16 Describe an implementation of the PositionalList methods add last and
add beforerealizedbyusingonlymethodsintheset{is empty,ﬁrst,last,
prev,next,add after,andadd ﬁrst}.
R-7.17 IntheFavoritesListMTFclass,werelyonpublicmethodsofthepositional
listADTtomoveanelementofalistatposition ptobecometheﬁrstele-
mentofthelist,whilekeepingtherelativeorderoftheremainingelements
unchanged. Internally, thatcombination ofoperations causes onenodeto
be removed and a new node to be inserted. Augment the PositionalList
class tosupport anew method,move to front(p), thataccomplishes this
goalmoredirectly, byrelinking theexistingnode.
R-7.18 Giventhesetofelement{a,b,c,d,e,f}storedinalist,showtheﬁnalstate
ofthelist,assumingweusethemove-to-front heuristic andaccesstheel-
ementsaccordingtothefollowingsequence: (a,b,c,d,e,f,a,c,f,b,d,e).
R-7.19 Supposethatwehavemadekntotalaccesses totheelementsinalistLof
nelements,forsomeintegerk≥1. Whataretheminimumandmaximum
numberofelementsthathavebeenaccessedfewerthanktimes?
R-7.20 LetLbealistofnitemsmaintainedaccordingtothemove-to-frontheuris-
tic. DescribeaseriesofO(n)accesses thatwillreverseL.
R-7.21 Suppose we have an n-element list L maintained according to the move-
to-front heuristic. Describe a sequence of n2 accesses that is guaranteed
totakeΩ(n3)timetoperformonL.
R-7.22 Implementaclear()methodfortheFavoritesListclassthatreturnsthelist
toempty.
R-7.23 Implementareset counts()methodfortheFavoritesListclassthatresets
all elements’ access counts to zero (while leaving the order of the list296 Chapter7. LinkedLists
Creativity
C-7.24 Give a complete implementation of the stack ADT using a singly linked
listthatincludes aheadersentinel.
C-7.25 Giveacomplete implementation of the queue ADTusing asingly linked
listthatincludes aheadersentinel.
C-7.26 Implement a method, concatenate(Q2) for the LinkedQueue class that
takesallelementsofLinkedQueue Q2andappendsthemtotheendofthe
original queue. The operation should run inO(1) time and should result
inQ2beinganemptyqueue.
C-7.27 Givearecursive implementation ofasingly linked listclass, such thatan
instance ofanonemptyliststoresitsﬁrstelementandareference toalist
ofremainingelements.
C-7.28 Describeafastrecursivealgorithm forreversing asinglylinkedlist.
C-7.29 Describe in detail an algorithm for reversing a singly linked list L using
onlyaconstantamountofadditionalspaceandnotusinganyrecursion.
C-7.30 ExerciseP-6.35describesaLeakyStackabstraction. ImplementthatADT
usingasinglylinkedlistforstorage.
C-7.31 DesignaforwardlistADTthatabstractstheoperations onasinglylinked
list, much as the positional list ADT abstracts the use of a doubly linked
list. ImplementaForwardListclassthatsupports suchanADT.
C-7.32 Designacircular positional listADTthatabstracts acircularly linked list
inthesamewaythatthepositionallistADTabstractsadoublylinkedlist,
withanotionofadesignated “cursor”position withinthelist.
C-7.33 Modifythe DoublyLinkedBaseclasstoincludeareversemethodthatre-
versestheorderofthelist,yetwithoutcreatingordestroyinganynodes.
C-7.34 ModifythePositionalListclasstosupportamethodswap(p, q)thatcauses
theunderlying nodesreferenced bypositionspandqtobeexchanged for
eachother. Relinktheexistingnodes;donotcreateanynewnodes.
C-7.35 ToimplementtheitermethodofthePositionalListclass,wereliedonthe
convenience of Python’s generator syntax and the yield statement. Give
an alternative implementation ofiterby designing a nested iterator class.
(SeeSection2.3.4fordiscussion ofiterators.)
C-7.36 GiveacompleteimplementationofthepositionallistADTusingadoubly
linkedlistthatdoesnotinclude anysentinel nodes.
C-7.37 Implement a function that accepts a PositionalList L of n integers sorted
innondecreasing order,andanothervalueV,anddeterminesinO(n)time
iftherearetwoelementsofLthatsumpreciselytoV. Thefunctionshould7.8. Exercises 297
C-7.38 Thereisasimple,butinefﬁcient,algorithm,calledbubble-sort,forsorting
alistLofncomparableelements. Thisalgorithmscansthelistn−1times,
where, ineachscan, thealgorithm compares thecurrent element withthe
nextoneandswapsthemiftheyareoutoforder. Implementabubble sort
function that takes apositional listLas aparameter. What isthe running
timeofthisalgorithm, assuming thepositional listisimplemented witha
doublylinkedlist?
C-7.39 To better model a FIFO queue in which entries may be deleted before
reaching thefront, designaPositionalQueueclassthatsupports thecom-
pletequeueADT,yetwithenqueuereturningapositioninstanceandsup-
port for a new method, delete(p), that removes the element associated
with position p from the queue. You may use the adapter design pattern
(Section6.1.2),usingaPositionalListasyourstorage.
C-7.40 DescribeanefﬁcientmethodformaintainingafavoriteslistL,withmove-
to-front heuristic, such that elements that have not been accessed in the
mostrecentnaccessesareautomatically purgedfromthelist.
C-7.41 ExerciseC-5.29introduces thenotion ofanaturaljoinoftwodatabases.
Describeandanalyzeanefﬁcientalgorithmforcomputingthenaturaljoin
ofalinkedlistAofnpairsandalinkedlistBofmpairs.
C-7.42 Write a Scoreboard class that maintains the top 10 scores for a game ap-
plication using a singly linked list, rather than the array that was used in
Section5.5.1.
C-7.43 Describe amethod forperforming acardshufﬂeofalistof2nelements,
byconverting itintotwolists. Acardshufﬂeisapermutationwherealist
Liscutintotwolists,L andL ,whereL istheﬁrsthalfofLandL isthe
1 2 1 2
second half of L, and then these two lists are merged into one by taking
theﬁrstelementinL ,thentheﬁrstelementinL ,followedbythesecond
1 2
elementinL ,thesecondelementinL ,andsoon.
1 2
Projects
P-7.44 Write a simple text editor that stores and displays a string of characters
usingthepositional listADT,togetherwithacursorobjectthathighlights
a position in this string. A simple interface is to print the string and then
touseasecondlineofoutputtounderlinethepositionofthecursor. Your
editorshouldsupport thefollowingoperations:
• left: Movecursorleftonecharacter (donothingifatbeginning).
• right: Movecursorrightonecharacter (donothingifatend).
• insert c: Insertthecharactercjustafterthecursor.298 Chapter7. LinkedLists
P-7.45 An array A is sparse if most of its entries are empty (i.e., None). A list
L can be used to implement such an array efﬁciently. In particular, for
each nonempty cell A[i], we can store an entry (i,e) in L, where e is the
elementstoredatA[i]. ThisapproachallowsustorepresentAusingO(m)
storage, where m is the number of nonempty entries in A. Provide such
aSparseArrayclassthatminimallysupportsmethods getitem (j)and
setitem (j, e) to provide standard indexing operations. Analyze the
efﬁciencyofthesemethods.
P-7.46 Although we have used a doubly linked list to implement the positional
list ADT, it is possible to support the ADT with an array-based imple-
mentation. Thekeyistousethecompositionpatternandstoreasequence
of position items, where each item stores an element as well as that ele-
ment’scurrentindexinthearray. Wheneveranelement’splaceinthearray
is changed, the recorded index in the position must be updated to match.
Given acomplete class providing such an array-based implementation of
thepositional listADT.Whatistheefﬁciencyofthevariousoperations?
P-7.47 Implement aCardHandclass that supports aperson arranging agroup of
cards in his or her hand. The simulator should represent the sequence of
cards using asingle positional list ADTsothat cards ofthesamesuit are
kepttogether. Implementthisstrategybymeansoffour“ﬁngers”intothe
hand, one for each of the suits of hearts, clubs, spades, and diamonds,
so that adding a new card to the person’s hand or playing a correct card
fromthehandcanbedoneinconstant time. Theclassshould support the
followingmethods:
• add card(r, s): Addanewcardwithrankrandsuitstothehand.
• play(s): Remove and return a card of suit s from the player’s hand;
ifthereisnocardofsuits,thenremoveandreturnanarbitrary card
fromthehand.
• iter (): Iteratethroughallcardscurrently inthehand.
• all of suit(s): Iterate through allcards ofsuitsthat arecurrently in
thehand.
Chapter Notes
A view of data structures as collections (and other principles of object-oriented design)
can be found in object-oriented design books by Booch [17], Budd [20], Goldberg and
Robson [42], and Liskov and Guttag [71]. Our positional list ADT is derived from the
“position”abstractionintroducedbyAho,Hopcroft,andUllman[6], andthelist ADTofChapter
8
Trees
Contents
8.1 General Trees . . . . . . . . . . . . . . . . . . . . . . . . . 300
8.1.1 Tree Deﬁnitions and Properties . . . . . . . . . . . . . . . 301
8.1.2 The Tree Abstract Data Type . . . . . . . . . . . . . . . 305
8.1.3 Computing Depth and Height. . . . . . . . . . . . . . . . 308
8.2 Binary Trees . . . . . . . . . . . . . . . . . . . . . . . . . . 311
8.2.1 The Binary Tree Abstract Data Type . . . . . . . . . . . . 313
8.2.2 Properties of Binary Trees . . . . . . . . . . . . . . . . . 315
8.3 Implementing Trees . . . . . . . . . . . . . . . . . . . . . . 317
8.3.1 Linked Structure for Binary Trees . . . . . . . . . . . . . . 317
8.3.2 Array-Based Representation of a Binary Tree . . . . . . . 325
8.3.3 Linked Structure for General Trees . . . . . . . . . . . . . 327
8.4 Tree Traversal Algorithms . . . . . . . . . . . . . . . . . . . 328
8.4.1 Preorder and Postorder Traversals of General Trees . . . . 328
8.4.2 Breadth-First Tree Traversal . . . . . . . . . . . . . . . . 330
8.4.3 Inorder Traversal of a Binary Tree . . . . . . . . . . . . . 331
8.4.4 Implementing Tree Traversals in Python . . . . . . . . . . 333
8.4.5 Applications of Tree Traversals . . . . . . . . . . . . . . . 337
(cid:2)
8.4.6 Euler Tours and the Template Method Pattern . . . . . 341
8.5 Case Study: An Expression Tree . . . . . . . . . . . . . . . 348300 Chapter8. Trees
8.1 General Trees
Productivity experts say that breakthroughs come by thinking “nonlinearly.” In
this chapter, we discuss one of the most important nonlinear data structures in
computing—trees. Treestructures areindeed abreakthrough indata organization,
for they allow us to implement a host of algorithms much faster than when using
linear datastructures, suchasarray-based listsorlinkedlists. Treesalsoprovide a
natural organization fordata, andconsequently havebecome ubiquitous structures
inﬁlesystems, graphical userinterfaces, databases, Websites, andothercomputer
systems.
It is not always clear what productivity experts mean by “nonlinear” thinking,
but when we say that trees are “nonlinear,” we are referring to an organizational
relationship that is richer than the simple “before” and “after” relationships be-
tweenobjectsinsequences. Therelationships inatreearehierarchical,withsome
objects being “above” and some “below” others. Actually, the main terminology
for tree data structures comes from family trees, with the terms “parent,” “child,”
“ancestor,” and“descendant” beingthemostcommonwordsusedtodescriberela-
tionships. WeshowanexampleofafamilytreeinFigure8.1.
m
a
h
a
br
A
shmael Isaac Zimran okshan Medan Midian Ishbak Shuah
I J
NebaiothKedarAdbeelMibsamMishmaDumahMassaHadadTemaJeturNaphishKedemah Esau b(Israel) ShebaDedan EphahEpherHanochAbidaEldaah
o
c
a
J
EliphazReuelJeushJalamKorah ReubenSimeonLeviJudahDanNaphtaliGadAsherIssacharZebulunDinahJosephBenjamin
Figure 8.1: A family tree showing some descendants of Abraham, as recorded in8.1. GeneralTrees 301
8.1.1 Tree Deﬁnitions and Properties
A tree is an abstract data type that stores elements hierarchically. With the excep-
tion of the top element, each element in a tree has a parent element and zero or
more children elements. A tree is usually visualized by placing elements inside
ovals or rectangles, and by drawing the connections betweenparents and children
with straight lines. (See Figure 8.2.) We typically call the top element the root
of the tree, but it is drawn as the highest element, with the other elements being
connected below(justtheopposite ofabotanical tree).
Electronics R’Us
R&D Sales Purchasing Manufacturing
Domestic International TV CD Tuner
Canada S. America Overseas
Africa Europe Asia Australia
Figure 8.2: A tree with 17 nodes representing the organization of a ﬁctitious cor-
poration. The root stores Electronics R’Us. The children of the root store R&D,
Sales, Purchasing, and Manufacturing. The internal nodes store Sales, Interna-
tional, Overseas,Electronics R’Us,andManufacturing.
Formal Tree Deﬁnition
Formally,wedeﬁneatreeT asasetofnodesstoring elementssuchthatthenodes
haveaparent-childrelationship thatsatisﬁesthefollowingproperties:
• IfT isnonempty,ithasaspecialnode,calledtherootofT,thathasnoparent.
• Each node v ofT different from the root has aunique parent node w; every
nodewithparentwisachildofw.
Notethataccording toourdeﬁnition, atreecanbeempty, meaningthatitdoesnot
have any nodes. This convention also allows us to deﬁne a tree recursively such
that a tree T is either empty or consists of a node r, called the root of T, and a302 Chapter8. Trees
Other Node Relationships
Two nodes that are children of the same parent aresiblings. A node v is external
if v has no children. A node v is internal if it has one or more children. External
nodesarealsoknownasleaves.
Example 8.1: In Section 4.1.4, wediscussed the hierarchical relationship be-
tweenﬁlesanddirectoriesinacomputer’sﬁlesystem,althoughatthetimewe
didnotemphasizethenomenclatureofaﬁlesystemasatree. InFigure8.3,we
revisitanearlierexample. Weseethattheinternalnodesofthetreeareassoci-
atedwithdirectoriesandtheleavesareassociatedwithregularﬁles.IntheUNIX
andLinuxoperatingsystems,therootofthetreeisappropriatelycalledthe“root
directory,”andisrepresentedbythesymbol“/.”
/user/rt/courses/
cs016/ cs252/
grades grades
homeworks/ programs/ projects/
hw1 hw2 hw3 pr1 pr2 pr3
papers/ demos/
buylow sellhigh market
Figure8.3: Treerepresenting aportionofaﬁlesystem.
A node u is an ancestor of a node v if u=v or u is an ancestor of the parent
ofv. Conversely,wesaythatanodevisadescendantofanodeuifuisanancestor
of v. For example, in Figure 8.3, cs252/ is an ancestor of papers/, and pr3 is a
descendant ofcs016/. ThesubtreeofT rooted atanodevisthetreeconsisting of
allthedescendantsofvinT (includingvitself). InFigure8.3,thesubtreerootedat
cs016/ consists of the nodes cs016/, grades, homeworks/, programs/, hw1, hw2,
hw3,pr1,pr2,andpr3.
Edges and Paths in Trees
An edge of tree T is a pair of nodes (u,v) such that u is the parent of v, or vice
versa. Apath of T is asequence of nodes such that any two consecutive nodes in
the sequence form an edge. For example, the tree in Figure 8.3contains the path8.1. GeneralTrees 303
Example 8.2: TheinheritancerelationbetweenclassesinaPythonprogramforms
atreewhensingleinheritanceisused.Forexample,inSection2.4weprovideda
summaryofthehierarchyforPython’sexceptiontypes,asportrayedinFigure8.4
(originallyFigure2.5).TheBaseExceptionclassistherootofthathierarchy,while
alluser-deﬁnedexceptionclassesshouldconventionallybedeclaredasdescendants
ofthemorespeciﬁcExceptionclass.(See,forexample,theEmptyclassweintro-
ducedinCodeFragment6.1ofChapter6.)
BaseException
SystemExit Exception KeyboardInterrupt
ValueError LookupError ArithmeticError
IndexError KeyError ZeroDivisionError
Figure8.4: AportionofPython’shierarchyofexception types.
In Python, all classes are organized into a single hierarchy, as there exists a
built-in class namedobjectastheultimate baseclass. Itisadirect orindirect base
classofallothertypesinPython(evenifnotdeclaredassuchwhendeﬁninganew
class). Therefore,thehierarchypicturedinFigure8.4isonlyaportionofPython’s
completeclasshierarchy.
As a preview of the remainder of this chapter, Figure 8.5 portrays our own
hierarchy ofclassesforrepresenting variousformsofatree.
Tree
BinaryTree LinkedTree
ArrayBinaryTree LinkedBinaryTree
Figure 8.5: Our own inheritance hierarchy for modeling various abstractions and
implementationsoftreedatastructures. Intheremainderofthischapter,weprovide
implementations of Tree, BinaryTree, and LinkedBinaryTree classes, and high-304 Chapter8. Trees
Ordered Trees
A tree is ordered if there is a meaningful linear order among the children of each
node; that is, we purposefully identify the children of a node as being the ﬁrst,
second, third, and soon. Such anorder isusually visualizedby arranging siblings
lefttoright, according totheirorder.
Example 8.3: Thecomponentsofastructureddocument,suchasabook,arehier-
archicallyorganizedasatreewhoseinternalnodesareparts,chapters,andsections,
andwhoseleavesareparagraphs,tables,ﬁgures,andsoon.(SeeFigure8.6.)The
rootofthetreecorrespondstothebookitself.Wecould,infact,considerexpanding
thetreefurthertoshowparagraphsconsistingofsentences,sentencesconsistingof
words,andwordsconsistingofcharacters.Suchatreeisanexampleofanordered
tree,becausethereisawell-deﬁnedorderamongthechildrenofeachnode.
Book
Preface Part A Part B References
... ... ... ...
¶ ¶ Ch. 1 Ch. 5 Ch. 6 Ch. 9 ¶ ¶
... ... ... ...
§ 1.1 § 1.4 § 5.1 § 5.7 § 6.1 § 6.5 § 9.1 § 9.6
... ...
...
¶ ¶ ¶ ¶
Figure8.6: Anorderedtreeassociated withabook.
Let’s look back at the other examples of trees that we have described thus far,
and consider whether the order of children is signiﬁcant. A family tree that de-
scribes generational relationships, asinFigure8.1, isoften modeled asanordered
tree,withsiblings orderedaccording totheirbirth.
Incontrast, anorganizational chartforacompany,asinFigure8.2,istypically
considered an unordered tree. Likewise, when using a tree to describe an inher-
itance hierarchy, as in Figure 8.4, there is no particular signiﬁcance to the order
among the subclasses of a parent class. Finally, we consider the use of a tree in
modelingacomputer’sﬁlesystem,asinFigure8.3. Althoughanoperatingsystem
oftendisplaysentriesofadirectoryinaparticularorder(e.g.,alphabetical, chrono-8.1. GeneralTrees 305
8.1.2 The Tree Abstract Data Type
As we did with positional lists in Section 7.4, we deﬁne a tree ADT using the
concept of a position as an abstraction for a node of a tree. An element is stored
ateachposition, andpositions satisfyparent-child relationships thatdeﬁnethetree
structure. Aposition objectforatreesupports themethod:
p.element(): Returntheelementstoredatpositionp.
The tree ADT then supports the following accessor methods, allowing a user to
navigatethevariouspositions ofatree:
T.root(): Returntheposition oftherootoftreeT,
orNoneifTisempty.
T.is root(p): ReturnTrueifpositionpistherootofTreeT.
T.parent(p): Returntheposition oftheparentofpositionp,
orNoneifpistherootofT.
T.num children(p): Returnthenumberofchildren ofpositionp.
T.children(p): Generateaniteration ofthechildrenofpositionp.
T.is leaf(p): ReturnTrueifpositionpdoesnothaveanychildren.
len(T): Returnthenumberofpositions(andhenceelements)that
arecontained intreeT.
T.is empty(): ReturnTrueiftreeTdoesnotcontain anypositions.
T.positions(): Generateaniteration ofallpositionsoftreeT.
iter(T): GenerateaniterationofallelementsstoredwithintreeT.
Anyoftheabovemethodsthatacceptsapositionasanargumentshouldgeneratea
ValueErrorifthatposition isinvalid forT.
IfatreeTisordered,thenT.children(p)reportsthechildrenofpinthenatural
order. If p is a leaf, then T.children(p) generates an empty iteration. In similar
regard,iftreeTisempty,thenbothT.positions()anditer(T)generateemptyiter-
ations. Wewilldiscussgeneralmeansforiteratingthroughallpositionsofatreein
Sections8.4.
We do not deﬁne any methods for creating or modifying trees at this point.
We prefer to describe different tree update methods in conjunction with speciﬁc306 Chapter8. Trees
A Tree Abstract Base Class in Python
Indiscussingtheobject-orienteddesignprincipleofabstractioninSection2.1.2,we
notedthatapublicinterfaceforanabstractdatatypeisoftenmanagedinPythonvia
ducktyping. Forexample,wedeﬁnedthenotionofthepublicinterfaceforaqueue
ADT in Section 6.2, and have since presented several classes that implement the
queue interface (e.g.,ArrayQueuein Section 6.2.2, LinkedQueue in Section 7.1.2,
CircularQueueinSection7.2.2). However, wenevergaveanyformal deﬁnition of
thequeueADTinPython;alloftheconcreteimplementationswereself-contained
classes that just happen to adhere to the same public interface. A more formal
mechanismtodesignatetherelationshipsbetweendifferentimplementationsofthe
same abstraction is through the deﬁnition of one class that serves as an abstract
baseclass, viainheritance, foroneormoreconcreteclasses. (SeeSection2.4.3.)
We choose to deﬁne a Tree class, in Code Fragment 8.1, that serves as an ab-
stractbaseclasscorrespondingtothetreeADT.Ourreasonfordoingsoisthatthere
isquiteabitofusefulcodethatwecanprovide,evenatthislevelofabstraction, al-
lowinggreatercodereuseintheconcretetreeimplementationswelaterdeﬁne. The
Tree class provides a deﬁnition of a nested Position class (which is also abstract),
anddeclarations ofmanyoftheaccessor methodsincludedinthetreeADT.
However, our Tree class does not deﬁne any internal representation for stor-
ing a tree, and ﬁve of the methods given in that code fragment remain abstract
(root,parent,num children,children,and len );eachofthesemethodsraisesa
NotImplementedError. (Amoreformalapproachfordeﬁningabstractbaseclasses
and abstract methods, using Python’s abc module, is described in Section 2.4.3.)
Thesubclassesareresponsibleforoverridingabstractmethods,suchaschildren,to
provideaworkingimplementationforeachbehavior,basedontheirchoseninternal
representation.
Although the Tree class is an abstract base class, it includes several concrete
methodswithimplementationsthatrelyoncallstotheabstractmethodsoftheclass.
IndeﬁningthetreeADTintheprevious section, wedeclare tenaccessor methods.
Fiveofthosearetheonesweleftasabstract, inCodeFragment8.1. Theotherﬁve
can be implemented based on the former. Code Fragment 8.2 provides concrete
implementations formethodsis root,is leaf,andis empty. InSection8.4,wewill
exploregeneralalgorithmsfortraversingatreethatcanbeusedtoprovideconcrete
implementations ofthepositionsand iter methods withintheTreeclass. The
beauty of this design is that the concrete methods deﬁned within the Tree abstract
baseclasswillbeinherited byallsubclasses. Thispromotes greater codereuse, as
therewillbenoneedforthosesubclasses toreimplement suchbehaviors.
We note that, with the Tree class being abstract, there is no reason to create a
directinstanceofit,norwouldsuchaninstancebeuseful. Theclassexiststoserve8.1. GeneralTrees 307
1 class Tree:
2 ”””Abstract base class representing a tree structure.”””
3
4 #------------------------------- nested Position class -------------------------------
5 class Position:
6 ”””An abstraction representing the location of a single element.”””
7
8 def element(self):
9 ”””Return the element stored at this Position.”””
10 raise NotImplementedError( must be implemented by subclass )
11
12 def eq (self, other):
13 ”””Return True if other Position represents the same location.”””
14 raise NotImplementedError( must be implemented by subclass )
15
16 def ne (self, other):
17 ”””Return True if other does not represent the same location.”””
18 return not (self == other) # opposite of eq
19
20 # ---------- abstract methods that concrete subclass must support ----------
21 def root(self):
22 ”””Return Position representing the trees root (or None if empty).”””
23 raise NotImplementedError( must be implemented by subclass )
24
25 def parent(self, p):
26 ”””Return Position representing ps parent (or None if p is root).”””
27 raise NotImplementedError( must be implemented by subclass )
28
29 def num children(self, p):
30 ”””Return the number of children that Position p has.”””
31 raise NotImplementedError( must be implemented by subclass )
32
33 def children(self, p):
34 ”””Generate an iteration of Positions representing ps children.”””
35 raise NotImplementedError( must be implemented by subclass )
36
37 def len (self):
38 ”””Return the total number of elements in the tree.”””
39 raise NotImplementedError( must be implemented by subclass )
Code Fragment8.1: A portion of our Tree abstract base class (continued in Code308 Chapter8. Trees
40 # ---------- concrete methods implemented in this class ----------
41 def is root(self, p):
42 ”””Return True if Position p represents the root of the tree.”””
43 return self.root( ) == p
44
45 def is leaf(self, p):
46 ”””Return True if Position p does not have any children.”””
47 return self.num children(p) == 0
48
49 def is empty(self):
50 ”””Return True if the tree is empty.”””
51 return len(self) == 0
CodeFragment8.2: Someconcrete methodsofourTreeabstractbaseclass.
8.1.3 Computing Depth and Height
Let p be the position of a node of a tree T. The depth of p is the number of
ancestors of p, excluding pitself. Forexample, in the tree of Figure 8.2, the node
storingInternational hasdepth2. Notethatthisdeﬁnitionimpliesthatthedepthof
therootofT is0. Thedepthof pcanalsoberecursively deﬁnedasfollows:
• If pistheroot,thenthedepthof pis0.
• Otherwise,thedepthof pisoneplusthedepthoftheparentof p.
Based on this deﬁnition, wepresent a simple, recursive algorithm, depth, in Code
Fragment8.3,forcomputingthedepthofaposition pinTreeT. Thismethodcalls
itselfrecursively ontheparentof p,andadds1tothevaluereturned.
52 def depth(self, p):
53 ”””Return the number of levels separating Position p from the root.”””
54 if self.is root(p):
55 return 0
56 else:
57 return 1 + self.depth(self.parent(p))
CodeFragment8.3: MethoddepthoftheTreeclass.
Therunning timeofT.depth(p)for position pisO(d +1), where d denotes
p p
thedepth of pinthetreeT,because thealgorithm performsaconstant-time recur-
sive step for each ancestor of p. Thus, algorithm T.depth(p) runs in O(n) worst-
case time, where n is the total number of positions of T, because a position of T
may have depth n−1 if all nodes form a single branch. Although such a running
timeisafunctionoftheinputsize,itismoreinformativetocharacterizetherunning
timeintermsoftheparameterd ,asthisparametermaybemuchsmallerthann.8.1. GeneralTrees 309
Height
Theheightofaposition pinatreeT isalsodeﬁnedrecursively:
• If pisaleaf,thentheheightof pis0.
• Otherwise, the height of p is one more than the maximum of the heights of
p’schildren.
The height of a nonempty tree T is the height of the root of T. For example, the
treeofFigure8.2hasheight4. Inaddition, heightcanalsobeviewedasfollows.
Proposition 8.4: TheheightofanonemptytreeT isequaltothemaximumof
thedepthsofitsleafpositions.
We leave the justiﬁcation of this fact to an exercise (R-8.3). We present an
algorithm, height1, implemented in Code Fragment 8.4 as a nonpublic method
height1 of the Tree class. It computes the height of a nonempty treeT based on
Proposition 8.4andthealgorithmdepthfromCodeFragment8.3.
58 def height1(self): # works, but O(nˆ2) worst-case time
59 ”””Return the height of the tree.”””
60 return max(self.depth(p) for p in self.positions( ) if self.is leaf(p))
CodeFragment8.4: Method height1oftheTreeclass. Notethatthismethodcalls
thedepthmethod.
Unfortunately, algorithmheight1isnotveryefﬁcient. Wehavenotyetdeﬁned
thepositions()method;wewillseethatitcanbeimplementedtoruninO(n)time,
wherenisthenumberofpositionsofT. Becauseheight1callsalgorithmdepth(p)
on each leaf of T, its running time is O(n+∑ (d +1)), where L is the set of
p∈L p
leaf positions ofT. In the worst case, the sum∑ (d +1) is proportional ton2.
p∈L p
(SeeExerciseC-8.33.) Thus,algorithmheight1runsinO(n2)worst-case time.
Wecan compute theheight ofatree moreefﬁciently, inO(n)worst-case time,
by relying instead on the original recursive deﬁnition. To do this, we will param-
eterize a function based on a position within the tree, and calculate the height of
thesubtreerootedatthatposition. Algorithmheight2,shownasnonpublicmethod
height2inCodeFragment8.5,computestheheightoftreeT inthisway.
61 def height2(self, p): # time is linear in size of subtree
62 ”””Return the height of the subtree rooted at Position p.”””
63 if self.is leaf(p):
64 return 0
65 else:
66 return 1 + max(self. height2(c) for c in self.children(p))
CodeFragment8.5: Method height2forcomputing theheight ofasubtree rooted310 Chapter8. Trees
It is important to understand why algorithm height2 is more efﬁcient than
height1. The algorithm is recursive, and it progresses in a top-down fashion. If
the method isinitially called on the root ofT, itwill eventually becalled once for
each position of T. This is because the root eventually invokes the recursion on
each of its children, which in turn invokes the recursion on each of their children,
andsoon.
Wecandeterminetherunningtimeoftheheight2algorithmbysumming,over
all the positions, the amount of time spent on the nonrecursive part of each call.
(Review Section 4.2 for analyses of recursive processes.) In our implementation,
thereisaconstantamountofworkperposition,plustheoverheadofcomputingthe
maximum over the iteration of children. Although we do not yet have a concrete
implementation of children(p), we assume that such an iteration is generated in
O(c +1)time, wherec denotes thenumber ofchildren of p. Algorithm height2
p p
spends O(c +1)timeateachposition ptocomputethemaximum,anditsoverall
p
running time is O(∑ (c +1))=O(n+∑ c ). In order to complete the analysis,
p p p p
wemakeuseofthefollowingproperty.
Proposition 8.5: LetT beatreewithnpositions,andletc denotethenumberof
p
childrenofapositionpofT.Then,summingoverthepositionsofT,∑ c =n−1.
p p
Justiﬁcation: Each position of T, with the exception of the root, is a child of
anotherposition, andthuscontributes oneunittotheabovesum.
ByProposition 8.5, therunning timeofalgorithm height2, whencalled onthe
rootofT,isO(n),wherenisthenumberofpositions ofT.
RevisitingthepublicinterfaceforourTreeclass,theabilitytocomputeheights
of subtrees is beneﬁcial, but a user might expect to be able tocompute the height
oftheentiretreewithoutexplicitlydesignating thetreeroot. Wecanwrapthenon-
public height2 in our implementation with a public height method that provides
a default interpretation when invoked on tree T with syntax T.height(). Such an
implementation isgiveninCodeFragment8.6.
67 def height(self, p=None):
68 ”””Return the height of the subtree rooted at Position p.
69
70 If p is None, return the height of the entire tree.
71 ”””
72 if p is None:
73 p = self.root()
74 return self. height2(p) # start height2 recursion
Code Fragment 8.6: Public method Tree.height that computes the height of the8.2. BinaryTrees 311
8.2 Binary Trees
Abinarytreeisanorderedtreewiththefollowingproperties:
1. Everynodehasatmosttwochildren.
2. Eachchildnodeislabeledasbeingeitheraleftchildorarightchild.
3. Aleftchildprecedes arightchildintheorderofchildren ofanode.
Thesubtreerootedataleftorrightchildofaninternalnodeviscalledaleftsubtree
or right subtree, respectively, ofv. Abinary tree isproper if each node has either
zero or two children. Some people also refer to such trees as being full binary
trees. Thus, in a proper binary tree, every internal node hasexactly two children.
Abinarytreethatisnotproperisimproper.
Example 8.6: Animportantclassofbinarytreesarisesincontextswherewewish
torepresentanumberofdifferentoutcomesthatcanresultfromansweringaseries
ofyes-or-noquestions.Eachinternalnodeisassociatedwithaquestion.Startingat
theroot,wegototheleftorrightchildofthecurrentnode,dependingonwhether
theanswertothequestionis“Yes”or“No.” Witheachdecision,wefollowan
edgefromaparenttoachild,eventuallytracingapathinthetreefromtheroot
toaleaf.Suchbinarytreesareknownasdecision trees,becausealeafpositionp
insuchatreerepresentsadecisionofwhattodoifthequestionsassociatedwith
p’sancestorsareansweredinawaythatleadstop. Adecisiontreeisaproper
binarytree.Figure8.7illustratesadecisiontreethatprovidesrecommendationsto
aprospectiveinvestor.
Are you nervous?
Yes No
Will you need to access most of the
Savings account.
money within the next 5 years?
Yes No
Are you willing to accept risks in
Money market fund.
exchange for higher expected returns?
Yes No
Diversiﬁed portfolio with stocks,
Stock portfolio.
bonds, and short-term instruments.312 Chapter8. Trees
Example 8.7: Anarithmeticexpressioncanberepresentedbyabinarytreewhose
leavesareassociatedwithvariablesorconstants, andwhoseinternalnodesare
associatedwithoneoftheoperators+,−,×,and/.(SeeFigure8.8.)Eachnode
insuchatreehasavalueassociatedwithit.
• Ifanodeisleaf,thenitsvalueisthatofitsvariableorconstant.
• Ifanodeisinternal,thenitsvalueisdeﬁnedbyapplyingitsoperationtothe
valuesofitschildren.
Anarithmeticexpressiontreeisaproperbinarytree,sinceeachoperator+,−,×,
and/takesexactlytwooperands.Ofcourse,ifweweretoallowunaryoperators,
likenegation(−),asin“−x,”thenwecouldhaveanimproperbinarytree.
−
/ +
× + ×
6
+ − −
3 2 3
3 1 9 5 7 4
Figure8.8:Abinarytreerepresentinganarithmeticexpression. Thistreerepresents
the expression ((((3+1)×3)/((9−5)+2))−((3×(7−4))+6)). The value
associated withtheinternalnodelabeled “/”is2.
A Recursive Binary Tree Deﬁnition
Incidentally, wecan also deﬁne a binary tree inarecursive waysuch that abinary
treeiseitheremptyorconsistsof:
• Anoder,calledtherootofT,thatstoresanelement
• Abinarytree(possibly empty),calledtheleftsubtree ofT8.2. BinaryTrees 313
8.2.1 The Binary Tree Abstract Data Type
Asanabstractdatatype,abinarytreeisaspecializationofatreethatsupportsthree
additional accessor methods:
T.left(p): Returntheposition thatrepresents theleftchildofp,
orNoneifphasnoleftchild.
T.right(p): Returntheposition thatrepresents therightchildofp,
orNoneifphasnorightchild.
T.sibling(p): Returntheposition thatrepresents thesibling ofp,
orNoneifphasnosibling.
JustasinSection8.1.2forthetreeADT,wedonotdeﬁnespecializedupdatemeth-
ods forbinary trees here. Instead, wewillconsider some possible update methods
whenwedescribe speciﬁcimplementations andapplicationsofbinarytrees.
The BinaryTree Abstract Base Class in Python
Just as Tree was deﬁned as an abstract base class in Section 8.1.2, we deﬁne a
newBinaryTreeclass associated withthe binary tree ADT.Werely oninheritance
to deﬁne the BinaryTree class based upon the existing Tree class. However, our
BinaryTree class remains abstract, as we still do not provide complete speciﬁca-
tions for how such a structure will be represented internally, nor implementations
forsomenecessary behaviors.
Our Python implementation of the BinaryTree class is given in Code Frag-
ment8.7. Byusinginheritance, abinarytreesupportsallthefunctionality thatwas
deﬁnedforgeneraltrees(e.g.,parent,is leaf,root). Ournewclassalsoinheritsthe
nested Position class that was originally deﬁned within the Tree class deﬁnition.
In addition, the new class provides declarations for new abstract methods left and
rightthatshouldbesupported byconcrete subclasses ofBinaryTree.
Our new class also provides two concrete implementations of methods. The
newsiblingmethodisderivedfromthecombinationofleft,right,andparent. Typ-
ically, we identify the sibling of a position p as the “other” child of p’s parent.
However, if pistheroot, ithasnoparent, and thus nosibling. Also, pmaybethe
onlychildofitsparent, andthusdoesnothaveasibling.
Finally,CodeFragment8.7providesaconcreteimplementation ofthechildren
method;thismethodisabstract intheTreeclass. Althoughwehavestillnotspeci-
ﬁedhowthechildrenofanodewillbestored,wederiveageneratorfortheordered314 Chapter8. Trees
1 class BinaryTree(Tree):
2 ”””Abstract base class representing a binary tree structure.”””
3
4 # --------------------- additional abstract methods ---------------------
5 def left(self, p):
6 ”””Return a Position representing ps left child.
7
8 Return None if p does not have a left child.
9 ”””
10 raise NotImplementedError( must be implemented by subclass )
11
12 def right(self, p):
13 ”””Return a Position representing ps right child.
14
15 Return None if p does not have a right child.
16 ”””
17 raise NotImplementedError( must be implemented by subclass )
18
19 # ---------- concrete methods implemented in this class ----------
20 def sibling(self, p):
21 ”””Return a Position representing ps sibling (or None if no sibling).”””
22 parent = self.parent(p)
23 if parent is None: # p must be the root
24 return None # root has no sibling
25 else:
26 if p == self.left(parent):
27 return self.right(parent) # possibly None
28 else:
29 return self.left(parent) # possibly None
30
31 def children(self, p):
32 ”””Generate an iteration of Positions representing ps children.”””
33 if self.left(p) is not None:
34 yield self.left(p)
35 if self.right(p) is not None:
36 yield self.right(p)
CodeFragment8.7: ABinaryTreeabstractbaseclassthatextendstheexistingTree8.2. BinaryTrees 315
8.2.2 Properties of Binary Trees
Binarytrees haveseveral interesting properties dealing withrelationships between
theirheightsandnumberofnodes. WedenotethesetofallnodesofatreeT atthe
same depth d as level d of T. In a binary tree, level 0 has at most one node (the
root), level 1 has at most two nodes (the children of the root), level 2 has at most
fournodes, andsoon. (SeeFigure8.9.) Ingeneral, leveld hasatmost2d nodes.
Level Nodes
0 1
1 2
2 4
3 8
... ...
. .
. .
. .
Figure8.9: Maximumnumberofnodesinthelevelsofabinarytree.
We can see that the maximum number of nodes on the levels of a binary tree
growsexponentially aswegodownthetree. Fromthissimpleobservation, wecan
derivethefollowingpropertiesrelatingtheheightofabinarytreeT withitsnumber
ofnodes. Adetailedjustiﬁcation oftheseproperties isleftasExerciseR-8.8.
Proposition 8.8: LetT beanonemptybinarytree,andletn,n ,n andhdenote
E I
thenumberofnodes, numberofexternalnodes, numberofinternalnodes, and
heightofT,respectively.ThenT hasthefollowingproperties:
1. h+1≤n≤2h+1−1
2. 1≤n ≤2h
E
3. h≤n ≤2h−1
I
4. log(n+1)−1≤h≤n−1
Also,ifT isproper,thenT hasthefollowingproperties:
1. 2h+1≤n≤2h+1−1
2. h+1≤n ≤2h
E
3. h≤n ≤2h−1
I316 Chapter8. Trees
Relating Internal Nodes to External Nodes in a Proper Binary Tree
In addition to the earlier binary tree properties, the following relationship exists
betweenthenumberofinternal nodesandexternalnodesinaproperbinarytree.
Proposition 8.9: InanonemptyproperbinarytreeT,withn externalnodesand
E
n internalnodes,wehaven =n +1.
I E I
Justiﬁcation: Wejustify thisproposition byremoving nodes fromT anddivid-
ing them upinto two“piles,” aninternal-node pile and anexternal-node pile, until
T becomesempty. Thepiles areinitially empty. Bytheend, wewillshowthatthe
external-node pilehasonemorenodethantheinternal-nodepile. Weconsider two
cases:
Case1: If T has only one node v, we remove v and place it on the external-node
pile. Thus, the external-node pile has one node and the internal-node pile is
empty.
Case2: Otherwise (T has more than one node), weremove fromT an (arbitrary)
external node w and its parent v, which is an internal node. We place w on
the external-node pile and v on the internal-node pile. If v has a parent u,
thenwereconnect uwiththeformersiblingzofw,asshowninFigure8.10.
Thisoperation, removesoneinternalnodeandoneexternalnode,andleaves
thetreebeingaproperbinarytree.
Repeating this operation, we eventually are left with a ﬁnal tree consisting
of a single node. Note that the same number of external and internal nodes
have been removed and placed on their respective piles by the sequence of
operations leading to this ﬁnal tree. Now, we remove the node of the ﬁnal
tree and we place it on the external-node pile. Thus, the the external-node
pilehasonemorenodethantheinternal-node pile.
u u
v u
z w z z
(a) (b) (c)
Figure8.10: Operation that removes an external node and its parent node, used in
thejustiﬁcation ofProposition 8.9.
Notethat theabove relationship does nothold, ingeneral, forimproper binary
treesandnonbinary trees, although thereareotherinteresting relationships thatdo8.3. ImplementingTrees 317
8.3 Implementing Trees
The Tree and BinaryTree classes that we have deﬁned thus far in this chapter are
bothformallyabstractbaseclasses. Althoughtheyprovideagreatdealofsupport,
neither of them can be directly instantiated. We have not yet deﬁned key imple-
mentation details for how a tree will be represented internally, and how we can
effectively navigate between parents and children. Speciﬁcally, a concrete imple-
mentation of a tree must provide methods root, parent, num children, children,
len ,andinthecaseofBinaryTree,theadditional accessorsleftandright.
There are several choices for the internal representation of trees. We describe
the most common representations in this section. We begin with the case of a
binarytree,sinceitsshapeismorenarrowlydeﬁned.
8.3.1 Linked Structure for Binary Trees
A natural way to realize a binary tree T is to use a linked structure, with a node
(see Figure 8.11a) that maintains references to the element stored at a position p
and to the nodes associated with the children and parent of p. If p is the root of
T, then the parent ﬁeld of p is None. Likewise, if p does not have a left child
(respectively, rightchild), theassociated ﬁeldisNone. Thetreeitselfmaintains an
instancevariablestoringareferencetotherootnode(ifany),andavariable,called
size, that represents the overall number of nodes of T. We show such a linked
structure representation ofabinarytreeinFigure8.11b.
∅
root
5
size
∅ ∅
parent
∅ ∅ ∅ ∅
left right Baltimore Chicago New York Providence Seattle
element
(a) (b)318 Chapter8. Trees
Python Implementation of a Linked Binary Tree Structure
In this section, we deﬁne a concrete LinkedBinaryTree class that implements the
binarytreeADTbysubclassingtheBinaryTreeclass. Ourgeneralapproachisvery
similar to what we used when developing the PositionalList in Section 7.4: We
deﬁne a simple, nonpublic Node class to represent a node, and a public Position
class that wraps a node. We provide a validate utility for robustly checking the
validity of a given position instance when unwrapping it, and a make position
utilityforwrappinganodeasaposition toreturntoacaller.
Those deﬁnitions are provided in Code Fragment 8.8. Asa formality, the new
Position class is declared to inherit immediately fromBinaryTree.Position. Tech-
nically, theBinaryTreeclass deﬁnition (seeCodeFragment8.7)does notformally
declaresuchanestedclass;ittriviallyinheritsitfromTree.Position. Aminorben-
eﬁt from this design is that our position class inherits the ne special method
sothatsyntaxp != qisderivedappropriately relativeto eq .
Our class deﬁnition continues, in Code Fragment 8.9, with a constructor and
withconcreteimplementationsforthemethodsthatremainabstractintheTreeand
BinaryTree classes. The constructor creates an empty tree by initializing root to
Noneand sizetozero. Theseaccessor methods areimplemented withcareful use
ofthe validateand make positionutilities tosafeguard againstboundary cases.
Operations for Updating a Linked Binary Tree
Thus far, we have provided functionality for examining an existing binary tree.
However, the constructor for our LinkedBinaryTree class results in an empty tree
andwehavenotprovidedanymeansforchangingthestructureorcontentofatree.
We chose not to declare update methods as part of theTree or BinaryTree ab-
stract base classes for several reasons. First, although the principle of encapsula-
tionsuggests thattheoutwardbehaviors ofaclass neednotdepend ontheinternal
representation, theefﬁciencyoftheoperationsdependsgreatlyupontherepresenta-
tion. Weprefertohaveeachconcrete implementation ofatreeclassofferthemost
suitable optionsforupdating atree.
The second reason we do not provide update methods in the baseclass is that
we may not want such update methods to be part of a public interface. There are
many applications of trees, and some forms of update operations that are suitable
foroneapplicationmaybeunacceptableinanother. However,ifweplaceanupdate
methodinabaseclass,anyclassthatinheritsfromthatbasewillinherittheupdate
method. Consider, for example, the possibility of a method T.replace(p, e) that
replaces the element stored at position p with another element e. Such a general
method may be unacceptable in the context of an arithmetic expression tree (see
Example 8.7 on page 312, and a later case study in Section 8.5), because we may8.3. ImplementingTrees 319
Forlinked binary trees, areasonable setofupdate methods tosupport forgen-
eralusagearethefollowing:
T.add root(e): Create arootforanemptytree, storingeastheelement,
andreturnthepositionofthatroot;anerroroccursifthe
treeisnotempty.
T.add left(p, e): Createanewnodestoringelemente,linkthenodeasthe
left child ofposition p,andreturn theresulting position;
anerroroccursifpalready hasaleftchild.
T.add right(p, e): Createanewnodestoringelemente,linkthenodeasthe
rightchildofpositionp,andreturntheresultingposition;
anerroroccursifpalready hasarightchild.
T.replace(p, e): Replace the element stored at positionpwithelement e,
andreturnthepreviously storedelement.
T.delete(p): Removethenodeatpositionp,replacingitwithitschild,
if any, and return the element that had been stored at p;
anerroroccursifphastwochildren.
T.attach(p, T1, T2): Attach the internal structure of treesT1and T2, respec-
tively, as the left and right subtrees of leaf position p of
T,andresetT1andT2toemptytrees;anerrorcondition
occursifpisnotaleaf.
We have speciﬁcally chosen this collection of operations because each can be
implemented in O(1) worst-case time with our linked representation. The most
complex of these are delete and attach, due to the case analyses involving the
various parent-child relationships andboundary conditions, yetthereremainsonly
aconstantnumberofoperations toperform. (Theimplementation ofbothmethods
could be greatly simpliﬁed if we used a tree representation with a sentinel node,
akintoourtreatmentofpositional lists;seeExerciseC-8.40).
To avoid the problem of undesirable update methods being inherited by sub-
classes of LinkedBinaryTree, we have chosen an implementation in which none
of the above methods are publicly supported. Instead, we provide nonpublic ver-
sions of each, for example, providing the underscored delete in lieu of a public
delete. Our implementations of these six update methods are provided in Code
Fragments8.10and8.11.
Inparticular applications, subclasses ofLinkedBinaryTreecaninvoke thenon-
public methods internally, while preserving a public interface that is appropriate
for the application. A subclass may also choose to wrap one ormore of the non-
public update methods with a public method to expose it to theuser. We leave as
anexercise(R-8.15),thetaskofdeﬁningaMutableLinkedBinaryTreesubclassthat320 Chapter8. Trees
1 class LinkedBinaryTree(BinaryTree):
2 ”””Linked representation of a binary tree structure.”””
3
4 class Node: # Lightweight, nonpublic class for storing a node.
5 slots = _element , _parent , _left , _right
6 def init (self, element, parent=None, left=None, right=None):
7 self. element = element
8 self. parent = parent
9 self. left = left
10 self. right = right
11
12 class Position(BinaryTree.Position):
13 ”””An abstraction representing the location of a single element.”””
14
15 def init (self, container, node):
16 ”””Constructor should not be invoked by user.”””
17 self. container = container
18 self. node = node
19
20 def element(self):
21 ”””Return the element stored at this Position.”””
22 return self. node. element
23
24 def eq (self, other):
25 ”””Return True if other is a Position representing the same location.”””
26 return type(other) is type(self) and other. node is self. node
27
28 def validate(self, p):
29 ”””Return associated node, if position is valid.”””
30 if not isinstance(p, self.Position):
31 raise TypeError( p must be proper Position type )
32 if p. container is not self:
33 raise ValueError( p does not belong to this container )
34 if p. node. parent is p. node: # convention for deprecated nodes
35 raise ValueError( p is no longer valid )
36 return p. node
37
38 def make position(self, node):
39 ”””Return Position instance for given node (or None if no node).”””
40 return self.Position(self, node) if node is not None else None
Code Fragment 8.8: The beginning of our LinkedBinaryTree class (continued in8.3. ImplementingTrees 321
41 #-------------------------- binary tree constructor --------------------------
42 def init (self):
43 ”””Create an initially empty binary tree.”””
44 self. root = None
45 self. size = 0
46
47 #-------------------------- public accessors --------------------------
48 def len (self):
49 ”””Return the total number of elements in the tree.”””
50 return self. size
51
52 def root(self):
53 ”””Return the root Position of the tree (or None if tree is empty).”””
54 return self. make position(self. root)
55
56 def parent(self, p):
57 ”””Return the Position of ps parent (or None if p is root).”””
58 node = self. validate(p)
59 return self. make position(node. parent)
60
61 def left(self, p):
62 ”””Return the Position of ps left child (or None if no left child).”””
63 node = self. validate(p)
64 return self. make position(node. left)
65
66 def right(self, p):
67 ”””Return the Position of ps right child (or None if no right child).”””
68 node = self. validate(p)
69 return self. make position(node. right)
70
71 def num children(self, p):
72 ”””Return the number of children of Position p.”””
73 node = self. validate(p)
74 count = 0
75 if node. left is not None: # left child exists
76 count += 1
77 if node. right is not None: # right child exists
78 count += 1
79 return count
Code Fragment 8.9: Public accessors for our LinkedBinaryTree class. The class322 Chapter8. Trees
80 def add root(self, e):
81 ”””Place element e at the root of an empty tree and return new Position.
82
83 Raise ValueError if tree nonempty.
84 ”””
85 if self. root is not None: raise ValueError( Root exists )
86 self. size = 1
87 self. root = self. Node(e)
88 return self. make position(self. root)
89
90 def add left(self, p, e):
91 ”””Create a new left child for Position p, storing element e.
92
93 Return the Position of new node.
94 Raise ValueError if Position p is invalid or p already has a left child.
95 ”””
96 node = self. validate(p)
97 if node. left is not None: raise ValueError( Left child exists )
98 self. size += 1
99 node. left = self. Node(e, node) # node is its parent
100 return self. make position(node. left)
101
102 def add right(self, p, e):
103 ”””Create a new right child for Position p, storing element e.
104
105 Return the Position of new node.
106 Raise ValueError if Position p is invalid or p already has a right child.
107 ”””
108 node = self. validate(p)
109 if node. right is not None: raise ValueError( Right child exists )
110 self. size += 1
111 node. right = self. Node(e, node) # node is its parent
112 return self. make position(node. right)
113
114 def replace(self, p, e):
115 ”””Replace the element at position p with e, and return old element.”””
116 node = self. validate(p)
117 old = node. element
118 node. element = e
119 return old
Code Fragment 8.10: Nonpublic update methods for the LinkedBinaryTree class8.3. ImplementingTrees 323
120 def delete(self, p):
121 ”””Delete the node at Position p, and replace it with its child, if any.
122
123 Return the element that had been stored at Position p.
124 Raise ValueError if Position p is invalid or p has two children.
125 ”””
126 node = self. validate(p)
127 if self.num children(p) == 2: raise ValueError( p has two children )
128 child = node. left if node. left else node. right # might be None
129 if child is not None:
130 child. parent = node. parent # childs grandparent becomes parent
131 if node is self. root:
132 self. root = child # child becomes root
133 else:
134 parent = node. parent
135 if node is parent. left:
136 parent. left = child
137 else:
138 parent. right = child
139 self. size −= 1
140 node. parent = node # convention for deprecated node
141 return node. element
142
143 def attach(self, p, t1, t2):
144 ”””Attach trees t1 and t2 as left and right subtrees of external p.”””
145 node = self. validate(p)
146 if not self.is leaf(p): raise ValueError( position must be leaf )
147 if not type(self) is type(t1) is type(t2): # all 3 trees must be same type
148 raise TypeError( Tree types must match )
149 self. size += len(t1) + len(t2)
150 if not t1.is empty(): # attached t1 as left subtree of node
151 t1. root. parent = node
152 node. left = t1. root
153 t1. root = None # set t1 instance to empty
154 t1. size = 0
155 if not t2.is empty(): # attached t2 as right subtree of node
156 t2. root. parent = node
157 node. right = t2. root
158 t2. root = None # set t2 instance to empty
159 t2. size = 0
Code Fragment 8.11: Nonpublic update methods for the LinkedBinaryTree class324 Chapter8. Trees
Performance of the Linked Binary Tree Implementation
Tosummarizetheefﬁcienciesofthelinkedstructurerepresentation, weanalyzethe
running times of the LinkedBinaryTree methods, including derived methods that
areinherited fromtheTreeandBinaryTreeclasses:
• Thelenmethod,implementedinLinkedBinaryTree,usesaninstancevariable
storing the number of nodes of T and takes O(1) time. Method is empty,
inherited fromTree,reliesonasinglecalltolenandthustakesO(1)time.
• Theaccessor methodsroot,left,right,parent,and num childrenare imple-
mented directly in LinkedBinaryTree and take O(1) time. The sibling and
children methods are derived in BinaryTree based on a constant number of
callstotheseotheraccessors, sotheyruninO(1)timeaswell.
• The is rootand is leaf methods, from theTree class, both run inO(1) time,
asis rootcallsrootandthenreliesonequivalencetestingofpositions,while
is leafcallsleftandrightandveriﬁesthatNoneisreturnedbyboth.
• Methods depth and height were each analyzed in Section 8.1.3. Thedepth
methodatposition prunsinO(d +1)timewhered isitsdepth;theheight
p p
methodontherootofthetreerunsinO(n)time.
• The various update methods add root, add left, add right, replace, delete,
andattach(thatis, theirnonpublic implementations) eachruninO(1)time,
astheyinvolverelinking onlyaconstantnumberofnodesperoperation.
Table8.1summarizes theperformance ofthelinked structure implementation ofa
binarytree.
Operation RunningTime
len,is empty O(1)
root,parent,left,right,sibling,children,num children O(1)
is root,is leaf O(1)
depth(p) O(d +1)
p
height O(n)
add root,add left,add right,replace,delete,attach O(1)
Table 8.1: Running times for the methods of an n-node binary tree implemented8.3. ImplementingTrees 325
8.3.2 Array-Based Representation of a Binary Tree
Analternativerepresentation ofabinarytreeT isbasedonawayofnumberingthe
positionsofT. Foreveryposition pofT,let f(p)betheintegerdeﬁnedasfollows.
• If pistherootofT,then f(p)=0.
• If pistheleftchildofpositionq,then f(p)=2f(q)+1.
• If pistherightchildofpositionq,then f(p)=2f(q)+2.
The numbering function f is known as a level numbering of the positions in a
binary tree T, for it numbers the positions on each level of T in increasing order
from left to right. (See Figure 8.12.) Note well that the level numbering is based
on potential positions within the tree, not actual positions of a given tree, so they
arenotnecessarily consecutive. Forexample,inFigure8.12(b),therearenonodes
with level numbering 13 or 14, because the node with level numbering 6 has no
children.
0
1 2
(a)
3 4 5 6
7 8 9 10 11 12 13 14
... ...
0
−
1 2
/ +
3 4 5 6
(b) × + × 6
7 8 9 10 11 12
+ − −
3 2 3
15 16 19 20 25 26
3 1 9 5 7 4326 Chapter8. Trees
The level numbering function f suggests a representation of a binary tree T
by means of an array-based structure A (such as a Python list), with the element
at position p of T stored at index f(p) of the array. We show an example of an
array-based representation ofabinarytreeinFigure8.13.
0
/
1 2
× +
3 4 5 6
+ −
4 2
7 8 11 12
3 1 9 5
/ × + + −
4 2 3 1 9 5
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
Figure8.13: Representation ofabinarytreebymeansofanarray.
One advantage of an array-based representation of a binary tree is that a posi-
tion pcanberepresented bythesingleinteger f(p),andthatposition-based meth-
odssuchasroot,parent,left,andrightcanbeimplementedusingsimplearithmetic
operations onthenumber f(p). Basedonourformulaforthelevelnumbering, the
left child of p has index 2f(p)+1, the right child of p has index 2f(p)+2, and
the parent of p has index (cid:16)(f(p)−1)/2(cid:17). We leave the details of a complete im-
plementation asanexercise(R-8.18).
Thespaceusageofanarray-based representation depends greatlyontheshape
of the tree. Let n be the number of nodes ofT, and let f be the maximum value
M
of f(p) over all the nodes of T. The array A requires length N = 1+ f , since
M
elements rangefromA[0]toA[f ]. NotethatAmayhave anumberofemptycells
M
that do not refer to existing nodes of T. In fact, in the worst case, N = 2n−1,
the justiﬁcation of which is left as an exercise (R-8.16). In Section 9.3, we will
see a class of binary trees, called “heaps” for which N =n. Thus, in spite of the
worst-case space usage, there are applications for which the array representation
of a binary tree is space efﬁcient. Still, for general binary trees, the exponential
worst-case spacerequirement ofthisrepresentation isprohibitive.
Anotherdrawbackofanarrayrepresentation isthatsomeupdateoperationsfor
trees cannot beefﬁciently supported. Forexample, deleting anode and promoting
itschildtakesO(n)timebecauseitisnotjustthechildthatmoveslocations within8.3. ImplementingTrees 327
8.3.3 Linked Structure for General Trees
Whenrepresentingabinarytreewithalinkedstructure,eachnodeexplicitlymain-
tains ﬁelds left and right as references to individual children. For a general tree,
thereisnoapriorilimitonthenumberofchildrenthatanodemayhave. Anatural
way to realize a general tree T as a linked structure is to have each node store a
single container of references to its children. For example, a children ﬁeld of a
node canbeaPythonlist ofreferences tothechildren ofthenode (ifany). Sucha
linkedrepresentation isschematically illustrated inFigure8.14.
New York
parent
element
Baltimore Chicago Providence Seattle
children
(a) (b)
Figure8.14:Thelinkedstructureforageneraltree: (a)thestructureofanode;(b)a
largerportionofthedatastructure associated withanodeanditschildren.
Table8.2summarizes theperformance oftheimplementationofageneral tree
using a linked structure. The analysis is left as an exercise (R-8.14), but we note
that,byusingacollectiontostorethechildrenofeachposition p,wecanimplement
children(p)bysimplyiteratingthatcollection.
Operation RunningTime
len,is empty O(1)
root,parent,is root,is leaf O(1)
children(p) O(c +1)
p
depth(p) O(d +1)
p
height O(n)
Table 8.2: Running times of the accessor methods of an n-node general tree im-
plemented with a linked structure. We let c denote the number of children of a
p328 Chapter8. Trees
8.4 Tree Traversal Algorithms
Atraversal ofatreeT isasystematic wayofaccessing, or“visiting,” alltheposi-
tions of T. The speciﬁc action associated with the “visit” of a position p depends
on the application of this traversal, and could involve anything from increment-
ing a counter to performing some complex computation for p. In this section, we
describe several common traversal schemes for trees, implement them in the con-
text of our various tree classes, and discuss several common applications of tree
traversals.
8.4.1 Preorder and Postorder Traversals of General Trees
In a preorder traversal of a tree T, the root of T is visited ﬁrst and then the sub-
trees rooted at its children are traversed recursively. If the tree is ordered, then
the subtrees are traversed according to the order of the children. The pseudo-code
for the preorder traversal of the subtree rooted at a position p is shown in Code
Fragment8.12.
Algorithmpreorder(T, p):
performthe“visit”actionforpositionp
foreachchildcinT.children(p)do
preorder(T, c) {recursively traverse thesubtreerootedatc}
CodeFragment8.12: Algorithmpreorderforperformingthepreordertraversalofa
subtreerootedatpositionpofatreeT.
Figure 8.15 portrays the order in which positions of a sample tree are visited
duringanapplication ofthepreordertraversal algorithm.
Paper
Title Abstract § 1 § 2 § 3 References
§ 1.1 § 1.2 § 2.1 § 2.2 § 2.3 § 3.1 § 3.2
Figure8.15: Preorder traversal ofanordered tree, wherethechildren ofeachposi-8.4. TreeTraversalAlgorithms 329
Postorder Traversal
Another important tree traversal algorithm is the postorder traversal. In some
sense, this algorithm can be viewed as the opposite of the preorder traversal, be-
causeitrecursivelytraversesthesubtreesrootedatthechildrenoftherootﬁrst,and
then visits the root (hence, the name “postorder”). Pseudo-code for the postorder
traversal is given in Code Fragment 8.13, and an example of a postorder traversal
isportrayed inFigure8.16.
Algorithmpostorder(T, p):
foreachchildcinT.children(p)do
postorder(T, c) {recursively traverse thesubtreerootedatc}
performthe“visit”actionforpositionp
CodeFragment8.13:Algorithmpostorderforperformingthepostordertraversalof
asubtreerootedatpositionpofatreeT.
Paper
Title Abstract § 1 § 2 § 3 References
§ 1.1 § 1.2 § 2.1 § 2.2 § 2.3 § 3.1 § 3.2
Figure8.16: Postordertraversal oftheorderedtreeofFigure8.15.
Running-Time Analysis
Bothpreorderandpostordertraversalalgorithmsareefﬁcientwaystoaccessallthe
positions ofatree. Theanalysis ofeitherofthesetraversal algorithms issimilarto
that of algorithm height2, given in Code Fragment 8.5 of Section 8.1.3. At each
position p,thenonrecursivepartofthetraversalalgorithmrequirestimeO(c +1),
p
wherec isthenumberofchildrenof p,undertheassumptionthatthe“visit”itself
p
takes O(1) time. By Proposition 8.5, the overall running time for the traversal of
treeT isO(n),wherenisthenumber ofpositions inthetree. Thisrunning timeis330 Chapter8. Trees
8.4.2 Breadth-First Tree Traversal
Although the preorder and postorder traversals are common ways of visiting the
positions of a tree, another common approach is to traverse atree so that we visit
all the positions at depth d before we visit the positions at depth d+1. Such an
algorithm isknownasabreadth-ﬁrst traversal.
A breadth-ﬁrst traversal is a common approach used in software for playing
games. A game tree represents the possible choices of moves that might be made
by aplayer (or computer) during agame, withthe root ofthe tree being the initial
conﬁguration for the game. For example, Figure 8.17 displays a partial game tree
forTic-Tac-Toe.
1
2 3 4
X X
X
O O XO X O X X X OX X X X X
X X O O O O
O O O
5 6 7 8 9 10 11 12 13 14 15 16
Figure8.17: Partial gametree for Tic-Tac-Toe, withannotations displaying the or-
derinwhichpositions arevisitedinabreadth-ﬁrst traversal.
Abreadth-ﬁrsttraversalofsuchagametreeisoftenperformedbecauseacomputer
maybeunabletoexploreacompletegametreeinalimitedamountoftime. Sothe
computerwillconsider allmoves,thenresponses tothosemoves,goingasdeepas
computational timeallows.
Pseudo-code for a breadth-ﬁrst traversal is given in Code Fragment 8.14. The
processisnotrecursive, sincewearenottraversingentiresubtreesatonce. Weuse
a queue to produce aFIFO (i.e., ﬁrst-in ﬁrst-out) semanticsfor the order in which
wevisitnodes. TheoverallrunningtimeisO(n),duetothencallstoenqueueand
ncallstodequeue.
Algorithmbreadthﬁrst(T):
Initialize queueQtocontainT.root()
whileQnotemptydo
p = Q.dequeue() {pistheoldestentryinthequeue}
performthe“visit”actionforpositionp
foreachchildcinT.children(p)do
Q.enqueue(c) {addp’schildrentotheendofthequeueforlatervisits}8.4. TreeTraversalAlgorithms 331
8.4.3 Inorder Traversal of a Binary Tree
The standard preorder, postorder, and breadth-ﬁrst traversals that were introduced
for general trees, can be directly applied to binary trees. In this section, we intro-
duceanother commontraversalalgorithm speciﬁcally forabinarytree.
During an inorder traversal, we visit a position between the recursive traver-
sals of its left and right subtrees. The inorder traversal of a binary tree T can be
informally viewedasvisiting thenodesofT “fromlefttoright.” Indeed, forevery
position p, the inorder traversal visits pafter allthepositions inthe leftsubtree of
pandbeforeallthepositions intherightsubtreeof p. Pseudo-code fortheinorder
traversal algorithm is given in Code Fragment 8.15, and an example of an inorder
traversal isportrayed inFigure8.18.
Algorithminorder(p):
ifphasaleftchildlcthen
inorder(lc) {recursively traversetheleftsubtreeofp}
performthe“visit”actionforpositionp
ifphasarightchildrcthen
inorder(rc) {recursively traverse therightsubtreeofp}
Code Fragment 8.15: Algorithm inorder for performing an inorder traversal of a
subtreerootedatpositionpofabinarytree.
−
/ +
× + ×
6
+ − −
3 2 3
3 1 9 5 7 4
Figure8.18: Inordertraversalofabinarytree.
Theinordertraversalalgorithmhasseveralimportantapplications. Whenusing
a binary tree to represent an arithmetic expression, as in Figure 8.18, the inorder
traversal visits positions in a consistent order with the standard representation of332 Chapter8. Trees
Binary Search Trees
Animportantapplicationoftheinordertraversalalgorithmariseswhenwestorean
orderedsequenceofelementsinabinarytree,deﬁningastructurewecallabinary
search tree. Let S be a set whose unique elements have an order relation. For
example, S could be aset of integers. A binary search tree forS is abinary treeT
suchthat,foreachposition pofT:
• Position pstoresanelementofS,denoted ase(p).
• Elementsstoredintheleftsubtree of p(ifany)arelessthane(p).
• Elementsstoredintherightsubtreeof p(ifany)aregreaterthane(p).
Anexample of abinary search tree isshown inFigure 8.19. Theabove properties
assure that an inorder traversal of a binary search tree T visits the elements in
nondecreasing order.
58
31 90
25 42 62
12 36 75
Figure8.19: Abinarysearchtreestoringintegers. Thesolidpathistraversed when
searching (successfully) for 36. The dashed path is traversed when searching (un-
successfully) for70.
We can use a binary search tree T for set S to ﬁnd whether a given search
value v is in S, by traversing a path down the tree T, starting at the root. At each
internal position p encountered, we compare our search value v with the element
e(p) stored at p. If v< e(p), then the search continues in the left subtree of p.
If v=e(p), then the search terminates successfully. If v>e(p), then the search
continuesintherightsubtreeof p. Finally,ifwereachanemptysubtree,thesearch
terminates unsuccessfully. In other words, abinary searchtree can be viewed as a
binarydecisiontree(recallExample8.6),wherethequestionaskedateachinternal
node is whether the element at that node is less than, equal to, or larger than the
element being searched for. Weillustrate several examplesofthesearch operation
inFigure8.19.
NotethattherunningtimeofsearchinginabinarysearchtreeT isproportional
totheheightofT. RecallfromProposition8.8thattheheightofabinarytreewith
nnodes canbe assmallas log(n+1)−1 oraslarge asn−1. Thus, binary search
trees are most efﬁcient when they have small height. Chapter11 is devoted to the8.4. TreeTraversalAlgorithms 333
8.4.4 Implementing Tree Traversals in Python
When ﬁrst deﬁning the tree ADT in Section 8.1.2, we stated that tree T should
includesupport forthefollowingmethods:
T.positions(): Generateaniteration ofallpositionsoftreeT.
iter(T): GenerateaniterationofallelementsstoredwithintreeT.
At that time, we did not make any assumption about the order inwhich these
iterations report their results. In this section, we demonstrate how any of the tree
traversal algorithmswehaveintroduced couldbeusedtoproducetheseiterations.
To begin, we note that it is easy to produce an iteration of all elements of a
tree, if we rely on a presumed iteration of all positions. Therefore, support for
the iter(T) syntax can be formally provided by a concrete implementation of the
special method iter within the abstract base class Tree. We rely on Python’s
generatorsyntaxasthemechanismforproducingiterations. (SeeSection1.8.) Our
implementation ofTree. iter isgiveninCodeFragment8.16.
75 def iter (self):
76 ”””Generate an iteration of the trees elements.”””
77 for p in self.positions(): # use same order as positions()
78 yield p.element( ) # but yield each element
CodeFragment8.16: Iterating all elements of aTree instance, based upon an iter-
ation of the positions of the tree. This code should be included in the body of the
Treeclass.
To implement the positions method, we have a choice of tree traversal algo-
rithms. Given that there are advantages to each of those traversal orders, we will
provide independent implementations of each strategy that can be called directly
by a user of our class. We can then trivially adapt one of those as a default order
forthepositionsmethodofthetreeADT.
Preorder Traversal
Webeginbyconsideringthepreordertraversalalgorithm. Wewillsupportapublic
method withcalling signatureT.preorder()fortree T,which generates apreorder
iteration ofallpositions withinthetree. However, therecursive algorithm forgen-
erating a preorder traversal, as originally described in Code Fragment 8.12, must
be parameterized by a speciﬁc position within the tree that serves as the root of a
subtree totraverse. Astandard solution forsuchacircumstance istodeﬁneanon-
public utilitymethodwiththedesired recursive parameterization, andthentohave
thepublic methodpreorder invoke thenonpublic method upontherootofthetree.334 Chapter8. Trees
79 def preorder(self):
80 ”””Generate a preorder iteration of positions in the tree.”””
81 if not self.is empty():
82 for p in self. subtree preorder(self.root()): # start recursion
83 yield p
84
85 def subtree preorder(self, p):
86 ”””Generate a preorder iteration of positions in subtree rooted at p.”””
87 yield p # visit p before its subtrees
88 for c in self.children(p): # for each child c
89 for other in self. subtree preorder(c): # do preorder of c’s subtree
90 yield other # yielding each to our caller
Code Fragment 8.17: Support for performing a preorder traversal of a tree. This
codeshould beincluded inthebodyoftheTreeclass.
Formally,bothpreorderandtheutility subtree preorderaregenerators. Rather
than perform a “visit” action from within this code, we yield each position to the
callerandletthecallerdecidewhatactiontoperformatthatposition.
The subtree preorder method is the recursive one. However, because we are
relying on generators rather than traditional functions, the recursion has a slightly
different form. Inorder toyieldallpositions withinthesubtreeofchild c,weloop
over the positions yielded by the recursive call self. subtree preorder(c), and re-
yield each position in the outer context. Note that if p is a leaf, the for loop over
self.children(p)istrivial(thisisthebasecaseforourrecursion).
We rely on a similar technique in the public preorder method to re-yield all
positions thataregenerated bytherecursive process startingattherootofthetree;
ifthetreeisempty,nothingisyielded. Atthispoint,wehaveprovidedfullsupport
forthepreordergenerator. Auseroftheclasscantherefore writecodesuchas
for p in T.preorder():
# ”visit” position p
TheofﬁcialtreeADTrequiresthatalltreessupport apositionsmethodaswell. To
use a preorder traversal as the default order of iteration, we include the deﬁnition
shown in Code Fragment 8.18 within our Tree class. Rather than loop over the
resultsreturned bythepreorder call,wereturntheentireiterationasanobject.
91 def positions(self):
92 ”””Generate an iteration of the trees positions.”””
93 return self.preorder( ) # return entire preorder iteration
CodeFragment8.18:AnimplementationofthepositionsmethodfortheTreeclass8.4. TreeTraversalAlgorithms 335
Postorder Traversal
We can implement a postorder traversal using very similar technique as with a
preordertraversal. Theonlydifferenceisthatwithintherecursiveutilityforapost-
orderwewaittoyieldposition puntilafterwehaverecursively yieldthepositions
initssubtrees. Animplementation isgiveninCodeFragment8.19.
94 def postorder(self):
95 ”””Generate a postorder iteration of positions in the tree.”””
96 if not self.is empty():
97 for p in self. subtree postorder(self.root()): # start recursion
98 yield p
99
100 def subtree postorder(self, p):
101 ”””Generate a postorder iteration of positions in subtree rooted at p.”””
102 for c in self.children(p): # for each child c
103 for other in self. subtree postorder(c): # do postorder of c’s subtree
104 yield other # yielding each to our caller
105 yield p # visit p after its subtrees
Code Fragment8.19: Support for performing a postorder traversal of a tree. This
codeshould beincluded inthebodyoftheTreeclass.
Breadth-First Traversal
InCodeFragment8.20,weprovideanimplementationofthebreadth-ﬁrsttraversal
algorithm in the context of our Tree class. Recall that the breadth-ﬁrst traversal
algorithm is not recursive; it relies on a queue of positions to manage the traver-
sal process. Our implementation uses the LinkedQueue class from Section 7.1.2,
although anyimplementation ofthequeueADTwouldsufﬁce.
Inorder Traversal for Binary Trees
The preorder, postorder, and breadth-ﬁrst traversal algorithms are applicable to
all trees, and so we include their implementations within the Tree abstract base
class. Those methods are inherited by the abstract BinaryTree class, the concrete
LinkedBinaryTreeclass,andanyotherdependent treeclasseswemightdevelop.
The inorder traversal algorithm, because it explicitly relies on the notion of a
leftandrightchildofanode, onlyapplies tobinary trees. Wetherefore include its
deﬁnition within the body of the BinaryTree class. We use a similar technique to
implement an inorder traversal (Code Fragment 8.21) aswedid withpreorder and336 Chapter8. Trees
106 def breadthﬁrst(self):
107 ”””Generate a breadth-ﬁrst iteration of the positions of the tree.”””
108 if not self.is empty():
109 fringe = LinkedQueue( ) # known positions not yet yielded
110 fringe.enqueue(self.root()) # starting with the root
111 while not fringe.is empty():
112 p = fringe.dequeue( ) # remove from front of the queue
113 yield p # report this position
114 for c in self.children(p):
115 fringe.enqueue(c) # add children to back of queue
CodeFragment8.20: Animplementation ofabreadth-ﬁrst traversal ofatree. This
codeshould beincluded inthebodyoftheTreeclass.
37 def inorder(self):
38 ”””Generate an inorder iteration of positions in the tree.”””
39 if not self.is empty():
40 for p in self. subtree inorder(self.root()):
41 yield p
42
43 def subtree inorder(self, p):
44 ”””Generate an inorder iteration of positions in subtree rooted at p.”””
45 if self.left(p) is not None: # if left child exists, traverse its subtree
46 for other in self. subtree inorder(self.left(p)):
47 yield other
48 yield p # visit p between its subtrees
49 if self.right(p) is not None: # if right child exists, traverse its subtree
50 for other in self. subtree inorder(self.right(p)):
51 yield other
CodeFragment8.21: Support for performing an inorder traversal of a binary tree.
ThiscodeshouldbeincludedintheBinaryTreeclass(giveninCodeFragment8.7).
For many applications of binary trees, an inorder traversal provides a natural
iteration. We could make it the default for the BinaryTree class by overriding the
positionsmethodthatwasinheritedfromtheTreeclass(seeCodeFragment8.22).
52 # override inherited version to make inorder the default
53 def positions(self):
54 ”””Generate an iteration of the trees positions.”””
55 return self.inorder( ) # make inorder the default
CodeFragment8.22:DeﬁningtheBinaryTree.positionmethodsothatpositionsare8.4. TreeTraversalAlgorithms 337
8.4.5 Applications of Tree Traversals
Inthissection,wedemonstrateseveralrepresentativeapplicationsoftreetraversals,
including somecustomizations ofthestandard traversal algorithms.
Table of Contents
Whenusingatreetorepresent thehierarchical structure ofadocument, apreorder
traversalofthetreecannaturallybeusedtoproduceatableofcontentsforthedoc-
ument. Forexample,thetableofcontentsassociatedwiththetreefromFigure8.15
isdisplayed in Figure 8.20. Part(a)of that ﬁguregives asimple presentation with
one element per line; part (b) shows a more attractive presentation produced by
indenting each element based on its depth within the tree. A similar presentation
could be used todisplay thecontents ofacomputer’s ﬁlesystem, based onits tree
representation (asinFigure8.3).
Paper Paper
Title Title
Abstract Abstract
1 1
1.1 1.1
1.2 1.2
2 2
2.1 2.1
... ...
(a) (b)
Figure8.20:TableofcontentsforadocumentrepresentedbythetreeinFigure8.15:
(a)withoutindentation; (b)withindentation basedondepthwithinthetree.
Theunindentedversionofthetableofcontents,givenatreeT,canbeproduced
withthefollowingcode:
for p in T.preorder():
print(p.element())
To produce the presentation of Figure 8.20(b), we indent each element with a
numberofspacesequaltotwicetheelement’sdepthinthetree(hence,therootele-
mentwasunindented). Althoughwecouldreplacethebodyoftheaboveloopwith
the statement print(2 T.depth(p) + str(p.element())), such an approach is
unnecessarily inefﬁcient. Althoughtheworktoproducethepreordertraversalruns
inO(n)time,basedontheanalysis ofSection8.4.1,thecallstodepthincurahid-
den cost. Making a call to depth from every position of the tree results in O(n2)338 Chapter8. Trees
Apreferred approach toproducing anindented table ofcontents istoredesign
a top-down recursion that includes the current depth as an additional parameter.
Suchan implementation isprovided in CodeFragment 8.23. Thisimplementation
runs in worst-case O(n) time (except, technically, the time it takes to print strings
ofincreasing lengths).
1 def preorder indent(T, p, d):
2 ”””Print preorder representation of subtree of T rooted at p at depth d.”””
3 print(2 d + str(p.element())) # use depth for indentation
4 for c in T.children(p):
5 preorder indent(T, c, d+1) # child depth is d+1
Code Fragment 8.23: Efﬁcient recursion for printing indented version of a pre-
order traversal. On a complete tree T, the recursion should be started with form
preorder indent(T, T.root(), 0).
In the example of Figure 8.20, we were fortunate in that the numbering was
embedded within the elements ofthe tree. More generally, wemight be interested
inusingapreorder traversal todisplay thestructure ofatree, withindentation and
also explicit numbering that was not present in the tree. For example, we might
displaythetreefromFigure8.2beginning as:
Electronics R’Us
1 R&D
2 Sales
2.1 Domestic
2.2 International
2.2.1 Canada
2.2.2 S. America
This is more challenging, because the numbers used as labels are implicit in
the structure of the tree. Alabel depends onthe index of eachposition, relative to
itssiblings, alongthepathfromtheroottothecurrent position. Toaccomplish the
task,weaddarepresentationofthatpathasanadditionalparametertotherecursive
signature. Speciﬁcally,weusealistofzero-indexednumbers,oneforeachposition
along the downward path, other than the root. (We convert those numbers to one-
indexedformwhenprinting.)
At the implementation level, we wish to avoid the inefﬁciency of duplicating
suchlistswhensendinganewparameterfromoneleveloftherecursiontothenext.
A standard solution is to share the same list instance throughout the recursion. At
one level of the recursion, a new entry is temporarily added to the end of the list
before makingfurther recursive calls. Inorderto“leave notrace,”thatsameblock
ofcode mustremove theextraneous entry from the list beforecompleting its task.8.4. TreeTraversalAlgorithms 339
1 def preorder label(T, p, d, path):
2 ”””Print labeled representation of subtree of T rooted at p at depth d.”””
3 label = . .join(str(j+1) for j in path) # displayed labels are one-indexed
4 print(2 d + label, p.element())
5 path.append(0) # path entries are zero-indexed
6 for c in T.children(p):
7 preorder label(T, c, d+1, path) # child depth is d+1
8 path[−1] += 1
9 path.pop()
CodeFragment8.24: Efﬁcient recursion for printing an indented and labeled pre-
sentation ofapreordertraversal.
Parenthetic Representations of a Tree
It is not possible to reconstruct a general tree, given only the preorder sequence
of elements, as in Figure 8.20(a). Some additional context is necessary for the
structure ofthe tree to bewell deﬁned. Theuse ofindentation or numbered labels
provides such context, with a very human-friendly presentation. However, there
aremoreconcise stringrepresentations oftreesthatarecomputer-friendly.
In this section, we explore one such representation. The parenthetic string
representation P(T) of tree T is recursively deﬁned as follows. IfT consists of a
singleposition p,then
P(T)=str(p.element()).
Otherwise,itisdeﬁnedrecursively as,
P(T)=str(p.element())+ ( +P(T )+ , + ··· + , +P(T )+ )
1 k
where p is the root of T and T ,T ,...,T are the subtrees rooted at the children
1 2 k
of p, which are given in order if T is an ordered tree. We are using “+” here to
denote string concatenation. As an example, the parenthetic representation of the
treeofFigure8.2wouldappearasfollows(linebreaksarecosmetic):
Electronics R’Us (R&D, Sales (Domestic, International (Canada,
S. America, Overseas (Africa, Europe, Asia, Australia))),
Purchasing, Manufacturing (TV, CD, Tuner))
Although the parenthetic representation is essentially a preorder traversal, we
cannot easily produce the additional punctuation using theformal implementation
of preorder, as given in Code Fragment 8.17. The opening parenthesis must be
producedjustbeforetheloopoveraposition’schildrenandtheclosingparenthesis
must be produced just after that loop. Furthermore, the separating commas must
beproduced. ThePython functionparenthesize, showninCodeFragment 8.25, is340 Chapter8. Trees
1 def parenthesize(T, p):
2 ”””Print parenthesized representation of subtree of T rooted at p.”””
3 print(p.element(), end= ) # use of end avoids trailing newline
4 if not T.is leaf(p):
5 ﬁrst time = True
6 for c in T.children(p):
7 sep = ( if ﬁrst time else , # determine proper separator
8 print(sep, end= )
9 ﬁrst time = False # any future passes will not be the ﬁrst
10 parenthesize(T, c) # recur on child
11 print( ) , end= ) # include closing parenthesis
CodeFragment8.25:Functionthatprintsparentheticstringrepresentationofatree.
Computing Disk Space
InExample8.1, weconsidered the useofatreeasamodel foraﬁle-system struc-
ture, with internal positions representing directories and leaves representing ﬁles.
In fact, when introducing the use of recursion back in Chapter 4, we speciﬁcally
examinedthetopicofﬁlesystems(seeSection4.1.4). Althoughwedidnotexplic-
itly model it as a tree at that time, we gave an implementation of an algorithm for
computing thediskusage(CodeFragment4.5).
Therecursivecomputationofdiskspaceisemblematicofapostordertraversal,
aswecannot effectively compute thetotalspace used byadirectory untilafter we
know the space that is used by its children directories. Unfortunately, the formal
implementation ofpostorder, as given in Code Fragment 8.19 does not sufﬁce for
thispurpose. Asitvisitstheposition ofadirectory, thereisnoeasywaytodiscern
whichoftheprevious positions represent children ofthatdirectory, norhowmuch
recursivediskspacewasallocated.
We would like to have a mechanism for children to return information to the
parent as part of the traversal process. A custom solution tothe disk space prob-
lem, with each level of recursion providing a return value tothe (parent) caller, is
provided inCodeFragment8.26.
1 def disk space(T, p):
2 ”””Return total disk space for subtree of T rooted at p.”””
3 subtotal = p.element().space( ) # space used at position p
4 for c in T.children(p):
5 subtotal += disk space(T, c) # add child’s space to subtotal
6 return subtotal
Code Fragment8.26: Recursive computation of disk space for a tree. We assume
that a space() method of each tree element reports the local space used at that8.4. TreeTraversalAlgorithms 341
(cid:2)
8.4.6 Euler Tours and the Template Method Pattern
The various applications described in Section 8.4.5 demonstrate the great power
of recursive tree traversals. Unfortunately, they also show that the speciﬁc imple-
mentations ofthepreorder andpostordermethods ofourTreeclass, ortheinorder
method of the BinaryTree class, are not general enough to capture the range of
computations we desire. In some cases, we need more of a blending of the ap-
proaches,withinitialworkperformedbeforerecurringonsubtrees,additionalwork
performed after those recursions, and in the case of abinarytree, workperformed
between the twopossible recursions. Furthermore, insomecontexts itwasimpor-
tant to know the depth of a position, or the complete path from the root to that
position, or to return information from one level of the recursion to another. For
each of the previous applications, we were able to develop a custom implementa-
tiontoproperlyadapttherecursiveideas,butthegreatprinciplesofobject-oriented
programming introduced inSection2.1.1includeadaptability andreusability.
In this section, we develop a more general framework for implementing tree
traversals based on a concept known as an Euler tour traversal. The Euler tour
traversalofageneraltreeT canbeinformallydeﬁnedasa“walk”aroundT,where
westartbygoingfromtheroottowarditsleftmostchild,viewingtheedgesofT as
being“walls”thatwealwayskeeptoourleft. (SeeFigure8.21.)
−
/ +
× + ×
6
+ − −
3 2 3
3 1 9 5 7 4
Figure8.21: Eulertourtraversalofatree.
The complexity of the walk is O(n), because it progresses exactly two times
alongeachofthen−1edgesofthetree—oncegoingdownwardalongtheedge,and
latergoing upwardalong theedge. Tounify theconcept ofpreorder andpostorder
traversals, wecanthinkoftherebeingtwonotable“visits”toeachposition p:
• A “pre visit” occurs when ﬁrst reaching the position, that is, when the walk
passesimmediately leftofthenodeinourvisualization.
• A“postvisit”occurswhenthewalklaterproceedsupwardfromthatposition,342 Chapter8. Trees
The process of an Euler tour can easily be viewed recursively. In between the
“pre visit” and “post visit” of a given position will be a recursive tour of each of
its subtrees. Looking at Figure 8.21 as an example, there is a contiguous portion
oftheentiretourthatisitselfanEulertourofthesubtreeofthenodewithelement
“/”. That tour contains twocontiguous subtours, one traversing that position’s left
subtreeandanothertraversing therightsubtree. Thepseudo-code foranEulertour
traversal ofasubtreerootedataposition pisshowninCodeFragment8.27.
Algorithmeulertour(T, p):
performthe“previsit”actionforpositionp
foreachchildcinT.children(p)do
eulertour(T, c) {recursively tourthesubtreerootedatc}
performthe“postvisit”actionforpositionp
CodeFragment8.27:AlgorithmeulertourforperforminganEulertourtraversalof
asubtreerootedatpositionpofatree.
The Template Method Pattern
To provide a framework that is reusable and adaptable, we rely on an interesting
object-orientedsoftwaredesignpattern,thetemplatemethodpattern. Thetemplate
methodpatterndescribesagenericcomputationmechanismthatcanbespecialized
foraparticular application byredeﬁningcertainsteps. Toallowcustomization, the
primary algorithm calls auxiliary functions known ashooks at designated steps of
theprocess.
In the context of an Euler tour traversal, we deﬁne two separate hooks, a pre-
visithookthatiscalledbeforethesubtreesaretraversed,andapostvisithookthatis
called after thecompletion ofthesubtree traversals. Ourimplementation willtake
the form of an EulerTour class that manages the process, and deﬁnes trivial deﬁ-
nitions forthehooks that donothing. Thetraversal canbecustomized bydeﬁning
a subclass of EulerTour and overriding one or both hooks to provide specialized
behavior.
Python Implementation
OurimplementationofanEulerTourclassisprovidedinCodeFragment8.28. The
primaryrecursiveprocessisdeﬁnedinthenonpublic tourmethod. Atourinstance
is created by sending a reference to a speciﬁc tree to the constructor, and then by
calling the public execute method, which beings the tour and returns a ﬁnal result8.4. TreeTraversalAlgorithms 343
1 class EulerTour:
2 ”””Abstract base class for performing Euler tour of a tree.
3
4 hook previsit and hook postvisit may be overridden by subclasses.
5 ”””
6 def init (self, tree):
7 ”””Prepare an Euler tour template for given tree.”””
8 self. tree = tree
9
10 def tree(self):
11 ”””Return reference to the tree being traversed.”””
12 return self. tree
13
14 def execute(self):
15 ”””Perform the tour and return any result from post visit of root.”””
16 if len(self. tree) > 0:
17 return self. tour(self. tree.root(), 0, [ ]) # start the recursion
18
19 def tour(self, p, d, path):
20 ”””Perform tour of subtree rooted at Position p.
21
22 p Position of current node being visited
23 d depth of p in the tree
24 path list of indices of children on path from root to p
25 ”””
26 self. hook previsit(p, d, path) # ”pre visit” p
27 results = [ ]
28 path.append(0) # add new index to end of path before recursion
29 for c in self. tree.children(p):
30 results.append(self. tour(c, d+1, path)) # recur on childs subtree
31 path[−1] += 1 # increment index
32 path.pop( ) # remove extraneous index from end of path
33 answer = self. hook postvisit(p, d, path, results) # ”post visit” p
34 return answer
35
36 def hook previsit(self, p, d, path): # can be overridden
37 pass
38
39 def hook postvisit(self, p, d, path, results): # can be overridden
40 pass
CodeFragment8.28: AnEulerTourbaseclassproviding aframeworkforperform-344 Chapter8. Trees
BasedonourexperienceofcustomizingtraversalsforsampleapplicationsSec-
tion 8.4.5, we build support into the primary EulerTour for maintaining the re-
cursive depth and therepresentation oftherecursive path through atree, using the
approachthatweintroducedinCodeFragment8.24. Wealsoprovideamechanism
foronerecursiveleveltoreturnavaluetoanotherwhenpost-processing. Formally,
ourframeworkreliesonthefollowingtwohooksthatcanbespecialized:
• method hook previsit(p, d, path)
Thisfunctioniscalledonceforeachposition,immediatelybeforeitssubtrees
(if any) are traversed. Parameterpis a position in the tree, dis the depth of
that position, andpathis alist of indices, using the convention described in
thediscussionofCodeFragment8.24. Noreturnvalueisexpectedfromthis
function.
• method hook postvisit(p, d, path, results)
Thisfunction iscalled once foreach position, immediatelyafter itssubtrees
(if any) aretraversed. Theﬁrstthree parameters use the same convention as
did hook previsit. Theﬁnalparameterisalistofobjectsthatwereprovided
asreturnvaluesfromthepostvisitsoftherespectivesubtreesofp. Anyvalue
returned bythiscallwillbeavailable totheparentofpduring itspostvisit.
Formorecomplextasks, subclasses ofEulerTourmayalsochoose toinitialize
andmaintainadditional stateintheformofinstance variablesthatcanbeaccessed
withinthebodiesofthehooks.
Using the Euler Tour Framework
To demonstrate the ﬂexibility of our Euler tour framework, we revisit the sample
applications fromSection8.4.5. Asasimpleexample,anindented preordertraver-
sal,akintothatoriginallyproducedbyCodeFragment8.23,canbegeneratedwith
thesimplesubclass giveninCodeFragment8.29.
1 class PreorderPrintIndentedTour(EulerTour):
2 def hook previsit(self, p, d, path):
3 print(2 d + str(p.element()))
CodeFragment8.29: A subclass of EulerTour that produces an indented preorder
listofatree’selements.
Suchatourwouldbestartedbycreatinganinstanceofthesubclassforagiven
treeT,andinvoking itsexecutemethod. Thiscouldbeexpressed asfollows:
tour = PreorderPrintIndentedTour(T)8.4. TreeTraversalAlgorithms 345
A labeled version of an indented, preorder presentation, akin to Code Frag-
ment 8.24, could be generated by the new subclass of EulerTour shown in Code
Fragment8.30.
1 class PreorderPrintIndentedLabeledTour(EulerTour):
2 def hook previsit(self, p, d, path):
3 label = . .join(str(j+1) for j in path) # labels are one-indexed
4 print(2 d + label, p.element())
CodeFragment8.30:AsubclassofEulerTourthatproducesalabeledandindented,
preorder listofatree’selements.
Toproducetheparentheticstringrepresentation, originallyachievedwithCode
Fragment 8.25, we deﬁne a subclass that overrides both the previsit and postvisit
hooks. Ournewimplementation isgiveninCodeFragment8.31.
1 class ParenthesizeTour(EulerTour):
2 def hook previsit(self, p, d, path):
3 if path and path[−1] > 0: # p follows a sibling
4 print( , , end= ) # so preface with comma
5 print(p.element(), end= ) # then print element
6 if not self.tree().is leaf(p): # if p has children
7 print( ( , end= ) # print opening parenthesis
8
9 def hook postvisit(self, p, d, path, results):
10 if not self.tree().is leaf(p): # if p has children
11 print( ) , end= ) # print closing parenthesis
CodeFragment8.31:AsubclassofEulerTourthatprintsaparenthetic stringrepre-
sentation ofatree.
Noticethatinthisimplementation,weneedtoinvokeamethodonthetreeinstance
that is being traversed from within the hooks. The public tree() method of the
EulerTourclassservesasanaccessor forthattree.
Finally, the task of computing disk space, as originally implemented in Code
Fragment 8.26, can be performed quite easily with theEulerTour subclass shown
inCodeFragment8.32. Thepostvisit result oftherootwillbereturned bythecall
toexecute().
1 class DiskSpaceTour(EulerTour):
2 def hook postvisit(self, p, d, path, results):
3 # we simply add space associated with p to that of its subtrees
4 return p.element().space( ) + sum(results)346 Chapter8. Trees
The Euler Tour Traversal of a Binary Tree
In Section 8.4.6, weintroduced the concept of an Euler tour traversal of a general
graph, using the template method pattern in designing the EulerTour class. That
class provided methods hook previsitand hook postvisitthat could be overrid-
den to customize a tour. In Code Fragment 8.33 we provide a BinaryEulerTour
specialization thatincludes anadditional hook invisitthatiscalled onceforeach
position—after itsleftsubtreeistraversed, butbeforeitsrightsubtreeistraversed.
Our implementation of BinaryEulerTour replaces the original tour utility to
specialize tothecaseinwhichanodehas atmosttwochildren. Ifanodehasonly
one child, atour differentiates between whether that is aleft child or aright child,
withthe“invisit”takingplaceafterthevisitofasoleleftchild,butbeforethevisit
ofasolerightchild. Inthecaseofaleaf,thethreehooksarecalledinsuccession.
1 class BinaryEulerTour(EulerTour):
2 ”””Abstract base class for performing Euler tour of a binary tree.
3
4 This version includes an additional hook invisit that is called after the tour
5 of the left subtree (if any), yet before the tour of the right subtree (if any).
6
7 Note: Right child is always assigned index 1 in path, even if no left sibling.
8 ”””
9 def tour(self, p, d, path):
10 results = [None, None] # will update with results of recursions
11 self. hook previsit(p, d, path) # ”pre visit” for p
12 if self. tree.left(p) is not None: # consider left child
13 path.append(0)
14 results[0] = self. tour(self. tree.left(p), d+1, path)
15 path.pop()
16 self. hook invisit(p, d, path) # ”in visit” for p
17 if self. tree.right(p) is not None: # consider right child
18 path.append(1)
19 results[1] = self. tour(self. tree.right(p), d+1, path)
20 path.pop()
21 answer = self. hook postvisit(p, d, path, results) # ”post visit” p
22 return answer
23
24 def hook invisit(self, p, d, path): pass # can be overridden
CodeFragment8.33:ABinaryEulerTourbaseclassprovidingaspecializedtourfor8.4. TreeTraversalAlgorithms 347
0
1
2
3
4
0 1 2 3 4 5 6 7 8 9 10 11 12
Figure8.22: Aninorderdrawingofabinarytree.
Todemonstrate use oftheBinaryEulerTourframework, wedevelop asubclass
that computes a graphical layout of a binary tree, as shown in Figure 8.22. The
geometry is determined by an algorithm that assigns x- and y-coordinates to each
position pofabinarytreeT usingthefollowingtworules:
• x(p)isthenumberofpositions visitedbefore pinaninordertraversal ofT.
• y(p)isthedepthof pinT.
In this application, we take the convention common in computer graphics that x-
coordinates increase left to right andy-coordinates increase top to bottom. So the
originisintheupperleftcornerofthecomputerscreen.
Code Fragment 8.34 provides an implementation of a BinaryLayout subclass
thatimplementstheabovealgorithmforassigning(x,y)coordinates totheelement
stored ateach position ofabinary tree. Weadapt theBinaryEulerTourframework
byintroducing additional stateintheformofa countinstance variablethatrepre-
sents the number of“in visits” that wehave performed. Thex-coordinate foreach
position issetaccording tothatcounter.
1 class BinaryLayout(BinaryEulerTour):
2 ”””Class for computing (x,y) coordinates for each node of a binary tree.”””
3 def init (self, tree):
4 super(). init (tree) # must call the parent constructor
5 self. count = 0 # initialize count of processed nodes
6
7 def hook invisit(self, p, d, path):
8 p.element().setX(self. count) # x-coordinate serialized by count
9 p.element().setY(d) # y-coordinate is depth
10 self. count += 1 # advance count of processed nodes
CodeFragment8.34: A BinaryLayout class that computes coordinates at which to
draw positions of a binary tree. We assume that the element type for the original348 Chapter8. Trees
8.5 Case Study: An Expression Tree
InExample8.7,weintroduced theuseofabinarytreetorepresent thestructure of
anarithmeticexpression. Inthissection,wedeﬁneanewExpressionTreeclassthat
provides support forconstructing suchtrees, and fordisplaying and evaluating the
arithmetic expression that such a tree represents. OurExpressionTree class is de-
ﬁnedasasubclass ofLinkedBinaryTree,andwerelyonthenonpublic mutators to
constructsuchtrees. Eachinternalnodemuststoreastringthatdeﬁnesabinaryop-
erator(e.g., + ),andeachleafmuststoreanumericvalue(orastringrepresenting
anumericvalue).
Oureventualgoalistobuildarbitrarilycomplexexpressiontreesforcompound
arithmetic expressions such as (((3+1)×4)/((9−5)+2)). However, it sufﬁces
fortheExpressionTreeclasstosupport twobasicformsofinitialization:
ExpressionTree(value): Createatreestoringthegivenvalueattheroot.
ExpressionTree(op,E ,E ): Create a tree storing string op at the root (e.g., +),
1 2
and with the structures of existing ExpressionTree
instances E andE astheleft andrightsubtrees of
1 2
theroot,respectively.
SuchaconstructorfortheExpressionTreeclassisgiveninCodeFragment8.35.
Theclass formally inherits fromLinkedBinaryTree,soithasaccess toallthenon-
publicupdatemethodsthatweredeﬁnedinSection8.3.1. Weuse add roottocre-
ateaninitialrootofthetreestoringthetokenprovidedastheﬁrstparameter. Then
we perform run-time checking of the parameters to determine whether the caller
invoked theone-parameter versionoftheconstructor (inwhichcase,wearedone),
or the three-parameter form. In that case, we use the inherited attach method to
incorporate thestructureoftheexistingtreesassubtreesoftheroot.
Composing a Parenthesized String Representation
A string representation of an existing expression tree instance, for example, as
(((3+1)x4)/((9-5)+2)) , can be produced by displaying tree elements us-
ing an inorder traversal, but with opening and closing parentheses inserted with
a preorder and postorder step, respectively. In the context of an ExpressionTree
class, we support a special str method (see Section 2.3.2) that returns the
appropriate string. Because itismore efﬁcient toﬁrstbuild asequence ofindivid-
ual strings to be joined together (see discussion of “Composing Strings” in Sec-
tion5.4.2), theimplementation of str relies onanonpublic, recursive method
named parenthesize recurthatappendsaseriesofstringstoalist. Thesemethods8.5. CaseStudy:AnExpressionTree 349
1 class ExpressionTree(LinkedBinaryTree):
2 ”””An arithmetic expression tree.”””
3
4 def init (self, token, left=None, right=None):
5 ”””Create an expression tree.
6
7 In a single parameter form, token should be a leaf value (e.g., 42),
8 and the expression tree will have that value at an isolated node.
9
10 In a three-parameter version, token should be an operator,
11 and left and right should be existing ExpressionTree instances
12 that become the operands for the binary operator.
13 ”””
14 super(). init ( ) # LinkedBinaryTree initialization
15 if not isinstance(token, str):
16 raise TypeError( Token must be a string )
17 self. add root(token) # use inherited, nonpublic method
18 if left is not None: # presumably three-parameter form
19 if token not in +-*x/ :
20 raise ValueError( token must be valid operator )
21 self. attach(self.root(), left, right) # use inherited, nonpublic method
22
23 def str (self):
24 ”””Return string representation of the expression.”””
25 pieces = [ ] # sequence of piecewise strings to compose
26 self. parenthesize recur(self.root(), pieces)
27 return .join(pieces)
28
29 def parenthesize recur(self, p, result):
30 ”””Append piecewise representation of ps subtree to resulting list.”””
31 if self.is leaf(p):
32 result.append(str(p.element())) # leaf value as a string
33 else:
34 result.append( ( ) # opening parenthesis
35 self. parenthesize recur(self.left(p), result) # left subtree
36 result.append(p.element()) # operator
37 self. parenthesize recur(self.right(p), result) # right subtree
38 result.append( ) ) # closing parenthesis350 Chapter8. Trees
Expression Tree Evaluation
The numeric evaluation of an expression tree can be accomplished with a simple
application of a postorder traversal. If we know the values represented by the two
subtrees ofaninternal position, wecancalculate theresultofthecomputation that
position designates. Pseudo-code for the recursive evaluation of the value repre-
sentedbyasubtreerootedatposition pisgiveninCodeFragment8.36.
Algorithmevaluate recur(p):
ifpisaleafthen
returnthevaluestoredatp
else
let◦betheoperator storedatp
x = evaluate recur(left(p))
y = evaluate recur(right(p))
returnx◦y
CodeFragment8.36: Algorithm evaluate recur for evaluating the expression rep-
resented byasubtree ofanarithmeticexpression treerootedatpositionp.
To implement this algorithm in the context of a Python ExpressionTree class,
weprovideapublicevaluatemethodthatisinvokedoninstanceTasT.evaluate().
Code Fragment 8.37 provides such an implementation, relying on a nonpublic
evaluate recurmethodthatcomputesthevalueofadesignated subtree.
39 def evaluate(self):
40 ”””Return the numeric result of the expression.”””
41 return self. evaluate recur(self.root())
42
43 def evaluate recur(self, p):
44 ”””Return the numeric result of subtree rooted at p.”””
45 if self.is leaf(p):
46 return ﬂoat(p.element()) # we assume element is numeric
47 else:
48 op = p.element()
49 left val = self. evaluate recur(self.left(p))
50 right val = self. evaluate recur(self.right(p))
51 if op == + : return left val + right val
52 elif op == - : return left val − right val
53 elif op == / : return left val / right val
54 else: return left val right val # treat x or as multiplication8.5. CaseStudy:AnExpressionTree 351
Building an Expression Tree
The constructor for the ExpressionTree class, from Code Fragment 8.35, provides
basic functionality for combining existing trees to build larger expression trees.
However, the question still remains how to construct a tree that represents an ex-
pression foragivenstring,suchas (((3+1)x4)/((9-5)+2)) .
To automate this process, we rely on a bottom-up construction algorithm, as-
suming that a string can ﬁrst be tokenized so that multidigit numbers are treated
atomically (see Exercise R-8.30), and that the expression is fully parenthesized.
The algorithm uses a stack S while scanning tokens of the input expression E to
ﬁndvalues, operators, andrightparentheses. (Leftparentheses areignored.)
• Whenweseeanoperator◦,wepushthatstringonthestack.
• When we see a literal value v, we create a single-node expression tree T
storingv,andpushT onthestack.
• When we see a right parenthesis, ) , we pop the top three items from the
stack S, which represent a subexpression (E ◦E ). We then construct a
1 2
tree T using trees for E and E as subtrees of the root storing ◦, and push
1 2
theresulting treeT backonthestack.
We repeat this until the expression E has been processed, at which time the top
elementonthestackistheexpression treeforE. Thetotalrunning timeisO(n).
AnimplementationofthisalgorithmisgiveninCodeFragment8.38intheform
ofastand-alonefunctionnamedbuild expression tree,whichproducesandreturns
anappropriateExpressionTreeinstance, assuming theinputhasbeentokenized.
1 def build expression tree(tokens):
2 ”””Returns an ExpressionTree based upon by a tokenized expression.”””
3 S = [ ] # we use Python list as stack
4 for t in tokens:
5 if t in +-x*/ : # t is an operator symbol
6 S.append(t) # push the operator symbol
7 elif t not in () : # consider t to be a literal
8 S.append(ExpressionTree(t)) # push trivial tree storing value
9 elif t == ) : # compose a new tree from three constituent parts
10 right = S.pop( ) # right subtree as per LIFO
11 op = S.pop( ) # operator symbol
12 left = S.pop( ) # left subtree
13 S.append(ExpressionTree(op, left, right)) # repush tree
14 # we ignore a left parenthesis
15 return S.pop()
Code Fragment8.38: Implementation of a build expression tree that produces an352 Chapter8. Trees
8.6 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-8.1 Thefollowingquestions refertothetreeofFigure8.3.
a. Whichnodeistheroot?
b. Whataretheinternal nodes?
c. Howmanydescendants doesnodecs016/have?
d. Howmanyancestors doesnodecs016/have?
e. Whatarethesiblings ofnodehomeworks/?
f. Whichnodesareinthesubtreerootedatnodeprojects/?
g. Whatisthedepthofnodepapers/?
h. Whatistheheightofthetree?
R-8.2 Showatreeachieving theworst-case running timeforalgorithmdepth.
R-8.3 Giveajustiﬁcation ofProposition 8.4.
R-8.4 What is the running time of a call to T. height2(p) when called on a
positionpdistinctfromtherootofT? (SeeCodeFragment8.5.)
R-8.5 Describe an algorithm, relying only on the BinaryTree operations, that
counts thenumber ofleaves inabinary tree thatare theleftchild oftheir
respective parent.
R-8.6 Let T be an n-node binary tree that may be improper. Describe how to
representT bymeansofaproperbinarytreeT(cid:2) withO(n)nodes.
R-8.7 What are the minimum and maximum number of internal and external
nodesinanimproperbinarytreewithnnodes?
R-8.8 Answerthefollowingquestions soastojustifyProposition8.8.
a. What isthe minimum number of external nodes for aproper binary
treewithheighth? Justify youranswer.
b. Whatisthemaximumnumberofexternal nodes foraproper binary
treewithheighth? Justify youranswer.
c. LetT beaproperbinarytreewithheighthandnnodes. Showthat
log(n+1)−1≤h≤(n−1)/2.
d. For which values of n and h can the above lower and upper bounds
onhbeattained withequality?
R-8.9 Giveaproofbyinduction ofProposition 8.9.
R-8.10 Giveadirectimplementationofthenum childrenmethodwithintheclass8.6. Exercises 353
R-8.11 Find the value of the arithmetic expression associated witheach subtree
ofthebinarytreeofFigure8.8.
R-8.12 Draw an arithmetic expression tree that has four external nodes, storing
thenumbers 1,5,6, and7(witheachnumberstored inadistinct external
node,butnotnecessarily inthisorder), andhasthreeinternal nodes,each
storing anoperator fromtheset{+,−,×,/},sothatthevalueoftheroot
is21. Theoperators mayreturnandactonfractions, andanoperatormay
beusedmorethanonce.
R-8.13 Draw the binary tree representation of the following arithmetic expres-
sion: “(((5+2)∗(2−1))/((2+9)+((7−2)−1))∗8)”.
R-8.14 Justify Table 8.2, summarizing the running time of the methods of a tree
represented with a linked structure, by providing, for eachmethod, a de-
scription ofitsimplementation, andananalysisofitsrunningtime.
R-8.15 The LinkedBinaryTree class provides only nonpublic versions of the up-
datemethodsdiscussedonpage319. Implementasimplesubclassnamed
MutableLinkedBinaryTreethatprovidespublicwrapperfunctionsforeach
oftheinherited nonpublic updatemethods.
R-8.16 Let T be a binary tree with n nodes, and let f() be the level numbering
function ofthepositions ofT,asgiveninSection8.3.2.
a. Showthat,foreveryposition pofT, f(p)≤2n−2.
b. Show an example of a binary tree with seven nodes that attains the
aboveupperboundon f(p)forsomeposition p.
R-8.17 Show how to use the Euler tour traversal to compute the level number
f(p),asdeﬁnedinSection8.3.2,ofeachposition inabinarytreeT.
R-8.18 Let T be a binary tree withn positions that is realized with an array rep-
resentationA,andlet f()bethelevelnumberingfunctionofthepositions
ofT,asgiven inSection 8.3.2. Givepseudo-code descriptions ofeachof
themethodsroot,parent,left,right,is leaf,andis root.
R-8.19 Our deﬁnition of the level numbering function f(p), as given in Sec-
tion 8.3.2, began with the root having number 0. Some authors prefer
tousealevelnumberingg(p)inwhichtherootisassignednumber1,be-
cause it simpliﬁes the arithmetic for ﬁnding neighboring positions. Redo
Exercise R-8.18, but assuming that we use a level numbering g(p) in
whichtherootisassigned number1.
R-8.20 DrawabinarytreeT thatsimultaneously satisﬁesthefollowing:
• EachinternalnodeofT storesasinglecharacter.
• Apreorder traversalofT yieldsEXAMFUN.
• Aninordertraversal ofT yieldsMAFXUEN.
R-8.21 In what order are positions visited during a preorder traversal of the tree354 Chapter8. Trees
R-8.22 Inwhatorderarepositions visited during apostorder traversal ofthetree
ofFigure8.8?
R-8.23 Let T be an ordered tree with more than one node. Is it possible thatthe
preorder traversal ofT visits thenodes inthesameorder asthepostorder
traversalofT? Ifso,giveanexample;otherwise,explainwhythiscannot
occur. Likewise, is it possible that the preorder traversal of T visits the
nodes in the reverse order of the postorder traversal ofT? If so, give an
example;otherwise, explainwhythiscannotoccur.
R-8.24 Answertheprevious question forthe casewhenT isaproper binary tree
withmorethanonenode.
R-8.25 Consider the example of a breadth-ﬁrst traversal given in Figure 8.17.
Using the annotated numbers from that ﬁgure, describe the contents of
the queue before each pass of the while loop in Code Fragment 8.14. To
get started, the queue has contents {1} before the ﬁrstpass, and contents
{2,3,4} beforethesecond pass.
R-8.26 The collections.deque class supports an extend method that adds a col-
lection of elements to the end of the queue at once. Reimplement the
breadthﬁrstmethodoftheTreeclasstotakeadvantage ofthisfeature.
R-8.27 Give the output of the function parenthesize(T, T.root()), as described
inCodeFragment8.25,whenT isthetreeofFigure8.8.
R-8.28 Whatisthe running timeofparenthesize(T, T.root()),asgiven inCode
Fragment8.25,foratreeT withnnodes?
R-8.29 Describe, in pseudo-code, an algorithm for computing the number of de-
scendants of each node of a binary tree. The algorithm should be based
ontheEulertourtraversal.
R-8.30 The build expression tree method of the ExpressionTree class requires
input that is an iterable of string tokens. We used a convenient exam-
ple, (((3+1)x4)/((9-5)+2)) , inwhicheach character isitsownto-
ken, so that the string itself sufﬁced as input to build expression tree.
In general, a string, such as (35 + 14) , must be explicitly tokenized
into list [ ( , 35 , + , 14 , ) ] so as to ignore whitespace and to
recognize multidigit numbers as a single token. Write a utility method,
tokenize(raw),thatreturnssuchalistoftokensforarawstring.
Creativity
C-8.31 Deﬁne the internal path length, I(T), of a tree T to be the sum of the
depthsofalltheinternalpositionsinT. Likewise,deﬁnetheexternalpath
length, E(T), of a tree T to be the sum of the depths of all the external
positionsinT. ShowthatifT isaproperbinarytreewithnpositions,then8.6. Exercises 355
C-8.32 LetT bea(notnecessarily proper) binary treewithnnodes, andletDbe
thesumofthedepthsofalltheexternalnodesofT. ShowthatifT hasthe
minimumnumberofexternal nodespossible, thenDisO(n)andifT has
themaximumnumberofexternalnodespossible, thenDisO(nlogn).
C-8.33 LetT bea(possibly improper) binary tree withnnodes, andletDbethe
sumofthedepthsofalltheexternalnodesofT. Describeaconﬁguration
for T such that D is Ω(n2). Such a tree would be the worst case for the
asymptotic runningtimeofmethod height1(CodeFragment8.4).
C-8.34 For a tree T, let n denote the number of its internal nodes, and let n
I E
denote thenumber ofitsexternal nodes. Showthat ifeveryinternal node
inT hasexactly3children, thenn =2n +1.
E I
(cid:2) (cid:2)(cid:2)
C-8.35 Two ordered trees T and T are said to be isomorphic if one of the fol-
lowingholds:
• BothT(cid:2) andT(cid:2)(cid:2) areempty.
• TherootsofT(cid:2)andT(cid:2)(cid:2) havethesamenumberk≥0ofsubtrees, and
the ith such subtree ofT(cid:2) isisomorphic to theith such subtree ofT(cid:2)(cid:2)
fori=1,...,k.
Design an algorithm that tests whether two given ordered trees are iso-
morphic. Whatistherunningtimeofyouralgorithm?
C-8.36 Show that there are more than 2n improper binary trees with n internal
nodessuchthatnopairareisomorphic (seeExerciseC-8.35).
C-8.37 If we exclude isomorphic trees (see Exercise C-8.35), exactly how many
properbinarytreesexistwithexactly4leaves?
C-8.38 Add support in LinkedBinaryTree for a method, delete subtree(p), that
removes the entire subtree rooted at position p, making sure to maintain
thecount onthesize ofthetree. Whatisthe running timeofyour imple-
mentation?
C-8.39 Add support in LinkedBinaryTree for a method, swap(p,q), that has the
effect of restructuring the tree so that the node referenced by p takes the
place of the node referenced byq, and vice versa. Make sure to properly
handlethecasewhenthenodesareadjacent.
C-8.40 We can simplify parts of our LinkedBinaryTree implementation if we
makeuseofofasinglesentinelnode,referencedasthe sentinelmember
of the tree instance, such that the sentinel is the parent of the real root of
the tree, and the root is referenced as the left child of the sentinel. Fur-
thermore, thesentinel willtaketheplaceofNoneasthevalueofthe left
or right member for a node without such a child. Give a new imple-
mentation of the update methods delete and attach, assuming such a356 Chapter8. Trees
C-8.41 DescribehowtocloneaLinkedBinaryTreeinstancerepresenting aproper
binarytree,withuseofthe attachmethod.
C-8.42 Describe how to clone a LinkedBinaryTree instance representing a (not
necessarily proper) binary tree, with use of the add left and add right
methods.
(cid:2)
C-8.43 Wecandeﬁneabinarytreerepresentation T foranordered general tree
T asfollows(seeFigure8.23):
• Foreachposition pofT,thereisanassociated position p(cid:2) ofT(cid:2).
• If pisaleafofT,then p(cid:2) inT(cid:2) doesnothavealeftchild; otherwise
(cid:2) (cid:2)
theleftchildof p isq,whereqistheﬁrstchildof pinT.
• If p has a sibling q ordered immediately after it inT, thenq (cid:2) is the
(cid:2) (cid:2)
rightchildof p inT;otherwise p doesnothavearightchild.
(cid:2)
Given such a representation T of a general ordered tree T, answer each
ofthefollowingquestions:
(cid:2)
a. Isapreordertraversal ofT equivalent toapreordertraversal ofT?
(cid:2)
b. IsapostordertraversalofT equivalenttoapostordertraversalofT?
(cid:2)
c. Isaninorder traversalofT equivalent tooneofthestandard traver-
salsofT? Ifso,whichone?
A A
B C D B
E F G E C
F D
G
(a) (b)
Figure8.23: Representation of a tree with a binary tree: (a) treeT; (b) binary tree
(cid:2) (cid:2)
T forT. ThedashededgesconnectnodesofT thataresiblings inT.
C-8.44 Giveanefﬁcient algorithm that computes andprints, forevery position p
ofatreeT,theelementof pfollowedbytheheightof p’ssubtree.
C-8.45 GiveanO(n)-time algorithm for computing the depths ofall positions of
atreeT,wherenisthenumberofnodesofT.
C-8.46 Thepathlengthofatree T isthesumofthe depths ofallpositions inT.
Describealinear-time methodforcomputing thepathlengthofatreeT.
C-8.47 Thebalance factorofaninternal position pofaproper binary treeisthe
difference between the heights of the right and left subtrees of p. Show
how to specialize the Euler tour traversal of Section 8.4.6 to print the8.6. Exercises 357
C-8.48 Given a proper binary tree T, deﬁne the reﬂection of T to be the binary
(cid:2) (cid:2)
treeT suchthateachnodevinT isalsoinT ,buttheleftchildofvinT
(cid:2) (cid:2)
is v’s right child in T and the right child of v in T is v’s left child in T .
Showthatapreorder traversalofaproperbinarytreeT isthesameasthe
postorder traversal ofT’sreﬂection,butinreverseorder.
C-8.49 Lettherankofaposition pduringatraversalbedeﬁnedsuchthattheﬁrst
element visited has rank 1, the second element visited has rank 2, and so
on. Foreachposition pinatreeT,letpre(p)betherankof pinapreorder
traversalofT,letpost(p)betherankof pinapostordertraversalofT,let
depth(p)bethedepthof p,andletdesc(p)bethenumberofdescendants
of p, including p itself. Derive a formula deﬁning post(p) in terms of
desc(p),depth(p),andpre(p), foreachnode pinT.
C-8.50 Designalgorithms forthefollowingoperations forabinarytreeT:
• preorder next(p): Return the position visited after p in a preorder
traversal ofT (orNoneif pisthelastnodevisited).
• inorder next(p): Return the position visited after p in an inorder
traversal ofT (orNoneif pisthelastnodevisited).
• postorder next(p): Returnthepositionvisitedafter pinapostorder
traversal ofT (orNoneif pisthelastnodevisited).
Whataretheworst-case runningtimesofyouralgorithms?
C-8.51 Toimplement thepreorder method ofthe LinkedBinaryTreeclass, were-
lied on the convenience of Python’s generator syntax and theyield state-
ment. Give an alternative implementation of preorder that returns an ex-
plicit instance ofanested iterator class. (SeeSection2.3.4fordiscussion
ofiterators.)
C-8.52 Algorithm preorder draw draws a binary tree T by assigning x- and y-
coordinates to eachposition psuch that x(p) isthenumber ofnodes pre-
ceding pinthepreorder traversal ofT andy(p)isthedepthof pinT.
a. ShowthatthedrawingofT producedbypreorder drawhasnopairs
ofcrossingedges.
b. RedrawthebinarytreeofFigure8.22usingpreorder draw.
C-8.53 Redothepreviousproblemforthealgorithmpostorder drawthatissimi-
lartopreorder drawexceptthatitassignsx(p)tobethenumberofnodes
preceding position pinthepostorder traversal.
C-8.54 Designanalgorithmfordrawinggeneraltrees,usingastylesimilartothe
inordertraversal approach fordrawingbinarytrees.
C-8.55 ExerciseP-4.27described thewalkfunction oftheosmodule. Thisfunc-
tionperformsatraversaloftheimplicittreerepresentedbytheﬁlesystem.
Read the formal documentation for the function, and in particular its use
of an optional Boolean parameter namedtopdown. Describe how its be-358 Chapter8. Trees
Sales(
Sales Domestic
International(
Canada
S.America
Domestic International
Overseas(
Africa
Europe
Canada S. America Overseas Asia
Australia
)
)
Africa Europe Asia Australia
)
(a) (b)
Figure8.24: (a)TreeT;(b)indented parenthetic representation ofT.
C-8.56 The indented parenthetic representation of a tree T is a variation of the
parentheticrepresentation ofT (seeCodeFragment8.25)thatusesinden-
tationandlinebreaksasillustrated inFigure8.24. Giveanalgorithm that
printsthisrepresentation ofatree.
C-8.57 Let T be a binary tree with n positions. Deﬁne a Roman position to be
a position pin T, such that the number of descendants in p’s left subtree
differ from the number of descendants in p’s right subtree by at most 5.
Describe alinear-time method forﬁnding each position pof T,such that
pisnotaRomanposition, butallof p’sdescendants areRoman.
C-8.58 Let T be a tree with n positions. Deﬁne the lowest common ancestor
(LCA)betweentwopositions pandqasthelowestposition inT thathas
both pandqasdescendants(whereweallowapositiontobeadescendant
ofitself). Giventwopositions pandq,describeanefﬁcientalgorithmfor
ﬁndingtheLCAofpandq. Whatistherunningtimeofyouralgorithm?
C-8.59 LetT beabinarytreewithnpositions, and,foranyposition pinT,letd
p
denote the depth of p in T. The distance between two positions p and q
inT isd +d −2d ,whereaisthelowestcommonancestor(LCA)of p
p q a
andq. ThediameterofT isthemaximumdistancebetweentwopositions
inT. Describe anefﬁcientalgorithm forﬁndingthediameter ofT. What
istherunning timeofyouralgorithm?
C-8.60 Supposeeachposition pofabinarytreeT islabeledwithitsvalue f(p)in
alevelnumberingofT. Designafastmethodfordetermining f(a)forthe
lowest common ancestor (LCA),a, of two positions p and q in T, given
f(p)and f(q). Youdonotneedtoﬁndpositiona,justvalue f(a).
C-8.61 Give an alternative implementation of the build expression tree method
oftheExpressionTreeclassthatreliesonrecursion toperform animplicit8.6. Exercises 359
C-8.62 Note that the build expression tree function of the ExpressionTree class
is written in such a way that a leaf token can be any string; for exam-
ple,itparsestheexpression (a*(b+c)) . However,withintheevaluate
method, an error would occur when attempting to convert a leaf token to
anumber. Modify theevaluatemethod toaccept anoptional Python dic-
tionary that can be used to map such string variables to numeric values,
with a syntax such as T.evaluate({ a :3, b :1, c :5}). In this way,
thesamealgebraic expression canbeevaluated usingdifferent values.
C-8.63 AsmentionedinExerciseC-6.22,postﬁxnotationisanunambiguousway
of writing an arithmetic expression without parentheses. It is deﬁned so
that if “(exp )op(exp )” is a normal (inﬁx) fully parenthesized expres-
1 2
sion with operation op, then its postﬁx equivalent is “pexp pexp op”,
1 2
where pexp is the postﬁx version of exp and pexp is the postﬁx ver-
1 1 2
sion of exp . The postﬁx version of a single number or variable is just
2
that number or variable. So, for example, the postﬁx version of the inﬁx
expression “((5+2)∗(8−3))/4” is “5 2 + 8 3 − ∗ 4 /”. Implement a
postﬁx method of the ExpressionTree class of Section 8.5 that produces
thepostﬁxnotation forthegivenexpression.
Projects
P-8.64 Implement the binary tree ADT using the array-based representation de-
scribedinSection8.3.2.
P-8.65 Implement the tree ADT using a linked structure as described in Sec-
tion8.3.3. Provideareasonable setofupdatemethodsforyourtree.
P-8.66 Thememoryusage fortheLinkedBinaryTreeclasscanbestreamlined by
removing the parent reference from each node, and instead having each
Positioninstancekeepamember, path,thatisalistofnodesrepresenting
theentire path from theroot tothatposition. (Thisgenerally saves mem-
ory because there are typically relatively few stored position instances.)
ReimplementtheLinkedBinaryTreeclassusingthisstrategy.
P-8.67 Aslicingﬂoorplandivides arectangle withhorizontal andvertical sides
usinghorizontalandverticalcuts. (SeeFigure8.25a.) Aslicingﬂoorplan
can be represented by a proper binary tree, called a slicing tree, whose
internal nodes represent the cuts, and whose external nodesrepresent the
basicrectanglesintowhichtheﬂoorplanisdecomposedbythecuts. (See
Figure8.25b.) Thecompactionproblemforaslicingﬂoorplanisdeﬁned
as follows. Assume that each basic rectangle of a slicing ﬂoor plan is
assigned a minimum width w and a minimum height h. The compaction
problemistoﬁndthesmallestpossibleheightandwidthforeachrectangle360 Chapter8. Trees
E F
A E F
C D
A
B
B
C D
(a) (b)
Figure8.25: (a)Slicingﬂoorplan;(b)slicing treeassociated withtheﬂoorplan.
of the basic rectangles. Namely, this problem requires the assignment of
valuesh(p)andw(p)toeachposition poftheslicingtreesuchthat:
⎧
⎪ if p is a leaf whose basic rectangle has
⎪⎪ w
⎪
⎪ minimumwidthw
⎪
⎪
⎪
⎪
⎪
⎪
⎪⎪ if pisaninternalposition,associatedwith
⎨
max(w((cid:3)),w(r)) ahorizontal cut,withleftchild(cid:3)andright
w(p)=
⎪⎪ childr
⎪
⎪
⎪
⎪⎪ if pisaninternalposition,associatedwith
⎪
⎪⎪⎪ w((cid:3))+w(r) a vertical cut, with left child (cid:3) and right
⎪
⎪
⎩ childr
⎧
⎪ if p is a leaf node whose basic rectangle
⎪⎪ h
⎪⎪ hasminimumheighth
⎪
⎪
⎪
⎪
⎪
⎪
⎪⎪ if pisaninternalposition,associatedwith
⎨
h((cid:3))+h(r) ahorizontal cut,withleftchild(cid:3)andright
h(p)=
⎪⎪ childr
⎪
⎪
⎪
⎪⎪ if pisaninternalposition,associatedwith
⎪
⎪
⎪⎪ max(h((cid:3)),h(r)) a vertical cut, with left child (cid:3) and right
⎪
⎪
⎩
childr
Designadatastructureforslicingﬂoorplansthatsupportstheoperations:
• Createaﬂoorplanconsisting ofasinglebasicrectangle.
• Decomposeabasicrectangle bymeansofahorizontal cut.
• Decomposeabasicrectangle bymeansofaverticalcut.
• Assignminimumheightandwidthtoabasicrectangle.
• Drawtheslicingtreeassociated withtheﬂoorplan.ChapterNotes 361
P-8.68 Writeaprogram that canplay Tic-Tac-Toeeffectively. (SeeSection 5.6.)
To do this, you will need to create a game tree T, which is a tree where
each position corresponds to a game conﬁguration, which, in this case,
is a representation of the Tic-Tac-Toe board. (See Section 8.4.2.) The
root corresponds to the initial conﬁguration. For each internal position p
in T, the children of p correspond to the game states we can reach from
p’s game state in a single legal move for the appropriate player, A (the
ﬁrstplayer)orB(thesecondplayer). Positionsatevendepthscorrespond
to moves for A and positions at odd depths correspond to moves for B.
Leaves are either ﬁnal gamestates or are at a depth beyond which wedo
not want to explore. We score each leaf with a value that indicates how
goodthisstateisforplayerA. Inlargegames,likechess,wehavetousea
heuristic scoring function, but for small games, like Tic-Tac-Toe, we can
construct the entire game tree and score leaves as +1, 0, −1, indicating
whether player A has a win, draw, or lose in that conﬁguration. A good
algorithm forchoosing movesisminimax. Inthisalgorithm, weassign a
scoretoeachinternalposition pinT,suchthatif prepresentsA’sturn,we
compute p’s score as the maximum of the scores of p’s children (which
corresponds toA’soptimal play from p). Ifaninternal node prepresents
B’s turn, then wecompute p’s score as the minimum of the scores of p’s
children (whichcorresponds toB’soptimalplayfrom p).
P-8.69 ImplementthetreeADTusingthebinarytreerepresentationdescribed in
ExerciseC-8.43. YoumayadapttheLinkedBinaryTreeimplementation.
P-8.70 Writeaprogram thattakesasinputageneral treeT andaposition pofT
and converts T to another tree with the same set of position adjacencies,
butnowwith pasitsroot.
Chapter Notes
Discussions of the classic preorder, inorder, and postorder tree traversal methods can be
foundin Knuth’sFundamentalAlgorithmsbook[64]. The Eulertourtraversaltechnique
comesfromtheparallelalgorithmscommunity;itisintroducedbyTarjanandVishkin[93]
and is discussed by Ja´Ja´ [54] and by Karp and Ramachandran [58]. The algorithm for
drawinga tree is generallyconsideredto be a partofthe “folklore”ofgraph-drawingal-
gorithms. The reader interested in graph drawing is referred to the book by Di Battista,
Eades,Tamassia, andTollis[34]andthesurveybyTamassiaandLiotta[92]. ThepuzzleChapter
9
Priority Queues
Contents
9.1 The Priority Queue Abstract Data Type. . . . . . . . . . . 363
9.1.1 Priorities . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9.1.2 The Priority Queue ADT . . . . . . . . . . . . . . . . . . 364
9.2 Implementing a Priority Queue . . . . . . . . . . . . . . . . 365
9.2.1 The Composition Design Pattern . . . . . . . . . . . . . . 365
9.2.2 Implementation with an Unsorted List . . . . . . . . . . . 366
9.2.3 Implementation with a Sorted List . . . . . . . . . . . . . 368
9.3 Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370
9.3.1 The Heap Data Structure . . . . . . . . . . . . . . . . . . 370
9.3.2 Implementing a Priority Queue with a Heap . . . . . . . . 372
9.3.3 Array-Based Representation of a Complete Binary Tree . . 376
9.3.4 Python Heap Implementation . . . . . . . . . . . . . . . . 376
9.3.5 Analysis of a Heap-Based Priority Queue . . . . . . . . . . 379
(cid:2)
9.3.6 Bottom-Up Heap Construction . . . . . . . . . . . . . 380
9.3.7 Python’s heapq Module . . . . . . . . . . . . . . . . . . . 384
9.4 Sorting with a Priority Queue. . . . . . . . . . . . . . . . . 385
9.4.1 Selection-Sort and Insertion-Sort . . . . . . . . . . . . . . 386
9.4.2 Heap-Sort . . . . . . . . . . . . . . . . . . . . . . . . . . 388
9.5 Adaptable Priority Queues . . . . . . . . . . . . . . . . . . 390
9.5.1 Locators . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
9.5.2 Implementing an Adaptable Priority Queue . . . . . . . . 3919.1. ThePriorityQueueAbstractDataType 363
9.1 The Priority Queue Abstract Data Type
9.1.1 Priorities
In Chapter 6, we introduced the queue ADT as a collection of objects that are
added and removed according to the ﬁrst-in, ﬁrst-out (FIFO) principle. A com-
pany’scustomercallcenterembodiessuchamodelinwhichwaitingcustomersare
told“calls willbeanswered intheorderthattheywerereceived.” Inthatsetting, a
new call is added to the back of the queue, and each time a customer service rep-
resentative becomes available, he orsheisconnected withthecall that isremoved
fromthefrontofthecallqueue.
Inpractice, therearemanyapplications inwhichaqueue-like structure isused
to manage objects that must be processed in some way, but for which the ﬁrst-in,
ﬁrst-outpolicydoesnotsufﬁce. Consider,forexample,anair-trafﬁccontrolcenter
that has todecide which ﬂightto clear for landing from amongmany approaching
theairport. Thischoicemaybeinﬂuencedbyfactorssuchaseachplane’sdistance
from the runway, time spent waiting in a holding pattern, or amount of remaining
fuel. Itisunlikely thatthelandingdecisions arebasedpurelyonaFIFOpolicy.
Thereareothersituationsinwhicha“ﬁrstcome,ﬁrstserve”policymightseem
reasonable, yet for which other priorities come into play. To use another airline
analogy, suppose a certain ﬂight is fully booked an hour prior to departure. Be-
cause of the possibility of cancellations, the airline maintains a queue of standby
passengers hoping to get a seat. Although the priority of a standby passenger is
inﬂuenced bythecheck-in timeofthatpassenger, other considerations include the
fare paid and frequent-ﬂyer status. So it may be that an available seat is given to
a passenger who has arrived later than another, if such a passenger is assigned a
betterprioritybytheairlineagent.
Inthischapter,weintroduceanewabstractdatatypeknownasapriorityqueue.
This is a collection of prioritized elements that allows arbitrary element insertion,
and allows the removal of the element that has ﬁrst priority. When an element is
addedtoapriorityqueue,theuserdesignatesitsprioritybyprovidinganassociated
key. The element with the minimum key will be the next to be removed from the
queue (thus, an element with key 1 will be given priority over an element with
key2). Althoughitisquitecommonforprioritiestobeexpressednumerically, any
Pythonobjectmaybeusedasakey,aslongastheobjecttypesupportsaconsistent
meaning for the test a < b, for any instances a and b, so as to deﬁne a natural
orderofthekeys. Withsuchgenerality, applications maydeveloptheirownnotion
of priority for each element. For example, different ﬁnancial analysts may assign364 Chapter9. PriorityQueues
9.1.2 The Priority Queue ADT
Formally, we model an element and its priority as a key-value pair. We deﬁne the
priorityqueueADTtosupport thefollowingmethodsforapriority queueP:
P.add(k, v): InsertanitemwithkeykandvaluevintopriorityqueueP.
P.min(): Return a tuple, (k,v), representing the key and value of an
item in priority queue P with minimum key (but do not re-
movetheitem);anerroroccursifthepriorityqueueisempty.
P.remove min(): Remove an item with minimum key from priority queue P,
andreturnatuple,(k,v),representingthekeyandvalueofthe
removeditem;anerroroccursifthepriority queueisempty.
P.is empty(): ReturnTrueifpriority queuePdoesnotcontainanyitems.
len(P): ReturnthenumberofitemsinpriorityqueueP.
Apriorityqueuemayhavemultipleentrieswithequivalentkeys,inwhichcase
methodsminandremove minmayreport anarbitrary choiceofitemhaving mini-
mumkey. Valuesmaybeanytypeofobject.
In our initial model for a priority queue, we assume that an element’s key re-
mainsﬁxedonceithasbeenaddedtoapriority queue. InSection9.5,weconsider
anextensionthatallowsausertoupdateanelement’skeywithinthepriorityqueue.
Example 9.1: Thefollowingtableshowsaseriesofoperationsandtheireffects
onaninitiallyemptypriorityqueueP.The“PriorityQueue”columnissomewhat
deceivingsinceitshowstheentriesastuplesandsortedbykey. Suchaninternal
representationisnotrequiredofapriorityqueue.
Operation ReturnValue PriorityQueue
P.add(5,A) {(5,A)}
P.add(9,C) {(5,A), (9,C)}
P.add(3,B) {(3,B), (5,A), (9,C)}
P.add(7,D) {(3,B), (5,A), (7,D), (9,C)}
P.min() (3,B) {(3,B), (5,A), (7,D), (9,C)}
P.remove min() (3,B) {(5,A), (7,D), (9,C)}
P.remove min() (5,A) {(7,D), (9,C)}
len(P) 2 {(7,D), (9,C)}
P.remove min() (7,D) {(9,C)}
P.remove min() (9,C) { }
P.is empty() True { }9.2. ImplementingaPriorityQueue 365
9.2 Implementing a Priority Queue
Inthissection, weshowhowtoimplementapriorityqueuebystoringitsentriesin
a positional list L. (See Section 7.4.) We provide two realizations, depending on
whetherornotwekeeptheentriesinLsortedbykey.
9.2.1 The Composition Design Pattern
Onechallenge inimplementing apriority queueisthatwemustkeeptrackofboth
an element and its key, even as items are relocated within ourdata structure. This
isreminiscentofacasestudyfromSection7.6inwhichwemaintainaccesscounts
with each element. In that setting, weintroduced thecomposition design pattern,
deﬁning an Item class that assured that each element remained paired with its
associated countinourprimarydatastructure.
For priority queues, we will use composition to store items internally as pairs
consistingofakeykandavaluev. Toimplementthisconceptforallpriorityqueue
implementations, we provide aPriorityQueueBase class (see Code Fragment 9.1)
that includes a deﬁnition for a nested class named Item. We deﬁne the syntax
a < b,foriteminstancesaandb,tobebaseduponthekeys.
1 class PriorityQueueBase:
2 ”””Abstract base class for a priority queue.”””
3
4 class Item:
5 ”””Lightweight composite to store priority queue items.”””
6 slots = _key , _value
7
8 def init (self, k, v):
9 self. key = k
10 self. value = v
11
12 def lt (self, other):
13 return self. key < other. key # compare items based on their keys
14
15 def is empty(self): # concrete method assuming abstract len
16 ”””Return True if the priority queue is empty.”””
17 return len(self) == 0
CodeFragment9.1: APriorityQueueBaseclasswithanested Itemclassthatcom-
posesakeyandavalueintoasingleobject. Forconvenience,weprovideaconcrete366 Chapter9. PriorityQueues
9.2.2 Implementation with an Unsorted List
In our ﬁrst concrete implementation of a priority queue, we store entries within
anunsorted list. OurUnsortedPriorityQueue class isgiven inCode Fragment 9.2,
inheritingfromthePriorityQueueBaseclassintroduced inCodeFragment9.1. For
internal storage, key-value pairs are represented as composites, using instances of
theinherited Itemclass. TheseitemsarestoredwithinaPositionalList,identiﬁed
asthe datamemberofourclass. Weassumethatthepositionallistisimplemented
with a doubly-linked list, as in Section 7.4, so that all operations of that ADT
executeinO(1)time.
We begin with an empty list when a new priority queue is constructed. At all
times,thesizeofthelistequalsthenumberofkey-valuepairscurrentlystoredinthe
priority queue. Forthis reason, our priority queue len method simply returns
thelengthoftheinternal datalist. BythedesignofourPriorityQueueBaseclass,
weinheritaconcreteimplementationoftheis emptymethodthatreliesonacallto
our len method.
Each time akey-value pair is added to the priority queue, viatheaddmethod,
wecreateanew Itemcomposite forthegivenkeyandvalue, andaddthatitemto
theendofthelist. Suchanimplementation takesO(1)time.
The remaining challenge is that when min or remove min is called, we must
locate the item with minimum key. Because the items are not sorted, we must
inspect all entries to ﬁnd one with a minimum key. For convenience, we deﬁne a
nonpublic ﬁnd minutility thatreturnsthepositionofanitemwithminimumkey.
Knowledge of the position allows the remove min method to invoke the delete
method onthe positional list. Theminmethod simply uses the position toretrieve
theitemwhenpreparingakey-valuetupletoreturn. Duetotheloopforﬁndingthe
minimumkey,bothminandremove minmethodsruninO(n)time,wherenisthe
numberofentriesinthepriority queue.
A summary of the running times for theUnsortedPriorityQueue class is given
inTable9.1.
Operation RunningTime
len O(1)
is empty O(1)
add O(1)
min O(n)
remove min O(n)
Table 9.1: Worst-case running times of the methods of a priority queue of size
n, realized by means of an unsorted, doubly linked list. The space requirement9.2. ImplementingaPriorityQueue 367
1 class UnsortedPriorityQueue(PriorityQueueBase): # base class deﬁnes Item
2 ”””A min-oriented priority queue implemented with an unsorted list.”””
3
4 def ﬁnd min(self): # nonpublic utility
5 ”””Return Position of item with minimum key.”””
6 if self.is empty(): # is empty inherited from base class
7 raise Empty( Priority queue is empty )
8 small = self. data.ﬁrst()
9 walk = self. data.after(small)
10 while walk is not None:
11 if walk.element( ) < small.element():
12 small = walk
13 walk = self. data.after(walk)
14 return small
15
16 def init (self):
17 ”””Create a new empty Priority Queue.”””
18 self. data = PositionalList()
19
20 def len (self):
21 ”””Return the number of items in the priority queue.”””
22 return len(self. data)
23
24 def add(self, key, value):
25 ”””Add a key-value pair.”””
26 self. data.add last(self. Item(key, value))
27
28 def min(self):
29 ”””Return but do not remove (k,v) tuple with minimum key.”””
30 p = self. ﬁnd min()
31 item = p.element()
32 return (item. key, item. value)
33
34 def remove min(self):
35 ”””Remove and return (k,v) tuple with minimum key.”””
36 p = self. ﬁnd min()
37 item = self. data.delete(p)
38 return (item. key, item. value)
Code Fragment 9.2: An implementation of a priority queue using an unsorted
list. The parent class PriorityQueueBase is given in Code Fragment 9.1, and the368 Chapter9. PriorityQueues
9.2.3 Implementation with a Sorted List
An alternative implementation of a priority queue uses a positional list, yet main-
taining entries sorted bynondecreasing keys. Thisensuresthat theﬁrstelementof
thelistisanentrywiththesmallestkey.
OurSortedPriorityQueueclassisgiveninCodeFragment9.3. Theimplemen-
tation ofminand remove minarerather straightforward givenknowledge that the
ﬁrstelement ofa list has aminimum key. Werely on theﬁrstmethod ofthe posi-
tionallisttoﬁndtheposition oftheﬁrstitem,andthedeletemethodtoremovethe
entryfromthelist. Assumingthatthelistisimplementedwithadoublylinkedlist,
operationsminandremove mintakeO(1)time.
Thisbeneﬁtcomesatacost,however,formethodaddnowrequiresthatwescan
thelisttoﬁndtheappropriate position toinsert thenewitem. Ourimplementation
starts at the end of the list, walking backward until the new key is smaller than
an existing item; in the worst case, it progresses until reaching the front of the
list. Therefore, theaddmethodtakesO(n)worst-case time,wherenisthenumber
of entries in the priority queue at the time the method is executed. In summary,
whenusingasortedlisttoimplementapriorityqueue,insertionrunsinlineartime,
whereasﬁndingandremovingtheminimumcanbedoneinconstant time.
Comparing the Two List-Based Implementations
Table 9.2 compares the running times of the methods of a priority queue realized
by means of a sorted and unsorted list, respectively. We see an interesting trade-
off when we use a list to implement the priority queue ADT. An unsorted list
supports fastinsertions butslowqueries anddeletions, whereasasortedlistallows
fastqueriesanddeletions, butslowinsertions.
Operation UnsortedList SortedList
len O(1) O(1)
is empty O(1) O(1)
add O(1) O(n)
min O(n) O(1)
remove min O(n) O(1)
Table 9.2: Worst-case running times of the methods of a priority queue of size n,
realized by means of an unsorted or sorted list, respectively. We assume that the9.2. ImplementingaPriorityQueue 369
1 class SortedPriorityQueue(PriorityQueueBase): # base class deﬁnes Item
2 ”””A min-oriented priority queue implemented with a sorted list.”””
3
4 def init (self):
5 ”””Create a new empty Priority Queue.”””
6 self. data = PositionalList()
7
8 def len (self):
9 ”””Return the number of items in the priority queue.”””
10 return len(self. data)
11
12 def add(self, key, value):
13 ”””Add a key-value pair.”””
14 newest = self. Item(key, value) # make new item instance
15 walk = self. data.last( ) # walk backward looking for smaller key
16 while walk is not None and newest < walk.element():
17 walk = self. data.before(walk)
18 if walk is None:
19 self. data.add ﬁrst(newest) # new key is smallest
20 else:
21 self. data.add after(walk, newest) # newest goes after walk
22
23 def min(self):
24 ”””Return but do not remove (k,v) tuple with minimum key.”””
25 if self.is empty():
26 raise Empty( Priority queue is empty. )
27 p = self. data.ﬁrst()
28 item = p.element()
29 return (item. key, item. value)
30
31 def remove min(self):
32 ”””Remove and return (k,v) tuple with minimum key.”””
33 if self.is empty():
34 raise Empty( Priority queue is empty. )
35 item = self. data.delete(self. data.ﬁrst())
36 return (item. key, item. value)
Code Fragment 9.3: An implementation of a priority queue using a sorted list.
The parent class PriorityQueueBase is given in Code Fragment 9.1, and the370 Chapter9. PriorityQueues
9.3 Heaps
The twostrategies for implementing a priority queue ADTin the previous section
demonstrate an interesting trade-off. When using anunsorted list to store entries,
we can perform insertions in O(1) time, but ﬁnding or removing an element with
minimumkeyrequiresanO(n)-timeloopthroughtheentirecollection. Incontrast,
ifusingasortedlist,wecantriviallyﬁndorremovetheminimumelementinO(1)
time, but adding a new element to the queue may require O(n) time to restore the
sortedorder.
Inthissection,weprovideamoreefﬁcientrealizationofapriorityqueueusing
adatastructurecalledabinaryheap. Thisdatastructureallowsustoperformboth
insertions and removals in logarithmic time, which is a signiﬁcant improvement
over the list-based implementations discussed in Section 9.2. The fundamental
way the heap achieves this improvement is to use the structure of a binary tree to
ﬁndacompromisebetweenelementsbeingentirelyunsorted andperfectly sorted.
9.3.1 The Heap Data Structure
A heap (see Figure 9.1) is a binary tree T that stores a collection of items at its
positions and that satisﬁes two additional properties: a relational property deﬁned
interms of the waykeys are stored inT and astructural property deﬁned interms
oftheshapeofT itself. Therelational property isthefollowing:
Heap-OrderProperty: In a heap T, for every position p other than the root, the
keystoredat pisgreaterthanorequaltothekeystoredat p’sparent.
Asaconsequence oftheheap-order property, thekeysencountered onapathfrom
the root to aleaf ofT are in nondecreasing order. Also, a minimum key isalways
stored at the root of T. This makes it easy to locate such an item when min or
remove miniscalled, asitisinformally saidtobe“atthetopoftheheap”(hence,
thename“heap”forthedatastructure). Bytheway,theheapdatastructuredeﬁned
herehasnothing todowiththememoryheap(Section15.1.1)usedintherun-time
environment supporting aprogramming language likePython.
Forthesakeofefﬁciency,aswillbecomeclearlater,wewanttheheapT tohave
assmallaheightaspossible. Weenforcethisrequirementbyinsistingthattheheap
T satisfyanadditional structural property—it mustbewhatwetermcomplete.
CompleteBinaryTreeProperty: AheapT withheighthisacompletebinarytree
if levels 0,1,2,...,h−1 of T have the maximum number of nodes possible
(namely, level i has 2i nodes, for 0≤i≤h−1) and the remaining nodes at9.3. Heaps 371
(4,C)
(5,A) (6,Z)
(15,K) (9,F) (7,Q) (20,B)
(16,X) (25,J) (14,E) (12,H) (11,S) (13,W)
Figure9.1:Exampleofaheapstoring13entrieswithintegerkeys. Thelastposition
istheonestoringentry(13,W).
ThetreeinFigure9.1iscompletebecauselevels0,1,and2arefull,andthesix
nodesinlevel3areinthesixleftmostpossiblepositionsatthatlevel. Informalizing
whatwemeanbytheleftmostpossiblepositions,werefertothediscussionoflevel
numberingfromSection8.3.2,inthecontextofanarray-based representation ofa
binarytree. (Infact,inSection9.3.3wewilldiscusstheuseofanarraytorepresent
aheap.) Acompletebinarytreewithnelementsisonethathaspositionswithlevel
numbering 0 through n−1. For example, in an array-based representation of the
abovetree,its13entrieswouldbestoredconsecutively fromA[0]toA[12].
The Height of a Heap
Let h denote the height of T. Insisting that T be complete also has an important
consequence, asshowninProposition 9.2.
Proposition 9.2: AheapT storingnentrieshasheighth=(cid:16)logn(cid:17).
Justiﬁcation: From the fact that T is complete, we know that the number of
nodesinlevels0throughh−1ofT isprecisely1+2+4+···+2h−1=2h−1,and
thatthenumberofnodesinlevelhisatleast1andatmost2h. Therefore
n≥2h−1+1=2h and n≤2h−1+2h=2h+1−1.
By taking the logarithm of both sides of inequality 2h ≤n, we see that height
h≤logn. Byrearrangingtermsandtakingthelogarithmofbothsidesofinequality
n ≤ 2h+1−1, we see that log(n+1)−1 ≤ h. Since h is an integer, these two372 Chapter9. PriorityQueues
9.3.2 Implementing a Priority Queue with a Heap
Proposition9.2hasanimportantconsequence, foritimpliesthatifwecanperform
update operations on a heap in time proportional to its height, then those opera-
tions will run in logarithmic time. Let us therefore turn to the problem of how to
efﬁcientlyperform variouspriorityqueuemethodsusingaheap.
WewillusethecompositionpatternfromSection9.2.1tostorekey-valuepairs
as items in the heap. The len and is empty methods can be implemented based
on examination of the tree, and the min operation is equally trivial because the
heap property assures that the element at the root of the tree has a minimum key.
The interesting algorithms are those for implementing the add and remove min
methods.
Adding an Item to the Heap
Let us consider how to perform add(k,v) on a priority queue implemented with a
heap T. We store the pair (k,v) as an item at a new node of the tree. To maintain
the complete binary tree property, that new node should be placed at a position p
just beyond the rightmost node at the bottom level of the tree, or as the leftmost
position ofanewlevel,ifthebottomlevelisalready full(oriftheheapisempty).
Up-Heap Bubbling After an Insertion
Afterthisaction,thetreeT iscomplete,butitmayviolatetheheap-order property.
Hence, unless position p is the root of T (that is, the priority queue was empty
beforetheinsertion), wecomparethekeyatposition ptothatof p’sparent, which
wedenoteasq. Ifkeyk ≥k ,theheap-orderpropertyissatisﬁedandthealgorithm
p q
terminates. If instead k < k , then we need to restore the heap-order property,
p q
whichcan belocally achieved byswapping theentries storedatpositions pand q.
(See Figure 9.2c and d.) This swap causes the new item to move up one level.
Again,theheap-orderpropertymaybeviolated,sowerepeattheprocess,goingup
inT untilnoviolation oftheheap-order property occurs. (SeeFigure9.2eandh.)
The upward movement of the newly inserted entry by means of swaps is con-
ventionally called up-heap bubbling. A swap either resolves the violation of the
heap-orderpropertyorpropagatesitonelevelupintheheap. Intheworstcase,up-
heap bubbling causes the new entry to move all the way up to theroot of heap T.
Thus,intheworstcase,thenumberofswapsperformedintheexecutionofmethod9.3. Heaps 373
(4,C) (4,C)
(5,A) (6,Z) (5,A) (6,Z)
(15,K) (9,F) (7,Q) (20,B) (15,K) (9,F) (7,Q) (20,B)
(16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (2,T)
(a) (b)
(4,C) (4,C)
(5,A) (6,Z) (5,A) (6,Z)
(15,K) (9,F) (7,Q) (15,K) (9,F) (7,Q) (2,T)
(20,B) (2,T)
(16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (20,B)
(c) (d)
(4,C) (4,C)
(2,T)
(5,A) (5,A) (2,T)
(15,K) (9,F) (7,Q) (15,K) (9,F) (7,Q) (6,Z)
(6,Z)
(16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (20,B) (16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (20,B)
(e) (f)
(2,T)
(2,T)
(4,C)
(5,A) (5,A) (4,C)
(15,K) (9,F) (7,Q) (6,Z) (15,K) (9,F) (7,Q) (6,Z)
(16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (20,B) (16,X) (25,J) (14,E) (12,H) (11,S) (13,W) (20,B)
(g) (h)
Figure 9.2: Insertion of a new entry with key 2 into the heap of Figure 9.1: (a)
initial heap; (b) after performing operation add; (c and d) swap to locally restore374 Chapter9. PriorityQueues
Removing the Item with Minimum Key
Let us now turn to method remove min of the priority queue ADT. We know that
anentrywiththesmallestkeyisstoredattherootrofT (evenifthereismorethan
oneentrywithsmallestkey). However,ingeneral wecannotsimplydeletenoder,
becausethiswouldleavetwodisconnected subtrees.
Instead, weensurethattheshapeoftheheaprespectsthecompletebinarytree
property by deleting the leaf at the last position p of T, deﬁned as the rightmost
position at the bottommost level of the tree. To preserve the item from the last
position p, wecopy itto the root r (in place of the item withminimum key that is
beingremovedbytheoperation). Figure9.3aandbillustrates anexampleofthese
steps, withminimal item(4,C)being removed from the rootand replaced byitem
(13,W) from the last position. The node at the last position is removed from the
tree.
Down-Heap Bubbling After a Removal
Wearenotyetdone,however,foreventhoughT isnowcomplete,itlikelyviolates
the heap-order property. If T has only one node (the root), then the heap-order
property is trivially satisﬁed and the algorithm terminates. Otherwise, we distin-
guishtwocases,where pinitially denotestherootofT:
• If phasnorightchild,letcbetheleftchildof p.
• Otherwise(phasbothchildren), letcbeachildof pwithminimalkey.
Ifkeyk ≤k ,theheap-order property issatisﬁed andthealgorithm terminates. If
p c
insteadk >k ,thenweneedtorestoretheheap-orderproperty. Thiscanbelocally
p c
achieved by swapping the entries stored at p and c. (See Figure 9.3c and d.) It is
worth noting that when p has two children, we intentionally consider the smaller
key of the two children. Not only is the key of c smaller than that of p, it is at
leastassmallasthekeyatc’ssibling. Thisensures thattheheap-order property is
locally restored when that smaller key is promoted above thekey that had been at
pandthatatc’ssibling.
Havingrestoredtheheap-orderpropertyfornodeprelativetoitschildren,there
maybeaviolation ofthisproperty atc;hence, wemayhavetocontinue swapping
down T until no violation of the heap-order property occurs. (See Figure 9.3e–h.)
This downward swapping process is called down-heap bubbling. A swap either
resolvestheviolationoftheheap-orderproperty orpropagates itoneleveldownin
the heap. In the worst case, an entry moves all the way down to the bottom level.
(SeeFigure9.3.) Thus,thenumberofswapsperformedintheexecutionofmethod
remove minis,intheworstcase,equaltotheheightofheapT,thatis,itis(cid:16)logn(cid:17)9.3. Heaps 375
(4,C)
(13,W)
(13,W)
(5,A) (6,Z) (5,A) (6,Z)
(15,K) (9,F) (7,Q) (20,B) (15,K) (9,F) (7,Q) (20,B)
(16,X) (25,J) (14,E) (12,H) (11,S) (16,X) (25,J) (14,E) (12,H) (11,S)
(a) (b)
(13,W) (5,A)
(5,A) (6,Z) (13,W) (6,Z)
(15,K) (9,F) (7,Q) (20,B) (15,K) (9,F) (7,Q) (20,B)
(16,X) (25,J) (14,E) (12,H) (11,S) (16,X) (25,J) (14,E) (12,H) (11,S)
(c) (d)
(5,A) (5,A)
(9,F) (6,Z) (9,F) (6,Z)
(15,K) (13,W) (7,Q) (20,B) (15,K) (13,W) (7,Q) (20,B)
(16,X) (25,J) (14,E) (12,H) (11,S) (16,X) (25,J) (14,E) (12,H) (11,S)
(e) (f)
(5,A) (5,A)
(9,F) (6,Z) (9,F) (6,Z)
(15,K) (7,Q) (20,B) (15,K) (12,H) (7,Q) (20,B)
(12,H)
(13,W)
(16,X) (25,J) (14,E) (11,S) (16,X) (25,J) (14,E) (13,W) (11,S)
(g) (h)
Figure 9.3: Removal of the entry with the smallest key from a heap: (a and b)
deletion of the last node, whose entry gets stored into the root; (c and d) swap to376 Chapter9. PriorityQueues
9.3.3 Array-Based Representation of a Complete Binary Tree
Thearray-basedrepresentationofabinarytree(Section8.3.2)isespeciallysuitable
for a complete binary tree T. We recall that in this implementation, the elements
of T are stored in an array-based list A such that the element at position p in T is
storedinAwithindexequaltothelevelnumber f(p)of p,deﬁnedasfollows:
• If pistherootofT,then f(p)=0.
• If pistheleftchildofpositionq,then f(p)=2f(q)+1.
• If pistherightchildofpositionq,then f(p)=2f(q)+2.
With this implementation, the elements ofT have contiguous indices in the range
[0,n−1]andthelastposition ofT isalwaysatindexn−1,wherenisthenumber
ofpositionsofT. Forexample,Figure9.4illustratesthearray-basedrepresentation
oftheheapstructureoriginally portrayed inFigure9.1.
(4,C) (5,A) (6,Z) (15,K) (9,F) (7,Q) (20,B)(16,X)(25,J) (14,E)(12,H)(11,S) (8,W)
0 1 2 3 4 5 6 7 8 9 10 11 12
Figure9.4: Anarray-based representation oftheheapfromFigure9.1.
Implementingapriorityqueueusinganarray-basedheaprepresentation allows
ustoavoidsomecomplexities ofanode-based treestructure. Inparticular, theadd
and remove min operations of a priority queue both depend on locating the last
index of a heap of size n. With the array-based representation, the last position
is at index n−1 of the array. Locating the last position of a complete binary tree
implementedwithalinkedstructure requiresmoreeffort. (SeeExerciseC-9.34.)
If the size of a priority queue is not known in advance, use of an array-based
representation doesintroducetheneedtodynamicallyresizethearrayonoccasion,
asisdonewithaPythonlist. Thespaceusageofsuchanarray-basedrepresentation
ofacompletebinarytreewithnnodesisO(n),andthetimeboundsofmethodsfor
addingorremovingelementsbecomeamortized. (SeeSection5.3.1.)
9.3.4 Python Heap Implementation
WeprovideaPythonimplementation ofaheap-basedpriorityqueueinCodeFrag-
ments9.4and9.5. Weuseanarray-based representation, maintaining aPythonlist
ofitem composites. Although wedo not formally use thebinary tree ADT,Code
Fragment9.4includesnonpublicutilityfunctionsthatcomputethelevelnumbering
ofaparentorchildofanother. Thisallowsustodescribetherestofouralgorithms
using tree-like terminology of parent, left, and right. However, the relevant vari-
ables are integer indexes (not “position” objects). We use recursion to implement9.3. Heaps 377
1 class HeapPriorityQueue(PriorityQueueBase): # base class deﬁnes Item
2 ”””A min-oriented priority queue implemented with a binary heap.”””
3 #------------------------------ nonpublic behaviors ------------------------------
4 def parent(self, j):
5 return (j−1) // 2
6
7 def left(self, j):
8 return 2 j + 1
9
10 def right(self, j):
11 return 2 j + 2
12
13 def has left(self, j):
14 return self. left(j) < len(self. data) # index beyond end of list?
15
16 def has right(self, j):
17 return self. right(j) < len(self. data) # index beyond end of list?
18
19 def swap(self, i, j):
20 ”””Swap the elements at indices i and j of array.”””
21 self. data[i], self. data[j] = self. data[j], self. data[i]
22
23 def upheap(self, j):
24 parent = self. parent(j)
25 if j > 0 and self. data[j] < self. data[parent]:
26 self. swap(j, parent)
27 self. upheap(parent) # recur at position of parent
28
29 def downheap(self, j):
30 if self. has left(j):
31 left = self. left(j)
32 small child = left # although right may be smaller
33 if self. has right(j):
34 right = self. right(j)
35 if self. data[right] < self. data[left]:
36 small child = right
37 if self. data[small child] < self. data[j]:
38 self. swap(j, small child)
39 self. downheap(small child) # recur at position of small child
Code Fragment 9.4: An implementation of a priority queue using an array-based
heap (continued inCode Fragment 9.5). Theextends thePriorityQueueBaseclass378 Chapter9. PriorityQueues
40 #------------------------------ public behaviors ------------------------------
41 def init (self):
42 ”””Create a new empty Priority Queue.”””
43 self. data = [ ]
44
45 def len (self):
46 ”””Return the number of items in the priority queue.”””
47 return len(self. data)
48
49 def add(self, key, value):
50 ”””Add a key-value pair to the priority queue.”””
51 self. data.append(self. Item(key, value))
52 self. upheap(len(self. data) − 1) # upheap newly added position
53
54 def min(self):
55 ”””Return but do not remove (k,v) tuple with minimum key.
56
57 Raise Empty exception if empty.
58 ”””
59 if self.is empty():
60 raise Empty( Priority queue is empty. )
61 item = self. data[0]
62 return (item. key, item. value)
63
64 def remove min(self):
65 ”””Remove and return (k,v) tuple with minimum key.
66
67 Raise Empty exception if empty.
68 ”””
69 if self.is empty():
70 raise Empty( Priority queue is empty. )
71 self. swap(0, len(self. data) − 1) # put minimum item at the end
72 item = self. data.pop( ) # and remove it from the list;
73 self. downheap(0) # then ﬁx new root
74 return (item. key, item. value)
Code Fragment 9.5: An implementation of a priority queue using an array-based9.3. Heaps 379
9.3.5 Analysis of a Heap-Based Priority Queue
Table9.3 showsthe running timeof thepriority queue ADTmethods for theheap
implementation of a priority queue, assuming that two keys can be compared in
O(1)timeandthattheheapT isimplementedwithanarray-based orlinked-based
treerepresentation.
Inshort,eachofthepriorityqueue ADTmethodscanbeperformed inO(1)or
in O(logn) time, where n is the number of entries at the time the method is exe-
cuted. Theanalysis oftherunningtimeofthemethodsisbasedonthefollowing:
• TheheapT hasnnodes,eachstoring areference toakey-value pair.
• TheheightofheapT isO(logn),sinceT iscomplete(Proposition 9.2).
• Theminoperation runsinO(1)becausetherootofthetreecontainssuchan
element.
• Locating the last position of a heap, as required for add and remove min,
canbeperformedinO(1)timeforanarray-basedrepresentation, orO(logn)
timeforalinked-tree representation. (SeeExerciseC-9.34.)
• In the worst case, up-heap and down-heap bubbling perform a number of
swapsequaltotheheightofT.
Operation RunningTime
len(P),P.is empty() O(1)
P.min() O(1)
P.add() O(logn)∗
P.remove min() O(logn)∗
∗
amortized, ifarray-based
Table 9.3: Performance of a priority queue, P, realized by means of a heap. We
let n denote the number of entries in the priority queue at the timean operation is
executed. Thespacerequirement isO(n). Therunning timeofoperations minand
remove minareamortizedforanarray-based representation, duetooccasional re-
sizingofadynamicarray;thoseboundsareworstcasewithalinkedtreestructure.
We conclude that the heap data structure is a very efﬁcient realization of the
priorityqueueADT,independentofwhethertheheapisimplementedwithalinked
structure or an array. The heap-based implementation achieves fast running times
forbothinsertionandremoval,unliketheimplementationsthatwerebasedonusing380 Chapter9. PriorityQueues
(cid:2)
9.3.6 Bottom-Up Heap Construction
Ifwestartwithaninitiallyemptyheap,nsuccessivecallstotheaddoperation will
run in O(nlogn) time in the worst case. However, if all n key-value pairs to be
stored in the heap are given in advance, such asduring theﬁrst phase ofthe heap-
sort algorithm, there is an alternative bottom-up construction method that runs in
O(n)time. (Heap-sort,however,stillrequiresΘ(nlogn)timebecauseofthesecond
phaseinwhichwerepeatedly removetheremainingelementwithsmallestkey.)
In this section, we describe the bottom-up heap construction, and provide an
implementation thatcanbeusedbytheconstructor ofaheap-based priorityqueue.
Forsimplicity of exposition, wedescribe this bottom-up heap construction as-
suming the number of keys, n, is an integer such that n = 2h+1−1. That is,
the heap is a complete binary tree with every level being full, so the heap has
height h = log(n+1)−1. Viewed nonrecursively, bottom-up heap construction
consists ofthefollowingh+1=log(n+1)steps:
1. In the ﬁrst step (see Figure 9.5b), we construct (n+1)/2 elementary heaps
storing oneentryeach.
2. Inthesecondstep(seeFigure9.5c–d),weform(n+1)/4heaps,eachstoring
three entries, by joining pairs of elementary heaps and adding a new entry.
The new entry is placed at the root and may have to be swapped with the
entrystoredatachildtopreservetheheap-order property.
3. In the third step (see Figure 9.5e–f), we form(n+1)/8 heaps, each storing
7entries, byjoiningpairsof3-entry heaps(constructed inthepreviousstep)
andaddinganewentry. Thenewentryisplacedinitiallyattheroot,butmay
have to move down with a down-heap bubbling to preserve the heap-order
property.
.
.
.
i. Inthegenericithstep,2≤i≤h,weform(n+1)/2iheaps,eachstoring2i−1
entries,byjoiningpairsofheapsstoring(2i−1−1)entries(constructedinthe
previous step) and adding a new entry. The new entry is placed initially at
theroot,butmayhavetomovedownwithadown-heapbubblingtopreserve
theheap-order property.
.
.
.
h+1. In the last step (see Figure 9.5g–h), we form the ﬁnal heap, storing all the
n entries, by joining two heaps storing (n−1)/2 entries (constructed in the
previous step) and adding a new entry. The new entry is placed initially at
theroot,butmayhavetomovedownwithadown-heapbubblingtopreserve
theheap-order property.9.3. Heaps 381
16 15 4 12 6 7 23 20
(a) (b)
25 9 11 17 15 4 6 17
16 15 4 12 6 7 23 20 16 25 9 12 11 7 23 20
(c) (d)
5 8 4 6
15 4 6 17 15 5 7 17
16 25 9 12 11 7 23 20 16 25 9 12 11 8 23 20
(e) (f)
14 4
4 6 5 6
15 5 7 17 15 9 7 17
16 25 9 12 11 8 23 20 16 25 14 12 11 8 23 20
(g) (h)
Figure9.5:Bottom-upconstructionofaheapwith15entries: (aandb)webeginby
constructing 1-entry heaps onthebottom level;(c andd)wecombinethese heaps
into3-entry heaps, andthen(e and f)7-entry heaps, until (g and h)wecreate the
ﬁnal heap. The paths of the down-heap bubblings are highlighted in (d, f, and h).382 Chapter9. PriorityQueues
Python Implementation of a Bottom-Up Heap Construction
Implementing a bottom-up heap construction is quite easy, given the existence of
a “down-heap” utility function. The “merging” of two equally sized heaps that
are subtrees of a common position p, as described in the opening of this section,
canbeaccomplished simplybydown-heaping p’sentry. Forexample, thatiswhat
happened tothekey14ingoingfromFigure9.5(f)to(g).
Withourarray-basedrepresentation ofaheap,ifweinitiallystoreallnitemsin
arbitraryorderwithinthearray,wecanimplementthebottom-upheapconstruction
process with a single loop that makes a call to downheap from each position of
thetree,aslongasthosecallsareorderedstartingwiththedeepestlevelandending
withtherootofthetree. Infact, that loopcan startwiththedeepest nonleaf, since
thereisnoeffectwhendown-heap iscalledataleafposition.
InCodeFragment9.6,weaugmenttheoriginalHeapPriorityQueueclassfrom
Section 9.3.4 to provide support for the bottom-up construction of an initial col-
lection. We introduce a nonpublic utility method, heapify, that calls downheap
oneachnonleaf position, beginning withthedeepest andconcluding withacallat
the root of the tree. We have redesigned the constructor of the class to accept an
optionalparameterthatcanbeanysequenceof(k,v)tuples. Ratherthaninitializing
self. datatoan empty list, weusealist comprehension syntax (see Section 1.9.2)
to create an initial list of item composites based on the given contents. We de-
clare an empty sequence as the default parameter value so that the default syntax
HeapPriorityQueue()continues toresultinanemptypriorityqueue.
def init (self, contents=()):
”””Create a new priority queue.
By default, queue will be empty. If contents is given, it should be as an
iterable sequence of (k,v) tuples specifying the initial contents.
”””
self. data = [ self. Item(k,v) for k,v in contents ] # empty by default
if len(self. data) > 1:
self. heapify()
def heapify(self):
start = self. parent(len(self) − 1) # start at PARENT of last leaf
for j in range(start, −1, −1): # going to and including the root
self. downheap(j)
Code Fragment 9.6: Revision to the HeapPriorityQueue class of Code Frag-
ments 9.4 and 9.5 to support a linear-time construction given an initial sequence9.3. Heaps 383
Asymptotic Analysis of Bottom-Up Heap Construction
Bottom-up heap construction is asymptotically faster thanincrementally inserting
n keys into an initially empty heap. Intuitively, we are performing a single down-
heap operation at each position in the tree, rather than a single up-heap operation
from each. Since more nodes are closer to the bottom of a tree than the top, the
sumofthedownwardpathsislinear, asshowninthefollowingproposition.
Proposition 9.3: Bottom-up construction ofaheapwithn entriestakes O(n)
time,assumingtwokeyscanbecomparedinO(1)time.
Justiﬁcation: The primary cost of the construction is due to the down-heap
stepsperformedateachnonleafposition. Letπ denotethepathofT fromnonleaf
v
node v to its “inorder successor” leaf, that is, the path that starts at v, goes to the
right child of v, and then goes down leftward until it reaches a leaf. Although,
π is not necessarily the path followed by the down-heap bubbling step from v,
v
the length (cid:7)π (cid:7) (its number of edges) is proportional to the height of the subtree
v
rooted at v, and thus a bound on the complexity of the down-heap operation at v.
Wecanboundthetotalrunningtimeofthebottom-upheapconstruction algorithm
basedonthesumofthesizesofpaths,∑ (cid:7)π (cid:7). Forintuition, Figure9.6illustrates
v v
thejustiﬁcation “visually,” marking each edgewiththelabel ofthenonleaf nodev
whosepathπ containsthatedge.
v
Weclaim thatthepathsπ forallnonleafvareedge-disjoint, andthusthesum
v
ofthepathlengthsisboundedbythenumberoftotaledgesinthetree,henceO(n).
To show this, we consider what we term “right-leaning” and “left-leaning” edges
(i.e.,thosegoingfromaparenttoaright,respectivelyleft,child). Aparticularright-
leaning edge e can only be part of the path π for node v that is the parent in the
v
relationship representedbye. Left-leaningedgescanbepartitioned byconsidering
the leaf that is reached if continuing down leftward until reaching a leaf. Each
nonleafnodeonlyusesleft-leaningedgesinthegroupleadingtothatnonleafnode’s
inordersuccessor. Sinceeachnonleafnodemusthaveadifferentinordersuccessor,
no two such paths can contain the same left-leaning edge. We conclude that the
bottom-up construction ofheapT takesO(n)time.
4
4
5 6
5 4 6
15 9 7 17
15 5 9 4 7 6 17
16 25 14 12 11 8 23 20
Figure 9.6: Visual justiﬁcation of the linear running time of bottom-up heap con-
struction. Eachedgeeislabeled withanodevforwhichπ containse(ifany).384 Chapter9. PriorityQueues
9.3.7 Python’s heapq Module
Python’s standard distribution includes a heapq module that provides support for
heap-basedpriorityqueues. Thatmoduledoesnotprovideanypriorityqueueclass;
instead it provides functions that allow a standard Python list to be managed as a
heap. Its model is essentially the same as our own, withn elements stored in list
cells L[0] through L[n−1], based on the level-numbering indices with the small-
est element at the root in L[0]. We note that heapq does not separately manage
associated values;elementsserveastheirownkey.
Theheapqmodulesupports thefollowingfunctions, allofwhichpresumethat
existinglistLsatisﬁestheheap-order propertypriortothecall:
heappush(L, e): Push element e onto list L and restore the heap-order
property. ThefunctionexecutesinO(logn)time.
heappop(L): PopandreturntheelementwithsmallestvaluefromlistL,
and reestablish the heap-order property. The operation
executesinO(logn)time.
heappushpop(L, e): Push element e on list L and then pop and return the
smallestitem. ThetimeisO(logn),butitisslightlymore
efﬁcient than separate calls topush and popbecause the
size of the list never changes. If the newly pushed el-
ement becomes the smallest, it is immediately returned.
Otherwise,thenewelementtakestheplaceofthepopped
elementattherootandadown-heap isperformed.
heapreplace(L, e): Similar to heappushpop, but equivalent to the pop be-
ing performed before the push (in other words, the new
element cannot be returned as the smallest). Again, the
timeisO(logn),butitismoreefﬁcientthattwoseparate
operations.
Themodulesupportsadditionalfunctionsthatoperateonsequencesthatdonot
previously satisfytheheap-order property.
heapify(L): Transform unordered list to satisfy the heap-order prop-
erty. This executes inO(n) time by using the bottom-up
construction algorithm.
nlargest(k, iterable): Producealistoftheklargestvaluesfromagiveniterable.
This can be implemented to run in O(n+klogn) time,
where we use n to denote the length of the iterable (see
ExerciseC-9.42).
nsmallest(k, iterable): Produce a list of the k smallest values from a given it-
erable. Thiscan be implemented to run inO(n+klogn)9.4. SortingwithaPriorityQueue 385
9.4 Sorting with a Priority Queue
IndeﬁningthepriorityqueueADT,wenotedthatanytypeofobjectcanbeusedas
a key, but that any pair of keys must be comparable to each other, and that the set
of keys benaturally ordered. In Python, it iscommon torely onthe < operator to
deﬁnesuchanorder,inwhichcasethefollowingproperties mustbesatisﬁed:
• Irreﬂexive property: k(cid:15)<k.
• Transitiveproperty: ifk <k andk <k ,thenk <k .
1 2 2 3 1 3
Formally, such a relationship deﬁnes what is known as a strict weak order, as it
allows for keys to be considered equal to each other, but the broader equivalence
classesaretotallyordered,astheycanbeuniquelyarrangedfromsmallesttolargest
duetothetransitive property.
As our ﬁrst application of priority queues, we demonstrate how they can be
used to sort a collection C of comparable elements. That is, we can produce a
sequence ofelementsofC inincreasing order(oratleastinnondecreasing orderif
thereareduplicates). Thealgorithm isquitesimple—weinsertallelementsintoan
initially empty priority queue, and then werepeatedly callremove minto retrieve
theelementsinnondecreasing order.
Animplementation ofthis algorithm isgiven inCodeFragment 9.7, assuming
that C is a positional list. (See Chapter 7.4.) We use an original element of the
collection asbothakeyandvaluewhencallingP.add(element, element).
1 def pq sort(C):
2 ”””Sort a collection of elements stored in a positional list.”””
3 n = len(C)
4 P = PriorityQueue()
5 for j in range(n):
6 element = C.delete(C.ﬁrst())
7 P.add(element, element) # use element as key and value
8 for j in range(n):
9 (k,v) = P.remove min()
10 C.add last(v) # store smallest remaining element in C
Code Fragment9.7: An implementation of the pq sort function, assuming an ap-
propriate implementation of a PriorityQueue class. Note that each element of the
inputlistCservesasitsownkeyinthepriorityqueueP.
With a minor modiﬁcation to this code, we can provide more general sup-
port, sorting elements according to an ordering other than the default. For exam-
ple, when working with strings, the < operator deﬁnes a lexicographic ordering,
whichisanextensionofthealphabeticorderingtoUnicode. Forexample,wehave386 Chapter9. PriorityQueues
apple < banana . Suppose that we have an application in which we have a
list of strings that are all known to represent integral values (e.g., 12 ), and our
goalistosortthestringsaccording tothoseintegral values.
In Python, the standard approach for customizing the order for a sorting algo-
rithm istoprovide, as anoptional parameter tothe sorting function, an object that
is itself a one-parameter function that computes a key for a given element. (See
Sections 1.5 and 1.10 for a discussion of this approach in thecontext of the built-
in max function.) For example, with a list of (numeric) strings, we might wish
to use the value of int(s) as a key for a string s of the list. In this case, the con-
structor for the int class can serve as the one-parameter function for computing a
key. Inthat way, the string 4 willbeordered before string 12 because its key
int( 4 ) < int( 12 ). We leave it as an exercise to support such an optional key
parameterforthepq sortfunction. (SeeExerciseC-9.46.)
9.4.1 Selection-Sort and Insertion-Sort
Our pq sort function works correctly given any valid implementation of the pri-
ority queue class. However, the running time of the sorting algorithm depends
on the running times of the operations add and remove min for the given priority
queue class. We next discuss a choice of priority queue implementations that in
effect cause the pq sort computation to behave as one of several classic sorting
algorithms.
Selection-Sort
Ifweimplement Pwith an unsorted list, then Phase 1 ofpq sorttakes O(n) time,
for we can add each element in O(1) time. In Phase 2, the running time of each
remove min operation is proportional to the size ofP. Thus, the bottleneck com-
putation is the repeated “selection” of the minimum element in Phase 2. For this
reason, thisalgorithm isbetterknownasselection-sort. (SeeFigure9.7.)
As noted above, the bottleneck is in Phase 2 where we repeatedly remove an
entry with smallest key from the priority queue P. The size of P starts at n and
incrementally decreases with each remove min until it becomes 0. Thus, the ﬁrst
operation takes timeO(n), the second one takes timeO(n−1), and so on. There-
fore,thetotaltimeneeded forthesecondphaseis
O(n+(n−1)+···+2+1)=O(∑n i).
i=1
ByProposition 3.3, wehave∑n i=n(n+1)/2. Thus, Phase 2takes timeO(n2),
i=19.4. SortingwithaPriorityQueue 387
CollectionC PriorityQueueP
Input (7,4,8,2,5,3) ()
Phase1 (a) (4,8,2,5,3) (7)
(b) (8,2,5,3) (7,4)
. . .
. . .
. . .
(f) () (7,4,8,2,5,3)
Phase2 (a) (2) (7,4,8,5,3)
(b) (2,3) (7,4,8,5)
(c) (2,3,4) (7,8,5)
(d) (2,3,4,5) (7,8)
(e) (2,3,4,5,7) (8)
(f) (2,3,4,5,7,8) ()
Figure9.7: Executionofselection-sort oncollectionC=(7,4,8,2,5,3).
Insertion-Sort
Ifweimplement the priority queue Pusing asorted list, then weimprove the run-
ningtimeofPhase2toO(n),foreachremove minoperation onPnowtakesO(1)
time. Unfortunately, Phase 1 becomes the bottleneck for the running time, since,
intheworstcase, eachaddoperation takes timeproportional tothecurrent sizeof
P. Thissortingalgorithmisbetterknownasinsertion-sort(seeFigure9.8);infact,
ourimplementation foraddinganelementtoapriorityqueueisalmostidenticalto
astepofinsertion-sort aspresented inSection7.5.
Theworst-case runningtimeofPhase1ofinsertion-sort is
O(1+2+...+(n−1)+n)=O(∑n i).
i=1
Again, by Proposition 3.3, this implies a worst-case O(n2) time for Phase 1, and
thus, the entire insertion-sort algorithm. However, unlike selection-sort, insertion-
sorthasabest-caserunning timeofO(n).
CollectionC PriorityQueueP
Input (7,4,8,2,5,3) ()
Phase1 (a) (4,8,2,5,3) (7)
(b) (8,2,5,3) (4,7)
(c) (2,5,3) (4,7,8)
(d) (5,3) (2,4,7,8)
(e) (3) (2,4,5,7,8)
(f) () (2,3,4,5,7,8)
Phase2 (a) (2) (3,4,5,7,8)
(b) (2,3) (4,5,7,8)
. . .
. . .
. . .
(f) (2,3,4,5,7,8) ()388 Chapter9. PriorityQueues
9.4.2 Heap-Sort
As we have previously observed, realizing a priority queue with a heap has the
advantagethatallthemethodsinthepriorityqueueADTruninlogarithmictimeor
better. Hence, this realization issuitable for applications where fast running times
are sought for all the priority queue methods. Therefore, let us again consider the
pq sortscheme,thistimeusingaheap-basedimplementationofthepriorityqueue.
During Phase 1, the ith add operation takes O(logi) time, since the heap has i
entriesaftertheoperationisperformed. ThereforethisphasetakesO(nlogn)time.
(It could be improved to O(n) with the bottom-up heap construction described in
Section9.3.6.)
During the second phase of pq sort, the jth remove min operation runs in
O(log(n− j+1)), since the heap has n− j+1 entries at the time the operation
is performed. Summing over all j, this phase takes O(nlogn) time, so the entire
priority-queue sortingalgorithm runsinO(nlogn)timewhenweuseaheaptoim-
plement the priority queue. This sorting algorithm is better known as heap-sort,
anditsperformance issummarizedinthefollowingproposition.
Proposition 9.4: Theheap-sortalgorithmsortsacollectionC ofn elementsin
O(nlogn)time,assumingtwoelementsofCcanbecomparedinO(1)time.
LetusstressthattheO(nlogn)runningtimeofheap-sortisconsiderably better
thantheO(n2)runningtimeofselection-sort andinsertion-sort (Section9.4.1).
Implementing Heap-Sort In-Place
If the collection C to be sorted is implemented by means of an array-based se-
quence, most notably as a Python list, we can speed up heap-sort and reduce its
space requirement by aconstant factor using aportion ofthelist itself to store the
heap,thusavoidingtheuseofanauxiliaryheapdatastructure. Thisisaccomplished
bymodifyingthealgorithm asfollows:
1. We redeﬁne the heap operations to be a maximum-oriented heap, with each
position’s key being at least as large as its children. This can be done by
recoding the algorithm, or by adjusting the notion of keys to be negatively
oriented. At any time during the execution of the algorithm, we use the left
portion ofC, upto acertain index i−1, to store the entries of the heap, and
the right portion of C, from index i to n−1, to store the elements of the
sequence. Thus, the ﬁrsti elements ofC (at indices 0,...,i−1)provide the
array-list representation oftheheap.
2. Intheﬁrstphaseofthealgorithm,westartwithanemptyheapandmovethe
boundary betweentheheapandthesequence fromlefttoright,onestepata
time. Instepi,fori=1,...,n,weexpand theheapbyadding theelementat9.4. SortingwithaPriorityQueue 389
3. In the second phase of the algorithm, we start with an empty sequence and
movetheboundarybetweentheheapandthesequencefromrighttoleft,one
step at a time. At step i, for i= 1,...,n, we remove a maximum element
fromtheheapandstoreitatindexn−i.
In general, we say that a sorting algorithm is in-place if it uses only a small
amountofmemoryinadditiontothesequencestoringtheobjectstobesorted. The
variation of heap-sort above qualiﬁes as in-place; insteadof transferring elements
out of the sequence and then back in, wesimply rearrange them. Weillustrate the
secondphaseofin-place heap-sort inFigure9.9.
9
(a) 9 7 5 2 6 4 7 5
2 6 4
7
(b) 7 6 5 2 4 9 6 5
2 4
6
(c) 6 4 5 2 7 9 4 5
2
5
(d) 5 4 2 6 7 9
4 2
4
(e) 4 2 5 6 7 9
2
(f) 2 4 5 6 7 9 2
Figure 9.9: Phase 2 of an in-place heap-sort. The heap portion of each sequence
representationishighlighted. Thebinarytreethateachsequence(implicitly)repre-390 Chapter9. PriorityQueues
9.5 Adaptable Priority Queues
The methods of the priority queue ADT given in Section 9.1.2 are sufﬁcient for
most basic applications of priority queues, such as sorting. However, there are
situations inwhichadditional methodswouldbeuseful, asshownbythescenarios
belowinvolving thestandby airlinepassenger application.
• Astandbypassengerwithapessimisticattitudemaybecometiredofwaiting
and decide to leave ahead of the boarding time, requesting to be removed
fromthewaitinglist. Thus,wewouldliketoremovefromthepriorityqueue
the entry associated with this passenger. Operation remove min does not
sufﬁce since the passenger leaving does not necessarily have ﬁrst priority.
Instead, wewantanewoperation,remove,thatremovesanarbitrary entry.
• Anotherstandby passengerﬁndshergoldfrequent-ﬂyer cardandshowsitto
theagent. Thus,herpriority hastobemodiﬁedaccordingly. Toachieve this
change of priority, we would like to have a new operation update allowing
ustoreplacethekeyofanexistingentrywithanewkey.
We will see another application of adaptable priority queues when implementing
certaingraphalgorithmsinSections14.6.2and14.7.1.
Inthissection, wedevelop anadaptable priority queueADTand demonstrate
howtoimplementthisabstractionasanextensiontoourheap-basedpriorityqueue.
9.5.1 Locators
In order to implement methods update and remove efﬁciently, we need a mecha-
nism for ﬁnding a user’s element within a priority queue thatavoids performing a
linear search through the entire collection. To support our goal, when a new ele-
mentisaddedtothepriorityqueue,wereturnaspecialobjectknownasalocatorto
thecaller. Wethenrequiretheusertoprovideanappropriatelocatorasaparameter
wheninvoking theupdateorremovemethod,asfollows,forapriority queueP:
P.update(loc, k, v): Replacekeyandvaluefortheitemidentiﬁedbylocatorloc.
P.remove(loc): Removetheitemidentiﬁedbylocatorlocfromthepriority
queueandreturnits(key,value)pair.
ThelocatorabstractionissomewhatakintothePositionabstractionusedinour
positional listADTfromSection7.4,andourtreeADTfromChapter8. However,
we differentiate between a locator and a position because a locator for a priority
queue does not represent a tangible placement of an element within the structure.
Inourpriorityqueue,anelementmayberelocatedwithinourdatastructureduring
an operation that does not seem directly relevant to that element. A locator for an9.5. AdaptablePriorityQueues 391
9.5.2 Implementing an Adaptable Priority Queue
Inthissection,weprovideaPythonimplementationofanadaptablepriorityqueue
asanextensionofourHeapPriorityQueueclassfromSection9.3.4. Toimplementa
Locatorclass,wewillextendtheexisting Itemcompositetoaddanadditionalﬁeld
designating the current index of the element within the array-based representation
ofourheap,asshowninFigure9.10.
token
(4,C,0) (5,A,1) (6,Z,2) (15,K,3) (9,F,4) (7,Q,5) (20,B,6) (16,X,7)
0 1 2 3 4 5 6 7
Figure9.10: Representing a heap using a sequence of locators. The third element
ofeachlocatorinstancecorrespondstotheindexoftheitemwithinthearray. Iden-
tiﬁertokenispresumedtobealocator referenceintheuser’sscope.
Thelistisasequence ofreferences tolocator instances, eachofwhichstores a
key, value, andthecurrent index oftheitemwithin thelist. Theuserwillbegiven
a reference to the Locator instance for each inserted element, as portrayed by the
tokenidentiﬁerinFigure9.10.
When we perform priority queue operations on our heap, and items are relo-
catedwithinourstructure,werepositionthelocatorinstanceswithinthelistandwe
updatethethirdﬁeldofeachlocatortoreﬂectitsnewindexwithinthelist. Asanex-
ample,Figure9.11showsthestateoftheaboveheapafteracalltoremove min().
The heap operation caused the minimum entry, (4,C), to be removed, and the en-
try,(16,X),tobetemporarily movedfromthelastposition totheroot,followedby
a down-heap bubble phase. During the down-heap, element (16,X) was swapped
token
(5,A,0) (9,F,1) (6,Z,2) (15,K,3) (16,X,4) (7,Q,5) (20,B,6)
0 1 2 3 4 5 6 7
Figure9.11: Theresult ofacall toremove min()onthe heap originally portrayed
in Figure 9.10. Identiﬁer token continues to reference the same locator instance
as in the original conﬁguration, but the placement of that locator in the list has392 Chapter9. PriorityQueues
with its left child, (5,A), at index 1 of the list, then swapped with its right child,
(9,F), at index 4 of the list. In the ﬁnal conﬁguration, the locatorinstances for all
affectedelementshavebeenmodiﬁedtoreﬂecttheirnewlocation.
It is important to emphasize that the locator instances have not changed iden-
tity. The user’s token reference, portrayed in Figures 9.10 and 9.11, continues to
referencethesameinstance;wehavesimplychangedthethirdﬁeldofthatinstance,
andwehavechanged wherethatinstance isreferenced withinthelistsequence.
Withthisnewrepresentation, providingtheadditionalsupportfortheadaptable
priority queue ADTis rather straightforward. When a locator instance is sent as a
parameter to updateor remove, we may rely on the third ﬁeld of that structure to
designate where the element resides in the heap. With that knowledge, the update
ofakeymaysimplyrequire anup-heap ordown-heap bubbling step toreestablish
the heap-order property. (The complete binary tree property remains intact.) To
implement the removal of an arbitrary element, we move the element at the last
position tothevacatedlocation, andagainperform anappropriate bubbling stepto
satisfytheheap-order property.
Python Implementation
CodeFragments 9.8and9.9present aPython implementation of anadaptable pri-
ority queue, asasubclass oftheHeapPriorityQueueclassfrom Section9.3.4. Our
modiﬁcations totheoriginalclassarerelatively minor. WedeﬁneapublicLocator
class that inherits from the nonpublic Item class and augments it with an addi-
tional index ﬁeld. We make it a public class because we will be using locators
asreturn values and parameters; however, thepublic interface forthelocator class
doesnotinclude anyotherfunctionality fortheuser.
Toupdatelocators duringtheﬂowofourheapoperations, werelyonaninten-
tionaldesigndecisionthatouroriginalclassusesanonpublic swapmethodforall
data movement. Weoverride that utility to execute the additional step of updating
thestoredindiceswithinthetwoswappedlocatorinstances.
We provide a new bubble utility that manages the reinstatement of the heap-
order property when a key has changed at an arbitrary position within the heap,
eitherduetoakeyupdate, ortheblindreplacement ofaremovedelementwiththe
item from the last position of the tree. The bubble utility determines whether to
apply up-heap or down-heap bubbling, depending on whether the given location
hasaparentwithasmallerkey. (Ifanupdatedkeycoincidentally remainsvalidfor
itscurrentlocation, wetechnically call downheapbutnoswapsresult.)
The public methods are provided in Code Fragment 9.9. The existing add
method isoverridden, both tomakeuseofaLocatorinstance rather than an Item
instance forstorage ofthenewelement, andtoreturnthelocator tothecaller. The
remainderofthatmethodissimilartotheoriginal,withthemanagementoflocator9.5. AdaptablePriorityQueues 393
ridetheremove minmethodbecausetheonlychangeinbehaviorfortheadaptable
priorityqueueisagainprovidedbytheoverridden swapmethod.
The update and remove methods provide the core new functionality for the
adaptable priority queue. We perform robust checking of thevalidity of a locator
that is sent by a caller (although in the interest of space, our displayed code does
not do preliminary type-checking to ensure that the parameter is indeed aLocator
instance). Toensurethatalocatorisassociated withacurrentelementofthegiven
priorityqueue,weexaminetheindexthatisencapsulated withinthelocatorobject,
andthenverifythattheentryofthelistatthatindexistheverysamelocator.
In conclusion, the adaptable priority queue provides the same asymptotic efﬁ-
ciency and space usage as the nonadaptive version, and provides logarithmic per-
formance for the new locator-based update and remove methods. A summary of
theperformance isgiveninTable9.4.
1 class AdaptableHeapPriorityQueue(HeapPriorityQueue):
2 ”””A locator-based priority queue implemented with a binary heap.”””
3
4 #------------------------------ nested Locator class ------------------------------
5 class Locator(HeapPriorityQueue. Item):
6 ”””Token for locating an entry of the priority queue.”””
7 slots = _index # add index as additional ﬁeld
8
9 def init (self, k, v, j):
10 super(). init (k,v)
11 self. index = j
12
13 #------------------------------ nonpublic behaviors ------------------------------
14 # override swap to record new indices
15 def swap(self, i, j):
16 super(). swap(i,j) # perform the swap
17 self. data[i]. index = i # reset locator index (post-swap)
18 self. data[j]. index = j # reset locator index (post-swap)
19
20 def bubble(self, j):
21 if j > 0 and self. data[j] < self. data[self. parent(j)]:
22 self. upheap(j)
23 else:
24 self. downheap(j)
CodeFragment9.8: An implementation of an adaptable priority queue (continued
in Code Fragment 9.9). This extends the HeapPriorityQueue class of Code Frag-394 Chapter9. PriorityQueues
25 def add(self, key, value):
26 ”””Add a key-value pair.”””
27 token = self.Locator(key, value, len(self. data)) # initiaize locator index
28 self. data.append(token)
29 self. upheap(len(self. data) − 1)
30 return token
31
32 def update(self, loc, newkey, newval):
33 ”””Update the key and value for the entry identiﬁed by Locator loc.”””
34 j = loc. index
35 if not (0 <= j < len(self) and self. data[j] is loc):
36 raise ValueError( Invalid locator )
37 loc. key = newkey
38 loc. value = newval
39 self. bubble(j)
40
41 def remove(self, loc):
42 ”””Remove and return the (k,v) pair identiﬁed by Locator loc.”””
43 j = loc. index
44 if not (0 <= j < len(self) and self. data[j] is loc):
45 raise ValueError( Invalid locator )
46 if j == len(self) − 1: # item at last position
47 self. data.pop( ) # just remove it
48 else:
49 self. swap(j, len(self)−1) # swap item to the last position
50 self. data.pop( ) # remove it from the list
51 self. bubble(j) # ﬁx item displaced by the swap
52 return (loc. key, loc. value)
CodeFragment9.9: An implementation of an adaptable priority queue (continued
fromCodeFragment9.8).
Operation RunningTime
len(P),P.is empty(),P.min() O(1)
P.add(k,v) O(logn)∗
P.update(loc, k, v) O(logn)
P.remove(loc) O(logn)∗
P.remove min() O(logn)∗
∗
amortizedwithdynamicarray
Table9.4:Runningtimesofthemethodsofanadaptablepriorityqueue,P,ofsizen,
realized by means of our array-based heap representation. The space requirement9.6. Exercises 395
9.6 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-9.1 How long would it take to remove the (cid:13)logn(cid:14) smallest elements from a
heapthatcontainsnentries, usingtheremove minoperation?
R-9.2 Suppose you label each position p of a binary tree T with a key equal to
itspreorderrank. Underwhatcircumstances isT aheap?
R-9.3 Whatdoeseachremove mincallreturnwithinthefollowing sequence of
priority queue ADT methods: add(5,A), add(4,B), add(7,F), add(1,D),
remove min(),add(3,J),add(6,L),remove min(),remove min(),
add(8,G),remove min(),add(2,H),remove min(),remove min()?
R-9.4 An airport is developing a computer simulation of air-trafﬁc control that
handleseventssuchaslandingsandtakeoffs. Eacheventhasatimestamp
that denotes the time when the event will occur. Thesimulation program
needstoefﬁcientlyperform thefollowingtwofundamental operations:
• Insertaneventwithagiventimestamp(thatis,addafutureevent).
• Extract the event with smallest time stamp (that is, determine the
nexteventtoprocess).
Whichdatastructure shouldbeusedfortheaboveoperations? Why?
R-9.5 The min method for the UnsortedPriorityQueue class executes in O(n)
time, asanalyzed inTable9.2. Giveasimplemodiﬁcation totheclass so
that minruns in O(1)time. Explain any necessary modiﬁcations toother
methodsoftheclass.
R-9.6 Canyouadaptyoursolutiontothepreviousproblemtomakeremove min
run in O(1) time for the UnsortedPriorityQueue class? Explain your an-
swer.
R-9.7 Illustrate the execution of the selection-sort algorithm on the following
inputsequence: (22,15,36,44,10,3,9,13,29,25).
R-9.8 Illustrate the execution of the insertion-sort algorithm on the input se-
quenceofthepreviousproblem.
R-9.9 Give an example of a worst-case sequence withn elements for insertion-
sort,andshowthatinsertion-sort runsinΩ(n2)timeonsuchasequence.
R-9.10 Atwhichpositions ofaheapmightthethirdsmallestkeybestored?396 Chapter9. PriorityQueues
R-9.12 Considerasituation inwhichauserhasnumerickeysandwishestohave
a priority queue that is maximum-oriented. How could a standard (min-
oriented) priorityqueuebeusedforsuchapurpose?
R-9.13 Illustrate theexecution ofthe in-place heap-sort algorithm onthe follow-
inginputsequence: (2,5,16,4,10,23,39,18,26,15).
R-9.14 Let T be a complete binary tree such that position p stores an element
withkey f(p),where f(p)isthelevelnumberof p(seeSection8.3.2). Is
treeT aheap? Whyorwhynot?
R-9.15 Explainwhythedescriptionofdown-heapbubblingdoesnotconsiderthe
caseinwhichposition phasarightchildbutnotaleftchild.
R-9.16 Is there a heap H storing seven entries with distinct keys such that a pre-
order traversal of H yields the entries of H in increasing or decreasing
order by key? How about an inorder traversal? How about a postorder
traversal? Ifso,giveanexample;ifnot,saywhy.
R-9.17 LetH beaheapstoring15entriesusingthearray-based representation of
a complete binary tree. What is the sequence of indices of thearray that
are visited in a preorder traversal of H? What about an inorder traversal
ofH? Whataboutapostorder traversalofH?
R-9.18 Showthatthesum
n
∑logi,
i=1
whichappearsintheanalysisofheap-sort, isΩ(nlogn).
R-9.19 Bill claims that a preorder traversal of a heap will list its keys in nonde-
creasing order. Drawanexampleofaheapthatproveshimwrong.
R-9.20 Hillaryclaimsthatapostorder traversalofaheapwilllistitskeysinnon-
increasing order. Drawanexampleofaheapthatprovesherwrong.
R-9.21 Showallthestepsofthealgorithmforremovingtheentry(16,X)fromthe
heapofFigure9.1,assumingtheentryhadbeenidentiﬁedwithalocator.
R-9.22 Show all the steps of the algorithm for replacing key of entry(5,A) with
18 in the heap of Figure 9.1, assuming the entry had been identiﬁed with
alocator.
R-9.23 Drawanexampleofaheapwhosekeysarealltheoddnumbersfrom1to
59(withnorepeats),suchthattheinsertionofanentrywithkey32would
cause up-heap bubbling to proceed all the way up to a child of the root
(replacing thatchild’s keywith32).
R-9.24 DescribeasequenceofninsertionsinaheapthatrequiresΩ(nlogn)time
toprocess.
R-9.25 Complete Figure 9.9 by showing all the steps of the in-place heap-sort
algorithm. Showboththearrayandtheassociatedheapattheendofeach9.6. Exercises 397
Creativity
C-9.26 Show how to implement the stack ADT using only a priority queue and
oneadditional integerinstance variable.
C-9.27 ShowhowtoimplementtheFIFOqueueADTusingonlyapriorityqueue
andoneadditional integerinstance variable.
C-9.28 Professor Idle suggests the following solution to the previous problem.
Whenever an item is inserted into the queue, it is assigned a key that is
equaltothecurrentsizeofthequeue. DoessuchastrategyresultinFIFO
semantics? Provethatitissoorprovideacounterexample.
C-9.29 Reimplement the SortedPriorityQueue using a Python list. Make sure to
maintainremove min’sO(1)performance.
C-9.30 Givea nonrecursive implementation of the upheapmethod for the class
HeapPriorityQueue.
C-9.31 Give a nonrecursive implementation of the downheap method for the
classHeapPriorityQueue.
C-9.32 Assume that we are using a linked representation of a complete binary
tree T, and an extra reference to the last node of that tree. Show howto
update the reference to the last node after operations addor remove min
in O(logn) time, where n is the current number of nodes of T. Be sure
andhandleallpossible cases,asillustrated inFigure9.12.
C-9.33 Whenusingalinked-tree representation foraheap,analternativemethod
for ﬁnding thelast node during aninsertion inaheapT istostore, inthe
last node and each leaf node of T, a reference to the leaf node immedi-
ately toitsright(wrapping totheﬁrstnodeinthenextlowerlevelforthe
rightmostleafnode). ShowhowtomaintainsuchreferencesinO(1)time
per operation ofthe priority queue ADTassuming thatT isimplemented
withalinkedstructure.
(2,B) (4,C)
(5,A) (4,C) (5,A) (6,Z)
(15,K) (9,F) (7,Q) (6,Z) (15,K) (9,F) (7,Q) (20,B)
w w z
(16,X) (25,J) (14,E) (12,H) (11,S) (8,W) (20,B) (10,L) (16,X) (25,J) (14,E) (12,H)
z
(a) (b)
Figure9.12: Updatingthelastnodeinacompletebinarytreeafteroperationaddor
remove. Node w is the last node before operation add or after operation remove.398 Chapter9. PriorityQueues
C-9.34 We can represent a path from the root to a given node of a binary tree
by means of a binary string, where 0 means “go to the left child” and 1
means “go to the right child.” For example, the path from the root to the
node storing (8,W) in the heap of Figure 9.12a is represented by “101.”
DesignanO(logn)-timealgorithm forﬁndingthelastnodeofacomplete
binary tree with n nodes, based on the above representation. Show how
thisalgorithmcanbeusedintheimplementationofacompletebinarytree
by means of a linked structure that does not keep a reference to the last
node.
C-9.35 Given a heap T and a key k, give an algorithm to compute all the entries
in T having akey less than orequal tok. Forexample, given the heap of
Figure9.12aandqueryk=7,thealgorithmshouldreporttheentrieswith
keys 2, 4, 5, 6, and 7 (but not necessarily in this order). Youralgorithm
should run in time proportional to the number of entries returned, and
shouldnotmodifytheheap
C-9.36 Provideajustiﬁcation ofthetimeboundsinTable9.4.
C-9.37 Give an alternative analysis of bottom-up heap construction by showing
thefollowingsummationisO(1),foranypositiveintegerh:
h (cid:9) (cid:10)
∑ i/2i .
i=1
C-9.38 Supposetwobinarytrees,T andT ,holdentriessatisfyingtheheap-order
1 2
property(butnotnecessarilythecompletebinarytreeproperty). Describe
amethodforcombiningT andT intoabinary treeT,whosenodeshold
1 2
theunion oftheentries inT and T andalso satisfy theheap-order prop-
1 2
erty. Your algorithm should run in time O(h +h ) where h and h are
1 2 1 2
therespective heightsofT andT .
1 2
C-9.39 ImplementaheappushpopmethodfortheHeapPriorityQueueclass,with
semanticsakintothatdescribed fortheheapqmoduleinSection9.3.7.
C-9.40 Implement a heapreplace method for the HeapPriorityQueue class, with
semanticsakintothatdescribed fortheheapqmoduleinSection9.3.7.
C-9.41 TamarindoAirlineswantstogiveaﬁrst-classupgradecoupontotheirtop
logn frequent ﬂyers, based on the number of miles accumulated, where
n is the total number of the airlines’ frequent ﬂyers. The algorithm they
currentlyuse,whichrunsinO(nlogn)time,sortstheﬂyersbythenumber
of miles ﬂown and then scans the sorted list to pick the top logn ﬂyers.
Describeanalgorithm thatidentiﬁesthetoplognﬂyersinO(n)time.
C-9.42 Explainhowtheklargestelementsfromanunorderedcollection ofsizen
canbefoundintimeO(n+klogn)usingamaximum-oriented heap.
C-9.43 Explainhowtheklargestelementsfromanunorderedcollection ofsizen9.6. Exercises 399
C-9.44 Givenaclass,PriorityQueue,thatimplementstheminimum-oriented pri-
orityqueueADT,provideanimplementationofaMaxPriorityQueueclass
thatadaptstoprovideamaximum-orientedabstractionwithmethodsadd,
max, and remove max. Your implementation should not make any as-
sumption about theinternal workings oftheoriginalPriorityQueueclass,
northetypeofkeysthatmightbeused.
C-9.45 Writeakeyfunction fornonnegativeintegersthatdeterminesorderbased
onthenumberof1’sineachinteger’sbinaryexpansion.
C-9.46 Give an alternative implementation of the pq sort function, from Code
Fragment9.7,thataccepts akeyfunctionasanoptional parameter.
C-9.47 Describe an in-place version of the selection-sort algorithm for an array
thatusesonlyO(1)spaceforinstancevariables inaddition tothearray.
C-9.48 AssumingtheinputtothesortingproblemisgiveninanarrayA,describe
howtoimplementtheinsertion-sort algorithm using onlythearrayAand
atmostaconstant numberofadditional variables.
C-9.49 Give an alternate description of the in-place heap-sort algorithm using
the standard minimum-oriented priority queue (instead of a maximum-
oriented one).
C-9.50 An online computer system for trading stocks needs to process orders of
the form “buy 100 shares at $x each” or “sell 100 shares at $y each.” A
buy order for $x can only be processed if there is an existing sell order
with price $y such that y≤x. Likewise, a sell order for $y can only be
processed if there is an existing buy order with price $x such that y≤x.
Ifabuyorsellorderisenteredbutcannotbeprocessed, itmustwaitfora
future orderthatallowsittobeprocessed. Describeaschemethatallows
buyandsellorderstobeenteredinO(logn)time,independentofwhether
ornottheycanbeimmediatelyprocessed.
C-9.51 Extend a solution to the previous problem so that users are allowed to
updatethepricesfortheirbuyorsellordersthathaveyettobeprocessed.
C-9.52 A group of children want to play a game, called Unmonopoly, where in
eachturntheplayerwiththemostmoneymustgivehalfofhis/hermoney
to the player with the least amount of money. What data structure(s)
shouldbeusedtoplaythisgameefﬁciently? Why?
Projects
P-9.53 Implement the in-place heap-sort algorithm. Experimentally compare its
running timewiththatofthestandardheap-sort thatisnotin-place.
P-9.54 Usethe approach ofeither Exercise C-9.42or C-9.43to reimplement the
topmethodoftheFavoritesListMTFclassfromSection7.6.2. Makesure400 Chapter9. PriorityQueues
P-9.55 Writeaprogram thatcan process asequence ofstock buy andsell orders
asdescribed inExerciseC-9.50.
P-9.56 Let S be a set of n points in the plane with distinct integer x- and y-
coordinates. Let T be a complete binary tree storing the points from S
at its external nodes, such that the points are ordered left to right by in-
creasingx-coordinates. ForeachnodevinT,letS(v)denotethesubsetof
S consisting of points stored in the subtree rooted atv. For the root r of
T, deﬁnetop(r) to be the point inS=S(r) with maximum y-coordinate.
For every other node v, deﬁnetop(r) to be the point in S with highest y-
coordinate inS(v)that isnotalso thehighesty-coordinate inS(u), where
uistheparentofvinT (ifsuchapointexists). SuchlabelingturnsT into
aprioritysearchtree. Describealinear-timealgorithm forturningT into
apriority searchtree. Implementthisapproach.
P-9.57 Oneofthemainapplications ofpriority queuesisinoperating systems—
for scheduling jobs on a CPU.In this project you are to build a program
that schedules simulated CPU jobs. Your program should run in a loop,
eachiteration ofwhichcorresponds toatimeslicefortheCPU.Eachjob
is assigned a priority, which is an integer between−20 (highest priority)
and19(lowestpriority),inclusive. Fromamongalljobswaitingtobepro-
cessed in a time slice, the CPUmust work on a job with highest priority.
Inthissimulation,eachjobwillalsocomewithalengthvalue,whichisan
integerbetween1and100,inclusive,indicatingthenumberoftimeslices
that are needed to process this job. For simplicity, you may assume jobs
cannot be interrupted—once it is scheduled on the CPU, a job runs for a
number oftimeslices equal toits length. Your simulator must output the
name of the job running on the CPUin each time slice and must process
asequence ofcommands,onepertimeslice,eachofwhichisoftheform
“addjobnamewithlengthnandpriority p”or“nonewjobthisslice”.
P-9.58 Develop a Python implementation of an adaptable priority queue that is
basedonanunsorted listandsupports location-aware entries.
Chapter Notes
Knuth’s book on sorting and searching [65] describes the motivation and history for the
selection-sort, insertion-sort, and heap-sort algorithms. The heap-sort algorithm is due
to Williams [103], and the linear-time heap construction algorithm is due to Floyd [39].
Additional algorithms and analyses for heaps and heap-sort variations can be found in
papersbyBentley[15],Carlsson[24],GonnetandMunro[45],McDiarmidandReed[74],Chapter
10
Maps, Hash Tables, and Skip Lists
Contents
10.1 Maps and Dictionaries . . . . . . . . . . . . . . . . . . . . . 402
10.1.1 The Map ADT . . . . . . . . . . . . . . . . . . . . . . . 403
10.1.2 Application: Counting Word Frequencies . . . . . . . . . . 405
10.1.3 Python’s MutableMapping Abstract Base Class . . . . . . 406
10.1.4 Our MapBase Class . . . . . . . . . . . . . . . . . . . . . 407
10.1.5 Simple Unsorted Map Implementation . . . . . . . . . . . 408
10.2 Hash Tables . . . . . . . . . . . . . . . . . . . . . . . . . . 410
10.2.1 Hash Functions . . . . . . . . . . . . . . . . . . . . . . . 411
10.2.2 Collision-HandlingSchemes . . . . . . . . . . . . . . . . . 417
10.2.3 Load Factors, Rehashing, and Eﬃciency . . . . . . . . . . 420
10.2.4 Python Hash Table Implementation . . . . . . . . . . . . 422
10.3 Sorted Maps . . . . . . . . . . . . . . . . . . . . . . . . . . 427
10.3.1 Sorted Search Tables . . . . . . . . . . . . . . . . . . . . 428
10.3.2 Two Applications of Sorted Maps . . . . . . . . . . . . . 434
10.4 Skip Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
10.4.1 Search and Update Operations in a Skip List . . . . . . . 439
(cid:2)
10.4.2 Probabilistic Analysis of Skip Lists . . . . . . . . . . . . 443
10.5 Sets, Multisets, and Multimaps . . . . . . . . . . . . . . . 446
10.5.1 The Set ADT . . . . . . . . . . . . . . . . . . . . . . . . 446
10.5.2 Python’s MutableSet Abstract Base Class . . . . . . . . . 448
10.5.3 Implementing Sets, Multisets, and Multimaps . . . . . . . 450402 Chapter10. Maps,HashTables,andSkipLists
10.1 Maps and Dictionaries
Python’sdictclassisarguablythemostsigniﬁcantdatastructureinthelanguage. It
represents an abstraction known as adictionary in which unique keys are mapped
to associated values. Because of the relationship they express between keys and
values, dictionaries are commonly known as associative arrays or maps. In this
book, weuse thetermdictionary whenspeciﬁcally discussing Python’sdict class,
andthetermmapwhendiscussingthemoregeneralnotionoftheabstractdatatype.
Asasimpleexample,Figure10.1illustratesamapfromthenamesofcountries
totheirassociated unitsofcurrency.
Turkey Spain Greece China United States India
Lira Euro Yuan Dollar Rupee
Figure10.1:Amapfromcountries(thekeys)totheirunitsofcurrency(thevalues).
Wenotethatthekeys(thecountrynames)areassumedtobeunique,butthevalues
(the currency units) are not necessarily unique. For example, we note that Spain
and Greece both use the euro for currency. Maps use an array-like syntax for in-
dexing, such ascurrency[ Greece ]to access avalue associated withagiven key
or currency[ Greece ] = Drachma to remap it to a new value. Unlike a stan-
dard array, indices for amapneed notbe consecutive norevennumeric. Common
applications ofmapsinclude thefollowing.
• A university’s information system relies on some form of a student ID as a
key that is mapped to that student’s associated record (such as the student’s
name,address, andcoursegrades)serving asthevalue.
• Thedomain-namesystem(DNS)mapsahostname,suchaswww.wiley.com,
toanInternet-Protocol (IP)address, suchas208.215.179.146.
• Asocialmediasitetypicallyreliesona(nonnumeric) usernameasakeythat
canbeefﬁcientlymappedtoaparticular user’sassociated information.
• Acomputer graphics system maymap acolor name, such as turquoise ,
tothetriple ofnumbers that describes the color’s RGB(red-green-blue) rep-
resentation, suchas(64,224,208).
• Pythonusesadictionarytorepresenteachnamespace,mappinganidentifying
string,suchas pi ,toanassociated object, suchas3.14159.
Inthischapterandthenextwedemonstratethatamapmaybeimplementedso
that asearch for a key, and its associated value, can be performed very efﬁciently,10.1. MapsandDictionaries 403
10.1.1 The Map ADT
Inthissection,weintroducethemapADT,anddeﬁneitsbehaviorstobeconsistent
withthoseofPython’sbuilt-indictclass. Webeginbylistingwhatweconsiderthe
mostsigniﬁcantﬁvebehaviors ofamapM asfollows:
M[k]: Return the value v associated with key k in map M, if
one exists; otherwise raise aKeyError. In Python, this is
implemented withthespecialmethod getitem .
M[k] = v: Associate valuev withkeykinmapM,replacing theex-
isting value if the map already contains an item with key
equaltok. InPython,thisisimplementedwiththespecial
method setitem .
del M[k]: Remove from map M the item with key equal to k; if M
hasnosuchitem,thenraiseaKeyError. InPython,thisis
implemented withthespecialmethod delitem .
len(M): Return the number of items in mapM. In Python, this is
implemented withthespecialmethod len .
iter(M): The default iteration for a map generates a sequence of
keys in the map. In Python, this is implemented with the
special method iter , and itallows loops ofthe form,
for k in M.
We have highlighted the above ﬁve behaviors because they demonstrate the core
functionality of amap—namely, the ability toquery, add, modify, or delete akey-
value pair, and the ability to report all such pairs. For additional convenience,
mapM should alsosupportthefollowingbehaviors:
k in M: Return True if the map contains an item with key k. In
Python,thisisimplementedwiththespecial contains
method.
M.get(k, d=None): Return M[k] if key k exists in the map; otherwise return
default valued. ThisprovidesaformtoqueryM[k]with-
outriskofaKeyError.
M.setdefault(k, d): If key k exists in the map, simply return M[k]; if key k
doesnotexist,setM[k] = dandreturnthatvalue.
M.pop(k, d=None): Removetheitemassociated withkeykfromthemapand
return its associated value v. If key k is not in the map,
return default valued(orraise KeyErrorifparameterdis404 Chapter10. Maps,HashTables,andSkipLists
M.popitem(): Removeanarbitrarykey-valuepairfromthemap,andre-
turna(k,v)tuplerepresenting theremovedpair. Ifmapis
empty,raiseaKeyError.
M.clear(): Removeallkey-value pairsfromthemap.
M.keys(): Returnaset-likeviewofallkeysofM.
M.values(): Returnaset-likeviewofallvaluesofM.
M.items(): Returnaset-likeviewof(k,v)tuplesforallentriesofM.
M.update(M2): AssignM[k] = vforevery(k,v)pairinmapM2.
M == M2: Return True if maps M and M2 have identical key-value
associations.
M != M2: ReturnTrueifmapsMandM2donothaveidenticalkey-
valueassociations.
Example 10.1: Inthefollowing,weshowtheeffectofaseriesofoperationson
aninitiallyemptymapstoringitemswithintegerkeysandsingle-charactervalues.
WeusetheliteralsyntaxforPython’sdictclasstodescribethemapcontents.
Operation ReturnValue Map
len(M) 0 { }
M[ K ] = 2 – { K : 2}
M[ B ] = 4 – { K : 2, B : 4}
M[ U ] = 2 – { K : 2, B : 4, U : 2}
M[ V ] = 8 – { K : 2, B : 4, U : 2, V : 8}
M[ K ] = 9 – { K : 9, B : 4, U : 2, V : 8}
M[ B ] 4 { K : 9, B : 4, U : 2, V : 8}
M[ X ] KeyError { K : 9, B : 4, U : 2, V : 8}
M.get( F ) None { K : 9, B : 4, U : 2, V : 8}
M.get( F , 5) 5 { K : 9, B : 4, U : 2, V : 8}
M.get( K , 5) 9 { K : 9, B : 4, U : 2, V : 8}
len(M) 4 { K : 9, B : 4, U : 2, V : 8}
del M[ V ] – { K : 9, B : 4, U : 2}
M.pop( K ) 9 { B : 4, U : 2}
M.keys() B , U { B : 4, U : 2}
M.values() 4, 2 { B : 4, U : 2}
M.items() ( B , 4), ( U , 2) { B : 4, U : 2}
M.setdefault( B , 1) 4 { B : 4, U : 2}
M.setdefault( A , 1) 1 { A : 1, B : 4, U : 2}10.1. MapsandDictionaries 405
10.1.2 Application: Counting Word Frequencies
As a case study for using a map, consider the problem of counting the number
ofoccurrences ofwordsinadocument. Thisisastandard taskwhenperforming a
statisticalanalysisofadocument,forexample,whencategorizinganemailornews
article. A map is an ideal data structure to use here, for we can use words as keys
andwordcountsasvalues. Weshowsuchanapplication inCodeFragment10.1.
We break apart the original document using a combination of ﬁle and string
methodsthatresultsinaloopoveralowercasedversionofallwhitespaceseparated
pieces of the document. Weomitall nonalphabetic characters so that parentheses,
apostrophes, andothersuchpunctuation arenotconsideredpartofaword.
In termsof mapoperations, webegin withan empty Python dictionary named
freq. Duringtheﬁrstphaseofthealgorithm, weexecutethecommand
freq[word] = 1 + freq.get(word, 0)
foreachwordoccurrence. Weusethegetmethodontheright-handsidebecausethe
current wordmightnotexistinthedictionary; thedefault valueof0isappropriate
inthatcase.
Duringthesecondphaseofthealgorithm,afterthefulldocumenthasbeenpro-
cessed, we examine the contents of the frequency map, looping over freq.items()
todetermine whichwordhasthemostoccurrences.
1 freq = { }
2 for piece in open(ﬁlename).read().lower().split():
3 # only consider alphabetic characters within this piece
4 word = .join(c for c in piece if c.isalpha())
5 if word: # require at least one alphabetic character
6 freq[word] = 1 + freq.get(word, 0)
7
8 max word =
9 max count = 0
10 for (w,c) in freq.items(): # (key, value) tuples represent (word, count)
11 if c > max count:
12 max word = w
13 max count = c
14 print( The most frequent word is , max word)
15 print( Its number of occurrences is , max count)
CodeFragment10.1: Aprogramforcountingwordfrequencies inadocument, and
reporting the most frequent word. We use Python’s dict class for the map. We406 Chapter10. Maps,HashTables,andSkipLists
10.1.3 Python’s MutableMapping Abstract Base Class
Section 2.4.3 provides an introduction to the concept of an abstract base class
and the role of such classes in Python’s collections module. Methods that are de-
clared to be abstract in such a base class must be implemented by concrete sub-
classes. However, an abstract base class may provide concrete implementation of
othermethods thatdepend upon useofthepresumed abstract methods. (Thisisan
exampleofthetemplatemethoddesignpattern.)
The collections module provides two abstract base classes that are relevant to
our current discussion: the Mappingand MutableMappingclasses. TheMapping
classincludesallnonmutatingmethodssupportedbyPython’sdictclass,whilethe
MutableMapping class extends that to include the mutating methods. What we
deﬁne as the map ADT in Section 10.1.1 is akin to the MutableMappingabstract
baseclassinPython’scollectionsmodule.
Thesigniﬁcanceoftheseabstractbaseclassesisthattheyprovideaframework
to assist in creating a user-deﬁned map class. In particular, the MutableMapping
class provides concrete implementations for all behaviors other than the ﬁrst ﬁve
outlinedinSection10.1.1: getitem , setitem , delitem , len ,and
iter . As we implement the map abstraction with various data structures, as
long asweprovide theﬁvecore behaviors, wecaninherit all other derived behav-
iorsbysimplydeclaringMutableMappingasaparentclass.
TobetterunderstandtheMutableMappingclass,weprovideafewexamplesof
howconcretebehaviorscanbederivedfromtheﬁvecoreabstractions. Forexample,
the contains method,supporting thesyntaxk in M,couldbeimplementedby
makingaguardedattempttoretrieveself[k]todetermineifthekeyexists.
def contains (self, k):
try:
self[k] # access via getitem (ignore result)
return True
except KeyError:
return False # attempt failed
Asimilarapproach mightbeusedtoprovidethelogicofthesetdefaultmethod.
def setdefault(self, k, d):
try:
return self[k] # if getitem succeeds, return value
except KeyError: # otherwise:
self[k] = d # set default value with setitem
return d # and return that newly assigned value
We leave as exercises the implementations of the remaining concrete methods of10.1. MapsandDictionaries 407
10.1.4 Our MapBase Class
We will be providing many different implementations of the map ADT, in the re-
mainderofthischapterandnext,usingavarietyofdatastructures demonstrating a
trade-offofadvantagesanddisadvantages. Figure10.2providesapreviewofthose
classes.
The MutableMapping abstract base class, from Python’s collections module
anddiscussedintheprecedingpages,isavaluabletoolwhenimplementingamap.
However, in the interest of greater code reuse, we deﬁne our own MapBaseclass,
which is itself a subclass of the MutableMapping class. Our MapBase class pro-
vides additional support for the composition design pattern. This is a technique
we introduced when implementing a priority queue (see Section 9.2.1) in order to
groupakey-value pairasasingleinstance forinternal use.
More formally, our MapBaseclass is deﬁned in Code Fragment 10.2, extend-
ing the existing MutableMapping abstract base class so that we inherit the many
useful concrete methods that class provides. We then deﬁne a nonpublic nested
Item class, whose instances are able to store both a key and value. This nested
class isreasonably similar indesign tothe Itemclass that wasdeﬁned within our
PriorityQueueBase class in Section 9.2.1, except that for a map we provide sup-
port for both equality tests and comparisons, both of which rely onthe item’s key.
Thenotionofequalityisnecessaryforallofourmapimplementations, asawayto
determine whether a key given as a parameter is equivalent to one that is already
stored inthemap. Thenotion ofcomparisons between keys, using the <operator,
willbecomerelevantwhenwelaterintroduce asortedmapADT(Section10.3).
MutableMapping
(collectionsmodule)
MapBase
(Section10.1.4)
UnsortedTableMap HashMapBase SortedTableMap TreeMap
(Section10.1.5) (Section10.2.4) (Section10.3.1) (Chapter11)
(additionalsubclasses)
ChainHashMap ProbeHashMap
(Section10.2.4) (Section10.2.4)408 Chapter10. Maps,HashTables,andSkipLists
1 class MapBase(MutableMapping):
2 ”””Our own abstract base class that includes a nonpublic Item class.”””
3
4 #------------------------------- nested Item class -------------------------------
5 class Item:
6 ”””Lightweight composite to store key-value pairs as map items.”””
7 slots = _key , _value
8
9 def init (self, k, v):
10 self. key = k
11 self. value = v
12
13 def eq (self, other):
14 return self. key == other. key # compare items based on their keys
15
16 def ne (self, other):
17 return not (self == other) # opposite of eq
18
19 def lt (self, other):
20 return self. key < other. key # compare items based on their keys
CodeFragment10.2:ExtendingtheMutableMappingabstractbaseclasstoprovide
anonpublic Itemclassforuseinourvariousmapimplementations.
10.1.5 Simple Unsorted Map Implementation
We demonstrate the use of the MapBaseclass with a very simple concrete imple-
mentation of the map ADT. Code Fragment 10.3 presents an UnsortedTableMap
classthatreliesonstoringkey-value pairsinarbitraryorderwithinaPythonlist.
An empty table is initialized asself. table within the constructor for our map.
When a new key is entered into the map, via line 22 of the setitem method,
we create a new instance of the nested Item class, which is inherited from our
MapBaseclass.
Thislist-basedmapimplementationissimple,butitisnotparticularlyefﬁcient.
Each of the fundamental methods, getitem , setitem , and delitem ,
reliesonaforlooptoscantheunderlying listofitemsinsearchofamatchingkey.
Inabest-casescenario,suchamatchmaybefoundnearthebeginningofthelist,in
which case the loop terminates; in the worst case, the entirelist willbe examined.10.1. MapsandDictionaries 409
1 class UnsortedTableMap(MapBase):
2 ”””Map implementation using an unordered list.”””
3
4 def init (self):
5 ”””Create an empty map.”””
6 self. table = [ ] # list of Item’s
7
8 def getitem (self, k):
9 ”””Return value associated with key k (raise KeyError if not found).”””
10 for item in self. table:
11 if k == item. key:
12 return item. value
13 raise KeyError( Key Error: + repr(k))
14
15 def setitem (self, k, v):
16 ”””Assign value v to key k, overwriting existing value if present.”””
17 for item in self. table:
18 if k == item. key: # Found a match:
19 item. value = v # reassign value
20 return # and quit
21 # did not ﬁnd match for key
22 self. table.append(self. Item(k,v))
23
24 def delitem (self, k):
25 ”””Remove item associated with key k (raise KeyError if not found).”””
26 for j in range(len(self. table)):
27 if k == self. table[j]. key: # Found a match:
28 self. table.pop(j) # remove item
29 return # and quit
30 raise KeyError( Key Error: + repr(k))
31
32 def len (self):
33 ”””Return number of items in the map.”””
34 return len(self. table)
35
36 def iter (self):
37 ”””Generate iteration of the maps keys.”””
38 for item in self. table:
39 yield item. key # yield the KEY
CodeFragment10.3:AnimplementationofamapusingaPythonlistasanunsorted410 Chapter10. Maps,HashTables,andSkipLists
10.2 Hash Tables
In this section, we introduce one of the most practical data structures for imple-
menting a map, and the one that is used by Python’s own implementation of the
dictclass. Thisstructureisknownasahashtable.
Intuitively, a map M supports the abstraction of using keys as indices with a
syntax such as M[k]. As a mental warm-up, consider a restricted setting in which
a map with n items uses keys that are known to be integers in a range from 0 to
N−1forsomeN ≥n. Inthiscase, wecanrepresent themapusingalookuptable
oflengthN,asdiagrammed inFigure10.3.
0 1 2 3 4 5 6 7 8 9 10
D Z C Q
Figure10.3:Alookuptablewithlength11foramapcontaining items(1,D),(3,Z),
(6,C),and(7,Q).
Inthisrepresentation, westorethevalueassociatedwithkeykatindexkofthe
table(presumingthatwehaveadistinctwaytorepresentanemptyslot). Basicmap
operations of getitem , setitem ,and delitem canbeimplementedin
O(1)worst-case time.
There aretwochallenges in extending this framework to themore general set-
tingofamap. First,wemaynotwishtodevoteanarrayoflengthN ifitisthecase
that N (cid:19)n. Second, we do not in general require that a map’s keys be integers.
The novel concept for a hash table is the use of a hash function to map general
keystocorresponding indicesinatable. Ideally,keyswillbewelldistributedinthe
rangefrom0toN−1byahashfunction, butinpracticetheremaybetwoormore
distinct keysthatgetmappedtothesameindex. Asaresult, wewillconceptualize
our table as a bucket array, as shown in Figure 10.4, in which each bucket may
manage acollection ofitems that aresent to aspeciﬁc index bythe hash function.
(Tosavespace,anemptybucketmaybereplaced byNone.)
0 1 2 3 4 5 6 7 8 9 10
(1,D) (25,C) (6,A) (7,Q)
(3,F) (39,C)
(14,Z)
Figure10.4: A bucket array of capacity 11 with items (1,D), (25,C), (3,F), (14,Z),10.2. HashTables 411
10.2.1 Hash Functions
The goal of a hash function, h, is to map each key k to an integer in the range
[0,N−1], where N is the capacity of the bucket array for a hash table. Equipped
with such a hash function, h, the main idea of this approach is to use the hash
function value, h(k), as an index into our bucket array, A, instead of the key k
(which may not be appropriate for direct use as an index). That is, we store the
item(k,v)inthebucketA[h(k)].
Iftherearetwoormorekeyswiththesamehashvalue,thentwodifferentitems
will be mapped to the same bucket in A. In this case, we say that a collision has
occurred. To be sure, there are ways of dealing with collisions, which we will
discuss later, but the best strategy isto try to avoid them inthe ﬁrst place. Wesay
that a hash function is “good” if it maps the keys in our map so as to sufﬁciently
minimize collisions. For practical reasons, we also would like a hash function to
befastandeasytocompute.
It is common to view the evaluation of a hash function, h(k), as consisting of
two portions—a hash code that maps a key k to an integer, and a compression
functionthatmapsthehashcodetoanintegerwithinarangeofindices,[0,N−1],
forabucketarray. (SeeFigure10.5.)
Arbitrary Objects
hashcode
... -2-1 0 1 2 ...
compressionfunction
0 1 2 ... N-1
Figure10.5: Twopartsofahashfunction: ahashcodeandacompressionfunction.
Theadvantageofseparatingthehashfunctionintotwosuchcomponentsisthat
the hash code portion of that computation is independent of a speciﬁc hash table
size. This allows the development of a general hash code for each object that can
be used for a hash table of any size; only the compression function depends upon
thetable size. Thisisparticularly convenient, because theunderlying bucket array
for a hash table may be dynamically resized, depending on the number of items412 Chapter10. Maps,HashTables,andSkipLists
Hash Codes
The ﬁrst action that a hash function performs is to take an arbitrary key k in our
mapandcomputeanintegerthatiscalledthehashcodefork;thisintegerneednot
beintherange[0,N−1],andmayevenbenegative. Wedesirethatthesetofhash
codes assigned to our keys should avoid collisions as much aspossible. For if the
hash codes ofourkeys cause collisions, thenthere isnohopeforourcompression
function to avoid them. In this subsection, we begin by discussing the theory of
hashcodes. Followingthat, wediscuss practical implementations ofhashcodesin
Python.
Treating the Bit Representation as an Integer
Tobegin,wenotethat,foranydatatypeX thatisrepresentedusingatmostasmany
bits as our integer hash codes, wecan simply take as a hash code for X an integer
interpretation of its bits. For example, the hash code for key 314 could simply be
314. The hash code for a ﬂoating-point number such as3.14 could be based upon
aninterpretation ofthebitsoftheﬂoating-point representation asaninteger.
Foratypewhosebitrepresentationislongerthanadesiredhashcode,theabove
scheme is not immediately applicable. For example, Python relies on 32-bit hash
codes. If a ﬂoating-point number uses a 64-bit representation, its bits cannot be
vieweddirectlyasahashcode. Onepossibilityistouseonlythehigh-order32bits
(orthelow-order32bits). Thishashcode,ofcourse,ignoreshalfoftheinformation
present in the original key, and if manyofthe keys in our maponly differ inthese
bits,thentheywillcollideusingthissimplehashcode.
Abetterapproachistocombineinsomewaythehigh-orderandlow-orderpor-
tions of a 64-bit key to form a 32-bit hash code, which takes all the original bits
into consideration. A simple implementation is to add the two components as 32-
bitnumbers(ignoringoverﬂow),ortotaketheexclusive-orofthetwocomponents.
Theseapproachesofcombiningcomponentscanbeextendedtoanyobjectxwhose
binary representation can be viewed as an n-tuple (x0,x1,...,xn−1) of 32-bit inte-
gers,forexample,byformingahashcodeforxas∑ni=−01xi,orasx0⊕x1⊕···⊕xn−1,
where the ⊕ symbol represents the bitwise exclusive-or operation (which is ˆ in
Python).
Polynomial Hash Codes
Thesummationandexclusive-orhashcodes,describedabove,arenotgoodchoices
forcharacterstringsorothervariable-length objectsthatcanbeviewedastuplesof
the form (x0,x1,...,xn−1), where the order of the xi’s is signiﬁcant. For example,
consider a 16-bit hash code for a character string s that sums the Unicode values10.2. HashTables 413
collisions for common groups of strings. In particular, "temp01" and "temp10"
collide using thisfunction, asdo"stop","tops","pots",and"spot". Abetter
hash code should somehow take into consideration the positions of the x’s. An
i
alternative hash code, which does exactly this, is to choose a nonzero constant,
a(cid:15)=1,anduseasahashcodethevalue
x0an−1+x1an−2+···+xn−2a+xn−1.
Mathematically speaking, this is simply a polynomial in a that takes the compo-
nents(x0,x1,...,xn−1)ofanobjectxasitscoefﬁcients. Thishashcodeistherefore
called apolynomial hashcode. ByHorner’s rule(see ExerciseC-3.50), thispoly-
nomialcanbecomputedas
xn−1+a(xn−2+a(xn−3+···+a(x2+a(x1+ax0))···)).
Intuitively,apolynomialhashcodeusesmultiplicationbydifferentpowersasa
waytospreadouttheinﬂuenceofeachcomponent acrosstheresulting hashcode.
Of course, on a typical computer, evaluating a polynomial will be done using
theﬁnitebitrepresentation forahashcode;hence,thevaluewillperiodically over-
ﬂowthe bits used foran integer. Since weare more interestedin agood spread of
the object xwith respect toother keys, wesimply ignore such overﬂows. Still, we
should be mindful that such overﬂows are occurring and choose the constant a so
that it has some nonzero, low-order bits, which will serve topreserve some of the
information contentevenasweareinanoverﬂowsituation.
We have done some experimental studies that suggest that 33, 37, 39, and 41
are particularly good choices for a when working with character strings that are
English words. In fact, ina list ofover 50,000 English wordsformed asthe union
ofthewordlistsprovided intwovariantsofUnix,wefoundthattaking atobe33,
37,39,or41produced lessthan7collisions ineachcase!
Cyclic-Shift Hash Codes
A variant of the polynomial hash code replaces multiplication by a with a cyclic
shift ofapartial sum by acertain number of bits. Forexample, a5-bit cyclic shift
of the 32-bit value 00111101100101101010100010101000 is achieved by taking
theleftmost ﬁvebits andplacing those onthe rightmost sideoftherepresentation,
resultingin10110010110101010001010100000111. Whilethisoperationhaslittle
naturalmeaningintermsofarithmetic, itaccomplishes thegoalofvaryingthebits
of the calculation. In Python, a cyclic shift of bits can be accomplished through
careful use ofthe bitwise operators <<and >>, taking care to truncate results to414 Chapter10. Maps,HashTables,andSkipLists
An implementation of a cyclic-shift hash code computation for a character
stringinPythonappearsasfollows:
def hash code(s):
mask = (1 << 32) − 1 # limit to 32-bit integers
h = 0
for character in s:
h = (h << 5 & mask) | (h >> 27) # 5-bit cyclic shift of running sum
h += ord(character) # add in value of next character
return h
Aswiththetraditional polynomial hashcode, ﬁne-tuning isrequired whenusing a
cyclic-shift hash code, as we must wisely choose the amount to shift by for each
newcharacter. Ourchoiceofa5-bitshiftisjustiﬁedbyexperimentsrunonalistof
just over 230,000 English words, comparing the number of collisions for various
shiftamounts(seeTable10.1).
Collisions
Shift Total Max
0 234735 623
1 165076 43
2 38471 13
3 7174 5
4 1379 3
5 190 3
6 502 2
7 560 2
8 5546 4
9 393 3
10 5194 5
11 11559 5
12 822 2
13 900 4
14 2001 4
15 19251 8
16 211781 37
Table 10.1: Comparison of collision behavior for the cyclic-shift hashcode as ap-
pliedtoalistof230,000Englishwords. The“Total”columnrecordsthetotalnum-
berofwordsthatcollidewithatleastoneother,andthe“Max”columnrecordsthe
maximumnumberofwordscollidingatanyonehashcode. Notethatwithacyclic10.2. HashTables 415
Hash Codes in Python
Thestandardmechanism forcomputing hashcodesinPythonisabuilt-infunction
withsignaturehash(x)thatreturnsanintegervaluethatservesasthehashcodefor
objectx. However,onlyimmutabledatatypesaredeemedhashableinPython. This
restriction is meant to ensure that aparticular object’s hash code remains constant
during that object’s lifespan. This is an important property for an object’s use as
a key in a hash table. A problem could occur if a key were inserted into the hash
table,yetalatersearchwereperformedforthatkeybasedonadifferent hashcode
thanthatwhichithadwheninserted; thewrongbucketwouldbesearched.
Among Python’s built-in data types, the immutable int, ﬂoat, str, tuple, and
frozenset classes produce robust hash codes, via the hash function, using tech-
niques similar to those discussed earlier in this section. Hash codes for character
strings are well crafted based on a technique similar to polynomial hash codes,
except using exclusive-or computations rather than additions. If we repeat the ex-
periment described in Table 10.1 using Python’s built-in hash codes, we ﬁnd that
only8stringsoutofthesetofmorethan230,000collidewithanother. Hashcodes
for tuples are computed with asimilar technique based upon acombination of the
hash codes of the individual elements of the tuple. When hashing a frozenset, the
orderoftheelementsshouldbeirrelevant,andsoanaturaloptionistocomputethe
exclusive-or oftheindividual hash codes without anyshifting. Ifhash(x)iscalled
foraninstancexofamutabletype,suchasalist,aTypeErrorisraised.
Instances of user-deﬁned classes are treated as unhashable by default, with a
TypeError raised by the hash function. However, a function that computes hash
codescanbeimplementedintheformofaspecialmethodnamed hash within
a class. The returned hash code should reﬂect the immutable attributes of an in-
stance. Itiscommontoreturnahashcodethatisitselfbasedonthecomputedhash
of the combination of such attributes. For example, a Color class that maintains
threenumericred,green,andbluecomponents mightimplementthemethodas:
def hash (self):
return hash( (self. red, self. green, self. blue) ) # hash combined tuple
Animportantruletoobeyisthatifaclassdeﬁnesequivalencethrough eq ,
then any implementation of hash must be consistent, in that if x == y, then
hash(x) == hash(y). This is important because if two instances are considered
to be equivalent and one is used as a key in a hash table, a search for the second
instance shouldresult inthediscovery oftheﬁrst. Itistherefore importantthatthe
hashcodeforthesecondmatchthehashcodefortheﬁrst,sothattheproperbucket
is examined. This rule extends to any well-deﬁned comparisons between objects
of different classes. For example, since Python treats the expression 5 == 5.0 as416 Chapter10. Maps,HashTables,andSkipLists
Compression Functions
The hash code for a key k will typically not be suitable for immediate use with a
bucketarray, becausetheintegerhashcodemaybenegativeormayexceedtheca-
pacityofthebucketarray. Thus,oncewehavedeterminedanintegerhashcodefor
akeyobjectk,thereisstilltheissueofmappingthatintegerintotherange[0,N−1].
This computation, known as a compression function, is the second action per-
formed as part of an overall hash function. A good compression function is one
thatminimizesthenumberofcollisions foragivensetofdistincthashcodes.
The Division Method
Asimplecompression function isthedivisionmethod,whichmapsanintegerito
imod N,
whereN,thesizeofthebucketarray,isaﬁxedpositiveinteger. Additionally, ifwe
takeN tobeaprimenumber,thenthiscompressionfunctionhelps“spreadout”the
distribution of hashed values. Indeed, ifN is not prime, then there is greater risk
thatpatternsinthedistribution ofhashcodeswillberepeatedinthedistribution of
hash values, thereby causing collisions. For example, if weinsert keys with hash
codes {200,205,210,215,220,...,600} into a bucket array of size 100, then each
hash code will collide with three others. But if we use a bucket array of size 101,
then there willbeno collisions. Ifahash function ischosenwell, it should ensure
thattheprobability oftwodifferentkeysgettinghashedtothesamebucketis1/N.
Choosing N to be a prime number is not always enough, however, for if there is
a repeated pattern of hash codes of the form pN+qfor several different p’s, then
therewillstillbecollisions.
The MAD Method
A more sophisticated compression function, which helps eliminate repeated pat-
ternsinasetofintegerkeys,istheMultiply-Add-and-Divide(or“MAD”)method.
Thismethodmapsanintegerito
[(ai+b) mod p]mod N,
where N is the size of the bucket array, p is a prime number larger than N, and a
and b are integers chosen at random from the interval [0,p−1], with a>0. This
compression functionischoseninordertoeliminaterepeated patterns inthesetof
hashcodesandgetusclosertohavinga“good”hashfunction,thatis,onesuchthat
theprobability anytwodifferentkeyscollideis1/N. Thisgoodbehaviorwouldbe10.2. HashTables 417
10.2.2 Collision-Handling Schemes
Themainideaofahashtableistotakeabucketarray,A,andahashfunction,h,and
use them to implement a map by storing each item (k,v) in the “bucket” A[h(k)].
Thissimpleideaischallenged,however,whenwehavetwodistinctkeys,k andk ,
1 2
such that h(k )=h(k ). Theexistence of such collisions prevents us from simply
1 2
inserting anewitem (k,v)directly into thebucket A[h(k)]. Italso complicates our
procedure forperforming insertion, search, anddeletion operations.
Separate Chaining
A simple and efﬁcient way for dealing with collisions is to have each bucket A[j]
storeitsownsecondarycontainer,holdingitems(k,v)suchthath(k)= j. Anatural
choiceforthesecondarycontainerisasmallmapinstanceimplementedusingalist,
asdescribed inSection10.1.5. Thiscollision resolutionruleisknownasseparate
chaining,andisillustrated inFigure10.6.
0 1 2 3 4 5 6 7 8 9 10 11 12
A
54 18 10 25
28 36 38
41 12
90
Figure10.6: Ahashtableofsize13,storing 10itemswithinteger keys, withcolli-
sionsresolvedbyseparatechaining. Thecompressionfunctionish(k)=k mod 13.
Forsimplicity, wedonotshowthevaluesassociated withthekeys.
In the worstcase, operations on an individual bucket take timeproportional to
thesizeofthebucket. Assuming weuseagood hashfunction toindexthe nitems
of our map in a bucket array of capacity N, the expected size of a bucket is n/N.
Therefore,ifgivenagoodhashfunction,thecoremapoperationsruninO((cid:13)n/N(cid:14)).
Theratio λ=n/N, called the load factor of the hash table, should be bounded by
asmall constant, preferably below 1. Aslong asλ isO(1), the core operations on418 Chapter10. Maps,HashTables,andSkipLists
Open Addressing
Theseparate chaining rule has many nice properties, such asaffording simple im-
plementations of map operations, but it nevertheless has one slight disadvantage:
Itrequires theuseofanauxiliary datastructure—a list—toholditemswithcollid-
ing keys. If space is at a premium (for example, if weare writing a program for a
smallhandheld device),thenwecanusethealternative approachofalwaysstoring
each item directly in a table slot. This approach saves space because no auxiliary
structures are employed, but it requires a bit more complexity to deal with colli-
sions. There are several variants of this approach, collectively referred to as open
addressingschemes,whichwediscussnext. Openaddressingrequiresthattheload
factorisalwaysatmost1andthatitemsarestoreddirectlyinthecellsofthebucket
arrayitself.
Linear Probing and Its Variants
A simple method for collision handling with open addressing is linear probing.
Withthisapproach,ifwetrytoinsertanitem(k,v)intoabucketA[j]thatisalready
occupied, where j=h(k),thenwenexttryA[(j+1)mod N]. IfA[(j+1)mod N]
is also occupied, then we tryA[(j+2)mod N], and so on, until we ﬁnd an empty
bucket that can accept the new item. Once this bucket is located, we simply in-
sert the item there. Of course, this collision resolution strategy requires that we
changetheimplementationwhensearchingforanexistingkey—theﬁrststepofall
getitem , setitem , or delitem operations. In particular, to attempt
to locate an item with key equal tok, we must examine consecutive slots, starting
fromA[h(k)],untilweeitherﬁndanitemwiththatkeyorweﬁndanemptybucket.
(SeeFigure10.7.) Thename“linearprobing” comesfromthefactthataccessing a
cellofthebucket arraycanbeviewedasa“probe.”
Mustprobe4times
Newelementwith beforeﬁndingemptyslot
key=15tobeinserted
0 1 2 3 4 5 6 7 8 9 10
13 26 5 37 16 21
Figure10.7: Insertion intoahash tablewithinteger keysusing linear probing. The10.2. HashTables 419
To implement a deletion, we cannot simply remove a found itemfrom its slot
in the array. For example, after the insertion of key 15 portrayed in Figure 10.7,
if the item with key 37 were trivially deleted, a subsequent search for 15 would
fail because that search would start by probing at index 4, then index 5, and then
index 6, at which an empty cell is found. A typical way to get around this difﬁ-
culty is to replace a deleted item with a special “available” marker object. With
this special marker possibly occupying spaces in our hash table, we modify our
search algorithm so that the search for a key k will skip over cells containing the
available marker andcontinue probing until reaching thedesired item oranempty
bucket (or returning back to where we started from). Additionally, our algorithm
for setitem should remember an available cell encountered during the search
fork,sincethisisavalidplacetoputanewitem(k,v),ifnoexistingitemisfound.
Although use of an open addressing scheme can save space, linear probing
suffers from anadditional disadvantage. Ittends tocluster theitems ofamapinto
contiguousruns,whichmayevenoverlap(particularlyifmorethanhalfofthecells
inthehashtableareoccupied). Suchcontiguous runsofoccupied hashcellscause
searches toslowdownconsiderably.
Anotheropenaddressingstrategy,knownasquadraticprobing,iterativelytries
thebucketsA[(h(k)+f(i)) mod N],fori=0,1,2,...,where f(i)=i2,untilﬁnding
an empty bucket. As with linear probing, the quadratic probing strategy compli-
cates the removal operation, but it does avoid the kinds of clustering patterns that
occurwithlinearprobing. Nevertheless,itcreatesitsownkindofclustering,called
secondary clustering, where the set of ﬁlled array cells still has a non-uniform
pattern, even if we assume that the original hash codes are distributed uniformly.
When N is prime and the bucket array is less than half full, the quadratic probing
strategy is guaranteed to ﬁnd an empty slot. However, this guarantee is not valid
once the table becomes at least half full, or ifN is not chosen as a prime number;
weexplorethecauseofthistypeofclustering inanexercise(C-10.36).
Anopenaddressingstrategythatdoesnotcauseclusteringofthekindproduced
bylinearprobingorthekindproduced byquadratic probingisthedoublehashing
(cid:2)
strategy. Inthis approach, wechoose asecondary hash function, h, and if hmaps
some key k to a bucket A[h(k)] that is already occupied, then we iteratively try
the buckets A[(h(k)+ f(i)) mod N] next, for i=1,2,3,..., where f(i)=i·h(cid:2)(k).
In this scheme, the secondary hash function is not allowed to evaluate to zero; a
common choice ish(cid:2)(k)=q−(k mod q), forsome prime number q<N. Also, N
shouldbeaprime.
Another approach to avoid clustering with open addressing is to iteratively try
buckets A[(h(k)+ f(i)) mod N] where f(i) is based on a pseudo-random number
generator, providing arepeatable, but somewhat arbitrary, sequence of subsequent
probes that depends upon bits of the original hash code. Thisis the approach cur-420 Chapter10. Maps,HashTables,andSkipLists
10.2.3 Load Factors, Rehashing, and Eﬃciency
In the hash table schemes described thus far, it is important that the load factor,
λ=n/N, be kept below 1. With separate chaining, as λ gets very close to 1, the
probability ofacollision greatly increases, whichaddsoverheadtoouroperations,
since we must revert to linear-time list-based methods in buckets that have col-
lisions. Experiments and average-case analyses suggest that we should maintain
λ<0.9forhashtableswithseparate chaining.
Withopenaddressing, ontheotherhand,astheloadfactorλgrowsbeyond0.5
andstartsapproaching1,clustersofentriesinthebucketarraystarttogrowaswell.
Theseclusterscausetheprobingstrategiesto“bouncearound”thebucketarrayfor
aconsiderable amountoftimebeforetheyﬁndanemptyslot. InExerciseC-10.36,
we explore the degradation of quadratic probing whenλ≥0.5. Experiments sug-
gest that we should maintain λ< 0.5 for an open addressing scheme with linear
probing, and perhaps only a bit higher for other open addressing schemes (for ex-
ample,Python’simplementation ofopenaddressing enforcesthatλ<2/3).
If an insertion causes the load factor of a hash table to go above the speciﬁed
threshold, thenitiscommontoresizethetable(toregainthespeciﬁedloadfactor)
and to reinsert all objects into this new table. Although we need not deﬁne a new
hash code for each object, wedo need toreapply anew compression function that
takes into consideration the size of the new table. Each rehashing will generally
scattertheitemsthroughoutthenewbucketarray. Whenrehashingtoanewtable,it
isagoodrequirementforthenewarray’ssizetobeatleastdoubletheprevioussize.
Indeed,ifwealwaysdoublethesizeofthetablewitheachrehashingoperation,then
we can amortize the cost of rehashing all the entries in the table against the time
usedtoinsertthemintheﬁrstplace(aswithdynamicarrays;seeSection5.3).
Eﬃciency of Hash Tables
Although the details of the average-case analysis of hashing are beyond the scope
of this book, its probabilistic basis is quite intuitive. Ifour hash function is good,
then we expect the entries to be uniformly distributed in theN cells of the bucket
array. Thus, to store n entries, the expected number of keys in a bucket would
be(cid:13)n/N(cid:14),whichisO(1)ifnisO(N).
Thecostsassociatedwithaperiodicrehashing,toresizeatableafteroccasional
insertions or deletions can be accounted for separately, leading to an additional
O(1)amortized costfor setitem and getitem .
Intheworstcase,apoorhashfunctioncouldmapeveryitemtothesamebucket.
Thiswouldresultinlinear-timeperformanceforthecoremapoperationswithsepa-
ratechaining, orwithanyopenaddressing modelinwhichthesecondary sequence
of probes depends only on the hash code. A summary of these costs is given in10.2. HashTables 421
Operation List HashTable
expected worstcase
getitem O(n) O(1) O(n)
setitem O(n) O(1) O(n)
delitem O(n) O(1) O(n)
len O(1) O(1) O(1)
iter O(n) O(n) O(n)
Table10.2: Comparison of the running times of the methods of a map realized by
means of an unsorted list (as in Section 10.1.5) or a hash table. We let n denote
the number of items in the map, and we assume that the bucket array supporting
the hash table ismaintained such that itscapacity isproportional tothe number of
itemsinthemap.
In practice, hash tables are among the most efﬁcient means for implementing
a map, and it is essentially taken for granted by programmersthat their core oper-
ations run in constant time. Python’s dict class is implemented with hashing, and
the Python interpreter relies on dictionaries to retrieve an object that is referenced
byanidentiﬁerinagivennamespace. (SeeSections1.10and2.5.) Thebasiccom-
mand c = a + b involves two calls to getitem in the dictionary for the local
namespace to retrieve the values identiﬁed as a and b, and a call to setitem
tostoretheresultassociated withnamecinthatnamespace. Inourownalgorithm
analysis, we simply presume that such dictionary operations run in constant time,
independent of the number of entries in the namespace. (Admittedly, the number
ofentries inatypicalnamespace canalmostsurelybebounded byaconstant.)
Ina2003academicpaper[31],researchersdiscussthepossibilityofexploiting
a hash table’s worst-case performance to cause a denial-of-service (DoS) attack
ofInternet technologies. Formanypublished algorithms thatcompute hashcodes,
theynotethatanattackercouldprecomputeaverylargenumberofmoderate-length
strings that all hash to the identical 32-bit hash code. (Recall that by any of the
hashing schemes we describe, other than double hashing, if two keys are mapped
tothesamehashcode,theywillbeinseparable inthecollision resolution.)
In late 2011, another team of researchers demonstrated an implementation of
just such an attack [61]. Web servers allow a series of key-value parameters to be
embeddedinaURLusingasyntaxsuchas?key1=val1&key2=val2&key3=val3.
Typically, those key-value pairs are immediately stored in a map by the server,
and a limit is placed on the length and number of such parameters presuming that
storage time in the map will be linear in the number of entries. If all keys were
to collide, that storage requires quadratic time (causing the server to perform an
inordinate amount of work). In spring of 2012, Python developers distributed a
security patch that introduces randomization into the computation of hash codes422 Chapter10. Maps,HashTables,andSkipLists
10.2.4 Python Hash Table Implementation
In this section, we develop two implementations of a hash table, one using sepa-
ratechainingandtheotherusingopenaddressing withlinearprobing. Whilethese
approaches to collision resolution are quite different, there are a great many com-
monalities to the hashing algorithms. For that reason, we extend the MapBase
class (from Code Fragment 10.2), to deﬁne a new HashMapBase class (see Code
Fragment10.4),providingmuchofthecommonfunctionalitytoourtwohashtable
implementations. ThemaindesignelementsoftheHashMapBaseclassare:
• The bucket array is represented as a Python list, named self. table, with all
entriesinitialized toNone.
• We maintain an instance variable self. n that represents the number of dis-
tinctitemsthatarecurrently storedinthehashtable.
• Iftheloadfactorofthetableincreases beyond0.5,wedoublethesizeofthe
tableandrehashallitemsintothenewtable.
• We deﬁne a hash function utility method that relies on Python’s built-in
hash function to produce hash codes for keys, and a randomized Multiply-
Add-and-Divide (MAD)formulaforthecompression function.
What is not implemented in the base class is any notion of how a “bucket”
shouldberepresented. Withseparate chaining, eachbucketwillbeanindependent
structure. With open addressing, however, there is no tangible container for each
bucket; the“buckets” areeffectivelyinterleaved duetotheprobingsequences.
In our design, the HashMapBase class presumes the following to be abstract
methods, whichmustbeimplementedbyeachconcrete subclass:
• bucket getitem(j, k)
This method should search bucket j for an item having key k, returning the
associated value,iffound, orelseraisingaKeyError.
• bucket setitem(j, k, v)
This method should modify bucket j so that key k becomes associated with
valuev. Ifthekeyalreadyexists,thenewvalueoverwritestheexistingvalue.
Otherwise, a new item is inserted and this method is responsible for incre-
mentingself. n.
• bucket delitem(j, k)
This method should remove the item from bucket j having key k, or raise a
KeyErrorifnosuchitemexists. (self. nisdecremented afterthismethod.)
• iter
This isthe standard map method to iterate through all keys ofthe map. Our
base class does not delegate this on a per-bucket basis because “buckets” in10.2. HashTables 423
1 class HashMapBase(MapBase):
2 ”””Abstract base class for map using hash-table with MAD compression.”””
3
4 def init (self, cap=11, p=109345121):
5 ”””Create an empty hash-table map.”””
6 self. table = cap [ None ]
7 self. n = 0 # number of entries in the map
8 self. prime = p # prime for MAD compression
9 self. scale = 1 + randrange(p−1) # scale from 1 to p-1 for MAD
10 self. shift = randrange(p) # shift from 0 to p-1 for MAD
11
12 def hash function(self, k):
13 return (hash(k) self. scale + self. shift) % self. prime % len(self. table)
14
15 def len (self):
16 return self. n
17
18 def getitem (self, k):
19 j = self. hash function(k)
20 return self. bucket getitem(j, k) # may raise KeyError
21
22 def setitem (self, k, v):
23 j = self. hash function(k)
24 self. bucket setitem(j, k, v) # subroutine maintains self. n
25 if self. n > len(self. table) // 2: # keep load factor <= 0.5
26 self. resize(2 len(self. table) − 1) # number 2ˆx - 1 is often prime
27
28 def delitem (self, k):
29 j = self. hash function(k)
30 self. bucket delitem(j, k) # may raise KeyError
31 self. n −= 1
32
33 def resize(self, c): # resize bucket array to capacity c
34 old = list(self.items()) # use iteration to record existing items
35 self. table = c [None] # then reset table to desired capacity
36 self. n = 0 # n recomputed during subsequent adds
37 for (k,v) in old:
38 self[k] = v # reinsert old key-value pair
Code Fragment 10.4: A base class for our hash table implementations, extending424 Chapter10. Maps,HashTables,andSkipLists
Separate Chaining
CodeFragment10.5providesaconcreteimplementationofahashtablewithsepa-
ratechaining,intheformoftheChainHashMapclass. Torepresentasinglebucket,
itreliesonaninstance oftheUnsortedTableMapclassfromCodeFragment10.3.
Theﬁrstthreemethodsintheclassuseindex jtoaccessthepotentialbucketin
thebucketarray,andacheckforthespecialcaseinwhichthattableentryisNone.
Theonlytimeweneedanewbucketstructureiswhen bucket setitemiscalledon
anotherwise empty slot. Theremaining functionality reliesonmapbehaviors that
are already supported by the individual UnsortedTableMap instances. We need a
bitofforethoughttodeterminewhethertheapplicationof setitem onthechain
causesanetincreaseinthesizeofthemap(thatis,whetherthegivenkeyisnew).
1 class ChainHashMap(HashMapBase):
2 ”””Hash map implemented with separate chaining for collision resolution.”””
3
4 def bucket getitem(self, j, k):
5 bucket = self. table[j]
6 if bucket is None:
7 raise KeyError( Key Error: + repr(k)) # no match found
8 return bucket[k] # may raise KeyError
9
10 def bucket setitem(self, j, k, v):
11 if self. table[j] is None:
12 self. table[j] = UnsortedTableMap( ) # bucket is new to the table
13 oldsize = len(self. table[j])
14 self. table[j][k] = v
15 if len(self. table[j]) > oldsize: # key was new to the table
16 self. n += 1 # increase overall map size
17
18 def bucket delitem(self, j, k):
19 bucket = self. table[j]
20 if bucket is None:
21 raise KeyError( Key Error: + repr(k)) # no match found
22 del bucket[k] # may raise KeyError
23
24 def iter (self):
25 for bucket in self. table:
26 if bucket is not None: # a nonempty slot
27 for key in bucket:
28 yield key10.2. HashTables 425
Linear Probing
Our implementation of aProbeHashMapclass, using open addressing with linear
probing, is given in Code Fragments 10.6 and 10.7. In order tosupport deletions,
weuseatechnique described inSection10.2.2inwhichweplaceaspecialmarker
in a table location at which an item has been deleted, so that we can distinguish
between it and a location that has always been empty. In our implementation, we
declare a class-level attribute, AVAIL, as a sentinel. (We use an instance of the
built-in object class because we do not care about any behaviors of the sentinel,
justourabilitytodifferentiate itfromotherobjects.)
The most challenging aspect of open addressing is to properly trace the series
of probes when collisions occur during an insertion or search for an item. To this
end, we deﬁne a nonpublic utility, ﬁnd slot, that searches for an item with keyk
in“bucket” j(thatis,where jistheindexreturnedbythehashfunction forkeyk).
1 class ProbeHashMap(HashMapBase):
2 ”””Hash map implemented with linear probing for collision resolution.”””
3 AVAIL = object( ) # sentinal marks locations of previous deletions
4
5 def is available(self, j):
6 ”””Return True if index j is available in table.”””
7 return self. table[j] is None or self. table[j] is ProbeHashMap. AVAIL
8
9 def ﬁnd slot(self, j, k):
10 ”””Search for key k in bucket at index j.
11
12 Return (success, index) tuple, described as follows:
13 If match was found, success is True and index denotes its location.
14 If no match found, success is False and index denotes ﬁrst available slot.
15 ”””
16 ﬁrstAvail = None
17 while True:
18 if self. is available(j):
19 if ﬁrstAvail is None:
20 ﬁrstAvail = j # mark this as ﬁrst avail
21 if self. table[j] is None:
22 return (False, ﬁrstAvail) # search has failed
23 elif k == self. table[j]. key:
24 return (True, j) # found a match
25 j = (j + 1) % len(self. table) # keep looking (cyclically)
Code Fragment 10.6: Concrete ProbeHashMap class that uses linear probing for426 Chapter10. Maps,HashTables,andSkipLists
26 def bucket getitem(self, j, k):
27 found, s = self. ﬁnd slot(j, k)
28 if not found:
29 raise KeyError( Key Error: + repr(k)) # no match found
30 return self. table[s]. value
31
32 def bucket setitem(self, j, k, v):
33 found, s = self. ﬁnd slot(j, k)
34 if not found:
35 self. table[s] = self. Item(k,v) # insert new item
36 self. n += 1 # size has increased
37 else:
38 self. table[s]. value = v # overwrite existing
39
40 def bucket delitem(self, j, k):
41 found, s = self. ﬁnd slot(j, k)
42 if not found:
43 raise KeyError( Key Error: + repr(k)) # no match found
44 self. table[s] = ProbeHashMap. AVAIL # mark as vacated
45
46 def iter (self):
47 for j in range(len(self. table)): # scan entire table
48 if not self. is available(j):
49 yield self. table[j]. key
Code Fragment 10.7: Concrete ProbeHashMap class that uses linear probing for
collision resolution (continued fromCodeFragment10.6).
Thethreeprimary mapoperations each relyonthe ﬁnd slotutility. Whenat-
temptingtoretrievethevalueassociatedwithagivenkey,wemustcontinueprobing
untilweﬁndthekey,oruntilwereachatableslotwiththeNonevalue. Wecannot
stop the search upon reaching an AVAILsentinel, because itrepresents alocation
thatmayhavebeenﬁlledwhenthedesireditemwasonceinserted.
When a key-value pair is being assigned in the map, we must attempt to ﬁnd
an existing item with the given key, so that we might overwrite its value, before
adding anewitemtothemap. Therefore, wemustsearch beyondanyoccurrences
ofthe AVAILsentinelwheninserting. However,ifnomatchisfound,wepreferto
repurpose theﬁrstslotmarkedwith AVAIL,ifany,whenplacing thenewelement
in the table. The ﬁnd slot method enacts this logic, continuing the search until a
trulyemptyslot,butreturning theindexoftheﬁrstavailable slotforaninsertion.
When deleting an existing item within bucket delitem, we intentionally set10.3. SortedMaps 427
10.3 Sorted Maps
ThetraditionalmapADTallowsausertolookupthevalueassociatedwithagiven
key,butthesearchforthatkeyisaformknownasanexactsearch.
For example, computer systems often maintain information about events that
have occurred (such as ﬁnancial transactions), organizing such events based upon
what are known as time stamps. If we can assume that time stamps are unique
for a particular system, then we might organize a map with a time stamp serving
as the key, and a record about the event that occurred at that time as the value. A
particular timestamp could serve asareference ID foranevent, inwhich case we
canquickly retrieve information aboutthateventfromthemap. However,themap
ADT does not provide any way to get a list of all events ordered by the time at
whichtheyoccur,ortosearchforwhicheventoccurredclosesttoaparticulartime.
Infact,thefastperformanceofhash-basedimplementationsofthemapADTrelies
on the intentionally scattering of keys that may seem very “near” to each other in
theoriginaldomain, sothattheyaremoreuniformly distributed inahashtable.
In this section, we introduce an extension known as thesorted map ADT that
includes allbehaviors ofthestandard map,plusthefollowing:
M.ﬁnd min(): Returnthe(key,value) pairwithminimumkey
(orNone,ifmapisempty).
M.ﬁnd max(): Returnthe(key,value) pairwithmaximumkey
(orNone,ifmapisempty).
M.ﬁnd lt(k): Return the (key,value) pair with the greatest key that
isstrictlylessthank(orNone,ifnosuchitemexists).
M.ﬁnd le(k): Return the (key,value) pair with the greatest key that
is less than or equal to k (or None, if no such item
exists).
M.ﬁnd gt(k): Return the (key,value) pair with the least key that is
strictlygreaterthank(orNone,ifnosuchitemexists).
M.ﬁnd ge(k): Return the (key,value) pair with the least key that is
greater thanorequaltok(orNone,ifnosuchitem).
M.ﬁnd range(start, stop): Iterateall(key,value)pairswithstart <= key < stop.
IfstartisNone,iterationbeginswithminimumkey;if
stopisNone,iteration concludes withmaximumkey.
iter(M): Iterate all keys of the map according to their natural
order, fromsmallesttolargest.
reversed(M): Iterateallkeysofthemapinreverseorder;inPython,428 Chapter10. Maps,HashTables,andSkipLists
10.3.1 Sorted Search Tables
Several data structures can efﬁciently support the sorted map ADT, and we will
examinesomeadvancedtechniquesinSection10.4andChapter11. Inthissection,
we begin by exploring a simple implementation of a sorted map. We store the
map’s items in an array-based sequence A so that they are in increasing order of
theirkeys,assumingthekeyshaveanaturallydeﬁnedorder. (SeeFigure10.8.) We
refertothisimplementation ofamapasasortedsearchtable.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
2 4 5 7 8 9 12 14 17 19 22 25 27 28 33 37
Figure10.8: Realizationofamapbymeansofasortedsearchtable. Weshowonly
thekeysforthismap,soastohighlight theirordering.
AswasthecasewiththeunsortedtablemapofSection10.1.5,thesortedsearch
tablehasaspacerequirement thatisO(n),assuming wegrowandshrink thearray
tokeepitssizeproportionaltothenumberofitemsinthemap. Theprimaryadvan-
tageofthisrepresentation, andourreasonforinsistingthatAbearray-based,isthat
itallowsustousethebinarysearchalgorithm foravarietyofefﬁcientoperations.
Binary Search and Inexact Searches
WeoriginallypresentedthebinarysearchalgorithminSection4.1.3,asameansfor
detecting whether agiventarget isstored withinasorted sequence. Inouroriginal
presentation (Code Fragment 4.3 on page 156), abinary search function returned
True of False to designate whether the desired target was found. While such an
approach could be used to implement the contains method of the map ADT,
we can adapt the binary search algorithm to provide far more useful information
whenperformingformsofinexactsearchinsupportofthesortedmapADT.
Theimportant realization isthat while performing abinarysearch, wecan de-
termine the index at or near where a target might be found. During a successful
search, thestandard implementation determines theprecise index atwhich thetar-
get is found. During an unsuccessful search, although the target is not found, the
algorithm will effectively determine a pair of indices designating elements of the
collection thatarejustlessthanorjustgreaterthanthemissingtarget.
Asamotivating example, ouroriginal simulation fromFigure4.5onpage 156
showsasuccessful binarysearchforatargetof22,usingthesamedataweportray
in Figure 10.8. Had we instead been searching for 21, the ﬁrst four steps of the
algorithmwouldbethesame. Thesubsequent differenceisthatwewouldmakean
additional call with inverted parametershigh=9 and low=10, effectively conclud-10.3. SortedMaps 429
Implementation
InCodeFragments10.8through10.10,wepresentacompleteimplementationofa
class, SortedTableMap, that supports the sorted map ADT. The most notable fea-
ture of our design is the inclusion of a ﬁnd index utility function. This method
using the binary search algorithm, but by convention returns the index of the left-
mostiteminthesearchintervalhavingkeygreaterthanorequaltok. Therefore,if
the key is present, it will return the index of the item havingthat key. (Recall that
keysareuniqueinamap.) Whenthekeyismissing, thefunction returns theindex
oftheiteminthesearchintervalthatisjustbeyondwherethekeywouldhavebeen
located. As a technicality, the method returns index high+1 to indicate that no
itemsoftheintervalhadakeygreaterthank.
We rely on this utility method when implementing the traditional map opera-
tions and the new sorted map operations. The body of each of the getitem ,
setitem ,and delitem methodsbegins withacallto ﬁnd indextodeter-
mineacandidateindexatwhichamatchingkeymightbefound. For getitem ,
wesimplycheckwhetherthatisavalidindexcontainingthetargettodeterminethe
result. For setitem , recall that the goal is to replace the value of an existing
item,ifonewithkeykisfound,butotherwisetoinsertanewitemintothemap. The
index returned by ﬁnd indexwillbe the index of the match, if one exists, or oth-
erwisetheexactindexatwhichthenewitemshouldbeinserted. For delitem ,
we again rely on the convenience of ﬁnd index to determine the location of the
itemtobepopped, ifany.
Our ﬁnd index utility is equally valuable when implementing the various in-
exact search methods given in Code Fragment 10.10. For each of the methods
ﬁnd lt, ﬁnd le, ﬁnd gt, and ﬁnd ge, we begin with a call to ﬁnd index utility,
whichlocatestheﬁrstindexatwhichthereisanelementwithkey≥k,ifany. This
is precisely whatwewant forﬁnd ge, if valid, and just beyond the index wewant
forﬁnd lt. Forﬁnd gtandﬁnd leweneedsomeextracaseanalysis todistinguish
whether the indicated index has a key equal to k. For example, if the indicated
item has a matching key, our ﬁnd gt implementation increments the index before
continuing with the process. (We omit the implementation ofﬁnd le, for brevity.)
Inallcases,wemustproperlyhandleboundarycases,reportingNonewhenunable
toﬁndakeywiththedesiredproperty.
Our strategy for implementing ﬁnd range is to use the ﬁnd index utility to
locatetheﬁrstitemwithkey≥start(assumingstartisnotNone). Withthatknowl-
edge, we use a while loop to sequentially report items until reaching one that has
a key greater than or equal to the stopping value (or until reaching the end of the
table). It is worth noting that the while loop may trivially iterate zero items if the
ﬁrstkeythatisgreaterthanorequaltostartalsohappenstobegreaterthanorequal430 Chapter10. Maps,HashTables,andSkipLists
1 class SortedTableMap(MapBase):
2 ”””Map implementation using a sorted table.”””
3
4 #----------------------------- nonpublic behaviors -----------------------------
5 def ﬁnd index(self, k, low, high):
6 ”””Return index of the leftmost item with key greater than or equal to k.
7
8 Return high + 1 if no such item qualiﬁes.
9
10 That is, j will be returned such that:
11 all items of slice table[low:j] have key < k
12 all items of slice table[j:high+1] have key >= k
13 ”””
14 if high < low:
15 return high + 1 # no element qualiﬁes
16 else:
17 mid = (low + high) // 2
18 if k == self. table[mid]. key:
19 return mid # found exact match
20 elif k < self. table[mid]. key:
21 return self. ﬁnd index(k, low, mid − 1) # Note: may return mid
22 else:
23 return self. ﬁnd index(k, mid + 1, high) # answer is right of mid
24
25 #----------------------------- public behaviors -----------------------------
26 def init (self):
27 ”””Create an empty map.”””
28 self. table = [ ]
29
30 def len (self):
31 ”””Return number of items in the map.”””
32 return len(self. table)
33
34 def getitem (self, k):
35 ”””Return value associated with key k (raise KeyError if not found).”””
36 j = self. ﬁnd index(k, 0, len(self. table) − 1)
37 if j == len(self. table) or self. table[j]. key != k:
38 raise KeyError( Key Error: + repr(k))
39 return self. table[j]. value
CodeFragment10.8: Animplementation ofaSortedTableMapclass(continued in10.3. SortedMaps 431
40 def setitem (self, k, v):
41 ”””Assign value v to key k, overwriting existing value if present.”””
42 j = self. ﬁnd index(k, 0, len(self. table) − 1)
43 if j < len(self. table) and self. table[j]. key == k:
44 self. table[j]. value = v # reassign value
45 else:
46 self. table.insert(j, self. Item(k,v)) # adds new item
47
48 def delitem (self, k):
49 ”””Remove item associated with key k (raise KeyError if not found).”””
50 j = self. ﬁnd index(k, 0, len(self. table) − 1)
51 if j == len(self. table) or self. table[j]. key != k:
52 raise KeyError( Key Error: + repr(k))
53 self. table.pop(j) # delete item
54
55 def iter (self):
56 ”””Generate keys of the map ordered from minimum to maximum.”””
57 for item in self. table:
58 yield item. key
59
60 def reversed (self):
61 ”””Generate keys of the map ordered from maximum to minimum.”””
62 for item in reversed(self. table):
63 yield item. key
64
65 def ﬁnd min(self):
66 ”””Return (key,value) pair with minimum key (or None if empty).”””
67 if len(self. table) > 0:
68 return (self. table[0]. key, self. table[0]. value)
69 else:
70 return None
71
72 def ﬁnd max(self):
73 ”””Return (key,value) pair with maximum key (or None if empty).”””
74 if len(self. table) > 0:
75 return (self. table[−1]. key, self. table[−1]. value)
76 else:
77 return None
CodeFragment10.9:AnimplementationofaSortedTableMapclass(togetherwith432 Chapter10. Maps,HashTables,andSkipLists
78 def ﬁnd ge(self, k):
79 ”””Return (key,value) pair with least key greater than or equal to k.”””
80 j = self. ﬁnd index(k, 0, len(self. table) − 1) # j s key >= k
81 if j < len(self. table):
82 return (self. table[j]. key, self. table[j]. value)
83 else:
84 return None
85
86 def ﬁnd lt(self, k):
87 ”””Return (key,value) pair with greatest key strictly less than k.”””
88 j = self. ﬁnd index(k, 0, len(self. table) − 1) # j s key >= k
89 if j > 0:
90 return (self. table[j−1]. key, self. table[j−1]. value) # Note use of j-1
91 else:
92 return None
93
94 def ﬁnd gt(self, k):
95 ”””Return (key,value) pair with least key strictly greater than k.”””
96 j = self. ﬁnd index(k, 0, len(self. table) − 1) # j s key >= k
97 if j < len(self. table) and self. table[j]. key == k:
98 j += 1 # advanced past match
99 if j < len(self. table):
100 return (self. table[j]. key, self. table[j]. value)
101 else:
102 return None
103
104 def ﬁnd range(self, start, stop):
105 ”””Iterate all (key,value) pairs such that start <= key < stop.
106
107 If start is None, iteration begins with minimum key of map.
108 If stop is None, iteration continues through the maximum key of map.
109 ”””
110 if start is None:
111 j = 0
112 else:
113 j = self. ﬁnd index(start, 0, len(self. table)−1) # ﬁnd ﬁrst result
114 while j < len(self. table) and (stop is None or self. table[j]. key < stop):
115 yield (self. table[j]. key, self. table[j]. value)
116 j += 1
Code Fragment10.10: An implementation of a SortedTableMap class (continued10.3. SortedMaps 433
Analysis
We conclude by analyzing the performance of our SortedTableMap implementa-
tion. A summary of the running times for all methods of the sorted map ADT
(including thetraditional mapoperations) isgiveninTable10.3. Itshould beclear
that the len , ﬁnd min, and ﬁnd maxmethods run inO(1) time, and that iter-
atingthekeysofthetableineitherdirection canbepeformedinO(n)time.
Theanalysisforthevariousformsofsearchalldependonthefactthatabinary
search on a table with n entries runs in O(logn) time. This claim was originally
shown as Proposition 4.2 in Section 4.2, and that analysis clearly applies to our
ﬁnd index method as well. We therefore claim an O(logn) worst-case running
timeformethods getitem ,ﬁnd lt,ﬁnd gt,ﬁnd le,andﬁnd ge. Eachofthese
makes a single call to ﬁnd index, followed by a constant number of additional
steps to determine the appropriate answer based on the index. The analysis of
ﬁnd range is a bit more interesting. It begins with a binary search to ﬁnd the ﬁrst
itemwithintherange(ifany). Afterthat,itexecutesaloopthattakesO(1)timeper
iterationtoreportsubsequentvaluesuntilreachingtheendoftherange. Ifthereare
sitemsreportedintherange,thetotalrunning timeisO(s+logn).
Incontrasttotheefﬁcientsearchoperations,updateoperationsforasortedtable
maytakeconsiderable time. Although binary search can helpidentify the indexat
whichanupdateoccurs,bothinsertionsanddeletionsrequire,intheworstcase,that
linearly many existing elements beshifted in order to maintain the sorted order of
the table. Speciﬁcally, the potential call to table.insert from within setitem
and table.pop from within delitem lead to O(n) worst-case time. (See the
discussion ofcorresponding operations ofthelistclassinSection5.4.1.)
In conclusion, sorted tables are primarily used in situations where we expect
manysearches butrelatively fewupdates.
Operation RunningTime
len(M) O(1)
k in M O(logn)
M[k] = v O(n)worstcase;O(logn)ifexistingk
del M[k] O(n)worstcase
M.ﬁnd min(),M.ﬁnd max() O(1)
M.ﬁnd lt(k),M.ﬁnd gt(k)
O(logn)
M.ﬁnd le(k),M.ﬁnd ge(k)
M.ﬁnd range(start, stop) O(s+logn)wheresitemsarereported
iter(M),reversed(M) O(n)
Table 10.3: Performance of a sorted map, as implemented with SortedTableMap.
We use n to denote the number of items in the map at the time the operation is434 Chapter10. Maps,HashTables,andSkipLists
10.3.2 Two Applications of Sorted Maps
In this section, we explore applications in which there is particular advantage to
using a sorted map rather than a traditional (unsorted) map. To apply a sorted
map, keys must come from a domain that is totally ordered. Furthermore, to take
advantage of the inexact or range searches afforded by a sorted map, there should
besomereasonwhynearbykeyshaverelevance toasearch.
Flight Databases
There are several Web sites on the Internet that allow users to perform queries on
ﬂight databases to ﬁnd ﬂights between various cities, typically with the intent to
buyaticket. Tomakeaquery,auserspeciﬁesoriginanddestinationcities,adepar-
ture date, and a departure time. To support such queries, we can model the ﬂight
database asamap, where keys areFlightobjects that contain ﬁelds corresponding
tothesefourparameters. Thatis,akeyisatuple
k=(origin,destination,date,time).
Additionalinformationaboutaﬂight,suchastheﬂightnumber,thenumberofseats
still available in ﬁrst (F) and coach (Y)class, the ﬂight duration, and the fare, can
bestoredinthevalueobject.
Finding a requested ﬂight is not simply a matter of ﬁnding an exact match
for a requested query. Although a user typically wants to exactly match the ori-
gin and destination cities, he or she may have ﬂexibility for the departure date,
and certainly will have some ﬂexibility for the departure time on a speciﬁc day.
We can handle such a query by ordering our keys lexicographically. Then, an ef-
ﬁcient implementation for a sorted map would be a good way to satisfy users’
queries. Forinstance, given auser query keyk, wecould call ﬁnd ge(k) to return
the ﬁrst ﬂight between the desired cities, having a departure date and time match-
ing the desired query or later. Better yet, with well-constructed keys, we could
use ﬁnd range(k1, k2)to ﬁndall ﬂights within agiven range oftimes. Forexam-
ple, if k1=(ORD, PVD, 05May, 09:30), and k2=(ORD, PVD, 05May, 20:00),
a respective call to ﬁnd range(k1, k2) might result in the following sequence of
key-value pairs:
(ORD, PVD, 05May, 09:53) : (AA 1840, F5, Y15, 02:05, 251),
(ORD, PVD, 05May, 13:29) : (AA 600, F2, Y0, 02:16, 713),
(ORD, PVD, 05May, 17:39) : (AA 416, F3, Y9, 02:09, 365),10.3. SortedMaps 435
Maxima Sets
Lifeisfulloftrade-offs. Weoftenhavetotradeoffadesiredperformancemeasure
againstacorrespondingcost. Suppose,forthesakeofanexample,weareinterested
in maintaining a database rating automobiles by their maximum speeds and their
cost. Wewouldliketoallowsomeonewithacertainamountofmoneytoqueryour
database toﬁndthefastestcartheycanpossibly afford.
We can model such a trade-off problem as this by using a key-value pair to
model the two parameters that we are trading off, which in this case would be the
pair (cost,speed) for each car. Notice that some cars are strictly better than other
cars using this measure. For example, a car with cost-speed pair (20000,100) is
strictly better than a car with cost-speed pair(30000,90). At the same time, there
aresomecarsthatarenotstrictlydominatedbyanothercar.Forexample,acarwith
cost-speedpair(20000,100)maybebetterorworsethanacarwithcost-speedpair
(30000,120), dependingonhowmuchmoneywehavetospend. (SeeFigure10.9.)
h
g
e
c f
n p
a
m e
r
o d
f c
r
e b
P
a
Cost
Figure 10.9: Illustrating the cost-performance trade-off with pairs represented by
points intheplane. Noticethat point pisstrictly better than pointsc,d,ande, but
maybebetterorworsethanpointsa,b, f,g,andh,depending onthepriceweare
willingtopay. Thus, ifweweretoadd ptoourset, wecould removethepointsc,
d,ande,butnottheothers.
Formally, we say a cost-performance pair(a,b) dominates pair (c,d)(cid:15)=(a,b)
if a≤c and b≥d, that is, if the ﬁrst pair has no greater cost and at least as good
performance. Apair (a,b) is called a maximum pair if it is not dominated by any
other pair. We are interested in maintaining the set of maxima of a collection of
cost-performance pairs. That is, we would like to add new pairs to this collection
(forexample,whenanewcarisintroduced),andtoquerythiscollectionforagiven436 Chapter10. Maps,HashTables,andSkipLists
Maintaining a Maxima Set with a Sorted Map
We can store the set of maxima pairs in a sorted map, M, so that the cost is the
keyﬁeldandperformance(speed)isthevalueﬁeld. Wecanthenimplementopera-
tionsadd(c,p),whichaddsanewcost-performance pair(c,p),andbest(c),which
returnsthebestpairwithcostatmostc,asshowninCodeFragment10.11.
1 class CostPerformanceDatabase:
2 ”””Maintain a database of maximal (cost,performance) pairs.”””
3
4 def init (self):
5 ”””Create an empty database.”””
6 self. M = SortedTableMap( ) # or a more eﬃcient sorted map
7
8 def best(self, c):
9 ”””Return (cost,performance) pair with largest cost not exceeding c.
10
11 Return None if there is no such pair.
12 ”””
13 return self. M.ﬁnd le(c)
14
15 def add(self, c, p):
16 ”””Add new entry with cost c and performance p.”””
17 # determine if (c,p) is dominated by an existing pair
18 other = self. M.ﬁnd le(c) # other is at least as cheap as c
19 if other is not None and other[1] >= p: # if its performance is as good,
20 return # (c,p) is dominated, so ignore
21 self. M[c] = p # else, add (c,p) to database
22 # and now remove any pairs that are dominated by (c,p)
23 other = self. M.ﬁnd gt(c) # other more expensive than c
24 while other is not None and other[1] <= p:
25 del self. M[other[0]]
26 other = self. M.ﬁnd gt(c)
CodeFragment10.11: An implementation of a class maintaining a set of maxima
cost-performance pairsusingasortedmap.
Unfortunately,ifweimplementMusingtheSortedTableMap,theaddbehavior
has O(n) worst-case running time. If, on the other hand, we implement M using
a skip list, which we next describe, we can perform best(c) queries in O(logn)
expected time and add(c,p) updates in O((1+r)logn) expected time, where r is10.4. SkipLists 437
10.4 Skip Lists
An interesting data structure for realizing the sorted map ADT is the skip list. In
Section10.3.1,wesawthatasortedarraywillallowO(logn)-timesearchesviathe
binary search algorithm. Unfortunately, update operations on a sorted array have
O(n) worst-case running time because of the need to shift elements. In Chapter 7
we demonstrated that linked lists support very efﬁcient update operations, as long
as the position within the list is identiﬁed. Unfortunately, we cannot perform fast
searchesonastandardlinkedlist;forexample,thebinarysearchalgorithmrequires
anefﬁcientmeansfordirectaccessing anelementofasequence byindex.
Skiplistsprovideaclevercompromisetoefﬁcientlysupportsearchandupdate
operations. A skip list S for a map M consists of a series of lists {S ,S ,...,S }.
0 1 h
Each list S stores a subset ofthe items ofM sorted by increasing keys, plus items
i
with two sentinel keys denoted −∞ and +∞, where −∞ is smaller than every
possible key that can be inserted in M and +∞ is larger than every possible key
thatcanbeinsertedinM. Inaddition, thelistsinSsatisfythefollowing:
• ListS contains everyitemofthemapM (plussentinels−∞and+∞).
0
• Fori=1,...,h−1,listS contains(inadditionto−∞and+∞)arandomly
i
generated subsetoftheitemsinlistSi−1.
• ListS contains only−∞and+∞.
h
An example of a skip list is shown in Figure 10.10. It is customary to visualize a
skiplistSwithlistS atthebottomandlistsS ,...,S aboveit. Also,werefertoh
0 1 h
astheheightofskiplistS.
Intuitively, thelistsaresetupsothatSi+1 contains moreorlessalternate items
of Si. As we shall see in the details of the insertion method, the items in Si+1 are
chosen at random from the items in S by picking each item from S to also be in
i i
Si+1 with probability 1/2. That is, in essence, we “ﬂip a coin” for each item inSi
S5 -∞ +∞
S4 -∞ 17 +∞
S3 -∞ 17 25 55 +∞
S2 -∞ 17 25 31 55 +∞
S1 -∞ 12 17 25 31 38 44 55 +∞
S0 -∞ 12 17 20 25 31 38 39 44 50 55 +∞
Figure10.10: Exampleofaskipliststoring10items. Forsimplicity, weshowonly438 Chapter10. Maps,HashTables,andSkipLists
andplacethatiteminSi+1ifthecoincomesup“heads.” Thus,weexpectS1tohave
about n/2items,S tohaveabout n/4items,and, ingeneral,S tohaveabout n/2i
2 i
items. Inotherwords,weexpecttheheighthofStobeaboutlogn. Thehalvingof
thenumberofitemsfromonelisttothenextisnotenforcedasanexplicitproperty
ofskiplists,however. Instead, randomization isused.
Functions that generate numbers that can be viewed as random numbers are
built into most modern computers, because they are used extensively in computer
games, cryptography, and computer simulations, Some functions, called pseudo-
randomnumbergenerators,generaterandom-likenumbers,startingwithaninitial
seed. (See discusion of random module in Section 1.11.1.) Other methods use
hardware devices to extract “true” random numbers from nature. In any case, we
will assume that our computer has access to numbers that are sufﬁciently random
forouranalysis.
The main advantage of using randomization in data structure and algorithm
designisthatthestructuresandfunctionsthatresultareusuallysimpleandefﬁcient.
Theskiplisthasthesamelogarithmic timebounds forsearching asisachieved by
the binary search algorithm, yet it extends that performance to update methods
when inserting or deleting items. Nevertheless, the bounds are expected for the
skiplist,whilebinarysearchhasaworst-caseboundwithasortedtable.
A skip list makes random choices in arranging its structure in such a way that
search and update times are O(logn) on average, where n is the number of items
inthemap. Interestingly, thenotionofaveragetimecomplexityusedheredoesnot
depend on the probability distribution of the keys in the input. Instead, it depends
on the use of a random-number generator in the implementation of the insertions
to help decide where toplace the new item. Therunning time isaveraged over all
possible outcomesoftherandom numbersusedwheninsertingentries.
Using the position abstraction used for lists and trees, we view a skip list as a
two-dimensional collection of positions arranged horizontally into levels and ver-
tically intotowers. EachlevelisalistS and each towercontains positions storing
i
thesameitemacross consecutive lists. Thepositions inaskiplistcanbetraversed
usingthefollowingoperations:
next(p): Returntheposition followingponthesamelevel.
prev(p): Returntheposition precedingponthesamelevel.
below(p): Returntheposition belowpinthesametower.
above(p): Returntheposition abovepinthesametower.
We conventionally assume that the above operations return None if the position
requested does not exist. Without going into the details, wenote that we can eas-
ily implement a skip list by means of a linked structure such that the individual
traversal methods each take O(1) time, given a skip-list position p. Such a linked
structureisessentiallyacollectionofhdoublylinkedlistsalignedattowers,which10.4. SkipLists 439
10.4.1 Search and Update Operations in a Skip List
The skip-list structure affords simple map search and update algorithms. In fact,
alloftheskip-listsearchandupdatealgorithmsarebasedonanelegantSkipSearch
methodthattakes akeyk andﬁndstheposition poftheiteminlistS thathasthe
0
largestkeylessthanorequaltok(whichispossibly−∞).
Searching in a Skip List
Suppose weare given a search keyk. Webegin the SkipSearchmethod by setting
a position variable p to the topmost, left position in the skip listS, called the start
position of S. That is, the start position is the position of S storing the special
h
entrywithkey−∞. Wethenperformthefollowingsteps(seeFigure10.11),where
key(p)denotesthekeyoftheitematposition p:
1. IfS.below(p)isNone,thenthesearchterminates—weareatthebottomand
havelocatedtheiteminSwiththelargestkeylessthanorequaltothesearch
keyk. Otherwise, wedrop downtothenextlowerlevelinthepresent tower
bysetting p=S.below(p).
2. Startingatposition p,wemove pforwarduntilitisattherightmostposition
onthepresentlevelsuchthatkey(p)≤k. Wecallthisthescanforwardstep.
Note that such a position always exists, since each level contains the keys
+∞ and −∞. It may be that p remains where it started after we perform
suchaforwardscanforthislevel.
3. Returntostep1.
S5 -∞ +∞
S4 -∞ 17 +∞
S3 -∞ 17 25 55 +∞
S2 -∞ 17 25 31 55 +∞
S1 -∞ 12 17 25 31 38 44 55 +∞
S0 -∞ 12 17 20 25 31 38 39 44 50 55 +∞
Figure 10.11: Example of a search in a skip list. The positions examined when
searching forkey50arehighlighted.
Wegiveapseudo-codedescriptionoftheskip-listsearchalgorithm,SkipSearch,
inCodeFragment 10.12. Giventhismethod, themapoperationM[k]isperformed
by computing p=SkipSearch(k) and testing whether or not key(p)=k. If these440 Chapter10. Maps,HashTables,andSkipLists
AlgorithmSkipSearch(k):
Input: Asearchkeyk
Output: PositionpinthebottomlistS withthelargestkeysuchthatkey(p)≤k
0
p = start {beginatstartposition}
while below(p)(cid:15)=None do
p = below(p) {dropdown}
whilek≥key(next(p))do
p = next(p) {scanforward}
returnp.
CodeFragment10.12: AlgorthmtosearchaskiplistSforkeyk.
Asitturnsout,theexpectedrunningtimeofalgorithmSkipSearchonaskiplist
withnentries isO(logn). Wepostpone thejustiﬁcation ofthisfact,however, until
afterwediscusstheimplementationoftheupdatemethodsforskiplists. Navigation
startingatthepositionidentiﬁedbySkipSearch(k)canbeeasilyusedtoprovidethe
additional formsofsearchesinthesortedmapADT(e.g.,ﬁnd gt,ﬁnd range).
Insertion in a Skip List
Theexecution ofthemapoperationM[k] = vbegins withacalltoSkipSearch(k).
Thisgivesustheposition pofthebottom-levelitemwiththelargestkeylessthanor
equaltok(notethat pmayholdthespecialitemwithkey−∞). Ifkey(p)=k,the
associatedvalueisoverwrittenwithv. Otherwise,weneedtocreateanewtowerfor
item(k,v). Weinsert (k,v) immediately after position pwithinS . Afterinserting
0
thenew itematthebottom level, weuserandomization todecide the height ofthe
towerforthenewitem. We“ﬂip”acoin,andiftheﬂipcomesuptails,thenwestop
here. Else (the ﬂip comes up heads), we backtrack to the previous (next higher)
levelandinsert(k,v)inthis levelattheappropriate position. Weagainﬂipacoin;
ifitcomes upheads, wego tothe nexthigher level and repeat. Thus, wecontinue
to insert the new item (k,v) in lists until we ﬁnally get a ﬂip that comes up tails.
Welink together all the references to the new item(k,v) created in this process to
createitstower. AcoinﬂipcanbesimulatedwithPython’sbuilt-inpseudo-random
numbergeneratorfromtherandommodulebycallingrandrange(2),whichreturns
0or1,eachwithprobability 1/2.
We give the insertion algorithm for a skip list S in Code Fragment 10.13 and
weillustrateitinFigure10.12. ThealgorithmusesaninsertAfterAbove(p,q,(k,v))
method that inserts a position storing the item (k,v) after position p (on the same
level as p) and above position q, returning the new position r (and setting internal
references sothatnext,prev, above,andbelowmethods willworkcorrectly for p,
q, and r). The expected running time ofthe insertion algorithm on askip list with10.4. SkipLists 441
AlgorithmSkipInsert(k,v):
Input: Keykandvaluev
Output: Topmostposition oftheiteminsertedintheskiplist
p = SkipSearch(k)
q = None {qwillrepresent topnodeinnewitem’stower}
i = −1
repeat
i = i+1
ifi≥h then
h = h+1 {addanewleveltotheskiplist}
t = next(s)
s = insertAfterAbove(None,s,(−∞,None)) {growleftmosttower}
insertAfterAbove(s,t,(+∞,None)) {growrightmosttower}
whileabove(p)isNonedo
p = prev(p) {scanbackward}
p = above(p) {jumpuptohigherlevel}
q = insertAfterAbove(p,q,(k,v)) {increaseheightofnewitem’stower}
untilcoinFlip()==tails
n = n+1
returnq
CodeFragment10.13: Insertioninaskiplist. MethodcoinFlip()returns“heads”or
“tails”, each with probability 1/2. Instance variables n, h, and s hold the number
ofentries, theheight, andthestartnodeoftheskiplist.
S5 -∞ +∞
S4 -∞ 17 +∞
S3 -∞ 17 25 42 55 +∞
S2 -∞ 17 25 31 42 55 +∞
S1 -∞ 12 17 25 31 38 42 44 55 +∞
S0 -∞ 12 17 20 25 31 38 39 42 44 50 55 +∞
Figure10.12:Insertionofanentrywithkey42intotheskiplistofFigure10.10. We
assumethattherandom“coinﬂips”forthenewentrycameupheadsthreetimesina
row,followedbytails. Thepositionsvisitedarehighlighted. Thepositionsinserted
toholdthenewentry aredrawnwiththick lines, and thepositions preceding them442 Chapter10. Maps,HashTables,andSkipLists
Removal in a Skip List
Like the search and insertion algorithms, the removal algorithm for a skip list is
quite simple. In fact, it iseven easier than the insertion algorithm. That is, to per-
form the map operation del M[k] we begin by executing method SkipSearch(k).
If the position p stores an entry with key different from k, we raise a KeyError.
Otherwise, we remove p and all the positions above p, which are easily accessed
by using aboveoperations toclimb up the towerof this entry inS starting atposi-
tion p. While removing levels of the tower, we reestablish links between the hor-
izontal neighbors of each removed position. The removal algorithm is illustrated
inFigure 10.13 and adetailed description ofitis left asanexercise (R-10.24). As
weshow in the next subsection, deletion operation in a skip list withn entries has
O(logn)expectedrunning time.
Before we give this analysis, however, there are some minor improvements to
theskip-list datastructure wewould liketodiscuss. First,wedonotactually need
to store references to values at the levels of the skip list above the bottom level,
because all that is needed at these levels are references to keys. In fact, we can
more efﬁciently represent a tower as a single object, storing the key-value pair,
and maintaining j previous references and j next references if the tower reaches
levelS . Second,forthehorizontalaxes,itispossibletokeepthelistsinglylinked,
j
storingonlythenextreferences. Wecanperforminsertionsandremovalsinstrictly
a top-down, scan-forward fashion. We explore the details of this optimization in
Exercise C-10.44. Neither of these optimizations improve the asymptotic perfor-
mance of skip lists by more than a constant factor, but these improvements can,
nevertheless, be meaningful in practice. In fact, experimental evidence suggests
that optimized skip lists are faster in practice than AVL trees and other balanced
searchtrees,whicharediscussed inChapter11.
S5 -∞ +∞
S4 -∞ 17 +∞
S3 -∞ 17 25 42 55 +∞
S2 -∞ 17 25 31 42 55 +∞
S1 -∞ 12 17 25 31 38 42 44 55 +∞
S0 -∞ 12 17 20 25 31 38 39 42 44 50 55 +∞
Figure10.13: Removalof the entry with key 25 from the skip list ofFigure 10.12.
The positions visited after the search for the position of S holding the entry are
010.4. SkipLists 443
Maintaining the Topmost Level
A skip list S must maintain a reference to the start position (the topmost, left po-
sition in S) as an instance variable, and must have a policy for any insertion that
wishes to continue inserting a new entry past the top level of S. There are two
possible coursesofactionwecantake,bothofwhichhavetheirmerits.
Onepossibility istorestrict thetoplevel,h,tobekeptatsomeﬁxedvaluethat
isafunction ofn,thenumberofentriescurrently inthemap(fromtheanalysis we
willseethath=max{10,2(cid:13)logn(cid:14)}isareasonablechoice,andpickingh=3(cid:13)logn(cid:14)
is even safer). Implementing this choice means that wemust modify the insertion
algorithm tostopinserting anew position once wereach thetopmost level(unless
(cid:13)logn(cid:14)<(cid:13)log(n+1)(cid:14),inwhichcasewecannowgoatleastonemorelevel,since
theboundontheheightisincreasing).
The other possibility is to let an insertion continue inserting a new position as
long as heads keeps getting returned from the random number generator. This is
theapproach taken byalgorithm SkipInsertofCodeFragment 10.13. Asweshow
intheanalysisofskiplists,theprobabilitythataninsertionwillgotoalevelthatis
morethanO(logn)isverylow,sothisdesignchoiceshouldalsowork.
Either choice will still result in the expected O(logn) time to perform search,
insertion, andremoval,however,whichweshowinthenextsection.
(cid:2)
10.4.2 Probabilistic Analysis of Skip Lists
As we have shown above, skip lists provide a simple implementation of a sorted
map. Intermsofworst-caseperformance,however,skiplistsarenotasuperiordata
structure. Infact,ifwedonotofﬁciallypreventaninsertionfromcontinuingsignif-
icantly pastthecurrent highest level, thentheinsertion algorithm cangointowhat
isalmostaninﬁniteloop(itisnotactuallyaninﬁniteloop,however,sincetheprob-
ability ofhaving afair coin repeatedly comeup heads forever is0). Moreover, we
cannot inﬁnitely add positions to alist without eventuallyrunning out of memory.
Inanycase,ifweterminatepositioninsertionatthehighestlevelh,thentheworst-
caserunningtimeforperformingthe getitem , setitem ,and delitem
mapoperations inaskip listSwithnentries andheight hisO(n+h). Thisworst-
case performance occurs whenthe towerofevery entry reaches level h−1, where
h is the height of S. However, this event has very low probability. Judging from
this worst case, wemight conclude that the skip-list structure is strictly inferior to
theothermapimplementations discussedearlierinthischapter. Butthiswouldnot444 Chapter10. Maps,HashTables,andSkipLists
Bounding the Height of a Skip List
Becausetheinsertionstepinvolvesrandomization,amoreaccurateanalysisofskip
listsinvolvesabitofprobability. Atﬁrst,thismightseemlikeamajorundertaking,
for a complete and thorough probabilistic analysis could require deep mathemat-
ics (and, indeed, there are several such deep analyses that have appeared in data
structures researchliterature). Fortunately, suchananalysis isnotnecessary toun-
derstand theexpected asymptotic behavior ofskiplists. Theinformalandintuitive
probabilisticanalysiswegivebelowusesonlybasicconceptsofprobabilitytheory.
Let us begin by determining the expected value of the heighth of a skip list S
withnentries(assumingthatwedonotterminateinsertionsearly). Theprobability
thatagivenentryhasatowerofheighti≥1isequal totheprobability ofgettingi
consecutive headswhenﬂippingacoin, thatis,thisprobability is1/2i. Hence,the
probability P thatlevelihasatleastoneposition isatmost
i
n
P ≤ ,
i 2i
for the probability that any one of n different events occurs is at most the sum of
theprobabilities thateachoccurs.
Theprobability thattheheighthofSislarger thaniisequal totheprobability
thatlevelihasatleastoneposition, thatis,itisnomorethanP. Thismeansthath
i
islargerthan,say,3lognwithprobability atmost
n
P ≤
3logn 23logn
n 1
= = .
n3 n2
For example, if n=1000, this probability is a one-in-a-million long shot. More
generally, given a constant c>1, h is larger than clogn with probability at most
1/nc−1. Thatis, the probability thathis smaller thanclognisatleast 1−1/nc−1.
Thus,withhighprobability, theheighthofSisO(logn).
Analyzing Search Time in a Skip List
Next, consider the running time of a search in skip list S, and recall that such a
searchinvolvestwonestedwhileloops. Theinnerloopperformsascanforwardon
alevelofSaslongasthenextkeyisnogreaterthanthesearchkeyk,andtheouter
loopdrops downtothenextlevelandrepeats thescan forwarditeration. Sincethe
height h of S is O(logn) with high probability, the number of drop-down steps is10.4. SkipLists 445
Sowehaveyettobound thenumberofscan-forward stepswemake. Letn be
i
thenumberofkeysexaminedwhilescanningforwardatleveli. Observethat,after
the key at the starting position, each additional key examined in a scan-forward at
level i cannot also belong to level i+1. If any of these keys were on the previous
level, we would have encountered them in the previous scan-forward step. Thus,
theprobabilitythatanykeyiscountedinn is1/2. Therefore,theexpectedvalueof
i
n is exactly equal to the expected number of times wemust ﬂipa fair coin before
i
it comes up heads. This expected value is 2. Hence, the expected amount of time
spentscanningforwardatanyleveliisO(1). SinceShasO(logn)levelswithhigh
probability, a search in S takes expected time O(logn). By a similar analysis, we
canshowthattheexpected runningtimeofaninsertionoraremovalisO(logn).
Space Usage in a Skip List
Finally, let us turn to the space requirement of a skip listS with n entries. As we
observed above, the expected number of positions at level i is n/2i, which means
thattheexpectedtotalnumberofpositions inSis
∑h n =n∑h 1.
2i 2i
i=0 i=0
UsingProposition 3.5ongeometricsummations, wehave
(cid:9) (cid:10) (cid:17) (cid:18)
∑h 1 = 12 h+1−1 =2· 1− 1 <2 forallh≥0.
2i 1−1 2h+1
i=0 2
Hence,theexpected spacerequirement ofSisO(n).
Table10.4summarizestheperformance ofasortedmaprealizedbyaskiplist.
Operation RunningTime
len(M) O(1)
k in M O(logn)expected
M[k] = v O(logn)expected
del M[k] O(logn)expected
M.ﬁnd min(),M.ﬁnd max() O(1)
M.ﬁnd lt(k),M.ﬁnd gt(k)
O(logn)expected
M.ﬁnd le(k),M.ﬁnd ge(k)
M.ﬁnd range(start, stop) O(s+logn)expected, withsitemsreported
iter(M),reversed(M) O(n)
Table10.4: Performanceofasortedmapimplemented withaskiplist. Weusento
denotethenumberofentriesinthedictionaryatthetimetheoperationisperformed.446 Chapter10. Maps,HashTables,andSkipLists
10.5 Sets, Multisets, and Multimaps
We conclude this chapter by examining several additional abstractions that are
closelyrelated tothemapADT,andthatcanbeimplementedusingdatastructures
similartothoseforamap.
• A set is an unordered collection of elements, without duplicates, that typi-
cally supports efﬁcient membership tests. In essence, elements of a set are
likekeysofamap,butwithoutanyauxiliary values.
• Amultiset(alsoknownasabag)isaset-likecontainerthatallowsduplicates.
• A multimap is similar to a traditional map, in that it associates values with
keys; however, in a multimap the same key can be mapped to multiple val-
ues. For example, the index of this book maps a given term to one or more
locations atwhichthetermoccurselsewhereinthebook.
10.5.1 The Set ADT
Python provides support forrepresenting themathematicalnotion ofasetthrough
the built-in classes frozenset and set, as originally discussed in Chapter 1, with
frozenset being an immutable form. Both of those classes are implemented using
hashtablesinPython.
Python’scollectionsmoduledeﬁnesabstractbaseclassesthatessentiallymirror
thesebuilt-inclasses. Althoughthechoiceofnamesiscounterintuitive, theabstract
base class collections.Set matches the concrete frozenset class, while the abstract
baseclasscollections.MutableSetisakintotheconcretesetclass.
Inourowndiscussion, weequatethe“setADT”withthebehaviorofthebuilt-
in set class (and thus, thecollections.MutableSetbase class). Webegin by listing
whatweconsider tobetheﬁvemostfundamental behaviors forasetS:
S.add(e): Add element e to the set. This has no effect if the set
already containse.
S.discard(e): Remove element e from the set, if present. This has no
effectifthesetdoesnotcontaine.
e in S: ReturnTrueifthesetcontainselemente. InPython,this
isimplementedwiththespecial contains method.
len(S): Return the number of elements in set S. In Python, this
isimplementedwiththespecial method len .
iter(S): Generateaniterationofallelementsoftheset. InPython,10.5. Sets,Multisets,andMultimaps 447
Inthenextsection, wewillseethattheaboveﬁvemethodssufﬁceforderiving
allotherbehaviorsofaset. Thoseremainingbehaviorscanbenaturallygroupedas
follows. Webegin by describing the following additional operations for removing
oneormoreelementsfromaset:
S.remove(e): Remove elemente from the set. Ifthe set does not contain e,
raiseaKeyError.
S.pop(): Remove and return an arbitrary element from the set. If the
setisempty,raiseaKeyError.
S.clear(): Removeallelementsfromtheset.
Thenextgroupofbehaviors performBooleancomparisons betweentwosets.
S == T: ReturnTrueifsetsSandThaveidentical contents.
S != T: ReturnTrueifsetsSandTarenotequivalent.
S <= T: ReturnTrueifsetSisasubsetofsetT.
S < T: ReturnTrueifsetSisapropersubsetofsetT.
S >= T: ReturnTrueifsetSisasupersetofsetT.
S > T: ReturnTrueifsetSisapropersupersetofsetT.
S.isdisjoint(T): ReturnTrueifsetsSandThavenocommonelements.
Finally, there exists a variety of behaviors that either update an existing set, or
computeanewsetinstance, basedonclassical settheoryoperations.
S | T: Returnanewsetrepresenting theunionofsetsSandT.
S |= T: UpdatesetStobetheunionofSandsetT.
S & T: Returnanewsetrepresenting theintersection ofsetsSandT.
S &= T: UpdatesetStobetheintersection ofSandsetT.
S ˆ T: Returnanewsetrepresentingthesymmetricdifferenceofsets
S and T, that is, a set of elements that are in precisely one of
SorT.
S ˆ= T: UpdatesetStobecomethesymmetricdifferenceofitselfand
setT.
S − T: Returnanewsetcontaining elementsinSbutnotT.448 Chapter10. Maps,HashTables,andSkipLists
10.5.2 Python’s MutableSet Abstract Base Class
Toaidinthecreation ofuser-deﬁned setclasses, Python’scollectionsmodule pro-
videsaMutableSetabstractbaseclass(justasitprovidestheMutableMappingab-
stractbaseclass discussed inSection10.1.3). TheMutableSetbaseclassprovides
concrete implementations for all methods described in Section 10.5.1, except for
ﬁvecorebehaviors (add,discard, contains , len ,and iter )thatmust
be implemented by any concrete subclass. This design is an example of what is
knownasthetemplatemethodpattern,astheconcretemethodsoftheMutableSet
classrely onthepresumed abstract methodsthatwillsubsequently beprovided by
asubclass.
Forthepurposeofillustration,weexaminealgorithmsforimplementingseveral
ofthederivedmethods oftheMutableSetbaseclass. Forexample, todetermineif
onesetisapropersubsetofanother,wemustverifytwoconditions: apropersubset
musthavesizestrictlysmallerthanthatofitssuperset,andeachelementofasubset
mustbecontained inthesuperset. Animplementationofthecorresponding lt
methodbasedonthislogicisgiveninCodeFragment10.14.
def lt (self, other): # supports syntax S < T
”””Return true if this set is a proper subset of other.”””
if len(self) >= len(other):
return False # proper subset must have strictly smaller size
for e in self:
if e not in other:
return False # not a subset since element missing from other
return True # success; all conditions are met
Code Fragment 10.14: A possible implementation of the MutableSet. lt
method,whichtestsifonesetisapropersubsetofanother.
As another example, we consider the computation of the union of two sets.
Theset ADTincludes two forms for computing aunion. The syntax S | T should
produceanewsetthathascontentsequaltotheunionofexistingsetsSandT. This
operation is implemented through the special method or in Python. Another
syntax, S |= T is used to update existing set S to become the union of itself and
set T. Therefore, all elements of T that are not already contained in S should
be added to S. We note that this “in-place” operation may be implemented more
efﬁciently thanifweweretorely onthe ﬁrstform, using thesyntax S = S | T,in
whichidentiﬁerSisreassigned toanewsetinstance thatrepresents theunion. For
convenience, Python’sbuilt-insetclasssupportsnamedversionofthesebehaviors,
with S.union(T) equivalent to S | T, and S.update(T) equivalent to S |= T (yet,
those named versions are not formally provided by the MutableSet abstract base10.5. Sets,Multisets,andMultimaps 449
def or (self, other): # supports syntax S | T
”””Return a new set that is the union of two existing sets.”””
result = type(self)( ) # create new instance of concrete class
for e in self:
result.add(e)
for e in other:
result.add(e)
return result
Code Fragment 10.15: An implementation of the MutableSet. or method,
whichcomputestheunionoftwoexisting sets.
An implementation of the behavior that computes a new set as aunion of two
othersisgivenintheformofthe or specialmethod, inCodeFragment10.15.
An important subtlety in this implementation is the instantiation of the resulting
set. Since the MutableSet class is designed as an abstract base class, instances
must belong to a concrete subclass. When computing the union of two such con-
creteinstances,theresultshouldpresumablybeaninstanceofthesameclassasthe
operands. The function type(self) returns a reference to the actual class of the in-
stance identiﬁed asself,andthesubsequent parentheses inexpression type(self)()
callthedefaultconstructor forthatclass.
In terms of efﬁciency, we analyze such set operations while letting n denote
the size of S and m denote the size of set T for an operation such as S | T. If
the concrete sets are implemented with hashing, the expected running time of the
implementation in Code Fragment 10.15 is O(m+n), because it loops over both
sets, performing constant-time operations in the form of a containment check and
apossible insertion intotheresult.
Our implementation of the in-place version of a union is given in Code Frag-
ment10.16,intheformofthe ior specialmethodthatsupportssyntaxS |= T.
Noticethatinthiscase,wedonotcreateanewsetinstance, insteadwemodifyand
returntheexistingset,afterupdatingitscontentstoreﬂecttheunionoperation. The
in-place version of the union has expected running timeO(m)where m is the size
ofthesecondset,becauseweonlyhavetoloopthrough thatsecondset.
def ior (self, other): # supports syntax S |= T
”””Modify this set to be the union of itself an another set.”””
for e in other:
self.add(e)
return self # technical requirement of in-place operator
Code Fragment 10.16: An implementation of the MutableSet. ior method,450 Chapter10. Maps,HashTables,andSkipLists
10.5.3 Implementing Sets, Multisets, and Multimaps
Sets
Although sets and maps have very different public interfaces, they are really quite
similar. A set is simply a map in which keys do not have associated values. Any
datastructureusedtoimplementamapcanbemodiﬁedtoimplementthesetADT
with similar performance guarantees. We could trivially adapt any map class by
storing set elements as keys, and using None as an irrelevant value, but such an
implementation is unnecessarily wasteful. An efﬁcient setimplementation should
abandon the Item composite that we use in our MapBaseclass and instead store
setelementsdirectlyinadatastructure.
Multisets
Thesameelementmayoccurseveral timesinamultiset. Allofthedata structures
we have seen can be reimplemented to allow for duplicates to appear as separate
elements. However, another way to implement a multiset is by using a map in
which the map key is a(distinct) element of the multiset, andthe associated value
isacountofthenumberofoccurrences ofthatelementwithinthemultiset. Infact,
that isessentially whatwedidinSection 10.1.2when computing thefrequency of
wordswithinadocument.
Python’s standard collections module includes a deﬁnition for a class named
Counter that is in essence a multiset. Formally, theCounter class is a subclass of
dict,withtheexpectationthatvaluesareintegers,andwithadditionalfunctionality
likeamost common(n)methodthatreturnsalistofthenmostcommonelements.
Thestandard iter reportseachelementonlyonce(sincethoseareformallythe
keys of the dictionary). There is another method named elements() that iterates
through themultisetwitheachelementbeingrepeated according toitscount.
Multimaps
Although there is no multimap in Python’s standard libraries, a common imple-
mentation approach is to use a standard map in which the valueassociated with a
key isitself acontainer class storing any number of associated values. Wegivean
example of such a MultiMapclass in Code Fragment 10.17. Our implementation
usesthestandarddictclassasthemap,andalistofvalues asacomposite valuein
the dictionary. Wehave designed the class sothat adifferent mapimplementation10.5. Sets,Multisets,andMultimaps 451
1 class MultiMap:
2 ”””A multimap class built upon use of an underlying map for storage.”””
3 MapType = dict # Map type; can be redeﬁned by subclass
4
5 def init (self):
6 ”””Create a new empty multimap instance.”””
7 self. map = self. MapType( ) # create map instance for storage
8 self. n = 0
9
10 def iter (self):
11 ”””Iterate through all (k,v) pairs in multimap.”””
12 for k,secondary in self. map.items():
13 for v in secondary:
14 yield (k,v)
15
16 def add(self, k, v):
17 ”””Add pair (k,v) to multimap.”””
18 container = self. map.setdefault(k, [ ]) # create empty list, if needed
19 container.append(v)
20 self. n += 1
21
22 def pop(self, k):
23 ”””Remove and return arbitrary (k,v) with key k (or raise KeyError).”””
24 secondary = self. map[k] # may raise KeyError
25 v = secondary.pop()
26 if len(secondary) == 0:
27 del self. map[k] # no pairs left
28 self. n −= 1
29 return (k, v)
30
31 def ﬁnd(self, k):
32 ”””Return arbitrary (k,v) pair with given key (or raise KeyError).”””
33 secondary = self. map[k] # may raise KeyError
34 return (k, secondary[0])
35
36 def ﬁnd all(self, k):
37 ”””Generate iteration of all (k,v) pairs with given key.”””
38 secondary = self. map.get(k, [ ]) # empty list, by default
39 for v in secondary:
40 yield (k,v)
CodeFragment10.17: An implementation of aMultiMapusing a dict for storage.452 Chapter10. Maps,HashTables,andSkipLists
10.6 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-10.1 Give a concrete implementation of the pop method in the context of the
MutableMappingclass,relyingonlyontheﬁveprimaryabstractmethods
ofthatclass.
R-10.2 Give a concrete implementation of the items() method in the context of
theMutableMappingclass,relyingonlyontheﬁveprimaryabstractmeth-
odsofthatclass. Whatwoulditsrunningtimebeifdirectlyappliedtothe
UnsortedTableMapsubclass?
R-10.3 Giveaconcreteimplementationoftheitems()methoddirectlywithinthe
UnsortedTableMap class, ensuring that the entire iteration runs in O(n)
time.
R-10.4 Whatistheworst-caserunningtimeforinsertingnkey-valuepairsintoan
initially empty map M that is implemented with the UnsortedTableMap
class?
R-10.5 ReimplementtheUnsortedTableMapclassfromSection10.1.5,usingthe
PositionalListclassfromSection7.4ratherthanaPythonlist.
R-10.6 Which of the hash table collision-handling schemes could tolerate aload
factorabove1andwhichcouldnot?
R-10.7 OurPositionclassesforlistsandtreessupportthe eq methodsothat
twodistinctpositioninstancesareconsideredequivalentiftheyrefertothe
same underlying node in a structure. For positions to be allowed as keys
in a hash table, there must be a deﬁnition for the hash method that
is consistent with this notion of equivalence. Provide such a hash
method.
R-10.8 What would bea good hash code for avehicle identiﬁcation number that
is a string of numbers and letters of the form “9X9XX99X9XX999999,”
wherea“9”represents adigitandan“X”represents aletter?
R-10.9 Draw the 11-entry hash table that results from using the hash function,
h(i)=(3i+5) mod 11,tohashthekeys12,44,13,88,23,94,11,39,20,
16,and5,assuming collisions arehandledbychaining.
R-10.10 What is the result of the previous exercise, assuming collisions are han-
dledbylinearprobing?
R-10.11 Show the result of Exercise R-10.9, assuming collisions are handled by10.6. Exercises 453
R-10.12 WhatistheresultofExerciseR-10.9whencollisionsarehandledbydou-
blehashingusingthesecondary hashfunctionh(cid:2)(k)=7−(k mod 7)?
R-10.13 Whatistheworst-casetimeforputtingnentriesinaninitiallyemptyhash
table,withcollisions resolvedbychaining? Whatisthebestcase?
R-10.14 Show the result of rehashing the hash table shown in Figure 10.6 into a
tableofsize19usingthenewhashfunctionh(k)=3k mod 17.
R-10.15 Our HashMapBase class maintains a load factor λ≤0.5. Reimplement
that class to allow the user to specify the maximum load, and adjust the
concrete subclasses accordingly.
R-10.16 Giveapseudo-code description ofaninsertion into ahash table thatuses
quadratic probing toresolve collisions, assuming wealso use the trick of
replacing deletedentrieswithaspecial“deactivated entry”object.
R-10.17 ModifyourProbeHashMaptousequadratic probing.
R-10.18 Explainwhyahashtableisnotsuitedtoimplementasortedmap.
R-10.19 Describe how a sorted list implemented as a doubly linked list could be
usedtoimplementthesortedmapADT.
R-10.20 Whatistheworst-caseasymptoticrunningtimeforperformingndeletions
fromaSortedTableMapinstance thatinitially contains2nentries?
R-10.21 Considerthefollowingvariantofthe ﬁnd indexmethodfromCodeFrag-
ment10.8,inthecontextoftheSortedTableMapclass:
def ﬁnd index(self, k, low, high):
if high < low:
return high + 1
else:
mid = (low + high) // 2
if self. table[mid]. key < k:
return self. ﬁnd index(k, mid + 1, high)
else:
return self. ﬁnd index(k, low, mid − 1)
Does this always produce the same result as the original version? Justify
youranswer.
R-10.22 Whatistheexpected runningtimeofthemethodsformaintaining amax-
ima set if weinsert npairs such that each pair has lower cost and perfor-
mancethanonebefore it? Whatiscontained inthesorted mapattheend
ofthisseriesofoperations? Whatifeachpairhadalowercostandhigher
performance thantheonebeforeit?
R-10.23 Draw an example skip list S that results from performing the following
series of operations on the skip list shown in Figure 10.13: del S[38],454 Chapter10. Maps,HashTables,andSkipLists
R-10.24 Give a pseudo-code description of the delitem map operation when
usingaskiplist.
R-10.25 Give a concrete implementation of the pop method, in the context of a
MutableSetabstractbaseclass,thatreliesonlyontheﬁvecoresetbehav-
iorsdescribed inSection10.5.2.
R-10.26 Give a concrete implementation of the isdisjoint method in the context
of the MutableSet abstract base class, relying only on the ﬁve primary
abstractmethodsofthatclass. YouralgorithmshouldruninO(min(n,m))
wherenandmdenote therespective cardinalities ofthetwosets.
R-10.27 What abstraction would you use to manage a database of friends’ birth-
days in order to support efﬁcient queries such as “ﬁnd all friends whose
birthday istoday” and“ﬁndthefriend whowillbethenexttocelebrate a
birthday”?
Creativity
C-10.28 Onpage406ofSection10.1.3,wegiveanimplementation ofthemethod
setdefaultasit might appear in theMutableMappingabstract base class.
While that method accomplishes the goal in a general fashion, its efﬁ-
ciency is less than ideal. In particular, when the key is new,there willbe
a failed search due to the initial use of getitem , and then a subse-
quent insertion via setitem . Fora concrete implementation, such as
the UnsortedTableMap, this is twice the work because a complete scan
of the table will take place during the failed getitem , and then an-
other complete scanofthetable takes placeduetotheimplementation of
setitem . AbettersolutionisfortheUnsortedTableMapclasstoover-
ride setdefault to provide a direct solution that performs a single search.
Givesuchanimplementation ofUnsortedTableMap.setdefault.
C-10.29 RepeatExerciseC-10.28fortheProbeHashMapclass.
C-10.30 RepeatExerciseC-10.28fortheChainHashMapclass.
C-10.31 For an ideal compression function, the capacity of the bucket array for a
hashtableshouldbeaprimenumber. Therefore,weconsidertheproblem
of locating a prime number in a range [M,2M]. Implement a method for
ﬁnding such a prime by using the sieve algorithm. In this algorithm, we
allocate a 2M cell Boolean array A, such that cell iis associated with the
integer i. We then initialize the array cells to all be “true” and we “mark
off” all the cells that are multiples of 2, 3, 5,√7, and so on. This process
can stop after it reaches a number larger than 2M√. (Hint: Consider a10.6. Exercises 455
C-10.32 Perform experiments onourChainHashMapand ProbeHashMapclasses
to measure its efﬁciency using random key sets and varying limits on the
loadfactor(seeExerciseR-10.15).
C-10.33 Our implementation of separate chaining in ChainHashMap conserves
memory by representing empty buckets in the table asNone, rather than
asemptyinstancesofasecondarystructure. Becausemanyofthesebuck-
ets will hold a single item, a better optimization is to have those slots of
the table directly reference the Item instance, and to reserve use of sec-
ondary containers for buckets that have two or more items. Modify our
implementation toprovidethisadditional optimization.
C-10.34 Computing ahash code can beexpensive, especially for lengthy keys. In
ourhash table implementations, wecompute the hashcode whenﬁrstin-
sertinganitem,andrecomputeeachitem’shashcodeeachtimeweresize
our table. Python’s dict class makes an interesting trade-off. The hash
code is computed once, when an item is inserted, and the hash code is
storedasanextraﬁeldoftheitemcomposite,sothatitneednotberecom-
puted. ReimplementourHashTableBaseclasstousesuchanapproach.
C-10.35 Describe how to perform a removal from a hash table that uses linear
probing to resolve collisions where we do not use a special marker to
representdeletedelements. Thatis,wemustrearrangethecontentssothat
itappears thattheremovedentrywasneverinserted intheﬁrstplace.
C-10.36 Thequadraticprobingstrategyhasaclusteringproblemrelatedtotheway
itlooksforopen slots. Namely, whenacollision occurs atbucket h(k),it
checksbucketsA[(h(k)+i2) mod N],fori=1,2,...,N−1.
a. Show that i2 mod N will assume at most (N+1)/2 distinct values,
for N prime, as i ranges from 1 toN−1. Asa part of this justiﬁca-
tion,notethati2 mod N =(N−i)2 mod N foralli.
b. Abetter strategy istochoose aprimeN such that N mod 4=3and
then to check the buckets A[(h(k)±i2) mod N] as i ranges from 1
to (N−1)/2, alternating between plus and minus. Show that this
alternate versionisguaranteed tocheckeverybucketinA.
C-10.37 Refactor our ProbeHashMap design so that the sequence of secondary
probes for collision resolution can be more easily customized. Demon-
strate your new framework by providing separate concrete subclasses for
linearprobingandquadratic probing.
C-10.38 Design a variation of binary search for performing the multimap opera-
tion ﬁnd all(k) implemented with a sorted search table that includes du-
plicates, andshowthatitrunsintimeO(s+logn),wherenisthenumber456 Chapter10. Maps,HashTables,andSkipLists
C-10.39 Although keys in a map are distinct, the binary search algorithm can be
appliedinamoregeneralsettinginwhichanarraystorespossiblyduplica-
tiveelementsinnondecreasing order. Considerthegoalofidentifying the
index of the leftmost element with key greater than or equal to given k.
Does the ﬁnd index method as given in Code Fragment 10.8 guarantee
such aresult? Doesthe ﬁnd indexmethod asgiveninExercise R-10.21
guarantee sucharesult? Justifyyouranswers.
C-10.40 SupposewearegiventwosortedsearchtablesSandT,eachwithnentries
(with S and T being implemented with arrays). Describe an O(log2n)-
time algorithm for ﬁnding the kth smallest key in the union of the keys
fromSandT (assuming noduplicates).
C-10.41 GiveanO(logn)-timesolution fortheprevious problem.
C-10.42 Supposethateachrowofann×narrayAconsistsof1’sand0’ssuchthat,
in any row of A, all the 1’s come before any 0’s in that row. AssumingA
is already in memory, describe a method running in O(nlogn) time (not
O(n2)time!) forcounting thenumberof1’sinA.
C-10.43 GivenacollectionC ofncost-performance pairs(c,p), describe analgo-
rithmforﬁndingthemaximapairsofC inO(nlogn)time.
C-10.44 Show that the methods above(p) and prev(p) are not actually needed to
efﬁciently implement a map using a skip list. That is, we can imple-
mentinsertionsanddeletionsinaskiplistusingastrictlytop-down,scan-
forwardapproach, withouteverusingtheaboveorprevmethods. (Hint:
In the insertion algorithm, ﬁrst repeatedly ﬂip the coin to determine the
levelwhereyoushouldstartinserting thenewentry.)
C-10.45 Describe how to modify a skip-list representation so that index-based
operations, such as retrieving the item at index j, can be performed in
O(logn)expectedtime.
C-10.46 For sets S and T, the syntax S ˆ T returns a new set that is the symmet-
ric difference, that is, a set of elements that are in precisely one of S or
T. This syntax is supported by the special xor method. Provide an
implementation of that method in the context of theMutableSetabstract
baseclass,relyingonlyontheﬁveprimaryabstractmethodsofthatclass.
C-10.47 In the context of the MutableSetabstract base class, describe a concrete
implementationofthe and method,whichsupportsthesyntaxS & T
forcomputingtheintersection oftwoexistingsets.
C-10.48 An inverted ﬁle is a critical data structure for implementing a search en-
gine or the index of a book. Given a document D, which can be viewed
asanunordered, numberedlistofwords,aninvertedﬁleisanorderedlist
of words, L, such that, for each word w in L, we store the indices of the
placesinDwherewappears. Designanefﬁcientalgorithm forconstruct-10.6. Exercises 457
C-10.49 Python’s collections module provides an OrderedDict class that is unre-
lated to our sorted map abstraction. AnOrderedDict is a subclass of the
standardhash-baseddictclassthatretainstheexpectedO(1)performance
fortheprimarymapoperations, butthatalsoguarantees thatthe iter
method reports items of the map according to ﬁrst-in, ﬁrst-out (FIFO)
order. That is, the key that has been in the dictionary the longest is re-
ported ﬁrst. (The order is unaffected when the value for an existing key
isoverwritten.) Describeanalgorithmicapproach forachievingsuchper-
formance.
Projects
P-10.50 Performacomparative analysis thatstudies thecollision ratesforvarious
hash codes for character strings, such as various polynomial hash codes
for different values of the parameter a. Use a hash table to determine
collisions, but only count collisions where different strings map to the
same hash code (not if they map to the same location in this hash table).
TestthesehashcodesontextﬁlesfoundontheInternet.
P-10.51 Performacomparativeanalysisasinthepreviousexercise,butfor10-digit
telephone numbersinsteadofcharacter strings.
P-10.52 Implement an OrderedDict class, as described in Exercise C-10.49, en-
suringthattheprimarymapoperations runinO(1)expectedtime.
P-10.53 Design a Python class that implements the skip-list data structure. Use
thisclasstocreateacompleteimplementation ofthesortedmapADT.
P-10.54 Extend the previous project by providing a graphical animation of the
skip-list operations. Visualize how entries move up the skip list during
insertions and are linked out of the skip list during removals. Also, in a
searchoperation, visualize thescan-forward anddrop-downactions.
P-10.55 Writeaspell-checker class thatstores alexicon ofwords,W,inaPython
set, and implements a method, check(s), which performs a spell check
on the string s with respect to the set of words, W. If s is in W, then
the call to check(s) returns a list containing only s, as it is assumed to
bespelled correctly inthiscase. IfsisnotinW, thenthecall tocheck(s)
returnsalistofeverywordinW thatmightbeacorrectspellingofs. Your
program should be able to handle all the common ways thats might be a
misspelling of a word inW, including swapping adjacent characters in a
word,inserting asingle character inbetweentwoadjacent characters ina
word,deletingasinglecharacterfromaword,andreplacingacharacterin
a word with another character. For an extra challenge, consider phonetic458 Chapter10. Maps,HashTables,andSkipLists
Chapter Notes
Hashingisa well-studiedtechnique. Thereaderinterestedinfurtherstudyisencouraged
to explore the book by Knuth [65], as well as the book by Vitter and Chen [100]. Skip
lists wereintroducedbyPugh[86]. Ouranalysisofskip listsisa simpliﬁcationofapre-
sentationgivenbyMotwaniandRaghavan[80]. Foramorein-depthanalysisofskiplists,
pleaseseethevariousresearchpapersonskipliststhathaveappearedinthedatastructuresChapter
11
Search Trees
Contents
11.1 Binary Search Trees . . . . . . . . . . . . . . . . . . . . . . 460
11.1.1 Navigating a Binary Search Tree . . . . . . . . . . . . . . 461
11.1.2 Searches . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
11.1.3 Insertions and Deletions . . . . . . . . . . . . . . . . . . . 465
11.1.4 Python Implementation . . . . . . . . . . . . . . . . . . . 468
11.1.5 Performance of a Binary Search Tree . . . . . . . . . . . . 473
11.2 Balanced Search Trees . . . . . . . . . . . . . . . . . . . . 475
11.2.1 Python Framework for Balancing Search Trees . . . . . . . 478
11.3 AVL Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
11.3.1 Update Operations . . . . . . . . . . . . . . . . . . . . . 483
11.3.2 Python Implementation . . . . . . . . . . . . . . . . . . . 488
11.4 Splay Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.4.1 Splaying . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.4.2 When to Splay. . . . . . . . . . . . . . . . . . . . . . . . 494
11.4.3 Python Implementation . . . . . . . . . . . . . . . . . . . 496
(cid:2)
11.4.4 Amortized Analysis of Splaying . . . . . . . . . . . . . 497
11.5 (2,4) Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
11.5.1 Multiway Search Trees . . . . . . . . . . . . . . . . . . . 502
11.5.2 (2,4)-Tree Operations . . . . . . . . . . . . . . . . . . . . 505
11.6 Red-Black Trees . . . . . . . . . . . . . . . . . . . . . . . . 512
11.6.1 Red-Black Tree Operations . . . . . . . . . . . . . . . . . 514
11.6.2 Python Implementation . . . . . . . . . . . . . . . . . . . 525460 Chapter11. SearchTrees
11.1 Binary Search Trees
In Chapter 8 we introduced the tree data structure and demonstrated a variety of
applications. Oneimportant use isasasearch tree(as described onpage 332). In
this chapter, we use a search tree structure to efﬁciently implement a sorted map.
Thethreemostfundamental methodsofamapM (seeSection10.1.1)are:
M[k]: Return the value v associated with key k in map M, if one exists;
otherwise raise aKeyError;implemented with getitem method.
M[k] = v: Associate value v with key k in map M, replacing the existing value
ifthemapalreadycontainsanitemwithkeyequaltok;implemented
with setitem method.
del M[k]: Remove from mapM the item withkey equal tok; if Mhas no such
item,thenraiseaKeyError;implemented with delitem method.
The sorted map ADT includes additional functionality (see Section 10.3), guar-
anteeing that an iteration reports keys in sorted order, and supporting additional
searches suchasﬁnd gt(k)andﬁnd range(start, stop).
Binarytreesareanexcellentdatastructureforstoringitemsofamap,assuming
wehaveanorderrelation deﬁnedonthekeys. Inthiscontext,abinarysearch tree
isabinarytreeT witheachposition pstoringakey-value pair(k,v)suchthat:
• Keysstoredintheleftsubtree of parelessthank.
• Keysstoredintherightsubtreeof paregreaterthank.
An example of such a binary search tree is given in Figure 11.1. As a matter of
convenience, we will not diagram the values associated withkeys in this chapter,
sincethosevaluesdonotaffecttheplacementofitemswithinasearchtree.
44
17 88
8 32 65 97
28 54 82 93
29 76
80
Figure11.1: Abinary searchtreewithinteger keys. Weomitthedisplay ofassoci-
atedvaluesinthischapter, sincetheyarenotrelevanttotheorderofitemswithina11.1. BinarySearchTrees 461
11.1.1 Navigating a Binary Search Tree
We begin by demonstrating that a binary search tree hierarchically represents the
sorted order of its keys. In particular, the structural property regarding the place-
ment of keys within a binary search tree assures the following important conse-
quenceregardinganinordertraversal(Section8.4.3)ofthetree.
Proposition 11.1: Aninordertraversalofabinarysearchtreevisitspositionsin
increasingorderoftheirkeys.
Justiﬁcation: We prove this by induction on the size of a subtree. If a subtree
has at most one item, its keys are trivially visited in order. More generally, an
inorder traversal of a (sub)tree consists of a recursive traversal of the (possibly
empty)leftsubtree, followedbyavisitoftheroot,andthenarecursivetraversalof
the(possiblyempty)rightsubtree. Byinduction,arecursiveinordertraversalofthe
leftsubtreewillproduce aniterationofthekeysinthatsubtree inincreasing order.
Furthermore, by the binary search tree property, all keys in the left subtree have
keysstrictlysmallerthanthatoftheroot. Therefore, visitingtherootjustafterthat
subtree extends the increasing order of keys. Finally, by the search tree property,
all keys in the right subtree are strictly greater than the root, and by induction, an
inordertraversal ofthatsubtree willvisitthosekeysinincreasing order.
Sinceaninordertraversalcanbeexecutedinlineartime,aconsequence ofthis
proposition isthat wecan produce asorted iteration ofthe keys of amapin linear
time,whenrepresented asabinarysearchtree.
Although an inorder traversal is typically expressed using a top-down recur-
sion, wecan provide nonrecursive descriptions ofoperations that allow moreﬁne-
grained navigation among the positions of a binary search relative to the order of
their keys. Our generic binary tree ADTfrom Chapter 8 is deﬁned as a positional
structure, allowingdirect navigation using methodssuchasparent(p),left(p),and
right(p). Withabinarysearchtree,wecanprovide additional navigation basedon
the natural order of the keys stored in the tree. In particular, we can support the
followingmethods, akintothoseprovidedbyaPositionalList(Section7.4.1).
ﬁrst(): Returnthepositioncontainingtheleastkey,orNoneifthetreeisempty.
last(): Returntheposition containing thegreatestkey,orNoneifemptytree.
before(p): Return the position containing the greatest key that is lessthan that of
positionp(i.e.,theposition thatwouldbevisitedimmediatelybefore p
inaninorder traversal), orNoneifpistheﬁrstposition.
after(p): Return the position containing the least key that is greater than that of
position p (i.e., the position that would be visited immediately after p462 Chapter11. SearchTrees
The“ﬁrst”position ofabinary search treecan belocated bystarting awalkat
therootandcontinuingtotheleftchild,aslongasaleftchildexists. Bysymmetry,
thelastposition isreachedbyrepeated stepsrightwardstarting attheroot.
Thesuccessorofaposition,after(p),isdeterminedbythefollowingalgorithm.
Algorithmafter(p):
ifright(p)isnotNonethen{successorisleftmostpositioninp’srightsubtree}
walk = right(p)
whileleft(walk)isnotNonedo
walk = left(walk)
returnwalk
else{successor isnearestancestorhavingpinitsleftsubtree}
walk = p
ancestor = parent(walk)
whileancestorisnotNoneandwalk==right(ancestor)do
walk = ancestor
ancestor = parent(walk)
returnancestor
CodeFragment11.1:Computingthesuccessorofapositioninabinarysearchtree.
The rationale for this process is based purely on the workings of an inorder
traversal, given the correspondence of Proposition 11.1. If p has a right subtree,
that right subtree isrecursively traversed immediately after pisvisited, and so the
ﬁrst position to be visited after p is the leftmost position within the right subtree.
If p does not have a right subtree, then the ﬂow of control of an inorder traversal
returns top’sparent. Ifpwereintheright subtree ofthat parent, then theparent’s
subtree traversal is complete and the ﬂow of control progresses to its parent and
so on. Once an ancestor is reached in which the recursion is returning from its
left subtree, then that ancestor becomes the next position visited by the inorder
traversal, andthusisthesuccessor ofp. Noticethattheonlycaseinwhichnosuch
ancestor is found is when p was the rightmost (last) position of the full tree, in
whichcasethereisnosuccessor.
A symmetric algorithm can be deﬁned to determine the predecessor of a po-
sition, before(p). At this point, we note that the running time of single call to
after(p)orbefore(p)isboundedbytheheighthofthefulltree,becauseitisfound
aftereitherasingledownwardwalkorasingleupwardwalk. Whiletheworst-case
running time is O(h), we note that either of these methods run inO(1) amortized
time,inthatseriesofncallstoafter(p)startingattheﬁrstpositionwillexecuteina
totalofO(n)time. Weleaveaformaljustiﬁcation ofthisfacttoExerciseC-11.34,
butintuitivelytheupwardanddownwardpathsmimicstepsoftheinordertraversal11.1. BinarySearchTrees 463
11.1.2 Searches
The most important consequence of the structural property of a binary search tree
is its namesake search algorithm. We can attempt to locate a particular key in a
binary search tree by viewing itas a decision tree (recall Figure 8.7). In this case,
thequestionaskedateachpositionpiswhetherthedesiredkeykislessthan,equal
to, or greater than the key stored at positionp, which we denote asp.key(). If the
answer is “less than,” then the search continues in the left subtree. If the answer
is “equal,” then the search terminates successfully. Iftheanswer is “greater than,”
thenthesearchcontinuesintherightsubtree. Finally,ifwereachanemptysubtree,
thenthesearchterminatesunsuccessfully. (SeeFigure11.2.)
44 44
17 88 17 88
8 32 65 97 8 32 65 97
28 54 82 93 28 54 82 93
29 76 29 76
80 80
(a) (b)
Figure 11.2: (a) A successful search for key 65 in a binary search tree; (b) an
unsuccessful search for key 68 that terminates because there is no subtree to the
leftofthekey76.
WedescribethisapproachinCodeFragment11.2. Ifkeykoccursinasubtree
rooted at p, a call to TreeSearch(T, p, k) results in the position at which the key
is found; in this case, the getitem map operation would return the associated
value at that position. In the event of an unsuccessful search, the TreeSearch al-
gorithm returns the ﬁnal position explored on the search path (which wewilllater
makeuseofwhendetermining wheretoinsertanewiteminasearchtree).
AlgorithmTreeSearch(T, p, k):
ifk==p.key()then
return p {successful search}
elseifk<p.key()andT.left(p)isnotNonethen
returnTreeSearch(T, T.left(p), k) {recuronleftsubtree}
elseifk>p.key()andT.right(p)isnotNonethen
returnTreeSearch(T, T.right(p), k) {recuronrightsubtree}
returnp {unsuccessful search}464 Chapter11. SearchTrees
Analysis of Binary Tree Searching
The analysis of the worst-case running time of searching in a binary search tree
T is simple. Algorithm TreeSearch is recursive and executes a constant number
of primitive operations for each recursive call. Each recursive call of TreeSearch
is made on a child of the previous position. That is, TreeSearch is called on the
positions of a path of T that starts at the root and goes down one level at a time.
Thus,thenumberofsuchpositionsisboundedbyh+1,wherehistheheightofT.
In other words, since we spend O(1) time per position encountered in the search,
the overall search runs in O(h) time, where h is the height of the binary search
treeT. (SeeFigure11.3.)
Height Timeperlevel
O(1)
TreeT:
O(1)
h
O(1)
Totaltime: O(h)
Figure11.3: Illustrating the running time of searching ina binary search tree. The
ﬁgure uses standard caricature of a binary search tree as a big triangle and a path
fromtherootasazig-zagline.
In the context of the sorted map ADT, the search will be used asa subroutine
for implementing the getitem method, as well as for the setitem and
delitem methods, since each of these begins by trying to locate an existing
item with a given key. To implement sorted map operations such as ﬁnd lt and
ﬁnd gt, we will combine this search with traversal methods before and after. All
of these operations will run in worst-case O(h) time for a tree with height h. We
can use a variation of this technique to implement the ﬁnd range method in time
O(s+h),wheresisthenumberofitemsreported (seeExerciseC-11.34).
Admittedly,theheighthofT canbeaslargeasthenumberofentries,n,butwe
expectthatitisusuallymuchsmaller. Indeed,laterinthischapterweshowvarious11.1. BinarySearchTrees 465
11.1.3 Insertions and Deletions
Algorithmsforinsertingordeletingentriesofabinarysearchtreearefairlystraight-
forward,although nottrivial.
Insertion
The map command M[k] = v, as supported by the setitem method, begins
with a search for key k (assuming the map is nonempty). If found, that item’s
existing value is reassigned. Otherwise, a node for the new item can be inserted
intotheunderlying treeTinplaceoftheemptysubtreethatwasreachedattheend
ofthefailedsearch. Thebinarysearchtreeproperty issustained bythatplacement
(note that it is placed exactly where a search would expect it). Pseudo-code for
suchaTreeInsertalgorithm isgivenininCodeFragment11.3.
AlgorithmTreeInsert(T, k, v):
Input: Asearchkeyktobeassociated withvaluev
p = TreeSearch(T,T.root(),k)
ifk==p.key()then
Setp’svaluetov
elseifk<p.key()then
addnodewithitem(k,v)asleftchildofp
else
addnodewithitem(k,v)asrightchildofp
Code Fragment 11.3: Algorithm for inserting a key-value pair into a map that is
represented asabinarysearchtree.
Anexampleofinsertion intoabinarysearchtreeisshowninFigure11.4.
44 44
17 88 17 88
8 32 65 97 8 32 65 97
28 54 82 93 28 54 82 93
29 76 29 76
80 68 80
(a) (b)
Figure 11.4: Insertion of an item with key 68 into the search tree of Figure 11.2.466 Chapter11. SearchTrees
Deletion
Deleting an item from a binary search treeT is a bit more complex than inserting
anew item because the location of the deletion might be anywhere in the tree. (In
contrast, insertions are always enacted at the bottom of a path.) To delete an item
with key k, we begin by calling TreeSearch(T, T.root(), k)to ﬁndthe position p
ofTstoring anitemwithkeyequaltok. Ifthesearchissuccessful, wedistinguish
betweentwocases(ofincreasing difﬁculty):
• If p has at most one child, the deletion of the node at position p is easily
implemented. When introducing update methods for the LinkedBinaryTree
classinSection8.3.1,wedeclaredanonpublicutility, delete(p),thatdeletes
anodeatpositionpandreplacesitwithitschild(ifany),presumingthatphas
atmostonechild. Thatispreciselythedesiredbehavior. Itremovestheitem
with key k from the map while maintaining all other ancestor-descendant
relationships in the tree, thereby assuring the upkeep of the binary search
treeproperty. (SeeFigure11.5.)
• If position p has two children, we cannot simply remove the node from T
since this would create a “hole” and two orphaned children. Instead, we
proceed asfollows(seeFigure11.6):
◦ Welocate position rcontaining the itemhaving the greatest keythatis
strictlylessthanthatofpositionp,thatis,r = before(p)bythenotation
of Section 11.1.1. Because p has two children, its predecessor is the
rightmost positionoftheleftsubtree ofp.
◦ Weuser’sitemasareplacementfortheonebeingdeletedatpositionp.
Because rhas the immediately preceding key in the map, any items in
p’srightsubtreewillhavekeysgreaterthanrandanyotheritemsinp’s
leftsubtreewillhavekeyslessthanr. Therefore, thebinarysearchtree
property issatisﬁedafterthereplacement.
◦ Having used r’s as a replacement for p, we instead delete the node at
position r from the tree. Fortunately, since r was located as the right-
most position in asubtree, rdoes not have a right child. Therefore, its
deletion canbeperformed usingtheﬁrst(andsimpler)approach.
As with searching and insertion, this algorithm for a deletion involves the
traversalofasinglepathdownwardfromtheroot,possiblymovinganitembetween
two positions of this path, and removing a node from that path and promoting its11.1. BinarySearchTrees 467
44 44
17 88 17 88
p r
8 32 65 97 8 28 65 97
r
28 54 82 93 29 54 82 93
29 76 76
68 80 68 80
(a) (b)
Figure11.5: Deletion from the binary search tree of Figure 11.4b, where the item
to delete (with key 32) is stored at a position p with one child r: (a) before the
deletion; (b)afterthedeletion.
44 44
p p
17 88 17 82
8 28 65 97 8 28 65 97
r r
29 54 82 93 29 54 76 93
76 68 80
68 80
(a) (b)
Figure11.6: Deletion from the binary search tree of Figure 11.5b, where the item
todelete (withkey 88)isstored ataposition pwithtwochildren, and replaced by468 Chapter11. SearchTrees
11.1.4 Python Implementation
In Code Fragments 11.4 through 11.8 we deﬁne aTreeMap class that implements
thesortedmapADTusingabinarysearchtree. Infact,ourimplementationismore
general. We support all of the standard map operations (Section 10.1.1), all ad-
ditional sorted map operations (Section 10.3), and positional operations including
ﬁrst(),last(),ﬁnd position(k),before(p),after(p),anddelete(p).
Our TreeMap class takes advantage of multiple inheritance for code reuse,
inheriting from theLinkedBinaryTree class of Section 8.3.1 for our representation
asapositional binary tree, and fromtheMapBaseclass from CodeFragment 10.2
ofSection10.1.4toprovideuswiththekey-valuecompositeitemandtheconcrete
behaviors from the collections.MutableMappingabstract base class. We subclass
thenested Positionclass tosupport morespeciﬁcp.key()and p.value()accessors
forourmap,ratherthanthep.element()syntaxinherited fromthetreeADT.
We deﬁne several nonpublic utilities, most notably a subtree search(p, k)
methodthatcorrespondstotheTreeSearchalgorithmofCodeFragment11.2. That
returnsaposition,ideallyonethatcontainsthekeyk,orotherwisethelastposition
that is visited on the search path. We rely on the fact that the ﬁnal position dur-
ing an unsuccessful search is either the nearest key less than k or the nearest key
greaterthank. Thissearchutilitybecomesthebasisforthepublicﬁnd position(k)
method,andalsoforinternal usewhensearching, inserting, ordeleting itemsfrom
amap,aswellasfortherobustsearches ofthesortedmapADT.
Whenmakingstructuralmodiﬁcations tothetree,werelyonnonpublic update
methods, such as add right, that are inherited from the LinkedBinaryTree class
(see Section 8.3.1). It isimportant that these inherited methods remain nonpublic,
asthesearchtreeproperty couldbeviolated throughmisuseofsuchoperations.
Finally, we note that our code is peppered with calls to presumed methods
named rebalance insert, rebalance delete,and rebalance access. Thesemeth-
ods serveashooks forfuture use whenbalancing search trees; wediscuss them in
Section11.2. Weconclude withabriefguidetotheorganization ofourcode.
CodeFragment11.4: BeginningofTreeMapclassincludingredeﬁnedPosition
classandnonpublic searchutilities.
CodeFragment11.5: Positional methods ﬁrst(), last(), before(p), after(p),
andﬁnd position(p)accessor.
CodeFragment11.6: Selected methods of the sorted map ADT: ﬁnd min(),
ﬁnd ge(k),andﬁnd range(start, stop);relatedmethods
areomittedforthesakeofbrevity.
CodeFragment11.7: getitem (k), setitem (k, v),and iter ().
CodeFragment11.8: Deletion either by position, as delete(p), or by key, as11.1. BinarySearchTrees 469
1 class TreeMap(LinkedBinaryTree, MapBase):
2 ”””Sorted map implementation using a binary search tree.”””
3
4 #---------------------------- override Position class ----------------------------
5 class Position(LinkedBinaryTree.Position):
6 def key(self):
7 ”””Return key of maps key-value pair.”””
8 return self.element(). key
9
10 def value(self):
11 ”””Return value of maps key-value pair.”””
12 return self.element(). value
13
14 #------------------------------- nonpublic utilities -------------------------------
15 def subtree search(self, p, k):
16 ”””Return Position of ps subtree having key k, or last node searched.”””
17 if k == p.key(): # found match
18 return p
19 elif k < p.key(): # search left subtree
20 if self.left(p) is not None:
21 return self. subtree search(self.left(p), k)
22 else: # search right subtree
23 if self.right(p) is not None:
24 return self. subtree search(self.right(p), k)
25 return p # unsucessful search
26
27 def subtree ﬁrst position(self, p):
28 ”””Return Position of ﬁrst item in subtree rooted at p.”””
29 walk = p
30 while self.left(walk) is not None: # keep walking left
31 walk = self.left(walk)
32 return walk
33
34 def subtree last position(self, p):
35 ”””Return Position of last item in subtree rooted at p.”””
36 walk = p
37 while self.right(walk) is not None: # keep walking right
38 walk = self.right(walk)
39 return walk470 Chapter11. SearchTrees
40 def ﬁrst(self):
41 ”””Return the ﬁrst Position in the tree (or None if empty).”””
42 return self. subtree ﬁrst position(self.root()) if len(self) > 0 else None
43
44 def last(self):
45 ”””Return the last Position in the tree (or None if empty).”””
46 return self. subtree last position(self.root()) if len(self) > 0 else None
47
48 def before(self, p):
49 ”””Return the Position just before p in the natural order.
50
51 Return None if p is the ﬁrst position.
52 ”””
53 self. validate(p) # inherited from LinkedBinaryTree
54 if self.left(p):
55 return self. subtree last position(self.left(p))
56 else:
57 # walk upward
58 walk = p
59 above = self.parent(walk)
60 while above is not None and walk == self.left(above):
61 walk = above
62 above = self.parent(walk)
63 return above
64
65 def after(self, p):
66 ”””Return the Position just after p in the natural order.
67
68 Return None if p is the last position.
69 ”””
70 # symmetric to before(p)
71
72 def ﬁnd position(self, k):
73 ”””Return position with key k, or else neighbor (or None if empty).”””
74 if self.is empty():
75 return None
76 else:
77 p = self. subtree search(self.root(), k)
78 self. rebalance access(p) # hook for balanced tree subclasses
79 return p11.1. BinarySearchTrees 471
80 def ﬁnd min(self):
81 ”””Return (key,value) pair with minimum key (or None if empty).”””
82 if self.is empty():
83 return None
84 else:
85 p = self.ﬁrst()
86 return (p.key(), p.value())
87
88 def ﬁnd ge(self, k):
89 ”””Return (key,value) pair with least key greater than or equal to k.
90
91 Return None if there does not exist such a key.
92 ”””
93 if self.is empty():
94 return None
95 else:
96 p = self.ﬁnd position(k) # may not ﬁnd exact match
97 if p.key( ) < k: # p’s key is too small
98 p = self.after(p)
99 return (p.key(), p.value()) if p is not None else None
100
101 def ﬁnd range(self, start, stop):
102 ”””Iterate all (key,value) pairs such that start <= key < stop.
103
104 If start is None, iteration begins with minimum key of map.
105 If stop is None, iteration continues through the maximum key of map.
106 ”””
107 if not self.is empty():
108 if start is None:
109 p = self.ﬁrst()
110 else:
111 # we initialize p with logic similar to ﬁnd ge
112 p = self.ﬁnd position(start)
113 if p.key( ) < start:
114 p = self.after(p)
115 while p is not None and (stop is None or p.key( ) < stop):
116 yield (p.key(), p.value())
117 p = self.after(p)472 Chapter11. SearchTrees
118 def getitem (self, k):
119 ”””Return value associated with key k (raise KeyError if not found).”””
120 if self.is empty():
121 raise KeyError( Key Error: + repr(k))
122 else:
123 p = self. subtree search(self.root(), k)
124 self. rebalance access(p) # hook for balanced tree subclasses
125 if k != p.key():
126 raise KeyError( Key Error: + repr(k))
127 return p.value()
128
129 def setitem (self, k, v):
130 ”””Assign value v to key k, overwriting existing value if present.”””
131 if self.is empty():
132 leaf = self. add root(self. Item(k,v)) # from LinkedBinaryTree
133 else:
134 p = self. subtree search(self.root(), k)
135 if p.key( ) == k:
136 p.element(). value = v # replace existing item’s value
137 self. rebalance access(p) # hook for balanced tree subclasses
138 return
139 else:
140 item = self. Item(k,v)
141 if p.key( ) < k:
142 leaf = self. add right(p, item) # inherited from LinkedBinaryTree
143 else:
144 leaf = self. add left(p, item) # inherited from LinkedBinaryTree
145 self. rebalance insert(leaf) # hook for balanced tree subclasses
146
147 def iter (self):
148 ”””Generate an iteration of all keys in the map in order.”””
149 p = self.ﬁrst()
150 while p is not None:
151 yield p.key()
152 p = self.after(p)
Code Fragment 11.7: Map operations for accessing and inserting items in the
TreeMap class. Reverse iteration can be implemented with reverse , using11.1. BinarySearchTrees 473
153 def delete(self, p):
154 ”””Remove the item at given Position.”””
155 self. validate(p) # inherited from LinkedBinaryTree
156 if self.left(p) and self.right(p): # p has two children
157 replacement = self. subtree last position(self.left(p))
158 self. replace(p, replacement.element()) # from LinkedBinaryTree
159 p = replacement
160 # now p has at most one child
161 parent = self.parent(p)
162 self. delete(p) # inherited from LinkedBinaryTree
163 self. rebalance delete(parent) # if root deleted, parent is None
164
165 def delitem (self, k):
166 ”””Remove item associated with key k (raise KeyError if not found).”””
167 if not self.is empty():
168 p = self. subtree search(self.root(), k)
169 if k == p.key():
170 self.delete(p) # rely on positional version
171 return # successful deletion complete
172 self. rebalance access(p) # hook for balanced tree subclasses
173 raise KeyError( Key Error: + repr(k))
CodeFragment11.8: Support for deleting an item from aTreeMap, located either
bypositionorbykey.
11.1.5 Performance of a Binary Search Tree
Ananalysis oftheoperations ofourTreeMapclassisgiveninTable11.1. Almost
all operations have a worst-case running time that depends on h, where h is the
heightofthecurrenttree. Thisisbecausemostoperationsrelyonaconstantamount
of work for each node along a particular path of the tree, and the maximum path
length within a tree is proportional to the height of the tree. Most notably, our
implementations of map operations getitem , setitem , and delitem
eachbeginwithacalltothe subtree searchutility whichtracesapathdownward
from the root of the tree, using O(1) time at each node to determine how to con-
tinue thesearch. Similarpaths aretracedwhenlooking forareplacement during a
deletion,orwhencomputingaposition’sinorderpredecessororsuccessor. Wenote
thatalthoughasinglecalltotheaftermethodhasworst-caserunningtimeofO(h),
the n successive calls made during a call to iter require a total of O(n) time,
sinceeachedgeistracedatmosttwice;inasense,thosecallshaveO(1)amortized
time bounds. A similar argument can be used to prove the O(s+h) worst-case474 Chapter11. SearchTrees
Operation RunningTime
k in T O(h)
T[k],T[k] = v O(h)
T.delete(p),del T[k] O(h)
T.ﬁnd position(k) O(h)
T.ﬁrst(),T.last(),T.ﬁnd min(),T.ﬁnd max() O(h)
T.before(p),T.after(p) O(h)
T.ﬁnd lt(k),T.ﬁnd le(k),T.ﬁnd gt(k),T.ﬁnd ge(k) O(h)
T.ﬁnd range(start, stop) O(s+h)
iter(T),reversed(T) O(n)
Table11.1:Worst-caserunningtimesoftheoperationsforaTreeMapT. Wedenote
thecurrentheightofthetreewithh,andthenumberofitemsreportedbyﬁnd range
ass. ThespaceusageisO(n),wherenisthenumberofitemsstoredinthemap.
AbinarysearchtreeTisthereforeanefﬁcientimplementation ofamapwithn
entriesonlyifitsheightissmall. Inthebestcase,Thasheighth=(cid:13)log(n+1)(cid:14)−1,
whichyieldslogarithmic-timeperformanceforallthemapoperations. Intheworst
case,however,Thasheightn,inwhichcaseitwouldlookandfeellikeanordered
listimplementation ofamap. Suchaworst-case conﬁguration arises, forexample,
ifweinsertitemswithkeysinincreasing ordecreasing order. (SeeFigure11.7.)
10
20
30
40
Figure11.7: Exampleofabinarysearchtreewithlinearheight,obtainedbyinsert-
ingentrieswithkeysinincreasing order.
We can nevertheless take comfort that, on average, a binary search tree with
n keys generated from a random series of insertions and removals of keys has ex-
pectedheightO(logn);thejustiﬁcationofthisstatementisbeyondthescopeofthe
book, requiring careful mathematical language to precisely deﬁne what we mean
byarandomseriesofinsertionsandremovals,andsophisticatedprobabilitytheory.
In applications where one cannot guarantee the random nature of updates, it
is better to rely on variations of search trees, presented in the remainder of this
chapter, that guarantee a worst-case height of O(logn), and thus O(logn) worst-11.2. BalancedSearchTrees 475
11.2 Balanced Search Trees
In the closing of the previous section, wenoted that ifwe could assume arandom
seriesofinsertions andremovals,thestandardbinarysearchtreesupportsO(logn)
expectedrunningtimesforthebasicmapoperations. However,wemayonlyclaim
O(n)worst-casetime,becausesomesequencesofoperationsmayleadtoanunbal-
ancedtreewithheightproportional ton.
In the remainder of this chapter, we explore four search tree algorithms that
provide stronger performance guarantees. Three of the fourdata structures (AVL
trees, splay trees, and red-black trees) are based on augmenting a standard binary
searchtreewithoccasional operations toreshapethetreeandreduceitsheight.
Theprimaryoperationtorebalanceabinarysearchtreeisknownasarotation.
During a rotation, we “rotate” a child to be above its parent, as diagrammed in
Figure11.8.
y x
x y
T T
3 1
T T T T
1 2 2 3
Figure 11.8: A rotation operation in a binary search tree. A rotation can be per-
formedtotransformtheleftformationintotheright,ortherightformationintothe
left. Notethat allkeys insubtreeT havekeys less than that ofpositionx, all keys
1
insubtree T have keys that arebetween those of positionsxand y, andall keysin
2
subtreeT havekeysthataregreaterthanthatofpositiony.
3
To maintain the binary search tree property through a rotation, we note that
if position x was a left child of position y prior to a rotation (and therefore the
key of x is less than the key of y), then y becomes the right child of x after the
rotation, and vice versa. Furthermore, we must relink the subtree of items with
keys that lie between the keys of the two positions that are being rotated. For
example, in Figure 11.8 the subtree labeled T represents items with keys that are
2
known to be greater than that of position x and less than that of position y. In the
ﬁrstconﬁguration ofthat ﬁgure,T istheright subtree ofposition x; in the second
2
conﬁguration, itistheleftsubtreeofpositiony.
Because a single rotation modiﬁes a constant number of parent-child relation-476 Chapter11. SearchTrees
In the context of a tree-balancing algorithm, a rotation allows the shape of a
tree tobe modiﬁed whilemaintaining the search tree property. Ifused wisely, this
operation can be performed to avoid highly unbalanced tree conﬁgurations. For
example, arightward rotation fromtheﬁrstformation ofFigure11.8tothesecond
reduces the depth of each node in subtree T by one, while increasing the depth
1
of each node in subtree T by one. (Note that the depth of nodes in subtreeT are
3 2
unaffected bytherotation.)
Oneormorerotationscanbecombinedtoprovidebroaderrebalancingwithina
tree. Onesuchcompoundoperationweconsiderisatrinoderestructuring. Forthis
manipulation, weconsiderapositionx,itsparenty,anditsgrandparentz. Thegoal
is to restructure the subtree rooted at z in order to reduce the overall path length
to x and its subtrees. Pseudo-code for a restructure(x) method is given in Code
Fragment11.9andillustrated inFigure11.9. Indescribingatrinode restructuring,
wetemporarily renamethe positionsx, y, andzasa,b, and c,sothat aprecedes b
and b precedes c in an inorder traversal ofT. There are four possible orientations
mapping x, y, and z to a, b, and c, as shown in Figure 11.9, which are uniﬁed
into one caseby ourrelabeling. Thetrinode restructuring replaces zwiththenode
identiﬁed asb, makes thechildren ofthisnode beaandc, and makes thechildren
of a and c be the four previous children of x, y, and z (other than x and y), while
maintaining theinorderrelationships ofallthenodesinT.
Algorithmrestructure(x):
Input: A position x of a binary search tree T that has both a parent y and a
grandparent z
Output: Tree T after a trinode restructuring (which corresponds to a single or
doublerotation) involving positionsx,y,andz
1: Let (a, b, c) be a left-to-right (inorder) listing of the positions x, y, and z, and
let (T ,T ,T ,T )be aleft-to-right (inorder) listing of the four subtrees ofx,
1 2 3 4
y,andznotrootedatx,y,orz.
2: Replacethesubtreerootedatzwithanewsubtreerootedatb.
3: LetabetheleftchildofbandletT1 andT2 betheleftandrightsubtrees ofa,
respectively.
4: Letcbethe right child ofbandlet T3 and T4 betheleft and right subtrees of
c,respectively.
CodeFragment11.9: Thetrinoderestructuring operation inabinarysearchtree.
In practice, the modiﬁcation of a tree T caused by a trinode restructuring op-
eration can be implemented through case analysis either as asingle rotation (as in
Figure 11.9a and b)oras adouble rotation (asin Figure 11.9cand d). Thedouble
rotation ariseswhenpositionxhasthemiddleofthethreerelevantkeysandisﬁrst
rotatedaboveitsparent,andthenabovewhatwasoriginallyitsgrandparent. Inany11.2. BalancedSearchTrees 477
a=z singlerotation b=y
b=y a=z c=x
c=x
T
1
T T T T T
2 1 2 3 4
T T
3 4
(a)
c=z singlerotation b=y
b=y a=x c=z
a=x
T
4
T T T T T
3 1 2 3 4
T T
1 2
(b)
a=z doublerotation b=x
c=y a=z c=y
b=x
T
1
T T T T T
4 1 2 3 4
T T
2 3
(c)
c=z doublerotation b=x
a=y a=y c=z
b=x
T
4
T T T T T
1 1 2 3 4
T T
2 3
(d)
Figure 11.9: Schematic illustration of a trinode restructuring operation: (a and b)478 Chapter11. SearchTrees
11.2.1 Python Framework for Balancing Search Trees
OurTreeMapclass,introducedinSection11.1.4,isaconcretemapimplementation
that does not perform any explicit balancing operations. However, we designed
that class to also serve as a base class for other subclasses that implement more
advanced tree-balancing algorithms. A summary of our inheritance hierarchy is
showninFigure11.10.
LinkedBinaryTree MapBase
(Section8.3.1) (Section10.1.4)
TreeMap
(Section11.1.4)
AVLTreeMap SplayTreeMap RedBlackTreeMap
(Section11.3.2) (Section11.4.3) (Section11.6.2)
Figure11.10: Ourhierarchyofbalancedsearchtrees(withreferencestowherethey
are deﬁned). Recall that TreeMap inherits multiply from LinkedBinaryTree and
MapBase.
Hooks for Rebalancing Operations
OurimplementationofthebasicmapoperationsinSection11.1.4includesstrategic
callstothreenonpublic methodsthatserveashooksforrebalancing algorithms:
• Acallto rebalance insert(p)ismadefromwithinthe setitem method
immediately afteranewnodeisaddedtothetreeatposition p.
• A call to rebalance delete(p) is made each time a node has been deleted
fromthetree,withposition pidentifying theparentofthenodethathasjust
beenremoved. Formally,thishookiscalledfromwithinthepublicdelete(p)
method,whichisindirectly invoked bythepublic delitem (k)behavior.
• Wealsoprovideahook, rebalance access(p),thatiscalledwhenanitemat
position pofatreeisaccessedthroughapublicmethodsuchas getitem .
Thishookisusedbythesplaytreestructure(seeSection11.4)torestructure
atreesothatmorefrequently accessed itemsarebrought closertotheroot.
Weprovidetrivialdeclarationsofthesethreemethods,inCodeFragment11.10,
having bodies that do nothing (using thepass statement). A subclass of TreeMap
may override any of these methods to implement a nontrivial action to rebalance
a tree. This is another example of thetemplate method design pattern, as seen in11.2. BalancedSearchTrees 479
174 def rebalance insert(self, p): pass
175 def rebalance delete(self, p): pass
176 def rebalance access(self, p): pass
CodeFragment11.10:AdditionalcodefortheTreeMapclass(continuedfromCode
Fragment11.8),providing stubsfortherebalancing hooks.
Nonpublic Methods for Rotating and Restructuring
A second form of support for balanced search trees is our inclusion of nonpub-
lic utility methods rotate and restructure that, respectively, implement a single
rotation and a trinode restructuring (described at the beginning of Section 11.2).
Although these methods are not invoked by the public TreeMap operations, we
promotecodereusebyprovidingtheseimplementationinthisclasssothattheyare
inherited byallbalanced-tree subclasses.
Our implementations are provided in Code Fragment 11.11. To simplify the
code, we deﬁne an additional relink utility that properly links parent and child
nodes to each other, including the special case in which a “child” is a None ref-
erence. The focus of the rotate method then becomes redeﬁning the relationship
betweentheparentandchild,relinkingarotatednodedirectlytoitsoriginalgrand-
parent,andshiftingthe“middle”subtree(thatlabeledasT inFigure11.8)between
2
the rotated nodes. For the trinode restructuring, we determine whether to perform
asingleordouble rotation, asoriginally described inFigure11.9.
Factory for Creating Tree Nodes
WedrawattentiontoanimportantsubtletyinthedesignofbothourTreeMapclass
and the original LinkedBinaryTree subclass. The low-level deﬁnition of a node is
provided by the nested Node class within LinkedBinaryTree. Yet, several of our
tree-balancing strategies require that auxiliary information be stored at each node
toguide thebalancing process. Thoseclasses willoverridethenested Nodeclass
toprovide storageforanadditional ﬁeld.
Whenever we add a new node to the tree, as within the add right method of
the LinkedBinaryTree (originally given in Code Fragment 8.10), we intentionally
instantiate the node using the syntax self. Node, rather than the qualiﬁed name
LinkedBinaryTree. Node. This is vital to our framework! When the expression
self. Node is applied to an instance of a tree (sub)class, Python’s nameresolution
follows the inheritance structure (as described in Section2.5.2). If a subclass has
overridden the deﬁnition for the Node class, instantiation of self. Node relies on
the newlydeﬁned node class. This technique isan example ofthe factory method
designpattern,asweprovideasubclass themeanstocontrolthetypeofnodethat480 Chapter11. SearchTrees
177 def relink(self, parent, child, make left child):
178 ”””Relink parent node with child node (we allow child to be None).”””
179 if make left child: # make it a left child
180 parent. left = child
181 else: # make it a right child
182 parent. right = child
183 if child is not None: # make child point to parent
184 child. parent = parent
185
186 def rotate(self, p):
187 ”””Rotate Position p above its parent.”””
188 x = p. node
189 y = x. parent # we assume this exists
190 z = y. parent # grandparent (possibly None)
191 if z is None:
192 self. root = x # x becomes root
193 x. parent = None
194 else:
195 self. relink(z, x, y == z. left) # x becomes a direct child of z
196 # now rotate x and y, including transfer of middle subtree
197 if x == y. left:
198 self. relink(y, x. right, True) # x. right becomes left child of y
199 self. relink(x, y, False) # y becomes right child of x
200 else:
201 self. relink(y, x. left, False) # x. left becomes right child of y
202 self. relink(x, y, True) # y becomes left child of x
203
204 def restructure(self, x):
205 ”””Perform trinode restructure of Position x with parent/grandparent.”””
206 y = self.parent(x)
207 z = self.parent(y)
208 if (x == self.right(y)) == (y == self.right(z)): # matching alignments
209 self. rotate(y) # single rotation (of y)
210 return y # y is new subtree root
211 else: # opposite alignments
212 self. rotate(x) # double rotation (of x)
213 self. rotate(x)
214 return x # x is new subtree root
CodeFragment11.11:AdditionalcodefortheTreeMapclass(continuedfromCode11.3. AVLTrees 481
11.3 AVL Trees
The TreeMap class, which uses a standard binary search tree as its data structure,
should be an efﬁcient map data structure, but its worst-case performance for the
various operations is linear time, because it is possible that a series of operations
results in atree withlinear height. In this section, wedescribe a simple balancing
strategythatguaranteesworst-caselogarithmicrunningtimeforallthefundamental
mapoperations.
Deﬁnition of an AVL Tree
The simple correction is to add a rule to the binary search tree deﬁnition that will
maintain a logarithmic height for the tree. Although we originally deﬁned the
height of a subtree rooted at position p of a tree to be the number of edges on
the longest path from p to a leaf (see Section 8.1.3), it is easier for explanation in
thissectiontoconsidertheheighttobethenumberofnodesonsuchalongestpath.
Bythis deﬁnition, a leaf position has height 1, while wetrivially deﬁne the height
ofa“null”childtobe0.
Inthissection,weconsiderthefollowingheight-balanceproperty,whichchar-
acterizesthestructure ofabinarysearchtreeT intermsoftheheightsofitsnodes.
Height-BalanceProperty: For every position p of T, the heights of the children
of pdifferbyatmost1.
Anybinary search tree T that satisﬁes the height-balance property is said to be an
AVL tree, named after the initials of its inventors: Adel’son-Vel’skii and Landis.
AnexampleofanAVLtreeisshowninFigure11.11.
4
44
2 3
17 78
1 2 1
0
32 50 88
1 1
0 0 0 0
48 62
0 0 0 0
Figure11.11: Anexample of anAVLtree. Thekeys of theitems are shown inside
the nodes, and the heights of the nodes are shown above the nodes (with empty482 Chapter11. SearchTrees
Animmediateconsequenceoftheheight-balancepropertyisthatasubtreeofan
AVLtreeisitselfanAVLtree. Theheight-balance property hasalsotheimportant
consequence ofkeepingtheheightsmall,asshowninthefollowingproposition.
Proposition 11.2: TheheightofanAVLtreestoringnentriesisO(logn).
Justiﬁcation: Instead oftrying toﬁndanupper bound on theheight ofanAVL
treedirectly, itturnsouttobeeasiertoworkonthe“inverse problem” ofﬁnding a
lowerbound ontheminimumnumber ofnodesn(h)ofanAVLtreewithheighth.
We will show that n(h) grows at least exponentially. From this, it will be an easy
steptoderivethattheheightofanAVLtreestoringnentriesisO(logn).
Webeginbynoting thatn(1)=1andn(2)=2,because anAVLtreeofheight
1 must have exactly one node and an AVL tree of height 2 must have at least two
nodes. Now, an AVLtree with the minimum number ofnodes having height hfor
h≥3, is such that both its subtrees are AVL trees with the minimum number of
nodes: one with height h−1 and the other with height h−2. Taking the root into
account,weobtainthefollowingformulathatrelatesn(h)ton(h−1)andn(h−2),
forh≥3:
n(h)=1+n(h−1)+n(h−2). (11.1)
Atthispoint,thereaderfamiliarwiththepropertiesofFibonacciprogressions(Sec-
tion 1.8 and Exercise C-3.49) will already see that n(h) is a function exponential
inh. Toformalizethatobservation, weproceedasfollows.
Formula 11.1 implies that n(h) is a strictly increasing function ofh. Thus, we
know that n(h−1)>n(h−2). Replacing n(h−1) with n(h−2) in Formula 11.1
anddropping the1,weget,forh≥3,
n(h) > 2·n(h−2). (11.2)
Formula11.2indicatesthatn(h)atleastdoubleseachtimehincreasesby2,which
intuitively meansthatn(h)growsexponentially. Toshowthisfactinaformalway,
weapplyFormula11.2repeatedly, yielding thefollowingseriesofinequalities:
n(h) > 2·n(h−2)
> 4·n(h−4)
> 8·n(h−6)
.
.
.
> 2i·n(h−2i). (11.3)
Thatis,n(h)>2i·n(h−2i),foranyintegeri,suchthath−2i≥1. Sincewealready
know the values ofn(1) and n(2), wepicki so thath−2i isequal to either 1or2.
Thatis,wepick (cid:19) (cid:20)
h
i= −1.11.3. AVLTrees 483
Bysubstituting theabovevalueofiinFormula11.3,weobtain, forh≥3,
(cid:17) (cid:19) (cid:20) (cid:18)
n(h) > 2(cid:13)2h(cid:14)−1·n h−2 h +2
2
≥ 2(cid:13)h2(cid:14)−1n(1)
≥ 2h2−1. (11.4)
BytakinglogarithmsofbothsidesofFormula11.4,weobtain
h
log(n(h)) > −1,
2
fromwhichweget
h < 2log(n(h))+2, (11.5)
whichimpliesthatanAVLtreestoringnentrieshasheightatmost2logn+2.
ByProposition11.2andtheanalysisofbinarysearchtreesgiveninSection11.1,
the operation getitem , in a map implemented with an AVLtree, runs in time
O(logn), where n is the number of items in the map. Of course, we still have to
showhowtomaintaintheheight-balance property afteraninsertion ordeletion.
11.3.1 Update Operations
Given a binary search tree T, we say that a position is balanced if the absolute
value ofthedifference between theheights ofitschildren isatmost1,and wesay
that it is unbalanced otherwise. Thus, the height-balance property characterizing
AVLtreesisequivalent tosayingthateverypositionisbalanced.
TheinsertionanddeletionoperationsforAVLtreesbeginsimilarlytothecorre-
spondingoperationsfor(standard)binarysearchtrees,butwithpost-processing for
each operation to restore the balance of any portions of the tree that are adversely
affectedbythechange.
Insertion
SupposethattreeT satisﬁestheheight-balance property,andhenceisanAVLtree,
prior to the insertion of a new item. Aninsertion of a new itemin a binary search
tree,asdescribed inSection11.1.3, resultsinanewnodeataleafposition p. This
action may violate the height-balance property (see, for example, Figure 11.12a),
yet the only positions that may become unbalanced are ancestors of p, because
those are the only positions whose subtrees have changed. Therefore, let us de-484 Chapter11. SearchTrees
5 4
44 44
2 4 2 3
17 78 z 17 62 x
1 3 1 1 2 2
0 32 50 y 88 0 32 50 y 78 z
1 2 1 1 1
0 0 48 62 x 0 0 0 0 48 54 0 88
1
T4 T3
0 0 54 0 0 0 0 0 0 0
T1 T3 T1 T2 T4
0 0
(a) T2 (b)
Figure 11.12: An example insertion of an item with key 54 in the AVL tree of
Figure 11.11: (a) after adding a new node for key 54, the nodes storing keys 78
and 44 become unbalanced; (b) a trinode restructuring restores the height-balance
property. We show the heights of nodes above them, and we identify the nodes x,
y,andzandsubtreesT ,T ,T ,andT participating inthetrinoderestructuring.
1 2 3 4
We restore the balance of the nodes in the binary search tree T by a simple
“search-and-repair” strategy. Inparticular,letzbetheﬁrstpositionweencounterin
goingupfrom ptowardtherootofT suchthatzisunbalanced(seeFigure11.12a.)
Also, let y denote the child of z with higher height (and note that y must be an
ancestor of p). Finally, letxbethechildofywithhigher height (there cannot bea
tie and position x must also be an ancestor of p, possibly p itself). We rebalance
thesubtreerootedatzbycallingthetrinoderestructuringmethod,restructure(x),
originally described in Section 11.2. An example of such a restructuring in the
contextofanAVLinsertion isportrayed inFigure11.12.
To formally argue the correctness of this process in reestablishing the AVL
height-balanceproperty,weconsidertheimplicationofzbeingthenearestancestor
of p that became unbalanced after the insertion of p. It must be that the height
of y increased by one due to the insertion and that it is now 2 greater than its
sibling. Since y remains balanced, it must be that it formerly had subtrees with
equal heights, and that the subtree containing x has increased its height by one.
That subtree increased either because x= p, and thus its height changed from 0
to 1, or because x previously had equal-height subtrees and the height of the one
containing phasincreasedby1. Lettingh≥0denotetheheightofthetallestchild
ofx,thisscenariomightbeportrayed asinFigure11.13.
After the trinode restructuring, we see that each of x, y, and z has become
balanced. Furthermore, the node that becomes the root of the subtree after the
restructuring has height h+2, which is precisely the height that z had before the
insertion of the new item. Therefore, any ancestor of z that became temporarily
unbalanced becomesbalancedagain,andthisonerestructuring restorestheheight-11.3. AVLTrees 485
h+2
h+1
h z
h
y h
h−1 x h−1
T
1
T
4
T T
2 3
(a)
h+3
h+2
h z
h+1
y h
h−1 x h
T
1
T
4
T
2
T
3
(b)
h+2
h+1 h+1
x
h z h−1 h y h
T
2
T T T
1 3 4
(c)
Figure11.13: Rebalancing ofasubtree during atypical insertion intoanAVLtree:
(a) before the insertion; (b) after an insertion in subtree T causes imbalance at z;
3
(c)afterrestoring balancewithtrinoderestructuring. Noticethattheoverallheight486 Chapter11. SearchTrees
Deletion
Recall that a deletion from a regular binary search tree results in the structural
removal of a node having either zero or one children. Such a change may violate
the height-balance property in an AVL tree. In particular, if position p represents
theparent oftheremoved node intreeT, there maybean unbalanced node onthe
pathfrom ptotherootofT. (SeeFigure11.14a.) Infact,therecanbeatmostone
suchunbalanced node. (Thejustiﬁcation ofthisfactisleftasExerciseC-11.49.)
4 4
44 z 62 y
1 3 3 2
17 62 y z 44 78 x
2 2 1 2 1
0 0 32 50 78 x 17 50 88
0
1 1 1 1 1
T1
48 54 0 88 0 0 48 54 T3 0 0
T3 T1 T4
0 0 0 0 0 0 0 0 0 0
T2 T4 T2
(a) (b)
Figure11.14: Deletionoftheitemwithkey32fromtheAVLtreeofFigure11.12b:
(a) after removing the node storing key 32, the root becomes unbalanced; (b) a
(single)rotation restorestheheight-balance property.
Aswithinsertion, weusetrinode restructuring torestore balance inthetreeT.
In particular, let z be the ﬁrst unbalanced position encountered going up from p
toward the root of T. Also, let y be the child of z with larger height (note that
position y is the child of z that is not an ancestor of p), and let x be the child of y
deﬁned as follows: If one of the children of y is taller than the other, let x be the
tallerchildofy;else(bothchildren ofyhavethesameheight), letxbethechildof
y on the same side as y (that is, if y is the left child of z, let x be the left child of
y, else let x be the right child ofy). In any case, wethen perform arestructure(x)
operation. (SeeFigure11.14b.)
The restructured subtree is rooted at the middle position denoted as b in the
description of the trinode restructuring operation. The height-balance property is
guaranteed to be locally restored within the subtree of b. (See Exercises R-11.11
andR-11.12). Unfortunately,thistrinoderestructuringmayreducetheheightofthe
subtree rooted atbby1,whichmaycauseanancestor ofbtobecomeunbalanced.
So,afterrebalancingz,wecontinuewalkingupT lookingforunbalancedpositions.
If we ﬁnd another, we perform a restructure operation to restore its balance, and
continue marching up T looking for more, all the way to the root. Still, since the
height of T is O(logn), where n is the number of entries, by Proposition 11.2,11.3. AVLTrees 487
Performance of AVL Trees
By Proposition 11.2, the height of an AVL tree with n items is guaranteed to be
O(logn). Because the standard binary search tree operation had running times
bounded by the height (see Table 11.1), and because the additional work in main-
tainingbalancefactorsandrestructuring anAVLtreecanbeboundedbythelength
of a path in the tree, the traditional map operations run in worst-case logarithmic
time with an AVL tree. We summarize these results in Table 11.2, and illustrate
thisperformance inFigure11.15.
Operation RunningTime
k in T O(logn)
T[k] = v O(logn)
T.delete(p),del T[k] O(logn)
T.ﬁnd position(k) O(logn)
T.ﬁrst(),T.last(),T.ﬁnd min(),T.ﬁnd max() O(logn)
T.before(p),T.after(p) O(logn)
T.ﬁnd lt(k),T.ﬁnd le(k),T.ﬁnd gt(k),T.ﬁnd ge(k) O(logn)
T.ﬁnd range(start, stop) O(s+logn)
iter(T),reversed(T) O(n)
Table11.2: Worst-case running times of operations for ann-item sorted map real-
izedasanAVLtreeT,withsdenotingthenumberofitemsreportedbyﬁnd range.
Height Timeperlevel
O(1)
AVLTreeT:
O(1)
O(logn)
downphase
O(1)
upphase
Worst-casetime:O(logn)
Figure11.15: Illustrating therunning timeofsearches andupdates inanAVLtree.
The time performance is O(1) per level, broken into a down phase, which typi-
callyinvolvessearching,andanupphase,whichtypicallyinvolvesupdatingheight488 Chapter11. SearchTrees
11.3.2 Python Implementation
A complete implementation of an AVLTreeMap class is provided in Code Frag-
ments 11.12 and 11.13. It inherits from the standard TreeMap class and relies on
the balancing framework described in Section 11.2.1. Wehighlight twoimportant
aspects of our implementation. First, the AVLTreeMap overrides the deﬁnition of
thenested Nodeclass,asshowninCodeFragment11.12,inordertoprovidesup-
port for storing the height of the subtree stored at anode. Wealso provide several
utilities involving heights ofnodes, andthecorresponding positions.
Toimplement thecorelogic oftheAVLbalancing strategy, wedeﬁneautility,
named rebalance,thatsufﬁcesasahookforrestoringtheheight-balance property
after an insertion or a deletion. Although the inherited behaviors for insertion and
deletion are quite different, the necessary post-processing for an AVL tree can be
uniﬁed. In both cases, we trace an upward path from the position p at which the
changetookplace,recalculating theheightofeachpositionbasedonthe(updated)
heightsofitschildren, andusingatrinoderestructuring operationifanimbalanced
position is reached. If we reach an ancestor with height that is unchanged by the
overall map operation, or if we perform a trinode restructuring that results in the
subtree having the same height it had before the map operation, we stop the pro-
cess;nofurtherancestor’sheightwillchange. Todetectthestoppingcondition, we
recordthe“old”heightofeachnodeandcompareittothenewlycalculatedheight.
1 class AVLTreeMap(TreeMap):
2 ”””Sorted map implementation using an AVL tree.”””
3
4 #-------------------------- nested Node class --------------------------
5 class Node(TreeMap. Node):
6 ”””Node class for AVL maintains height value for balancing.”””
7 slots = _height # additional data member to store height
8
9 def init (self, element, parent=None, left=None, right=None):
10 super(). init (element, parent, left, right)
11 self. height = 0 # will be recomputed during balancing
12
13 def left height(self):
14 return self. left. height if self. left is not None else 0
15
16 def right height(self):
17 return self. right. height if self. right is not None else 011.3. AVLTrees 489
18 #------------------------- positional-based utility methods -------------------------
19 def recompute height(self, p):
20 p. node. height = 1 + max(p. node.left height(), p. node.right height())
21
22 def isbalanced(self, p):
23 return abs(p. node.left height( ) − p. node.right height()) <= 1
24
25 def tall child(self, p, favorleft=False): # parameter controls tiebreaker
26 if p. node.left height( ) + (1 if favorleft else 0) > p. node.right height():
27 return self.left(p)
28 else:
29 return self.right(p)
30
31 def tall grandchild(self, p):
32 child = self. tall child(p)
33 # if child is on left, favor left grandchild; else favor right grandchild
34 alignment = (child == self.left(p))
35 return self. tall child(child, alignment)
36
37 def rebalance(self, p):
38 while p is not None:
39 old height = p. node. height # trivially 0 if new node
40 if not self. isbalanced(p): # imbalance detected!
41 # perform trinode restructuring, setting p to resulting root,
42 # and recompute new local heights after the restructuring
43 p = self. restructure(self. tall grandchild(p))
44 self. recompute height(self.left(p))
45 self. recompute height(self.right(p))
46 self. recompute height(p) # adjust for recent changes
47 if p. node. height == old height: # has height changed?
48 p = None # no further changes needed
49 else:
50 p = self.parent(p) # repeat with parent
51
52 #---------------------------- override balancing hooks ----------------------------
53 def rebalance insert(self, p):
54 self. rebalance(p)
55
56 def rebalance delete(self, p):
57 self. rebalance(p)490 Chapter11. SearchTrees
11.4 Splay Trees
Thenextsearchtreestructurewestudyisknownasaasplaytree. Thisstructureis
conceptually quitedifferent fromtheotherbalanced searchtreeswediscussinthis
chapter, forasplay treedoes notstrictly enforce alogarithmic upper bound onthe
heightofthetree. Infact,therearenoadditionalheight,balance,orotherauxiliary
dataassociated withthenodesofthistree.
The efﬁciency of splay trees is due to a certain move-to-root operation, called
splaying, that is performed at the bottommost position p reached during every in-
sertion, deletion, or even a search. (In essence, this is a tree variant of the move-
to-front heuristic that we explored for lists in Section 7.6.2.) Intuitively, a splay
operation causes more frequently accessed elements to remain nearer to the root,
thereby reducing the typical search times. The surprising thing about splaying is
that it allows us to guarantee a logarithmic amortized running time, for insertions,
deletions, andsearches.
11.4.1 Splaying
Given a node x of a binary search tree T, wesplay x by moving x to the root of T
through asequence ofrestructurings. Theparticular restructurings weperform are
important, for it is not sufﬁcient to move x to the root of T by just any sequence
of restructurings. The speciﬁc operation we perform to movex up depends upon
therelativepositionsofx,itsparenty,and(ifitexists)x’sgrandparentz. Thereare
threecasesthatweconsider.
zig-zig: The node x and its parent y are both left children or both right children.
(See Figure 11.16.) We promote x, making y a child of x and z a child of y,
whilemaintaining theinorderrelationships ofthenodesinT.
10 30
z x
20 20
y y
30 10
x z
T T
1 4
T T
2 3
T T T T
3 4 1 2
(a) (b)
Figure11.16: Zig-zig: (a) before; (b) after. There is another symmetric conﬁgura-11.4. SplayTrees 491
zig-zag: One of x and y is a left child and the other is a right child. (See Fig-
ure 11.17.) In this case, we promote x by making x have y and z as its chil-
dren,whilemaintaining theinorderrelationships ofthenodesinT.
10
z
30 20
y x
20 10 30
x z y
T
1
T
4
T T T T T T
2 3 1 2 3 4
(a) (b)
Figure11.17: Zig-zag: (a) before; (b)after. There isanother symmetric conﬁgura-
tionwherexisarightchildandyisaleftchild.
zig: xdoes nothave agrandparent. (SeeFigure11.18.) Inthiscase, weperform a
single rotation topromotexovery,makingyachildofx,whilemaintaining
therelativeinorderrelationships ofthenodesinT.
10 20
y x
20 10
x y
T T
1 3
T T T T
2 3 1 2
(a) (b)
Figure11.18: Zig: (a) before; (b) after. There is another symmetric conﬁguration
wherexisoriginally aleftchildofy.
Weperform azig-zigorazig-zag whenxhasagrandparent, andweperform a
zigwhenxhasaparentbutnotagrandparent. Asplayingstepconsistsofrepeating
theserestructurings atxuntilxbecomestherootofT. Anexampleofthesplaying492 Chapter11. SearchTrees
8
3 10
4 11
6 12
5 7 16
13 17
14
(a)
8
3 10
4 11
6 12
5 7 14
13 16
17
(b)
8
3 10
4 11
6 12
5 7 14
13 16
17
(c)
Figure11.19: Example of splaying a node: (a) splaying the node storing 14 starts
withazig-zag; (b)after the zig-zag; (c)the nextstep willbeazig-zig. (Continues11.4. SplayTrees 493
8
3 10
4 14
6 12 16
5 7 11 13 17
(d)
8
3 10
4 14
6 12 16
5 7 11 13 17
(e)
14
10 16
8 12 17
3 11 13
4
6
5 7
(f)
Figure11.20: Example of splaying a node:(d) after the zig-zig; (e) the next step is494 Chapter11. SearchTrees
11.4.2 When to Splay
Therulesthatdictatewhensplaying isperformedareasfollows:
• When searching for key k, if k is found at position p, we splay p, else we
splay the leaf position at which the search terminates unsuccessfully. For
example, the splaying in Figures 11.19 and 11.20 would be performed after
searching successfully forkey14orunsuccessfully forkey15.
• When inserting key k, we splay the newly created internal node where k
gets inserted. For example, the splaying in Figures 11.19 and 11.20 would
be performed if 14 were the newly inserted key. We show a sequence of
insertions inasplaytreeinFigure11.21.
1 1 3
3 1
(a) (b) (c)
3 2 2
1 1 3 1 3
2 4
(d) (e) (f)
4
3
2
1
(g)
Figure 11.21: A sequence of insertions in a splay tree: (a) initial tree; (b) after
inserting 3,butbeforeazigstep;(c)aftersplaying; (d)afterinserting2,butbefore
a zig-zag step; (e) after splaying; (f) after inserting 4, but before a zig-zig step;11.4. SplayTrees 495
• When deleting a key k, we splay the position p that is the parent of the re-
movednode;recallthatbytheremovalalgorithm forbinarysearchtrees,the
removednodemaybethatoriginallycontainingk,oradescendantnodewith
areplacement key. Anexampleofsplaying following adeletion isshownin
Figure11.22.
8
7
3 10 3 10
7
4 11 4 11
p
6 6
w
5 5
(a) (b)
7
7
6 10
6 10
4 11
4 11
3 5
3 5
(c) (d)
6
4 7
3 5 10
11
(e)
Figure11.22: Deletion from a splay tree: (a) the deletion of 8 from the root node
is performed by moving to the root the key of its inorder predecessor w, deleting
w,andsplaying theparent pofw;(b)splaying pstartswithazig-zig; (c)after the496 Chapter11. SearchTrees
11.4.3 Python Implementation
Although the mathematical analysis of a splay tree’s performance is complex (see
Section 11.4.4), the implementation of splay trees is a rather simple adaptation to
a standard binary search tree. Code Fragment 11.14 provides a complete imple-
mentationofaSplayTreeMapclass,basedupontheunderlyingTreeMapclassand
useofthebalancing frameworkdescribed inSection11.2.1. Itisimportant tonote
that our original TreeMap class makes calls to the rebalance access method, not
justfromwithinthe getitem method,butalsoduring setitem whenmod-
ifying the value associated with anexisting key, and after any mapoperations that
resultinafailedsearch.
1 class SplayTreeMap(TreeMap):
2 ”””Sorted map implementation using a splay tree.”””
3 #--------------------------------- splay operation --------------------------------
4 def splay(self, p):
5 while p != self.root():
6 parent = self.parent(p)
7 grand = self.parent(parent)
8 if grand is None:
9 # zig case
10 self. rotate(p)
11 elif (parent == self.left(grand)) == (p == self.left(parent)):
12 # zig-zig case
13 self. rotate(parent) # move PARENT up
14 self. rotate(p) # then move p up
15 else:
16 # zig-zag case
17 self. rotate(p) # move p up
18 self. rotate(p) # move p up again
19
20 #---------------------------- override balancing hooks ----------------------------
21 def rebalance insert(self, p):
22 self. splay(p)
23
24 def rebalance delete(self, p):
25 if p is not None:
26 self. splay(p)
27
28 def rebalance access(self, p):
29 self. splay(p)11.4. SplayTrees 497
(cid:2)
11.4.4 Amortized Analysis of Splaying
Afterazig-zig orzig-zag, thedepthofposition pdecreases bytwo,andafterazig
the depth of p decreases by one. Thus, if p has depth d, splaying p consists of a
sequence of (cid:16)d/2(cid:17) zig-zigs and/or zig-zags, plus one ﬁnal zig ifd is odd. Since a
singlezig-zig, zig-zag, orzigaffectsaconstant numberofnodes, itcanbedonein
O(1) time. Thus, splaying a position p in a binary search tree T takes time O(d),
where d is thedepth of pinT. Inother words, the timeforperforming asplaying
stepforaposition pisasymptoticallythesameasthetimeneededjusttoreachthat
position inatop-downsearchfromtherootofT.
Worst-Case Time
In the worst case, the overall running time of a search, insertion, or deletion in a
splay tree of height h is O(h), since the position we splay might be the deepest
position in the tree. Moreover, it is possible forh to be as large as n, as shown in
Figure11.21. Thus,fromaworst-casepointofview,asplaytreeisnotanattractive
datastructure.
In spite of its poor worst-case performance, a splay tree performs well in an
amortized sense. That is, in a sequence of intermixed searches, insertions, and
deletions, eachoperationtakesonaveragelogarithmictime. Weperformtheamor-
tizedanalysis ofsplaytreesusingtheaccounting method.
Amortized Performance of Splay Trees
Forouranalysis,wenotethatthetimeforperformingasearch,insertion,ordeletion
is proportional to the time for the associated splaying. So let us consider only
splaying time.
Let T be a splay tree with n keys, and let w be a node of T. We deﬁne the
size n(w) of w as the number of nodes in the subtree rooted at w. Note that this
deﬁnition implies that the size of a nonleaf node is one more than the sum of the
sizesofitschildren. Wedeﬁnetherankr(w)ofanodewasthelogarithminbase2
ofthesizeofw,thatis,r(w)=log(n(w)). Clearly,therootofT hasthemaximum
size,n,andthemaximumrank,logn,whileeachleafhassize1andrank0.
We use cyber-dollars to pay for the work we perform in splaying a position p
in T, and we assume that one cyber-dollar pays for a zig, while twocyber-dollars
pay for a zig-zig or a zig-zag. Hence, the cost of splaying a position at depth d is
d cyber-dollars. Wekeepavirtualaccountstoringcyber-dollars ateachpositionof
T. Notethatthisaccountexistsonlyforthepurposeofouramortizedanalysis, and498 Chapter11. SearchTrees
An Accounting Analysis of Splaying
When weperform asplaying, wepay a certain number of cyber-dollars (the exact
valueofthepaymentwillbedeterminedattheendofouranalysis). Wedistinguish
threecases:
• Ifthepaymentisequaltothesplaying work,thenweuseitalltopayforthe
splaying.
• Ifthepaymentisgreaterthanthesplayingwork,wedeposittheexcessinthe
accounts ofseveralnodes.
• Ifthepaymentislessthanthesplayingwork,wemakewithdrawalsfromthe
accounts ofseveralnodestocoverthedeﬁciency.
WeshowbelowthatapaymentofO(logn)cyber-dollars peroperationissufﬁcient
to keep the system working, that is, to ensure that each node keeps a nonnegative
accountbalance.
An Accounting Invariant for Splaying
We use a scheme in which transfers are made between the accounts of the nodes
toensurethattherewillalwaysbeenoughcyber-dollars towithdrawforpayingfor
splaying workwhenneeded.
In order to use the accounting method to perform our analysisof splaying, we
maintainthefollowinginvariant:
Beforeandafterasplaying,eachnodewofT hasr(w)cyber-dollars
initsaccount.
Notethattheinvariant is“ﬁnancially sound,”sinceitdoesnotrequireustomakea
preliminary deposittoendowatreewithzerokeys.
Letr(T)bethesumoftheranksofallthenodesofT. Topreservetheinvariant
afterasplaying, wemustmakeapaymentequaltothesplayingworkplusthetotal
changeinr(T). Werefertoasinglezig,zig-zig, orzig-zagoperation inasplaying
as asplaying substep. Also, wedenote the rank of a nodew ofT before and after
a splaying substep with r(w) and r(cid:2)(w), respectively. The following proposition
gives an upper bound on the change of r(T) caused by a single splaying substep.
Wewillrepeatedlyusethislemmainouranalysisofafullsplayingofanodetothe11.4. SplayTrees 499
Proposition 11.3: Letδbethevariationofr(T)causedbyasinglesplayingsub-
step(azig,zig-zig,orzig-zag)foranodexinT.Wehavethefollowing:
• δ≤3(r(cid:2)(x)−r(x))−2ifthesubstepisazig-zigorzig-zag.
• δ≤3(r(cid:2)(x)−r(x))ifthesubstepisazig.
Justiﬁcation: Weuse thefact (see Proposition B.1, Appendix A)that, ifa>0,
b>0,andc>a+b,
loga+logb<2logc−2. (11.6)
Letusconsider thechangeinr(T)caused byeachtypeofsplaying substep.
zig-zig: (Recall Figure 11.16.) Since the size of each node is one more than the
size of its two children, note that only the ranks of x, y, and z change in a
zig-zig operation, where y is the parent of x and z is the parent of y. Also,
r(cid:2)(x)=r(z),r(cid:2)(y)≤r(cid:2)(x),andr(x)≤r(y). Thus,
δ = r(cid:2)(x)+r(cid:2)(y)+r(cid:2)(z)−r(x)−r(y)−r(z)
= r(cid:2)(y)+r(cid:2)(z)−r(x)−r(y)
≤ r(cid:2)(x)+r(cid:2)(z)−2r(x). (11.7)
Note that n(x)+n(cid:2)(z)<n(cid:2)(x). Thus, r(x)+r(cid:2)(z)<2r(cid:2)(x)−2, as per For-
mula11.6;thatis,
r(cid:2)(z)<2r(cid:2)(x)−r(x)−2.
Thisinequality andFormula11.7imply
δ ≤ r(cid:2)(x)+(2r(cid:2)(x)−r(x)−2)−2r(x)
≤ 3(r(cid:2)(x)−r(x))−2.
zig-zag: (Recall Figure 11.17.) Again, bythe deﬁnition ofsize and rank, only the
ranksofx,y,andzchange,whereydenotestheparentofxandzdenotesthe
parentofy. Also,r(x)<r(y)<r(z)=r(cid:2)(x). Thus,
δ = r(cid:2)(x)+r(cid:2)(y)+r(cid:2)(z)−r(x)−r(y)−r(z)
= r(cid:2)(y)+r(cid:2)(z)−r(x)−r(y)
≤ r(cid:2)(y)+r(cid:2)(z)−2r(x). (11.8)
Note that n(cid:2)(y)+n(cid:2)(z)<n(cid:2)(x); hence, r(cid:2)(y)+r(cid:2)(z)<2r(cid:2)(x)−2, as per For-
mula11.6. Thus,
δ ≤ 2r(cid:2)(x)−2−2r(x)
= 2(r(cid:2)(x)−r(x))−2≤3(r(cid:2)(x)−r(x))−2.
zig: (Recall Figure11.18.) Inthis case, only the ranks ofxand ychange, wherey
denotes theparentofx. Also,r(cid:2)(y)≤r(y)andr(cid:2)(x)≥r(x). Thus,
δ = r(cid:2)(y)+r(cid:2)(x)−r(y)−r(x)
≤ r(cid:2)(x)−r(x)500 Chapter11. SearchTrees
Proposition 11.4: LetT beasplaytreewithroott,andletΔbethetotalvariation
ofr(T)causedbysplayinganodexatdepthd.Wehave
Δ≤3(r(t)−r(x))−d+2.
Justiﬁcation: Splaying node x consists of c= (cid:13)d/2(cid:14) splaying substeps, each
of which is a zig-zig or a zig-zag, except possibly the last one, which is a zig if
d is odd. Let r (x)=r(x) be the initial rank of x, and for i=1,...,c, let r(x) be
0 i
the rank of x after the ith substep and δ be the variation of r(T) caused by the ith
i
substep. ByProposition 11.3,thetotalvariationΔofr(T)caused bysplayingxis
c
Δ = ∑δ
i
i=1
c
≤ 2+∑3(ri(x)−ri−1(x))−2
i=1
= 3(r (x)−r (x))−2c+2
c 0
≤ 3(r(t)−r(x))−d+2.
ByProposition 11.4, ifwemake apayment of3(r(t)−r(x))+2 cyber-dollars
towards the splaying of node x, we have enough cyber-dollars to maintain the in-
variant, keeping r(w) cyber-dollars at each node w in T, and pay for the entire
splaying work, which costs d cyber-dollars. Since the size of the root t is n, its
rank r(t) = logn. Given that r(x) ≥ 0, the payment to be made for splaying is
O(logn) cyber-dollars. Tocomplete our analysis, wehave tocomputethe cost for
maintaining theinvariant whenanodeisinserted ordeleted.
When inserting a new node w into a splay tree with n keys, the ranks of all
the ancestors of w are increased. Namely, let w ,w,...,w be the ancestors of w,
0 i d
where w0 =w, wi is the parent of wi−1, and wd is the root. For i=1,...,d, let
n(cid:2)(w) and n(w) be the size of w before and after the insertion, respectively, and
i i i
letr(cid:2)(w)andr(w)betherankofw beforeandaftertheinsertion. Wehave
i i i
n(cid:2)(w)=n(w)+1.
i i
Also, since n(wi)+1≤n(wi+1), for i=0,1,...,d−1, we have the following for
eachiinthisrange:
r(cid:2)(wi)=log(n(cid:2)(wi))=log(n(wi)+1)≤log(n(wi+1))=r(wi+1).
Thus,thetotalvariation ofr(T)causedbytheinsertion is
d (cid:9) (cid:10) d−1
∑ r(cid:2)(wi)−r(wi) ≤ r(cid:2)(wd)+ ∑ (r(wi+1)−r(wi))
i=1 i=1
= r(cid:2)(w )−r(w )
d 0
≤ logn.
Therefore,apaymentofO(logn)cyber-dollarsissufﬁcienttomaintaintheinvariant11.4. SplayTrees 501
When deleting anode w from a splay tree withn keys, the ranks of all the an-
cestors ofwaredecreased. Thus,thetotalvariation ofr(T)caused bythedeletion
is negative, and we do not need to make any payment to maintain the invariant
when a node is deleted. Therefore, we may summarize our amortized analysis in
thefollowingproposition (whichissometimescalledthe“balanceproposition” for
splaytrees):
Proposition 11.5: Considerasequenceofmoperationsonasplaytree,eachone
asearch,insertion,ordeletion,startingfromasplaytreewithzerokeys.Also,let
n bethenumberofkeysinthetreeafteroperationi,andnbethetotalnumberof
i
insertions.Thetotalrunningtimeforperformingthesequenceofoperationsis
(cid:21) (cid:22)
m
O m+∑logn ,
i
i=1
whichisO(mlogn).
In other words, the amortized running time of performing a search, insertion,
or deletion in a splay tree is O(logn), where n is the size of the splay tree at the
time. Thus, a splay tree can achieve logarithmic-time amortized performance for
implementing asorted mapADT. Thisamortized performance matchestheworst-
case performance of AVL trees, (2,4) trees, and red-black trees, but it does so
using asimple binary tree that does not need anyextra balance information stored
at each of its nodes. In addition, splay trees have a number of other interesting
properties thatarenotsharedbytheseotherbalanced searchtrees. Weexploreone
such additional property in the following proposition (which is sometimes called
the“StaticOptimality”proposition forsplaytrees):
Proposition 11.6: Considerasequenceofmoperationsonasplaytree,eachone
asearch,insertion,ordeletion,startingfromasplaytreeT withzerokeys.Also,let
f(i)denotethenumberoftimestheentryiisaccessedinthesplaytree,thatis,its
frequency,andletndenotethetotalnumberofentries.Assumingthateachentryis
accessedatleastonce,thenthetotalrunningtimeforperformingthesequenceof
operationsis
(cid:21) (cid:22)
n
O m+∑ f(i)log(m/f(i)) .
i=1
Weomittheproofofthisproposition,butitisnotashardtojustifyasonemight
imagine. The remarkable thing is that this proposition states that the amortized502 Chapter11. SearchTrees
11.5 (2,4) Trees
Inthissection, weconsider adatastructure knownasa(2,4)tree. Itisaparticular
example of a more general structure known as a multiway search tree, in which
internal nodes may have more than two children. Other forms of multiway search
treeswillbediscussed inSection15.3.
11.5.1 Multiway Search Trees
Recallthatgeneraltreesaredeﬁnedsothatinternalnodesmayhavemanychildren.
Inthissection, wediscuss howgeneraltreescanbeusedasmultiwaysearch trees.
Mapitemsstoredinasearchtreearepairsoftheform(k,v),wherekisthekeyand
visthevalueassociated withthekey.
Deﬁnition of a Multiway Search Tree
Letw be a node of an ordered tree. Wesay thatw is a d-node if w has d children.
We deﬁne a multiway search tree to be an ordered tree T that has the following
properties, whichareillustrated inFigure11.23a:
• EachinternalnodeofT hasatleasttwochildren. Thatis,eachinternalnode
isad-nodesuchthatd≥2.
• Eachinternald-node wofT withchildren c ,...,c stores anordered setof
1 d
d−1key-valuepairs(k1,v1),...,(kd−1,vd−1),wherek1≤···≤kd−1.
• Let us conventionally deﬁne k =−∞ and k =+∞. For each item (k,v)
0 d
stored at a node in the subtree of w rooted at c, i=1,...,d, we have that
i
ki−1 ≤k≤ki.
That is, if wethink ofthe set of keys stored atwas including the special ﬁctitious
keys k =−∞ and k =+∞, then a key k stored in the subtree of T rooted at a
0 d
child node c must be “in between” two keys stored at w. This simple viewpoint
i
gives rise to the rule that a d-node stores d−1 regular keys, and it also forms the
basisofthealgorithm forsearching inamultiwaysearchtree.
By the above deﬁnition, the external nodes of a multiway search do not store
anydata andserve only as“placeholders.” These external nodes can be efﬁciently
represented by None references, as has been our convention with binary search
trees (Section 11.1). However, for the sake of exposition, we will discuss these
as actual nodes that do not store anything. Based on this deﬁnition, there is an
interesting relationship between the number of key-value pairs and the number of
externalnodesinamultiwaysearchtree.
Proposition 11.7: Ann-itemmultiwaysearchtreehasn+1externalnodes.11.5. (2,4)Trees 503
22
5 10 25
3 4 6 8 14 23 24 27
11 13 17
(a)
22
5 10 25
3 4 6 8 14 23 24 27
11 13 17
(b)
22
5 10 25
3 4 6 8 14 23 24 27
11 13 17
(c)
Figure11.23: (a)AmultiwaysearchtreeT;(b)searchpathinT forkey12(unsuc-504 Chapter11. SearchTrees
Searching in a Multiway Tree
SearchingforanitemwithkeykinamultiwaysearchtreeT issimple. Weperform
suchasearchbytracingapathinT startingattheroot. (SeeFigure11.23bandc.)
Whenweareatad-nodewduringthissearch,wecomparethekeykwiththekeys
k1,...,kd−1 stored atw. Ifk=ki for somei, the search issuccessfully completed.
Otherwise, we continue the search in the child ci of w such that ki−1 < k < ki.
(Recall that we conventionally deﬁne k = −∞ and k = +∞.) If we reach an
0 d
external node, then we know that there is no item with keyk in T, and the search
terminatesunsuccessfully.
Data Structures for Representing Multiway Search Trees
InSection 8.3.3, wediscuss alinked data structure for representing ageneral tree.
This representation can also be used for a multiway search tree. When using a
general tree to implement a multiway search tree, we must store at each node one
ormorekey-valuepairsassociated withthatnode. Thatis,weneedtostorewithw
areference tosomecollection thatstorestheitemsforw.
During a search for key k in a multiway search tree, the primary operation
neededwhennavigatinganodeisﬁndingthesmallestkeyatthatnodethatisgreater
than or equal to k. For this reason, it is natural to model the information at a
node itself as a sorted map, allowing use of the ﬁnd ge(k) method. We say such
a map serves as a secondary data structure to support the primary data structure
represented by the entire multiway search tree. This reasoning may at ﬁrst seem
like a circular argument, since we need a representation of a(secondary) ordered
maptorepresent a(primary) ordered map. Wecanavoid anycircular dependence,
however, byusing thebootstrapping technique, whereweuseasimplesolution to
aproblem tocreateanew,moreadvanced solution.
In the context of a multiway search tree, a natural choice for the secondary
structure ateachnode istheSortedTableMapofSection 10.3.1. Because wewant
to determine the associated value in case of a match for keyk, and otherwise the
corresponding child ci such that ki−1 < k < ki, we recommend having each key
k in the secondary structure map to the pair (v,c). With such a realization of a
i i i
multiway search tree T, processing a d-node w while searching for an item of T
withkeyk canbeperformed using abinary search operation inO(logd)time. Let
d denotethemaximumnumberofchildrenofanynodeofT,andlethdenotethe
max
height of T. The search time in a multiway search tree is therefore O(hlogd ).
max
Ifd isaconstant, therunningtimeforperforming asearchisO(h).
max
Theprimary efﬁciency goal for amultiway search tree istokeep theheight as
smallaspossible. Wenextdiscussastrategythatcapsd at4whileguaranteeing
max11.5. (2,4)Trees 505
11.5.2 (2,4)-Tree Operations
Amultiwaysearchtreethatkeepsthesecondarydatastructuresstoredateachnode
smallandalsokeepstheprimarymultiwaytreebalancedisthe(2,4)tree,whichis
sometimes called a 2-4 tree or 2-3-4 tree. This data structure achieves these goals
bymaintaining twosimpleproperties (seeFigure11.24):
SizeProperty: Everyinternalnodehasatmostfourchildren.
DepthProperty: Alltheexternalnodeshavethesamedepth.
12
5 10 15
3 4 6 7 8 11 13 14 17
Figure11.24: A(2,4)tree.
Again,weassumethatexternalnodesareemptyand,forthesakeofsimplicity,
we describe our search and update methods assuming that external nodes are real
nodes, althoughthislatterrequirement isnotstrictly needed.
Enforcing the size property for (2,4) trees keeps the nodes in the multiway
search tree simple. It also gives rise to the alternative name “2-3-4 tree,” since it
impliesthateachinternal nodeinthetreehas2,3,or4children. Anotherimplica-
tion of this rule is that wecan represent the secondary map stored at each internal
nodeusinganunorderedlistoranorderedarray,andstillachieveO(1)-timeperfor-
mance for all operations (since d =4). The depth property, on the other hand,
max
enforces animportantboundontheheightofa(2,4)tree.
Proposition 11.8: Theheightofa(2,4)treestoringnitemsisO(logn).
Justiﬁcation: Let h be the height of a (2,4) tree T storing n items. We justify
theproposition byshowingtheclaim
1
log(n+1)≤h≤log(n+1). (11.9)
2
To justify this claim note ﬁrst that, by the size property, wecan have at most
4 nodes at depth 1, at most 42 nodes at depth 2, and so on. Thus, the number of506 Chapter11. SearchTrees
ofa(2,4) tree, wemusthaveatleast 2nodes atdepth 1,atleast22 nodes atdepth
2,andsoon. Thus,thenumberofexternalnodesinT isatleast2h. Inaddition, by
Proposition 11.7,thenumberofexternalnodesinT isn+1. Therefore,weobtain
2h≤n+1≤4h.
Takingthelogarithm inbase2ofthetermsfortheaboveinequalities, wegetthat
h≤log(n+1)≤2h,
whichjustiﬁesourclaim(Formula11.9)whentermsarerearranged.
Proposition11.8statesthatthesizeanddepthpropertiesaresufﬁcientforkeep-
ing a multiway tree balanced. Moreover, this proposition implies that performing
a search in a (2,4) tree takes O(logn) time and that the speciﬁc realization of the
secondarystructuresatthenodesisnotacrucialdesignchoice,sincethemaximum
numberofchildrend isaconstant.
max
Maintainingthesizeanddepthpropertiesrequiressomeeffortafterperforming
insertions anddeletionsina(2,4)tree,however. Wediscusstheseoperations next.
Insertion
Toinsertanewitem(k,v),withkeyk,intoa(2,4)treeT,weﬁrstperformasearch
fork. AssumingthatT hasnoitemwithkeyk,thissearchterminatesunsuccessfully
atanexternal nodez. Letwbetheparent ofz. Weinsert thenewitemintonodew
andaddanewchildy(anexternal node)towontheleftofz.
Ourinsertionmethodpreservesthedepthproperty,sinceweaddanewexternal
node at the same level as existing external nodes. Nevertheless, it may violate the
size property. Indeed, if a nodew was previously a 4-node, then it would become
a 5-node after the insertion, which causes the tree T to no longer be a (2,4) tree.
This type of violation of the size property is called an overﬂow at node w, and it
mustberesolved inorder torestore theproperties ofa(2,4)tree. Letc ,...,c be
1 5
thechildrenofw,andletk ,...,k bethekeysstoredatw. Toremedytheoverﬂow
1 4
atnodew,weperformasplitoperation onwasfollows(seeFigure11.25):
• Replacewwithtwonodesw(cid:2) andw(cid:2)(cid:2),where
◦ w(cid:2) isa3-node withchildrenc ,c ,c storingkeysk andk
1 2 3 1 2
◦ w(cid:2)(cid:2) isa2-nodewithchildrenc ,c storingkeyk .
4 5 4
• IfwistherootofT,createanewrootnodeu;else,letubetheparentofw.
• Insert keyk into uandmakew(cid:2) andw(cid:2)(cid:2) children ofu,sothatifwwaschild
3
iofu,thenw(cid:2) andw(cid:2)(cid:2) becomechildreniandi+1ofu,respectively.
Asaconsequence ofasplitoperation onnodew,anew overﬂowmayoccur atthe
parent uofw. Ifsuch anoverﬂow occurs, it triggers inturn asplit atnodeu. (See
Figure11.26.) Asplitoperationeithereliminatestheoverﬂoworpropagatesitinto
theparent ofthecurrent node. Weshowasequence ofinsertions ina(2,4) treein11.5. (2,4)Trees 507
u u u
h h h h h k h
1 2 1 2 1 3 2
k
w w 3 w(cid:3) w(cid:3)(cid:3)
k k k k k k k k k k
1 2 3 4 1 2 4 1 2 4
c c c c c c c c c c c c c c c
1 2 3 4 5 1 2 3 4 5 1 2 3 4 5
(a) (b) (c)
Figure11.25:Anodesplit: (a)overﬂowata5-nodew;(b)thethirdkeyofwinserted
(cid:2) (cid:2)(cid:2)
intotheparentuofw;(c)nodewreplacedwitha3-nodew anda2-nodew .
5 10 12 5 10 12
3 4 6 7 8 11 13 14 15 3 4 6 7 8 11 13 14 15 17
(a) (b)
5 10 12 5 10 12 15
15
3 4 6 7 8 11 13 14 17 3 4 6 7 8 11 13 14 17
(c) (d)
12
12
5 10 15 5 10 15
3 4 6 7 8 11 13 14 17 3 4 6 7 8 11 13 14 17
(e) (f)
Figure11.26: An insertion in a (2,4) tree that causes a cascading split: (a) before
theinsertion; (b)insertion of17, causing anoverﬂow;(c)asplit; (d)afterthesplit508 Chapter11. SearchTrees
4 4 6 4 6 12 4 6 12 15
(a) (b) (c) (d)
12
12
4 6 15 4 6 15
(e) (f)
12 12
3 4 6 15 3 4 5 6 15
(g) (h)
12 5 12
5
3 4 6 15 3 4 6 15
(i) (j)
5 12 5 12
3 4 6 10 15 3 4 6 8 10 15
(k) (l)
Figure 11.27: A sequence of insertions into a (2,4) tree: (a) initial tree with one
item; (b) insertion of 6; (c) insertion of 12; (d) insertion of 15, which causes an
overﬂow;(e)split,whichcausesthecreationofanewrootnode;(f)afterthesplit;
(g)insertionof3;(h)insertionof5,whichcausesanoverﬂow;(i)split;(j)afterthe11.5. (2,4)Trees 509
Analysis of Insertion in a (2,4) Tree
Because d isatmost 4, theoriginal search for theplacement ofnew keyk uses
max
O(1)timeateachlevel, andthusO(logn)timeoverall, since theheight ofthetree
isO(logn)byProposition 11.8.
The modiﬁcations to a single node to insert a new key and child can be im-
plemented to run in O(1) time, as can a single split operation. The number of
cascadingsplitoperationsisboundedbytheheightofthetree,andsothatphaseof
theinsertionprocessalsorunsinO(logn)time. Therefore,thetotaltimetoperform
aninsertionina(2,4)treeisO(logn).
Deletion
Letusnowconsidertheremovalofanitemwithkeykfroma(2,4)treeT. Webegin
such an operation by performing a search inT for an item with key k. Removing
an item from a (2,4) tree can always be reduced to the case where the item to be
removed is stored at a node w whose children are external nodes. Suppose, for
instance, that the item with key k that we wish to remove is stored in the ith item
(k,v) at a node z that has only internal-node children. In this case, we swap the
i i
item (k,v) with an appropriate item that is stored at a nodew with external-node
i i
children asfollows(seeFigure11.28d):
1. Weﬁndtherightmostinternal nodewinthesubtreerootedattheith childof
z,notingthatthechildren ofnodewareallexternal nodes.
2. Weswaptheitem(k,v)atzwiththelastitemofw.
i i
Once we ensure that the item to remove is stored at a node w with only external-
node children (because either it was already at w or we swapped it into w), we
simplyremovetheitemfromwandremovetheith externalnodeofw.
Removinganitem(andachild)fromanodewasdescribedabovepreservesthe
depth property, for we always remove an external child from a node w with only
external children. However, in removing such an external node, we may violate
the size property at w. Indeed, if w was previously a 2-node, then it becomes a
1-nodewithnoitemsaftertheremoval(Figure11.28aandd),whichisnotallowed
in a (2,4) tree. This type of violation of the size property is called an underﬂow
at node w. To remedy an underﬂow, wecheck whether an immediate sibling of w
is a 3-node or a 4-node. If we ﬁnd such a sibling s, then we perform a transfer
operation, inwhichwemoveachildofstow,akeyofstotheparentuofwands,
andakeyofutow. (SeeFigure11.28bandc.) Ifwhasonlyonesibling,orifboth
immediatesiblingsofware2-nodes,thenweperformafusionoperation, inwhich
(cid:2)
wemergewwithasibling,creatinganewnodew,andmoveakeyfromtheparent
(cid:2)510 Chapter11. SearchTrees
12 12
u
5 10 15 10 15
5
4 w 6 s
6 8 11 13 14 17 8 11 13 14 17
(a) (b)
12
12
u 11
6 10 15 6 10 15
w s
5 8 11 13 14 17 5 8 13 14 17
(c) (d)
11 11
u u
6 15 6 15
10
w w(cid:2)
5 8 13 14 17 5 8 10 13 14 17
(e) (f)
11 11
6 15 6 15
13
5 8 10 14 17 5 8 10 14 17
(g) (h)
Figure11.28: Asequence ofremovals from a(2,4) tree: (a)removal of4, causing
an underﬂow; (b) atransfer operation; (c) after the transfer operation; (d) removal
of 12, causing an underﬂow; (e) a fusion operation; (f) afterthe fusion operation;11.5. (2,4)Trees 511
Afusionoperationatnodewmaycauseanewunderﬂowtooccurattheparent
uofw, which inturn triggers atransfer or fusion atu. (SeeFigure 11.29.) Hence,
the number of fusion operations is bounded by the height of the tree, which is
O(logn)byProposition11.8. Ifanunderﬂowpropagatesallthewayuptotheroot,
thentherootissimplydeleted. (SeeFigure11.29candd.)
11 11
u
6 15 6
14 15
w
5 8 10 17 5 8 10 17
(a) (b)
u
11
w
6 6 11
5 8 10 15 17 5 8 10 15 17
(c) (d)
Figure11.29: Apropagating sequence offusions ina(2,4)tree: (a)removalof14,
whichcausesanunderﬂow;(b)fusion,whichcausesanotherunderﬂow;(c)second
fusionoperation, whichcausestheroottoberemoved;(d)ﬁnaltree.
Performance of (2,4) Trees
Theasymptotic performance ofa(2,4)treeisidentical tothatofanAVLtree(see
Table 11.2) in terms of the sorted map ADT, with guaranteed logarithmic bounds
for most operations. The time complexity analysis for a (2,4) tree having n key-
valuepairsisbasedonthefollowing:
• Theheightofa(2,4)treestoringnentriesisO(logn),byProposition 11.8.
• Asplit,transfer, orfusionoperation takesO(1)time.
• Asearch,insertion, orremovalofanentryvisitsO(logn)nodes.
Thus,(2,4)treesprovideforfastmapsearchandupdateoperations. (2,4)trees512 Chapter11. SearchTrees
11.6 Red-Black Trees
Although AVL trees and (2,4) trees have a number of nice properties, they also
have some disadvantages. For instance, AVL trees may require many restructure
operations (rotations) tobeperformed afteradeletion, and(2,4)treesmayrequire
manysplitorfusing operations tobeperformed afteraninsertion orremoval. The
data structure we discuss in this section, the red-black tree, does not have these
drawbacks;itusesO(1)structuralchangesafteranupdateinordertostaybalanced.
Formally,ared-black treeisabinarysearchtree(seeSection11.1)withnodes
coloredredandblackinawaythatsatisﬁesthefollowingproperties:
RootProperty: Therootisblack.
RedProperty: Thechildren ofarednode(ifany)areblack.
DepthProperty: All nodes with zero or one children have the same black depth,
deﬁned as the number of black ancestors. (Recall that a node is its own
ancestor).
Anexampleofared-black treeisshowninFigure11.30.
12
5 15
3 10 13 17
4 7 11 14
6 8
Figure11.30:Anexampleofared-blacktree,with“red”nodesdrawninwhite. The
commonblackdepthforthistreeis3.
Wecanmakethered-black tree deﬁnition moreintuitive bynoting aninterest-
ingcorrespondence betweenred-black treesand(2,4)trees(excluding theirtrivial
external nodes). Namely, given ared-black tree, wecanconstruct acorresponding
(2,4) tree bymerging every red nodewinto itsparent, storing the entry fromwat
itsparent, andwiththechildren ofwbecoming ordered children oftheparent. For
example,thered-black treeinFigure11.30corresponds tothe(2,4)treefromFig-
ure 11.24, as illustrated in Figure 11.31. The depth property of the red-black tree
corresponds tothedepthproperty ofthe(2,4)treesinceexactlyoneblacknodeof
thered-black treecontributes toeachnodeofthecorresponding (2,4)tree.
Conversely,wecantransformany(2,4)treeintoacorrespondingred-blacktree
bycoloring eachnodewblackandthenperforming thefollowing transformations,11.6. Red-BlackTrees 513
12
5 15
3 10 13 17
4 7 11 14
6 8
Figure11.31: Anillustration thatthered-black tree ofFigure 11.30corresponds to
the(2,4)treeofFigure11.24,basedonthehighlighted groupingofrednodeswith
theirblackparents.
• Ifwisa2-node, thenkeepthe(black)children ofwasis.
• If w is a 3-node, then create a new red node y, give w’s last two (black)
children toy,andmaketheﬁrstchildofwandybethetwochildren ofw.
• If w is a 4-node, then create two new red nodes y and z, give w’s ﬁrst two
(black) children toy, givew’slasttwo(black) children toz,and makey and
zbethetwochildren ofw.
Noticethatarednodealwayshasablackparentinthisconstruction.
Proposition 11.9: Theheightofared-blacktreestoringnentriesisO(logn).
15 15
←→
(a)
13 14 13 14
←→ or
14 13
(b)
6 7 8 7
←→
6 8
(c)
Figure11.32: Correspondence between nodes of a (2,4) tree and a red-black tree:514 Chapter11. SearchTrees
Justiﬁcation: LetT beared-black treestoringnentries, andlethbetheheight
ofT. Wejustifythisproposition byestablishing thefollowingfact:
log(n+1)−1≤h≤2log(n+1)−2.
Let d be the common black depth of all nodes of T having zero or one children.
LetT(cid:2) bethe(2,4)treeassociated withT,andleth(cid:2) betheheightofT(cid:2) (excluding
trivial leaves). Because of the correspondence between red-black trees and (2,4)
trees,weknowthath(cid:2)=d. Hence,byProposition11.8,d=h(cid:2)≤log(n+1)−1. By
theredproperty,h≤2d. Thus,weobtainh≤2log(n+1)−2. Theotherinequality,
log(n+1)−1≤h,followsfromProposition 8.8andthefactthatT hasnnodes.
11.6.1 Red-Black Tree Operations
Thealgorithm forsearching inared-black treeT isthesameasthatforastandard
binary search tree (Section 11.1). Thus, searching in a red-black tree takes time
proportional totheheightofthetree,whichisO(logn)byProposition 11.9.
Thecorrespondencebetween(2,4)treesandred-blacktreesprovidesimportant
intuition thatwewilluseinourdiscussion ofhowtoperformupdates inred-black
trees;infact,theupdatealgorithmsforred-blacktreescanseemmysteriouslycom-
plex without this intuition. Split and fuse operations of a(2,4) tree will be effec-
tivelymimickedbyrecoloring neighboring red-black treenodes. Arotation within
a red-black tree will be used to change orientations of a 3-node between the two
formsshowninFigure11.32(b).
Insertion
Now consider the insertion of a key-value pair (k,v) into a red-black tree T. The
algorithm initially proceeds as in a standard binary search tree (Section 11.1.3).
Namely,wesearchforkinT untilwereachanullsubtree,andweintroduceanew
leaf x at that position, storing the item. In the special case thatx is the only node
of T, and thus the root, we color it black. In all other cases, we color x red. This
action corresponds toinserting (k,v) into anode ofthe(2,4) tree T(cid:2) with external
children. The insertion preserves the root and depth properties of T, but it may
violate the red property. Indeed, if x is not the root of T and the parent y of x is
red,thenwehaveaparentandachild(namely,yandx)thatarebothred. Notethat
bytherootproperty,ycannot betherootofT,andbytheredproperty (whichwas
previously satisﬁed),theparentzofymustbeblack. Sincexanditsparentarered,
but x’s grandparent z is black, we call this violation of the red property a double11.6. Red-BlackTrees 515
Case1: TheSiblingsofyIsBlack(orNone). (See Figure 11.33.) In this case,
the double red denotes the fact that we have added the new node to a cor-
responding 3-node of the (2,4) tree T(cid:2), effectively creating a malformed
4-node. This formation has one red node (y) that is the parent of another
red node (x), while wewant ittohave the tworednodes assiblings instead.
To ﬁx this problem, we perform a trinode restructuring of T. The trinode
restructuring is done by the operation restructure(x), which consists of the
following steps (see again Figure 11.33; this operation is also discussed in
Section11.2):
• Take node x, its parent y, and grandparent z, and temporarily relabel
them as a, b, and c, in left-to-right order, so that a, b, and c will be
visitedinthisorderbyaninordertreetraversal.
• Replace the grandparent z with the node labeled b, and make nodes a
andcthechildren ofb,keeping inorderrelationships unchanged.
Afterperformingtherestructure(x)operation,wecolorbblackandwecolor
aand cred. Thus, the restructuring eliminates thedouble-red problem. No-
tice that the portion of any path through the restructured part of the tree is
incident toexactly oneblack node, bothbefore andafterthetrinode restruc-
turing. Therefore, theblackdepthofthetreeisunaffected.
z z z z
30 30 10 10
y y y y
20 10 20 30
s s s s
x x x x
10 20 30 20
(a)
b
20
a c
10 30
(b)
Figure 11.33: Restructuring a red-black tree to remedy a double red: (a) the four516 Chapter11. SearchTrees
Case2: TheSiblingsofyIsRed. (SeeFigure11.34.) Inthiscase,thedoublered
denotes an overﬂow in the corresponding (2,4) tree T(cid:2). To ﬁxthe problem,
weperform theequivalent ofasplit operation. Namely, wedoarecoloring:
we color y and s black and their parent z red (unless z is the root, in which
case, it remains black). Notice that unless z is the root, the portion of any
path through the affected part of the tree is incident to exactly one black
node, both before andafter therecoloring. Therefore, theblack depth ofthe
tree is unaffected by the recoloring unless z is the root, in which case it is
increased byone.
However, it is possible that the double-red problem reappears after such a
recoloring, albeit higher up in the tree T, sincez may have a red parent. If
thedouble-redproblemreappearsatz,thenwerepeattheconsiderationofthe
two cases at z. Thus, a recoloring either eliminates the double-red problem
at node x, or propagates it to the grandparent z of x. We continue going
upT performing recolorings untilweﬁnallyresolvethedouble-red problem
(with either a ﬁnal recoloring or a trinode restructuring). Thus, the number
of recolorings caused by an insertion is no more than half theheight of tree
T,thatis,O(logn)byProposition 11.9.
z
30
y s
10 20 30 40
20 40
x
10
(a)
z
30
...30... y s
20 40
x
10 20 40 10
(b)
Figure11.34: Recoloring to remedy the double-red problem: (a) before recoloring
andthecorresponding 5-node intheassociated(2,4)treebeforethesplit;(b)after
recoloring andthecorresponding nodesintheassociated(2,4)treeafterthesplit.
As further examples, Figures 11.35 and 11.36 show a sequence of insertion11.6. Red-BlackTrees 517
4 4 4 7
7 7 4 12
12
(a) (b) (c) (d)
7 7 7 7
4 12 4 12 4 12 4 12
15 15 3 15 3 5 15
(e) (f) (g) (h)
7 7
4 12 4 14
3 5 15 3 5 12 15
14
(i) (j)
7 7
4 14 4 14
3 5 12 15 3 5 12 15
18 18
(k) (l)
Figure11.35: Asequence ofinsertions inared-blacktree: (a)initialtree;(b)inser-
tionof7;(c)insertion of12,whichcauses adouble red;(d)afterrestructuring; (e)
insertion of 15, which causes a double red; (f) after recoloring (the root remains
black); (g) insertion of 3; (h) insertion of 5; (i) insertion of 14, which causes a
double red; (j) after restructuring; (k) insertion of 18, which causes a double red;518 Chapter11. SearchTrees
7 7
4 14 4 14
3 5 12 15 3 5 12 16
18 15 18
16
(m) (n)
7 7
4 14 4 14
3 5 12 16 3 5 12 16
15 18 15 18
17 17
(o) (p)
14
7 16
4 12 15 18
3 5 17
(q)
Figure 11.36: A sequence of insertions in a red-black tree: (m) insertion of 16,
whichcausesadoublered;(n)afterrestructuring; (o)insertionof17,whichcauses
a double red; (p) after recoloring there is again a double red, to be handled by a11.6. Red-BlackTrees 519
Deletion
Deletinganitemwithkeykfromared-blacktreeT initiallyproceedsasforabinary
search tree(Section 11.1.3). Structurally, theprocess results intheremovalanode
that has at most one child (either that originally containing key k or its inorder
predecessor) andthepromotionofitsremainingchild(ifany).
If the removed node was red, this structural change does not affect the black
depthsofanypathsinthetree,norintroduceanyredviolations,andsotheresulting
tree remains a valid red-black tree. In the corresponding (2,4) tree T(cid:2), this case
denotes the shrinking of a 3-node or 4-node. If the removed node was black, then
it either had zero children or it had one child that was a red leaf (because the null
subtree of the removed node has black height 0). In the latter case, the removed
node represents the black part of a corresponding 3-node, and we restore the red-
blackproperties byrecoloring thepromotedchildtoblack.
Themore complex case iswhen a (nonroot) black leaf isremoved. Inthe cor-
responding (2,4)tree, thisdenotes theremovalofanitem froma2-node. Without
rebalancing, such a change results ina deﬁcit of one for the black depth along the
path leading to the deleted item. By necessity, the removed node must have a sib-
ling whose subtree has black height 1 (given that this was a valid red-black tree
priortothedeletionoftheblackleaf).
Toremedythisscenario, weconsider amoregeneral setting withanodezthat
isknowntohavetwosubtrees,T andT ,suchthattherootofT (ifany)is
heavy light light
blackandsuch thattheblack depthofT isexactly onemorethanthatofT ,
heavy light
asportrayed inFigure11.37. Inthecaseofaremovedblackleaf,zistheparentof
thatleafandT istrivially theempty subtree thatremains after thedeletion. We
light
describe the more general case of a deﬁcit because our algorithm for rebalancing
thetreewill,insomecases,pushthedeﬁcithigherinthetree(justastheresolution
ofadeletion ina(2,4) treesometimes cascades upward). Weletydenote theroot
ofT . (SuchanodeexistsbecauseT hasblackheightatleastone.)
heavy heavy
z
y
T
light
T
heavy
Figure11.37: Portrayalofadeﬁcitbetweentheblackheightsofsubtrees ofnodez.
The gray color in illustrating y and z denotes the fact that these nodes may be520 Chapter11. SearchTrees
Weconsiderthreepossible casestoremedyadeﬁcit.
Case1: NodeyIsBlackandHasaRedChildx. (SeeFigure11.38.)
Weperform atrinoderestructuring, asoriginally described inSection11.2.
The operation restructure(x) takes the node x, its parent y, and grandparent
z, labels them temporarily lefttoright asa, b, andc, andreplaces zwiththe
nodelabeledb,makingittheparentoftheothertwo. Wecoloraandcblack,
andgivebtheformercolorofz.
Notice that the path to T in the result includes one additional black node
light
after the restructure, thereby resolving its deﬁcit. In contrast, the number
of black nodes on paths to any of the other three subtrees illustrated in Fig-
ure11.38remainsunchanged.
Resolving this case corresponds to a transfer operation in the (2,4) tree T(cid:2)
between the two children of the node withz. The fact that y has a red child
assures us that it represents either a 3-node or a 4-node. In effect, the item
previously stored at z is demoted to become a new 2-node to resolve the
deﬁciency,whileanitemstoredatyoritschildispromotedtotaketheplace
oftheitempreviously storedatz.
z x
y 30 y 20 z
10 x 10 30
20
T
light
T
light
z y
y 30 x 20 z
x 20 10 30
10
T
light
T
light
Figure11.38:ResolvingablackdeﬁcitinT byperformingatrinoderestructuring
light
asrestructure(x). Twopossibleconﬁgurationsareshown(twootherconﬁgurations
aresymmetric). Thegraycolorofzintheleftﬁguresdenotesthefactthatthisnode
may be colored either red or black. The root of the restructured portion is given11.6. Red-BlackTrees 521
Case2: NodeyIsBlackandBothChildrenofyAreBlack(orNone).
Resolving this case corresponds to a fusion operation in the corresponding
(2,4) tree T(cid:2), as y must represent a 2-node. We do a recoloring; we color
y red, and, if z is red, we color it black. (See Figure 11.39). This does not
introduce anyredviolation, becauseydoesnothavearedchild.
Inthecasethatzwasoriginallyred,andthustheparentinthecorresponding
(2,4) tree is a 3-node or 4-node, this recoloring resolves the deﬁcit. (See
Figure11.39a.) Thepathleading toT includes oneadditional blacknode
light
in the result, while the recoloring did not affect the number of black nodes
onthepathtothesubtrees ofT .
heavy
Inthecasethatzwasoriginally black,andthustheparentinthecorrespond-
ing (2,4) tree is a 2-node, the recoloring has not increased the number of
black nodes on the path to T ; in fact, it has reduced the number of black
light
nodesonthepathtoT . (SeeFigure11.39b.) Afterthisstep,thetwochil-
heavy
dren ofzwillhave thesameblack height. However, theentire treerooted at
z has become deﬁcient, thereby propogating the problem higher in the tree;
wemustrepeatconsideration ofallthreecasesattheparentofzasaremedy.
z z
y 30 y 30
20 20
T
light
T
heavy
(a)
z z
y 30 y 30
20 20
T
light
T T
heavy light
(b)
Figure11.39: ResolvingablackdeﬁcitinT byarecoloring operation: (a)when
light
zisoriginally red,reversingthecolorsofyandzresolvestheblackdeﬁcitinT ,
light
ending the process; (b) when z is originally black, recoloring y causes the entire522 Chapter11. SearchTrees
Case3: NodeyIsRed. (SeeFigure11.40.)
BecauseyisredandT hasblackdepthatleast1,zmustbeblackandthe
heavy
twosubtreesofymusteachhaveablackrootandablackdepthequaltothat
ofT . Inthiscase,weperformarotationaboutyandz,andthenrecolory
heavy
blackandzred. Thisdenotesareorientationofa3-nodeinthecorresponding
(2,4)treeT(cid:2).
Thisdoesnotimmediatelyresolvethedeﬁcit,asthenewsubtreeofzisanold
(cid:2)
subtree of y with black root y and black height equal to that of the original
T . Wereapply the algorithm to resolve the deﬁcit atz, knowing that the
heavy
(cid:2)
new child y, that is the root ofT is now black, and therefore that either
heavy
Case 1 applies or Case 2 applies. Furthermore, the next application will be
thelast,becauseCase1isalwaysterminalandCase2willbeterminalgiven
thatzisred.
z y
y 30 20 z
20 30
(cid:2)
y
T
light
T T T
heavy heavy light
Figure11.40:Arotationandrecoloringaboutrednodeyandblacknodez,assuming
a black deﬁcit at z. This amounts to a change of orientation in the corresponding
3-node ofa(2,4) tree. This operation does not affect the black depth ofanypaths
through this portion of the tree. Furthermore, because y was originally red, the
(cid:2)
newsubtree ofzmusthaveablack rooty andmusthave black height equaltothe
originalT . Therefore,ablackdeﬁcitremainsatnodezafterthetransformation.
heavy
InFigure11.41,weshowasequenceofdeletionsonared-blacktree. Adashed
edgeinthoseﬁgures,suchastotherightof7inpart(c),representsabranchwitha
blackdeﬁciencythathasnotyetbeenresolved. WeillustrateaCase1restructuring
in parts (c) and (d). Weillustrate a Case 2 recoloring in parts (f) and (g). Finally,
weshowanexampleofaCase3rotationbetweenparts(i)and(j),concludingwith11.6. Red-BlackTrees 523
14 14
7 16 7 16
4 12 15 18 4 12 15 18
3 5 17 5 17
(a) (b)
14 14
7 16 5 16
4 15 18 4 7 15 18
5 17 17
(c) (d)
14 14 14
5 16 5 16 5 16
4 7 15 18 4 7 15 4 7 15
(e) (f) (g)
14 14 5 5
5 16 5 4 14 4 14
4 7 4 7 7 7
(h) (i) (j) (k)
Figure11.41: Asequence ofdeletions fromared-black tree: (a)initial tree; (b)re-
movalof 3; (c)removal of12, causing ablack deﬁcit tothe right of7(handled by
restructuring); (d)afterrestructuring; (e)removalof17;(f)removalof18,causing
ablackdeﬁcittotherightof16(handledbyrecoloring);(g)afterrecoloring;(h)re-
moval of 15; (i) removal of 16, causing a black deﬁcit to the right of 14 (handled
initiallybyarotation);(j)aftertherotationtheblackdeﬁcitneedstobehandledby524 Chapter11. SearchTrees
Performance of Red-Black Trees
Theasymptotic performance of ared-black tree is identicalto that of an AVLtree
or a (2,4) tree in terms of the sorted map ADT, with guaranteed logarithmic time
bounds for most operations. (See Table 11.2 for a summary of the AVL perfor-
mance.) The primary advantage of a red-black tree is that an insertion or deletion
requires only aconstant number of restructuring operations. (This is in contrast
toAVLtreesand(2,4)trees,bothofwhichrequire alogarithmic numberofstruc-
turalchangespermapoperationintheworstcase.) Thatis,aninsertionordeletion
in a red-black tree requires logarithmic time for a search, and may require a loga-
rithmic number ofrecoloring operations that cascade upward. Yetweshow, inthe
following propositions, thatthere are aconstant number ofrotations orrestructure
operations forasinglemapoperation.
Proposition 11.10: Theinsertionofaniteminared-blacktreestoringn items
canbedoneinO(logn) timeandrequiresO(logn) recoloringsandatmostone
trinoderestructuring.
Justiﬁcation: Recall that an insertion begins with a downward search, the cre-
ationofanewleafnode,andthenapotentialupwardefforttoremedyadouble-red
violation. There may belogarithmically many recoloring operations due toan up-
wardcascadingofCase2applications, butasingleapplicationoftheCase1action
eliminates thedouble-red problem withatrinode restructuring. Therefore, atmost
onerestructuring operation isneededforared-black treeinsertion.
Proposition 11.11: Thealgorithmfordeletinganitemfromared-blacktreewith
n itemstakesO(logn) timeandperformsO(logn) recoloringsandatmosttwo
restructuringoperations.
Justiﬁcation: A deletion begins with the standard binary search tree deletion
algorithm, whichrequires timeproportional tothe height ofthetree; forred-black
trees, that height is O(logn). The subsequent rebalancing takes place along an
upwardpathfromtheparentofadeleted node.
Weconsideredthreecasestoremedyaresultingblackdeﬁcit. Case1requiresa
trinoderestructuring operation, yetcompletestheprocess,sothiscaseisappliedat
mostonce. Case2maybeappliedlogarithmically manytimes,butitonlyinvolves
arecoloring ofuptotwonodesperapplication. Case3requires arotation, butthis
casecanonlyapply once, because iftherotation doesnotresolve theproblem, the
verynextactionwillbeaterminalapplication ofeitherCase1orCase2.
Intheworstcase,therewillbeO(logn)recolorings fromCase2,asinglerota-11.6. Red-BlackTrees 525
11.6.2 Python Implementation
AcompleteimplementationofaRedBlackTreeMapclassisprovidedinCodeFrag-
ments 11.15 through 11.17. Itinherits from the standardTreeMapclass and relies
onthebalancing frameworkdescribed inSection11.2.1.
We begin, in Code Fragment 11.15, by overriding the deﬁnition of the nested
Node class to introduce an additional Boolean ﬁeld to denote the current color
of a node. Our constructor intentionally sets the color of a new node to red to
be consistent with our approach for inserting items. We deﬁne several additional
utility functions, atthetopofCodeFragment11.16,thataidinsetting thecolorof
nodesandquerying variousconditions.
When an element has been inserted as a leaf in the tree, the rebalance insert
hook is called, allowing us the opportunity to modify the tree. The new node is
red by default, so we need only look for the special case of the new node being
the root (in which case it should be colored black), or the possibility that we have
a double-red violation because the new node’s parent is alsored. To remedy such
violations, wecloselyfollowthecaseanalysis described inSection11.6.1.
The rebalancing after a deletion also follows the case analysis described in
Section 11.6.1. Anadditional challenge isthatbythe timethe rebalance hookis
called, theoldnodehasalready been removedfromthetree. Thathookisinvoked
ontheparentoftheremovednode. Someofthecaseanalysisdependsonknowing
aboutthepropertiesoftheremovednode. Fortunately,wecanreverseengineerthat
information by relying on the red-black tree properties. Inparticular, if p denotes
theparentoftheremovednode,itmustbethat:
• If phasnochildren, theremovednodewasaredleaf. (ExerciseR-11.26.)
• If p has one child, the removed node was a black leaf, causing a deﬁcit,
unlessthatoneremaining childisaredleaf. (ExerciseR-11.27.)
• If phastwochildren,theremovednodewasablacknodewithoneredchild,
whichwaspromoted. (ExerciseR-11.28.)
1 class RedBlackTreeMap(TreeMap):
2 ”””Sorted map implementation using a red-black tree.”””
3 class Node(TreeMap. Node):
4 ”””Node class for red-black tree maintains bit that denotes color.”””
5 slots = _red # add additional data member to the Node class
6
7 def init (self, element, parent=None, left=None, right=None):
8 super(). init (element, parent, left, right)
9 self. red = True # new node red by default
Code Fragment 11.15: Beginning of the RedBlackTreeMap class. (Continued in526 Chapter11. SearchTrees
10 #------------------------- positional-based utility methods -------------------------
11 # we consider a nonexistent child to be trivially black
12 def set red(self, p): p. node. red = True
13 def set black(self, p): p. node. red = False
14 def set color(self, p, make red): p. node. red = make red
15 def is red(self, p): return p is not None and p. node. red
16 def is red leaf(self, p): return self. is red(p) and self.is leaf(p)
17
18 def get red child(self, p):
19 ”””Return a red child of p (or None if no such child).”””
20 for child in (self.left(p), self.right(p)):
21 if self. is red(child):
22 return child
23 return None
24
25 #------------------------- support for insertions -------------------------
26 def rebalance insert(self, p):
27 self. resolve red(p) # new node is always red
28
29 def resolve red(self, p):
30 if self.is root(p):
31 self. set black(p) # make root black
32 else:
33 parent = self.parent(p)
34 if self. is red(parent): # double red problem
35 uncle = self.sibling(parent)
36 if not self. is red(uncle): # Case 1: misshapen 4-node
37 middle = self. restructure(p) # do trinode restructuring
38 self. set black(middle) # and then ﬁx colors
39 self. set red(self.left(middle))
40 self. set red(self.right(middle))
41 else: # Case 2: overfull 5-node
42 grand = self.parent(parent)
43 self. set red(grand) # grandparent becomes red
44 self. set black(self.left(grand)) # its children become black
45 self. set black(self.right(grand))
46 self. resolve red(grand) # recur at red grandparent
Code Fragment 11.16: Continuation of the RedBlackTreeMap class. (Continued11.6. Red-BlackTrees 527
47 #------------------------- support for deletions -------------------------
48 def rebalance delete(self, p):
49 if len(self) == 1:
50 self. set black(self.root()) # special case: ensure that root is black
51 elif p is not None:
52 n = self.num children(p)
53 if n == 1: # deﬁcit exists unless child is a red leaf
54 c = next(self.children(p))
55 if not self. is red leaf(c):
56 self. ﬁx deﬁcit(p, c)
57 elif n == 2: # removed black node with red child
58 if self. is red leaf(self.left(p)):
59 self. set black(self.left(p))
60 else:
61 self. set black(self.right(p))
62
63 def ﬁx deﬁcit(self, z, y):
64 ”””Resolve black deﬁcit at z, where y is the root of zs heavier subtree.”””
65 if not self. is red(y): # y is black; will apply Case 1 or 2
66 x = self. get red child(y)
67 if x is not None: # Case 1: y is black and has red child x; do ”transfer”
68 old color = self. is red(z)
69 middle = self. restructure(x)
70 self. set color(middle, old color) # middle gets old color of z
71 self. set black(self.left(middle)) # children become black
72 self. set black(self.right(middle))
73 else: # Case 2: y is black, but no red children; recolor as ”fusion”
74 self. set red(y)
75 if self. is red(z):
76 self. set black(z) # this resolves the problem
77 elif not self.is root(z):
78 self. ﬁx deﬁcit(self.parent(z), self.sibling(z)) # recur upward
79 else: # Case 3: y is red; rotate misaligned 3-node and repeat
80 self. rotate(y)
81 self. set black(y)
82 self. set red(z)
83 if z == self.right(y):
84 self. ﬁx deﬁcit(z, self.left(z))
85 else:
86 self. ﬁx deﬁcit(z, self.right(z))
CodeFragment11.17:ConclusionoftheRedBlackTreeMapclass. (Continuedfrom528 Chapter11. SearchTrees
11.7 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-11.1 Ifweinserttheentries(1,A),(2,B),(3,C),(4,D),and(5,E),inthisorder,
intoaninitiallyemptybinarysearchtree,whatwillitlooklike?
R-11.2 Insert, into an empty binary search tree, entries with keys 30, 40, 24, 58,
48,26,11,13(inthisorder). Drawthetreeaftereachinsertion.
R-11.3 Howmanydifferentbinarysearchtreescanstorethekeys{1,2,3}?
R-11.4 Dr.Amongusclaimsthattheorderinwhichaﬁxedsetofentriesisinserted
intoabinarysearchtreedoesnotmatter—thesametreeresultseverytime.
Giveasmallexamplethatprovesheiswrong.
R-11.5 Dr.Amongusclaimsthattheorderinwhichaﬁxedsetofentriesisinserted
into an AVLtree does notmatter—the sameAVLtree results every time.
Giveasmallexamplethatprovesheiswrong.
R-11.6 Our implementation of the TreeMap. subtree search utility, from Code
Fragment 11.4, relies onrecursion. Foralarge unbalanced tree, Python’s
default limit on recursive depth may be prohibitive. Give an alternative
implementation ofthatmethodthatdoesnotrelyontheuseofrecursion.
R-11.7 Do the trinode restructurings in Figures 11.12 and 11.14 result in single
ordoublerotations?
R-11.8 Draw the AVL tree resulting from the insertion of an entry with key 52
intotheAVLtreeofFigure11.14b.
R-11.9 Draw the AVL tree resulting from the removal of the entry with key 62
fromtheAVLtreeofFigure11.14b.
R-11.10 Explain why performing a rotation in an n-node binary tree when using
thearray-based representation ofSection8.3.2takesΩ(n)time.
R-11.11 Giveaschematic ﬁgure,inthestyleofFigure11.13, showingtheheights
of subtrees during a deletion operation in an AVL tree that triggers a tri-
node restructuring for the case in which the two children of the node de-
noted asystart withequal heights. What isthenet effect ofthe heightof
therebalanced subtree duetothedeletion operation?
R-11.12 Repeat the previous problem, considering the case in which y’s children11.7. Exercises 529
R-11.13 The rules for adeletion in an AVLtree speciﬁcally require that when the
twosubtreesofthenodedenotedasyhaveequalheight,childxshouldbe
chosentobe“aligned”withy(sothatxandyarebothleftchildrenorboth
right children). Tobetter understand this requirement, repeat Exercise R-
11.11 assuming we picked the misaligned choice of x. Why might there
beaprobleminrestoring theAVLproperty withthatchoice?
R-11.14 Perform the following sequence of operations in an initially empty splay
treeanddrawthetreeaftereachsetofoperations.
a. Insertkeys0,2,4,6,8,10,12,14,16,18,inthisorder.
b. Searchforkeys1,3,5,7,9,11,13,15,17,19,inthisorder.
c. Deletekeys0,2,4,6,8,10,12,14,16,18,inthisorder.
R-11.15 What does a splay tree look like if its entries are accessed in increasing
orderbytheirkeys?
R-11.16 IsthesearchtreeofFigure11.23(a)a(2,4)tree? Whyorwhynot?
R-11.17 An alternative way of performing a split at a node w in a (2,4) tree is
(cid:2) (cid:2)(cid:2) (cid:2) (cid:2)(cid:2)
to partition w into w and w , with w being a 2-node and w a 3-node.
Whichofthekeysk ,k ,k ,ork dowestoreatw’sparent? Why?
1 2 3 4
R-11.18 Dr. Amongus claims that a (2,4) tree storing a set of entries will always
have the same structure, regardless of the order in which the entries are
inserted. Showthatheiswrong.
R-11.19 Drawfourdifferentred-blacktreesthatcorrespondtothesame(2,4)tree.
R-11.20 ConsiderthesetofkeysK ={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}.
a. Draw a (2,4) tree storing K as its keys using the fewest number of
nodes.
b. Drawa(2,4) treestoring K asits keys using the maximum number
ofnodes.
R-11.21 Considerthesequence ofkeys(5,16,22,45,2,10,18,30,50,12,1). Draw
theresultofinserting entrieswiththesekeys(inthegivenorder)into
a. Aninitially empty(2,4)tree.
b. Aninitially emptyred-black tree.
R-11.22 Forthefollowing statements aboutred-black trees, provide ajustiﬁcation
foreachtruestatementandacounterexample foreachfalseone.
a. Asubtree ofared-black treeisitselfared-black tree.
b. Anodethatdoesnothaveasiblingisred.
c. Thereisaunique(2,4)treeassociated withagivenred-black tree.
d. Thereisauniquered-black treeassociated withagiven(2,4)tree.
R-11.23 Explain why you would get the same output in an inorder listing of the
entriesinabinarysearchtree,T,independent ofwhetherT ismaintained530 Chapter11. SearchTrees
R-11.24 Consider a tree T storing 100,000 entries. What is the worst-case height
ofT inthefollowingcases?
a. T isabinarysearchtree.
b. T isanAVLtree.
c. T isasplaytree.
d. T isa(2,4)tree.
e. T isared-black tree.
R-11.25 Drawanexampleofared-black treethatisnotanAVLtree.
R-11.26 Let T be a red-black tree and let p be the position of the parent of the
originalnodethatisdeletedbythestandardsearchtreedeletionalgorithm.
Provethatif phaszerochildren, theremovednodewasaredleaf.
R-11.27 Let T be a red-black tree and let p be the position of the parent of the
originalnodethatisdeletedbythestandardsearchtreedeletionalgorithm.
Prove that if p has one child, the deletion has caused ablack deﬁcit at p,
exceptforthecasewhentheoneremainingchildisaredleaf.
R-11.28 Let T be a red-black tree and let p be the position of the parent of the
originalnodethatisdeletedbythestandardsearchtreedeletionalgorithm.
Provethatif phastwochildren,theremovednodewasblackandhadone
redchild.
Creativity
C-11.29 Explain how to use an AVL tree or a red-black tree to sortn comparable
elementsinO(nlogn)timeintheworstcase.
C-11.30 Can weuse a splay tree to sortn comparable elements inO(nlogn) time
intheworstcase? Whyorwhynot?
C-11.31 RepeatExerciseC-10.28fortheTreeMapclass.
C-11.32 Show that any n-node binary tree can be converted to any other n-node
binarytreeusingO(n)rotations.
C-11.33 For a key k that is not found in binary search tree T, prove that both the
greatest key less than k and the least key greater than k lie on the path
tracedbythesearchfork.
C-11.34 InSection 11.1.2 weclaim thattheﬁnd rangemethod ofabinary search
treeexecutesinO(s+h)timewheresisthenumberofitemsfoundwithin
the range and h is the height of the tree. Our implementation, in Code
Fragment 11.6 begins by searching for the starting key, and then repeat-
edlycallingtheaftermethoduntilreachingtheendoftherange. Eachcall
to after is guaranteed to run inO(h) time. This suggests a weakerO(sh)
bound for ﬁnd range,since itinvolves O(s)calls toafter. Provethat this11.7. Exercises 531
C-11.35 Describehowtoperform anoperationremove range(start, stop)thatre-
moves all the items whose keys fall withinrange(start, stop)in a sorted
map that is implemented with a binary search tree T, and show that this
method runs in time O(s+h), where s is the number of items removed
andhistheheightofT.
C-11.36 RepeatthepreviousproblemusinganAVLtree,achievingarunningtime
of O(slogn). Why doesn’t the solution to the previous problem trivially
resultinanO(s+logn)algorithm forAVLtrees?
C-11.37 Suppose wewishtosupport anew methodcount range(start, stop)that
determineshowmanykeysofasortedmapfallinthespeciﬁedrange. We
couldclearlyimplementthisinO(s+h)timebyadaptingourapproachto
ﬁnd range. Describe how to modify the search tree structure to support
O(h)worst-case timeforcount range.
C-11.38 If the approach described in the previous problem were implemented as
partoftheTreeMapclass,whatadditionalmodiﬁcations(ifany)wouldbe
necessary toasubclass suchasAVLTreeMapinordertomaintainsupport
forthenewmethod?
C-11.39 Draw a schematic of an AVL tree such that a single remove operation
could require Ω(logn) trinode restructurings (or rotations) from a leaf to
therootinordertorestoretheheight-balance property.
C-11.40 In our AVL implementation, each node stores the height of its subtree,
which is an arbitrarily large integer. The space usage for an AVL tree
can be reduced by instead storing thebalance factor of a node, which is
deﬁnedastheheightofitsleftsubtreeminustheheightofitsrightsubtree.
Thus, the balance factor of a node is always equal to−1, 0, or 1, except
duringaninsertionorremoval,whenitmaybecometemporarilyequalto
−2 or +2. Reimplement the AVLTreeMap class storing balance factors
ratherthansubtreeheights.
C-11.41 If we maintain a reference to the position of the leftmost node of a bi-
nary search tree, thenoperation ﬁnd mincanbeperformed inO(1)time.
Describe how the implementation of the other map methods need to be
modiﬁedtomaintainareferencetotheleftmostposition.
C-11.42 If the approach described in the previous problem were implemented as
part of the TreeMap class, what additional modiﬁcations (if any) would
be necessary to a subclass such as AVLTreeMap in order to accurately
maintainthereference totheleftmostposition?
C-11.43 Describe a modiﬁcation to the binary search tree implementation having
worst-case O(1)-time performance for methods after(p) and before(p)532 Chapter11. SearchTrees
C-11.44 If the approach described in the previous problem were implemented as
part of the TreeMap class, what additional modiﬁcations (if any) would
be necessary to a subclass such as AVLTreeMap in order to maintain the
efﬁciency?
C-11.45 For a standard binary search tree, Table 11.1 claims O(h)-time perfor-
mance for the delete(p) method. Explain why delete(p) would run in
O(1)timeifgivenasolution toExerciseC-11.43.
C-11.46 Describeamodiﬁcationtothebinarysearchtreedatastructurethatwould
supportthefollowingtwoindex-basedoperationsforasortedmapinO(h)
time,wherehistheheightofthetree.
at index(i): Returntheposition poftheitematindexiofasortedmap.
index of(p): Returntheindexioftheitematposition pofasortedmap.
C-11.47 Drawasplaytree,T ,togetherwiththesequenceofupdatesthatproduced
1
it, and a red-black tree, T , on the same set of ten entries, such that a
2
preorder traversalofT wouldbethesameasapreorder traversalofT .
1 2
C-11.48 Show that the nodes that become temporarily unbalanced in anAVLtree
during an insertion may be nonconsecutive on the path from the newly
inserted nodetotheroot.
C-11.49 Show that at most one node in an AVL tree becomes temporarily un-
balanced after the immediate deletion of a node as part of the standard
delitem mapoperation.
C-11.50 Let T and U be (2,4) trees storing n and m entries, respectively, such
that all the entries in T have keys less than the keys of all the entries in
U. Describe anO(logn+logm)-time method for joining T andU into a
singletreethatstoresalltheentriesinT andU.
C-11.51 Repeattheprevious problemforred-black treesT andU.
C-11.52 JustifyProposition 11.7.
C-11.53 The Boolean indicator used to mark nodes in a red-black tree as being
“red” or “black” is not strictly needed when we have distinct keys. De-
scribe a scheme for implementing a red-black tree without adding any
extraspacetostandard binarysearchtreenodes.
C-11.54 LetT beared-black treestoringnentries,andletkbethekeyofanentry
inT. ShowhowtoconstructfromT,inO(logn)time,twored-blacktrees
(cid:2) (cid:2)(cid:2) (cid:2) (cid:2)(cid:2)
T and T , such that T contains all the keys of T less than k, and T
contains allthekeysofT greaterthank. Thisoperation destroysT.
C-11.55 Showthatthenodes ofanyAVLtreeT canbecolored “red” and“black”11.7. Exercises 533
C-11.56 The standard splaying step requires two passes, one downward pass to
ﬁnd the node x to splay, followed by an upward pass to splay the node
x. Describe a method for splaying and searching for x in one downward
pass. Each substep now requires that you consider the next two nodes
in the path down to x, with a possible zig substep performed at the end.
Describehowtoperform thezig-zig, zig-zag, andzigsteps.
C-11.57 Consideravariationofsplaytrees,calledhalf-splaytrees,wheresplaying
anodeatdepthd stopsassoonasthenodereachesdepth(cid:16)d/2(cid:17). Perform
anamortizedanalysis ofhalf-splay trees.
C-11.58 Describeasequenceofaccessestoann-nodesplaytreeT,wherenisodd,
that results in T consisting of a single chain of nodes such that the path
downT alternates betweenleftchildren andrightchildren.
C-11.59 Asapositional structure, ourTreeMap implementation has asubtle ﬂaw.
A position instance p associated with an key-value pair (k,v) should re-
main valid as long as that item remains in the map. In particular, that
positionshouldbeunaffectedbycallstoinsertordeleteotheritemsinthe
collection. Our algorithm for deleting an item from a binary search tree
mayfail toprovide such aguarantee, inparticular because ofourrulefor
using the inorder predecessor of a key as a replacement when deleting a
keythatislocatedinanodewithtwochildren. Givenanexplicitseriesof
Pythoncommandsthatdemonstrates suchaﬂaw.
C-11.60 How might the TreeMap implementation be changed to avoid the ﬂaw
described intheprevious problem?
Projects
P-11.61 Perform an experimental study to compare the speed of our AVL tree,
splay tree, and red-black tree implementations for various sequences of
operations.
P-11.62 Redo the previous exercise, including an implementation of skip lists.
(SeeExerciseP-10.53.)
P-11.63 ImplementtheMapADTusinga(2,4)tree. (SeeSection10.1.1.)
P-11.64 Redothepreviousexercise,includingallmethodsoftheSortedMapADT.
(SeeSection10.3.)
P-11.65 Redo Exercise P-11.63 providing positional support, as we did for bi-
narysearchtrees(Section11.1.1),soastoincludemethodsﬁrst(),last(),
before(p), after(p), and ﬁnd position(k). Each item should have a dis-
tinctposition inthisabstraction, eventhoughseveralitemsmaybestored534 Chapter11. SearchTrees
P-11.66 WriteaPythonclassthatcantakeanyred-blacktreeandconvertitintoits
corresponding(2,4)treeandcantakeany(2,4)treeandconvertitintoits
corresponding red-black tree.
P-11.67 In describing multisets and multimaps in Section 10.5.3, we describe a
general approach for adapting a traditional map by storing all duplicates
within a secondary container as a value in the map. Give an alternative
implementation of a multimap using a binary search tree such that each
entryofthemapisstoredatadistinctnodeofthetree. Withtheexistence
of duplicates, weredeﬁne the search tree property so that all items in the
leftsubtreeofaposition pwithkeykhavekeysthatarelessthanorequal
tok,whileallitemsintherightsubtreeofphavekeysthataregreaterthan
orequaltok. UsethepublicinterfacegiveninCodeFragment10.17.
P-11.68 Prepare an implementation of splay trees that uses top-down splaying as
described inExerciseC-11.56. Performextensiveexperimental studiesto
compareitsperformancetothestandardbottom-upsplayingimplemented
inthischapter.
P-11.69 The mergeable heap ADT is an extension of the priority queue ADT
consisting of operations add(k, v), min(), remove min() and merge(h),
wherethemerge(h)operations performsaunionofthemergeable heaph
with the present one, incorporating all items into the current one while
emptying h. Describe a concrete implementation of the mergeable heap
ADT that achieves O(logn) performance for all its operations, where n
denotes thesizeoftheresulting heapforthemergeoperation.
P-11.70 Writeaprogramthatperformsasimplen-bodysimulation, called“Jump-
ingLeprechauns.” Thissimulationinvolvesnleprechauns, numbered1to
n. It maintains a gold value g for each leprechaun i, which begins with
i
each leprechaun starting out with a million dollars worth ofgold, that is,
g = 1000000 for each i = 1,2,...,n. In addition, the simulation also
i
maintains, for each leprechaun, i, a place on the horizon, which is repre-
sented as a double-precision ﬂoating-point number, x. In each iteration
i
ofthesimulation, thesimulation processes theleprechauns inorder. Pro-
cessing a leprechaun i during this iteration begins by computing a new
placeonthehorizon fori,whichisdetermined bytheassignment
x = x +rg,
i i i
where r is a random ﬂoating-point number between −1 and 1. The lep-
rechaun i then steals half the gold from the nearest leprechauns on either
side ofhim and adds thisgold tohis gold value,g. Writeaprogram that
i
can perform a series of iterations in this simulation for a given number,
n,ofleprechauns. Youmustmaintain thesetofhorizon positions using aChapterNotes 535
Chapter Notes
Some of the data structures discussed in this chapter are extensively covered by Knuth
in his Sorting and Searchingbook [65], and by Mehlhorn in [76]. AVL trees are due to
Adel’son-Vel’skiiandLandis[2],whoinventedthisclassofbalancedsearchtreesin1962.
Binarysearchtrees,AVLtrees,andhashingaredescribedinKnuth’sSortingandSearch-
ing[65]book.Average-heightanalysesforbinarysearchtreescanbefoundinthebooksby
Aho,Hopcroft,andUllman[6]andCormen,Leiserson,RivestandStein[29]. Thehand-
bookbyGonnetandBaeza-Yates[44]containsanumberoftheoreticalandexperimental
comparisonsamongmapimplementations. Aho, Hopcroft,andUllman[5]discuss(2,3)
trees,whicharesimilarto(2,4)trees. Red-blacktreesweredeﬁnedbyBayer[10]. Vari-
ationsandinterestingpropertiesofred-blacktreesarepresentedinapaperbyGuibasand
Sedgewick[48]. Thereaderinterestedinlearningmoreaboutdifferentbalancedtreedata
structuresisreferredtothebooksbyMehlhorn[76]andTarjan[95],andthebookchapter
byMehlhornandTsakalidis[78]. Knuth[65]isexcellentadditionalreadingthatincludes
earlyapproachestobalancingtrees. SplaytreeswereinventedbySleatorandTarjan[89]Chapter
12
Sorting and Selection
Contents
12.1 Why Study Sorting Algorithms? . . . . . . . . . . . . . . . 537
12.2 Merge-Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
12.2.1 Divide-and-Conquer . . . . . . . . . . . . . . . . . . . . . 538
12.2.2 Array-Based Implementation of Merge-Sort . . . . . . . . 543
12.2.3 The Running Time of Merge-Sort . . . . . . . . . . . . . 544
(cid:2)
12.2.4 Merge-Sort and Recurrence Equations . . . . . . . . . . 546
12.2.5 Alternative Implementations of Merge-Sort . . . . . . . . 547
12.3 Quick-Sort . . . . . . . . . . . . . . . . . . . . . . . . . . . 550
12.3.1 Randomized Quick-Sort . . . . . . . . . . . . . . . . . . . 557
12.3.2 Additional Optimizations for Quick-Sort . . . . . . . . . . 559
12.4 Studying Sorting through an Algorithmic Lens . . . . . . . 562
12.4.1 Lower Bound for Sorting . . . . . . . . . . . . . . . . . . 562
12.4.2 Linear-Time Sorting: Bucket-Sort and Radix-Sort . . . . . 564
12.5 Comparing Sorting Algorithms . . . . . . . . . . . . . . . . 567
12.6 Python’s Built-In Sorting Functions . . . . . . . . . . . . . 569
12.6.1 Sorting According to a Key Function . . . . . . . . . . . . 569
12.7 Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571
12.7.1 Prune-and-Search . . . . . . . . . . . . . . . . . . . . . . 571
12.7.2 Randomized Quick-Select . . . . . . . . . . . . . . . . . . 572
12.7.3 Analyzing Randomized Quick-Select . . . . . . . . . . . . 57312.1. WhyStudySortingAlgorithms? 537
12.1 Why Study Sorting Algorithms?
Much of this chapter focuses on algorithms for sorting a collection of objects.
Given a collection, the goal is to rearrange the elements so that they are ordered
from smallest to largest (or to produce a new copy of the sequence with such an
order). Aswedidwhenstudying priorityqueues (seeSection9.4),weassumethat
such a consistent order exists. In Python, the natural orderof objects is typically1
deﬁnedusingthe<operator havingfollowingproperties:
• Irreﬂexive property: k(cid:15)<k.
• Transitiveproperty: ifk <k andk <k ,thenk <k .
1 2 2 3 1 3
The transitive property is important as it allows us to inferthe outcome of certain
comparisonswithouttakingthetimetoperformthosecomparisons,therebyleading
tomoreefﬁcientalgorithms.
Sortingisamongthemostimportant,andwellstudied,ofcomputingproblems.
Datasetsareoftenstoredinsortedorder,forexample,toallowforefﬁcientsearches
with the binary search algorithm (see Section 4.1.3). Many advanced algorithms
foravarietyofproblemsrelyonsortingasasubroutine.
Python has built-in support for sorting data, in the form of the sort method of
the list class that rearranges the contents of a list, and the built-in sorted function
thatproducesanewlistcontaining theelementsofanarbitrary collection insorted
order. Those built-in functions use advanced algorithms (some of which we will
describe in this chapter), and they are highly optimized. A programmer should
typically relyoncallstothebuilt-in sortingfunctions, asitisraretohaveaspecial
enoughcircumstance towarrantimplementingasortingalgorithm fromscratch.
With that said, it remains important to have a deep understanding of sorting
algorithms. Most immediately, when calling the built-in function, it is good to
know what to expect in terms of efﬁciency and how that may depend upon the
initialorderofelementsorthetypeofobjectsthatarebeingsorted. Moregenerally,
the ideas and approaches that have led to advances in the development of sorting
algorithm carryovertoalgorithm development inmanyotherareasofcomputing.
Wehaveintroduced severalsortingalgorithms alreadyinthisbook:
• Insertion-sort (seeSections5.5.2,7.5,and9.4.1)
• Selection-sort (seeSection9.4.1)
• Bubble-sort (seeExerciseC-7.38)
• Heap-sort(seeSection9.4.2)
In this chapter, we present four other sorting algorithms, called merge-sort,
quick-sort, bucket-sort, andradix-sort, andthendiscusstheadvantages anddisad-
vantages ofthevariousalgorithms inSection12.5.
1InSection12.6.1,wewillexploreanothertechniqueusedinPythonforsortingdataaccording538 Chapter12. SortingandSelection
12.2 Merge-Sort
12.2.1 Divide-and-Conquer
Theﬁrsttwoalgorithmswedescribeinthischapter,merge-sortandquick-sort, use
recursion in an algorithmic design pattern called divide-and-conquer. We have
already seen thepower ofrecursion in describing algorithms inanelegant manner
(see Chapter 4). The divide-and-conquer pattern consists of the following three
steps:
1. Divide: If the input size is smaller than a certain threshold (say, one or two
elements), solve the problem directly using a straightforward method and
return the solution so obtained. Otherwise, divide the input data into twoor
moredisjointsubsets.
2. Conquer: Recursivelysolvethesubproblems associated withthesubsets.
3. Combine: Takethe solutions to the subproblems and merge them into a so-
lutiontotheoriginal problem.
Using Divide-and-Conquer for Sorting
Wewillﬁrstdescribe themerge-sortalgorithm atahighlevel,withoutfocusing on
whether the data is an array-based (Python) list or a linked list; we will soon give
concrete implementations foreach. TosortasequenceSwithnelementsusingthe
threedivide-and-conquer steps,themerge-sort algorithmproceeds asfollows:
1. Divide: If S has zero or one element, return S immediately; it is already
sorted. Otherwise (S has at least two elements), remove all the elements
from S and put them into two sequences, S and S , each containing about
1 2
half of the elements of S; that is, S contains the ﬁrst (cid:16)n/2(cid:17) elements of S,
1
andS contains theremaining(cid:13)n/2(cid:14)elements.
2
2. Conquer: RecursivelysortsequencesS andS .
1 2
3. Combine: Put back the elements into S by merging the sorted sequences S
1
andS intoasortedsequence.
2
Inreference tothedividestep,werecallthatthenotation(cid:16)x(cid:17)indicates theﬂoorof
x,thatis,thelargest integerk,suchthatk≤x. Similarly,thenotation(cid:13)x(cid:14)indicates12.2. Merge-Sort 539
Wecanvisualizeanexecutionofthemerge-sortalgorithmbymeansofabinary
treeT,calledthemerge-sorttree. EachnodeofT representsarecursiveinvocation
(or call) of the merge-sort algorithm. We associate with each node v of T the
sequence S that is processed by the invocation associated withv. The children of
nodevareassociated withtherecursive callsthatprocess thesubsequences S and
1
S of S. The external nodes of T are associated with individual elements of S,
2
corresponding toinstances ofthealgorithm thatmakenorecursive calls.
Figure 12.1 summarizes an execution of the merge-sort algorithm by showing
theinput and output sequences processed ateachnode ofthe merge-sort tree. The
step-by-stepevolutionofthemerge-sorttreeisshowninFigures12.2through12.4.
This algorithm visualization in terms of the merge-sort tree helps us analyze
the running time of the merge-sort algorithm. In particular, since the size of the
input sequence roughly halves at each recursive call of merge-sort, the height of
themerge-sort treeisaboutlogn(recallthatthebaseoflogis2ifomitted).
85 24 63 45 17 31 96 50
85 24 63 45 17 31 96 50
85 24 63 45 17 31 96 50
85 24 63 45 17 31 96 50
(a)
17 24 31 45 50 63 85 96
24 45 63 85 17 31 50 96
24 85 45 63 17 31 50 96
85 24 63 45 17 31 96 50
(b)
Figure 12.1: Merge-sort tree T for an execution of the merge-sort algorithm on
a sequence with 8 elements: (a) input sequences processed at each node of T;540 Chapter12. SortingandSelection
85 24 63 45 17 31 96 50 17 31 96 50
85 24 63 45
(a) (b)
17 31 96 50 17 31 96 50
63 45 63 45
85 24 24
85
(c) (d)
17 31 96 50 17 31 96 50
63 45 63 45
85 24 85
24
(e) (f)
Figure 12.2: Visualization of an execution of merge-sort. Each node of the tree
representsarecursivecallofmerge-sort. Thenodesdrawnwithdashedlinesrepre-
sentcallsthathavenotbeenmadeyet. Thenodedrawnwiththicklinesrepresents
thecurrent call. Theempty nodes drawnwiththinlines represent completed calls.
Theremainingnodes(drawnwiththinlinesandnotempty)represent callsthatare12.2. Merge-Sort 541
17 31 96 50 17 31 96 50
24 85 63 45 24 85
63 45
(g) (h)
17 31 96 50 17 31 96 50
24 85 24 85
45 63
63 45
(i) (j)
17 31 96 50 17 31 96 50
24 85 24 45 63 85
45 63
(k) (l)
Figure 12.3: Visualization of an execution of merge-sort. (Combined with Fig-542 Chapter12. SortingandSelection
24 45 63 85 24 45 63 85
17 31 96 50 17 31 50 96
(m) (n)
24 45 63 85 17 31 50 96 17 24 31 45 50 63 85 96
(o) (p)
Figure 12.4: Visualization of an execution of merge-sort (continued from Fig-
ure 12.3). Several invocations are omitted between (m)and (n). Note the merging
oftwohalvesperformed instep(p).
Proposition 12.1: Themerge-sorttreeassociatedwithanexecutionofmerge-
sortonasequenceofsizenhasheight(cid:13)logn(cid:14).
WeleavethejustiﬁcationofProposition12.1asasimpleexercise(R-12.1). We
willusethisproposition toanalyzetherunningtimeofthemerge-sort algorithm.
Having given an overview of merge-sort and an illustration of how it works,
let us consider each of the steps of this divide-and-conquer algorithm in more de-
tail. Dividing asequence of sizeninvolves separating itatthe element withindex
(cid:13)n/2(cid:14), andrecursive callscanbestartedbypassing thesesmallersequences aspa-
rameters. The difﬁcult step is combining the two sorted sequences into a single
sorted sequence. Thus, before we present our analysis of merge-sort, we need to12.2. Merge-Sort 543
12.2.2 Array-Based Implementation of Merge-Sort
We begin by focusing on the case when a sequence of items is represented as an
(array-based)Pythonlist. Themergefunction(CodeFragment12.1)isresponsible
for the subtask of merging two previously sorted sequences, S and S , with the
1 2
output copied into S. We copy one element during each pass of the while loop,
conditionally determining whetherthenextelementshouldbetakenfromS orS .
1 2
Thedivide-and-conquer merge-sort algorithm isgiveninCodeFragment12.2.
We illustrate a step of the merge process in Figure 12.5. During the process,
index i represents the number of elements ofS that have been copied to S, while
1
index jrepresentsthenumberofelementsofS thathavebeencopiedtoS. Assum-
2
ing S and S both have atleast one uncopied element, wecopy the smaller of the
1 2
two elements being considered. Since i+ j objects have been previously copied,
the next element is placed inS[i+ j]. (For example, when i+ j is 0, the next ele-
mentiscopiedtoS[0]). Ifwereachtheendofoneofthesequences, wemustcopy
thenextelementfromtheother.
1 def merge(S1, S2, S):
2 ”””Merge two sorted Python lists S1 and S2 into properly sized list S.”””
3 i = j = 0
4 while i + j < len(S):
5 if j == len(S2) or (i < len(S1) and S1[i] < S2[j]):
6 S[i+j] = S1[i] # copy ith element of S1 as next item of S
7 i += 1
8 else:
9 S[i+j] = S2[j] # copy jth element of S2 as next item of S
10 j += 1
CodeFragment12.1:AnimplementationofthemergeoperationforPython’sarray-
basedlistclass.
0 1 2 3 4 5 6 0 1 2 3 4 5 6
S1 2 5 8 11 12 14 15 S1 2 5 8 11 12 14 15
i i
0 1 2 3 4 5 6 0 1 2 3 4 5 6
S2 3 9 10 18 19 22 25 S2 3 9 10 18 19 22 25
j j
0 1 2 3 4 5 6 7 8 9 10 11 12 13 0 1 2 3 4 5 6 7 8 9 10 11 12 13
S 2 3 5 8 9 S 2 3 5 8 9 10
i+j i+j
(a) (b)
Figure12.5: A step in the merge of two sorted arrays for which S [j]<S [i]. We
2 1544 Chapter12. SortingandSelection
1 def merge sort(S):
2 ”””Sort the elements of Python list S using the merge-sort algorithm.”””
3 n = len(S)
4 if n < 2:
5 return # list is already sorted
6 # divide
7 mid = n // 2
8 S1 = S[0:mid] # copy of ﬁrst half
9 S2 = S[mid:n] # copy of second half
10 # conquer (with recursion)
11 merge sort(S1) # sort copy of ﬁrst half
12 merge sort(S2) # sort copy of second half
13 # merge results
14 merge(S1, S2, S) # merge sorted halves back into S
CodeFragment12.2: Animplementation oftherecursive merge-sort algorithm for
Python’s array-based list class (using the merge function deﬁned in Code Frag-
ment12.1.
12.2.3 The Running Time of Merge-Sort
We begin by analyzing the running time of the merge algorithm. Let n and n
1 2
bethenumberofelements ofS andS ,respectively. Itisclearthattheoperations
1 2
performedinsideeachpassofthewhilelooptakeO(1)time. Thekeyobservationis
thatduringeachiterationoftheloop,oneelementiscopiedfromeitherS orS into
1 2
S (and that element is considered no further). Therefore, thenumber of iterations
oftheloopisn +n . Thus,therunningtimeofalgorithmmergeisO(n +n ).
1 2 1 2
Having analyzed the running time of the merge algorithm used to combine
subproblems, let us analyze the running time of the entire merge-sort algorithm,
assumingitisgivenaninputsequenceofnelements. Forsimplicity,werestrictour
attention tothecasewherenisapowerof2. Weleaveittoanexercise(R-12.3)to
showthattheresultofouranalysis alsoholdswhennisnotapowerof2.
When evaluating the merge-sort recursion, we rely on the analysis technique
introduced in Section 4.2. We account for the amount of time spent within each
recursive call, but excluding any time spent waiting for successive recursive calls
to terminate. In the case of our merge sort function, we account for the time to
divide the sequence into two subsequences, and the call to merge to combine the12.2. Merge-Sort 545
A merge-sort tree T, as portrayed in Figures 12.2 through 12.4, can guide our
analysis. Considerarecursivecallassociatedwithanodevofthemerge-sorttreeT.
The divide step at node v is straightforward; this step runs in time proportional to
thesizeofthesequenceforv,basedontheuseofslicingtocreatecopiesofthetwo
list halves. Wehave already observed that the merging step also takes time that is
linear in the size of the merged sequence. If we let i denote the depth of node v,
the time spent at node v is O(n/2i), since the size of the sequence handled by the
recursivecallassociated withvisequalton/2i.
LookingatthetreeT moreglobally,asshowninFigure12.6,weseethat,given
our deﬁnition of“time spent at anode,” the running timeof merge-sort isequal to
thesumofthetimesspentatthenodesofT. ObservethatT hasexactly2i nodesat
depth i. This simple observation has an important consequence, forit implies that
theoveralltimespentatallthenodesofT atdepthiisO(2i·n/2i),whichisO(n).
ByProposition 12.1, the height ofT is (cid:13)logn(cid:14). Thus, since the time spent at each
ofthe(cid:13)logn(cid:14)+1levelsofT isO(n),wehavethefollowingresult:
Proposition 12.2: Algorithmmerge-sortsortsasequenceSofsizeninO(nlogn)
time,assumingtwoelementsofScanbecomparedinO(1)time.
Height Timeperlevel
n O(n)
n/2 n/2 O(n)
O(logn)
n/4 n/4 n/4 n/4 O(n)
Totaltime: O(nlogn)
Figure12.6: A visual analysis of the running time of merge-sort. Each node rep-
resents the time spent in a particular recursive call, labeled with the size of its546 Chapter12. SortingandSelection
(cid:2)
12.2.4 Merge-Sort and Recurrence Equations
Thereisanotherwaytojustifythattherunningtimeofthemerge-sortalgorithm is
O(nlogn)(Proposition12.2). Namely,wecandealmoredirectlywiththerecursive
nature of the merge-sort algorithm. In this section, wepresent such an analysis of
therunningtimeofmerge-sort,andinsodoing,introducethemathematicalconcept
ofarecurrenceequation(alsoknownasrecurrencerelation).
Let the function t(n) denote the worst-case running time of merge-sort on an
input sequence of size n. Since merge-sort is recursive, we can characterize func-
tiont(n)by meansofanequation wherethe functiont(n)isrecursively expressed
in terms of itself. In order to simplify our characterization of t(n), let us restrict
ourattentiontothecasewhennisapowerof2. (Weleavetheproblemofshowing
that our asymptotic characterization still holds in the general case as an exercise.)
Inthiscase,wecanspecifythedeﬁnitionoft(n)as
(cid:4)
b ifn≤1
t(n) =
2t(n/2)+cn otherwise.
An expression such as the one above is called a recurrence equation, since the
function appears onboththeleft-andright-hand sidesoftheequalsign. Although
such a characterization is correct and accurate, what we really desire is a big-Oh
type of characterization oft(n) that does not involve the functiont(n) itself. That
is,wewantaclosed-form characterization oft(n).
Wecanobtainaclosed-formsolutionbyapplyingthedeﬁnitionofarecurrence
equation, assuming n is relatively large. For example, after one more application
oftheequation above,wecanwriteanewrecurrence fort(n)as
t(n) = 2(2t(n/22)+(cn/2))+cn
= 22t(n/22)+2(cn/2)+cn = 22t(n/22)+2cn.
If we apply the equation again, we get t(n)=23t(n/23)+3cn. At this point, we
shouldseeapatternemerging, sothatafterapplying thisequation itimes,weget
t(n) = 2it(n/2i)+icn.
Theissuethatremains,then,istodeterminewhentostopthisprocess. Toseewhen
to stop, recall that we switch to the closed formt(n)=b when n≤1, which will
occur when 2i =n. In other words, this will occur when i= logn. Making this
substitution, then,yields
t(n) = 2lognt(n/2logn)+(logn)cn
= nt(1)+cnlogn
= nb+cnlogn.12.2. Merge-Sort 547
12.2.5 Alternative Implementations of Merge-Sort
Sorting Linked Lists
The merge-sort algorithm can easily be adapted to use any form of a basic queue
asitscontainer type. InCodeFragment12.3, weprovide suchanimplementation,
based on use of the LinkedQueue class from Section 7.1.2. The O(nlogn) bound
for merge-sort from Proposition 12.2 applies to this implementation aswell, since
each basic operation runs in O(1) time when implemented with a linked list. We
showanexampleexecution ofthisversionofthemergealgorithm inFigure12.7.
1 def merge(S1, S2, S):
2 ”””Merge two sorted queue instances S1 and S2 into empty queue S.”””
3 while not S1.is empty( ) and not S2.is empty():
4 if S1.ﬁrst( ) < S2.ﬁrst():
5 S.enqueue(S1.dequeue())
6 else:
7 S.enqueue(S2.dequeue())
8 while not S1.is empty(): # move remaining elements of S1 to S
9 S.enqueue(S1.dequeue())
10 while not S2.is empty(): # move remaining elements of S2 to S
11 S.enqueue(S2.dequeue())
12
13 def merge sort(S):
14 ”””Sort the elements of queue S using the merge-sort algorithm.”””
15 n = len(S)
16 if n < 2:
17 return # list is already sorted
18 # divide
19 S1 = LinkedQueue( ) # or any other queue implementation
20 S2 = LinkedQueue()
21 while len(S1) < n // 2: # move the ﬁrst n//2 elements to S1
22 S1.enqueue(S.dequeue())
23 while not S.is empty(): # move the rest to S2
24 S2.enqueue(S.dequeue())
25 # conquer (with recursion)
26 merge sort(S1) # sort ﬁrst half
27 merge sort(S2) # sort second half
28 # merge results
29 merge(S1, S2, S) # merge sorted halves back into S548 Chapter12. SortingandSelection
S1 24 45 63 85 S1 24 45 63 85
S2 17 31 50 96 S2 31 50 96
S S 17
(a) (b)
S1 45 63 85 S1 45 63 85
S2 31 50 96 S2 50 96
S 17 24 S 17 24 31
(c) (d)
S1 63 85 S1 63 85
S2 50 96 S2 96
S 17 24 31 45 S 17 24 31 45 50
(e) (f)
S1 85 S1
S2 96 S2 96
S 17 24 31 45 50 63 85
S 17 24 31 45 50 63
(g) (h)
S1
S2
S 17 24 31 45 50 63 85 96
(i)
Figure12.7: Example of an execution of the merge algorithm, as implemented in12.2. Merge-Sort 549
A Bottom-Up (Nonrecursive) Merge-Sort
Thereisanonrecursiveversionofarray-basedmerge-sort,whichrunsinO(nlogn)
time. It is a bit faster than recursive merge-sort in practice, as it avoids the extra
overheads of recursive calls and temporary memory at each level. The main idea
istoperformmerge-sortbottom-up, performingthemergeslevelbylevelgoingup
the merge-sort tree. Given an input array of elements, we begin by merging every
successivepairofelementsintosortedrunsoflengthtwo. Wemergetheserunsinto
runsoflengthfour,mergethesenewrunsintorunsoflengtheight,andsoon,until
the array is sorted. To keep the space usage reasonable, wedeploy a second array
thatstoresthemergedruns(swapping inputandoutputarraysaftereachiteration).
We give a Python implementation in Code Fragment 12.4. A similar bottom-up
approach canbeusedforsorting linkedlists. (SeeExerciseC-12.29.)
1 def merge(src, result, start, inc):
2 ”””Merge src[start:start+inc] and src[start+inc:start+2 inc] into result.”””
3 end1 = start+inc # boundary for run 1
4 end2 = min(start+2 inc, len(src)) # boundary for run 2
5 x, y, z = start, start+inc, start # index into run 1, run 2, result
6 while x < end1 and y < end2:
7 if src[x] < src[y]:
8 result[z] = src[x]; x += 1 # copy from run 1 and increment x
9 else:
10 result[z] = src[y]; y += 1 # copy from run 2 and increment y
11 z += 1 # increment z to reﬂect new result
12 if x < end1:
13 result[z:end2] = src[x:end1] # copy remainder of run 1 to output
14 elif y < end2:
15 result[z:end2] = src[y:end2] # copy remainder of run 2 to output
16
17 def merge sort(S):
18 ”””Sort the elements of Python list S using the merge-sort algorithm.”””
19 n = len(S)
20 logn = math.ceil(math.log(n,2))
21 src, dest = S, [None] n # make temporary storage for dest
22 for i in (2 k for k in range(logn)): # pass i creates all runs of length 2i
23 for j in range(0, n, 2 i): # each pass merges two length i runs
24 merge(src, dest, j, i)
25 src, dest = dest, src # reverse roles of lists
26 if S is not src:
27 S[0:n] = src[0:n] # additional copy to get results to S550 Chapter12. SortingandSelection
12.3 Quick-Sort
The next sorting algorithm we discuss is called quick-sort. Like merge-sort, this
algorithm is also based onthedivide-and-conquer paradigm, but ituses this tech-
nique in a somewhat opposite manner, as all the hard work is done before the
recursivecalls.
High-Level Description of Quick-Sort
The quick-sort algorithm sorts a sequence S using a simple recursive approach.
The main idea is to apply the divide-and-conquer technique, whereby we divide
S into subsequences, recur to sort each subsequence, and thencombine the sorted
subsequences by a simple concatenation. In particular, the quick-sort algorithm
consists ofthefollowingthreesteps(seeFigure12.8):
1. Divide: If S has at least two elements (nothing needs to be done if S has
zero or one element), select a speciﬁc elementx from S, which is called the
pivot. Asiscommonpractice, choose thepivotxtobethelastelement inS.
RemovealltheelementsfromSandputthemintothreesequences:
• L,storingtheelementsinSlessthanx
• E,storingtheelementsinSequaltox
• G,storing theelementsinSgreaterthanx
Ofcourse, ifthe elements ofS are distinct, then E holds just one element—
thepivotitself.
2. Conquer: RecursivelysortsequencesLandG.
3. Combine: PutbacktheelementsintoSinorderbyﬁrstinsertingtheelements
ofL,thenthoseofE,andﬁnallythoseofG.
1.Splitusingpivotx.
E(=x)
2.Recur. 2.Recur.
L(<x) G(>x)
3.Concatenate.12.3. Quick-Sort 551
Likemerge-sort,theexecutionofquick-sortcanbevisualizedbymeansofabi-
naryrecursiontree,calledthequick-sorttree. Figure12.9summarizesanexecution
ofthequick-sortalgorithmbyshowingtheinputandoutputsequencesprocessedat
each node of the quick-sort tree. The step-by-step evolution of the quick-sort tree
isshowninFigures12.10,12.11,and12.12.
Unlikemerge-sort,however,theheightofthequick-sorttreeassociatedwithan
executionofquick-sortislinearintheworstcase. Thishappens,forexample,ifthe
sequence consists ofndistinct elements andisalready sorted. Indeed, inthiscase,
thestandardchoiceofthelastelementaspivotyieldsasubsequenceLofsizen−1,
whilesubsequence E hassize 1and subsequence Ghassize 0. Ateach invocation
of quick-sort on subsequence L, the size decreases by 1. Hence, the height of the
quick-sort treeisn−1.
85 24 63 45 17 31 96 50
24 45 17 31 85 63 96
24 17 45 85 63
24 85
(a)
17 24 31 45 50 63 85 96
17 24 31 45 63 85 96
17 24 45 63 85
24 85
(b)
Figure12.9: Quick-sorttreeT foranexecutionofthequick-sort algorithm onase-
quencewith8elements: (a)inputsequencesprocessedateachnodeofT;(b)output
sequencesgeneratedateachnodeofT. Thepivotusedateachleveloftherecursion552 Chapter12. SortingandSelection
85 24 63 45 17 31 96 50 24 45 17 31 50 85 63 96
(a) (b)
50 85 63 96 50 85 63 96
24 45 17 31 24 17 31 45
(c) (d)
50 85 63 96 50 85 63 96
31 45 31 45
24 17 17 24
(e) (f)
Figure 12.10: Visualization of quick-sort. Each node of the tree represents a re-
cursive call. Thenodes drawn withdashed lines represent calls that have notbeen
madeyet. Thenode drawnwiththick lines represents therunning invocation. The
emptynodesdrawnwiththinlinesrepresentterminatedcalls. Theremainingnodes
represent suspended calls(thatis,activeinvocations thatarewaitingforachildin-
vocationtoreturn). Notethedividestepsperformedin(b),(d),and(f). (Continues12.3. Quick-Sort 553
50 85 63 96 50 85 63 96
31 45 31 45
17 24 17 24
(g) (h)
50 85 63 96 50 85 63 96
31 45 31 45
17 17 24
24
(i) (j)
50 85 63 96 50 85 63 96
31 45 17 24 31 45
17 24
(k) (l)
Figure12.11: Visualization of an execution of quick-sort. Note the concatenation554 Chapter12. SortingandSelection
50 85 63 96 50 85 63 96
17 24 31 17 24 31 45
45
(m) (n)
50 85 63 96 17 24 31 45 50 85 63 96
17 24 31 45
(o) (p)
17 24 31 45 50 63 85 96 17 24 31 45 50 63 85 96
(q) (r)
Figure12.12: Visualization of an execution of quick-sort. Several invocations be-
tween(p)and(q)havebeenomitted. Notetheconcatenationstepsperformedin(o)12.3. Quick-Sort 555
Performing Quick-Sort on General Sequences
In Code Fragment 12.5, we give an implementation of the quick-sort algorithm
that works on any sequence type that operates as a queue. Thisparticular version
reliesontheLinkedQueueclassfromSection7.1.2;weprovideamorestreamlined
implementation ofquick-sort usinganarray-based sequence inSection12.3.2.
Our implementation chooses the ﬁrst item of the queue as the pivot (since it
is easily accessible), and then it divides sequence S into queues L, E, and G of
elements that are respectively less than, equal to, and greater than the pivot. We
then recur on the L and G lists, and transfer elements from the sorted lists L, E,
and G back to S. All of the queue operations run in O(1) worst-case time when
implementedwithalinkedlist.
1 def quick sort(S):
2 ”””Sort the elements of queue S using the quick-sort algorithm.”””
3 n = len(S)
4 if n < 2:
5 return # list is already sorted
6 # divide
7 p = S.ﬁrst( ) # using ﬁrst as arbitrary pivot
8 L = LinkedQueue()
9 E = LinkedQueue()
10 G = LinkedQueue()
11 while not S.is empty(): # divide S into L, E, and G
12 if S.ﬁrst( ) < p:
13 L.enqueue(S.dequeue())
14 elif p < S.ﬁrst():
15 G.enqueue(S.dequeue())
16 else: # S.ﬁrst() must equal pivot
17 E.enqueue(S.dequeue())
18 # conquer (with recursion)
19 quick sort(L) # sort elements less than p
20 quick sort(G) # sort elements greater than p
21 # concatenate results
22 while not L.is empty():
23 S.enqueue(L.dequeue())
24 while not E.is empty():
25 S.enqueue(E.dequeue())
26 while not G.is empty():
27 S.enqueue(G.dequeue())556 Chapter12. SortingandSelection
Running Time of Quick-Sort
We can analyze the running time of quick-sort with the same technique used for
merge-sort inSection 12.2.3. Namely, wecanidentify thetimespent ateachnode
ofthequick-sort treeT andsumuptherunning timesforallthenodes.
Examining Code Fragment 12.5, wesee that the divide step andthe ﬁnal con-
catenation of quick-sort can be implemented in linear time. Thus, the time spent
at a node v of T is proportional to the input size s(v) of v, deﬁned as the size of
thesequencehandledbytheinvocation ofquick-sortassociatedwithnodev. Since
subsequenceE hasatleastoneelement(thepivot),thesumoftheinputsizesofthe
children ofvisatmosts(v)−1.
Let s denote the sum of the input sizes of the nodes at depth i for a particular
i
quick-sort treeT. Clearly,s =n,sincetherootrofT isassociated withtheentire
0
sequence. Also, s ≤n−1, since the pivot is not propagated to the children of r.
1
Moregenerally, itmustbethatsi <si−1 since theelements ofthesubsequences at
depthiallcomefromdistinctsubsequences atdepthi−1,andatleastoneelement
from depth i−1 does not propagate to depthibecause itis in asetE (in fact, one
elementfromeachnodeatdepthi−1doesnotpropagate todepthi).
Wecan therefore bound the overall running time ofanexecution ofquick-sort
asO(n·h)wherehistheoverall height ofthequick-sort treeT forthat execution.
Unfortunately,intheworstcase,theheightofaquick-sorttreeisΘ(n),asobserved
in Section 12.3. Thus, quick-sort runs in O(n2) worst-case time. Paradoxically,
if we choose the pivot as the last element of the sequence, this worst-case behav-
ior occurs for problem instances when sorting should be easy—if the sequence is
alreadysorted.
Given its name, we would expect quick-sort to run quickly, and it often does
in practice. The best case for quick-sort on a sequence of distinct elements oc-
curs when subsequences L and G have roughly the same size. In that case, as
wesawwithmerge-sort, thetree hasheightO(logn)and therefore quick-sort runs
in O(nlogn) time; we leave the justiﬁcation of this fact as an exercise (R-12.10).
More so, we can observe an O(nlogn) running time even if the split between L
and G isnot as perfect. Forexample, ifevery divide step caused one subsequence
to have one-fourth of those elements and the other to have three-fourths of the
elements, theheight ofthetreewould remainO(logn)andthus theoverallperfor-
manceO(nlogn).
Wewillseeinthe nextsection that introducing randomization inthechoice of
a pivot will makes quick-sort essentially behave in this way on average, with an12.3. Quick-Sort 557
12.3.1 Randomized Quick-Sort
One common method for analyzing quick-sort is to assume that the pivot will al-
ways divide the sequence in a reasonably balanced manner. We feel such an as-
sumptionwouldpresupposeknowledgeabouttheinputdistributionthatistypically
notavailable, however. Forexample, wewouldhave toassumethatwewillrarely
be given “almost” sorted sequences to sort, which are actually common in many
applications. Fortunately, this assumption is not needed in order for us to match
ourintuition toquick-sort’s behavior.
In general, we desire some way of getting close to the best-case running time
forquick-sort. Thewaytogetclosetothebest-case runningtime,ofcourse, isfor
the pivot to divide the input sequence S almost equally. If this outcome were to
occur, then it would result in arunning time that isasymptotically the sameas the
best-case running time. That is, having pivots close to the “middle” of the set of
elementsleadstoanO(nlogn)runningtimeforquick-sort.
Picking Pivots at Random
Sincethegoalofthepartitionstepofthequick-sortmethodistodividethesequence
Swithsufﬁcientbalance,letusintroducerandomizationintothealgorithmandpick
as the pivot a random element of the input sequence. That is, instead of picking
thepivot astheﬁrstorlastelementofS,wepick anelement ofSatrandom asthe
pivot, keeping the rest of the algorithm unchanged. This variation of quick-sort is
called randomized quick-sort. The following proposition shows that the expected
runningtimeofrandomizedquick-sortonasequencewithnelementsisO(nlogn).
Thisexpectationistakenoverallthepossiblerandomchoicesthealgorithmmakes,
and is independent of any assumptions about the distribution of the possible input
sequences thealgorithm islikelytobegiven.
Proposition 12.3: Theexpectedrunningtimeofrandomizedquick-sortonase-
quenceSofsizenisO(nlogn).
Justiﬁcation: We assume two elements of S can be compared in O(1) time.
Considerasinglerecursivecallofrandomized quick-sort,andletndenotethesize
oftheinputforthiscall. Saythatthiscallis“good”ifthepivotchosenissuchthat
subsequences L and G have size at least n/4 and at most 3n/4 each; otherwise, a
callis“bad.”
Now, consider the implications of our choosing a pivot uniformly at random.
Note that there are n/2 possible good choices for the pivot for any given call of
sizenoftherandomizedquick-sortalgorithm. Thus,theprobabilitythatanycallis
good is1/2. Notefurther that agood callwillatleast partition alistofsizeninto
twolistsofsize3n/4andn/4,andabadcallcouldbeasbadasproducingasingle558 Chapter12. SortingandSelection
Nowconsider arecursion traceforrandomized quick-sort. Thistracedeﬁnesa
binarytree,T,suchthateachnodeinT corresponds toadifferentrecursivecallon
asubproblem ofsortingaportionoftheoriginallist.
Saythat anodevinT isinsize groupiifthesize ofv’ssubproblem isgreater
than(3/4)i+1nandatmost(3/4)in. Letusanalyzetheexpectedtimespentworking
on all the subproblems for nodes in size group i. By the linearity of expectation
(Proposition B.19), the expected time for working on all these subproblems is the
sum of the expected times for each one. Some of these nodes correspond to good
callsandsomecorrespond tobadcalls. Butnotethat,sinceagoodcalloccurswith
probability 1/2, theexpected number ofconsecutive calls wehave tomakebefore
getting a good call is 2. Moreover, notice that as soon as we have a good call for
a node in size group i, its children will be in size groups higher than i. Thus, for
any element x from in the input list, the expected number of nodes in size group i
containingxintheirsubproblemsis2. Inotherwords,theexpectedtotalsizeofall
thesubproblems insizegroupiis2n. Sincethenonrecursive workweperform for
anysubproblem isproportional toits size, this implies that thetotal expected time
spentprocessing subproblems fornodesinsizegroupiisO(n).
The number of size groups is log n, since repeatedly multiplying by 3/4 is
4/3
the same as repeatedly dividing by 4/3. That is, the number of size groups is
O(logn). Therefore, the total expected running time of randomized quick-sort is
O(nlogn). (SeeFigure12.13.)
Iffact,wecanshowthattherunningtimeofrandomizedquick-sortisO(nlogn)
withhighprobability. (SeeExerciseC-12.54.)
Numberof Expectedtime
sizegroups persizegroup
s(r) sizegroup0 O(n)
s(a) s(b) sizegroup1 O(n)
O(logn)
s(c) s(d) s(e) s(f) sizegroup2 O(n)
Totalexpectedtime: O(nlogn)
Figure12.13: A visual time analysis of the quick-sort treeT. Each node is shown12.3. Quick-Sort 559
12.3.2 Additional Optimizations for Quick-Sort
An algorithm is in-place if it uses only a small amount of memory in addition
to that needed for the original input. Our implementation ofheap-sort, from Sec-
tion9.4.2,isanexampleofsuchanin-placesortingalgorithm. Ourimplementation
ofquick-sortfromCodeFragment12.5doesnotqualifyasin-placebecauseweuse
additionalcontainersL,E,andGwhendividingasequenceSwithineachrecursive
call. Quick-sortofanarray-basedsequencecanbeadaptedtobein-place,andsuch
anoptimization isusedinmostdeployed implementations.
Performing the quick-sort algorithm in-place requires a bit of ingenuity, how-
ever,forwemustusetheinputsequence itselftostorethesubsequences forallthe
recursive calls. We show algorithm inplace quick sort, which performs in-place
quick-sort, in Code Fragment 12.6. Our implementation assumes that the input
sequence, S, is given as a Python list of elements. In-place quick-sort modiﬁes
the input sequence using element swapping and does not explicitly create subse-
quences. Instead, asubsequence oftheinput sequence isimplicitly represented by
a range of positions speciﬁed by a leftmost index a and a rightmost index b. The
1 def inplace quick sort(S, a, b):
2 ”””Sort the list from S[a] to S[b] inclusive using the quick-sort algorithm.”””
3 if a >= b: return # range is trivially sorted
4 pivot = S[b] # last element of range is pivot
5 left = a # will scan rightward
6 right = b−1 # will scan leftward
7 while left <= right:
8 # scan until reaching value equal or larger than pivot (or right marker)
9 while left <= right and S[left] < pivot:
10 left += 1
11 # scan until reaching value equal or smaller than pivot (or left marker)
12 while left <= right and pivot < S[right]:
13 right −= 1
14 if left <= right: # scans did not strictly cross
15 S[left], S[right] = S[right], S[left] # swap values
16 left, right = left + 1, right − 1 # shrink range
17
18 # put pivot into its ﬁnal place (currently marked by left index)
19 S[left], S[b] = S[b], S[left]
20 # make recursive calls
21 inplace quick sort(S, a, left − 1)
22 inplace quick sort(S, left + 1, b)560 Chapter12. SortingandSelection
dividestepisperformedbyscanningthearraysimultaneouslyusinglocalvariables
left,whichadvancesforward,andright,whichadvancesbackward,swappingpairs
of elements that are in reverse order, as shown in Figure 12.14. When these two
indices pass each other, the division step is complete and the algorithm completes
byrecurringonthesetwosublists. Thereisnoexplicit“combine”step,becausethe
concatenation ofthetwosublists isimplicittothein-placeuseoftheoriginallist.
It isworth noting that if asequence has duplicate values, weare not explicitly
creatingthreesublistsL,E,andG,asinouroriginalquick-sortdescription. Wein-
stead allow elements equal tothe pivot (other than thepivotitself) tobedispersed
acrossthetwosublists. ExerciseR-12.11explores thesubtlety ofourimplementa-
tion in the presence of duplicate keys, and Exercise C-12.33describes an in-place
algorithm thatstrictly partitions intothreesublistsL,E,andG.
85 24 63 45 17 31 96 50
l r
(a)
85 24 63 45 17 31 96 50
l r
(b)
31 24 63 45 17 85 96 50
l r
(c)
31 24 63 45 17 85 96 50
l r
(d)
31 24 17 45 63 85 96 50
l,r
(e)
31 24 17 45 63 85 96 50
r < l
(f)
31 24 17 45 50 85 96 63
(g)
Figure12.14:Dividestepofin-placequick-sort,usingindexlasshorthandforiden-
tiﬁer left, and index r as shorthand for identiﬁer right. Index l scans the sequence
fromlefttoright, andindexr scansthesequence fromrighttoleft. Aswapisper-
formedwhenl isatanelementaslargeasthepivotandr isatanelementassmall12.3. Quick-Sort 561
Although the implementation we describe in this section for dividing the se-
quence into twopieces is in-place, wenote that the completequick-sort algorithm
needs space for a stack proportional to the depth of the recursion tree, which in
thiscasecanbeaslargeasn−1. Admittedly,theexpectedstackdepthisO(logn),
which is small compared to n. Nevertheless, a simple trick lets us guarantee the
stacksizeisO(logn). Themainideaistodesignanonrecursiveversionofin-place
quick-sortusinganexplicitstacktoiterativelyprocesssubproblems(eachofwhich
canberepresented withapairofindices marking subarray boundaries). Eachiter-
ation involves popping the top subproblem, splitting it in two(if itis big enough),
and pushing the two new subproblems. The trick is that when pushing the new
subproblems, weshould ﬁrstpushthelarger subproblem andthenthesmallerone.
In this way, the sizes of the subproblems will at least double as we go down the
stack;hence,thestackcanhavedepthatmostO(logn). Weleavethedetailsofthis
implementation asanexercise(P-12.56).
Pivot Selection
Ourimplementationinthissectionblindlypicksthelastelementasthepivotateach
levelofthequick-sort recursion. Thisleavesitsusceptible totheΘ(n2)-timeworst
case, mostnotably whentheoriginal sequence isalready sorted, reverse sorted, or
nearlysorted.
AsdescribedinSection12.3.1,thiscanbeimproveduponbyusingarandomly
chosen pivot for each partition step. In practice, another common technique for
choosing a pivot is to use the median of tree values, taken respectively from the
front, middle, andtailofthearray. Thismedian-of-three heuristic willmoreoften
choose agood pivotandcomputing amedianofthree mayrequire loweroverhead
than selecting a pivot with a random number generator. For larger data sets, the
medianofmorethanthreepotential pivotsmightbecomputed.
Hybrid Approaches
Although quick-sort has very good performance on large data sets, it has rather
high overhead on relatively small data sets. For example, the process of quick-
sortingasequence ofeightelements, asillustrated inFigures12.10through 12.12,
involves considerable bookkeeping. In practice, a simple algorithm like insertion-
sort(Section7.5)willexecutefasterwhensortingsuchashortsequence.
It is therefore common, in optimized sorting implementations, to use a hybrid
approach,withadivide-and-conquer algorithmuseduntilthesizeofasubsequence
falls below some threshold (perhaps 50 elements); insertion-sort can be directly
invoked upon portions with length below the threshold. We will further discuss
suchpractical considerations inSection12.5, whencomparing theperformance of562 Chapter12. SortingandSelection
12.4 Studying Sorting through an Algorithmic Lens
Recappingourdiscussionsonsortingtothispoint,wehavedescribedseveralmeth-
odswitheither aworstcaseorexpected running timeofO(nlogn)onaninput se-
quence of size n. These methods include merge-sort and quick-sort, described in
this chapter, as well as heap-sort (Section 9.4.2). In this section, we study sorting
asanalgorithmic problem,addressing generalissuesaboutsortingalgorithms.
12.4.1 Lower Bound for Sorting
A natural ﬁrst question to ask is whether we can sort any faster than O(nlogn)
time. Interestingly,ifthecomputationalprimitiveusedbyasortingalgorithmisthe
comparison oftwoelements, this isinfactthebest wecando—comparison-based
sorting has an Ω(nlogn) worst-case lower bound on its running time. (Recall the
notation Ω(·)from Section 3.3.1.) Tofocus onthemaincostofcomparison-based
sorting, letusonlycountcomparisons, forthesakeofalowerbound.
Suppose we are given a sequence S = (x0,x1,...,xn−1) that we wish to sort,
and assume that all the elements of S are distinct (this is not really a restriction
since we are deriving a lower bound). We do not care if S is implemented as an
array or a linked list, for the sake of our lower bound, since we are only counting
comparisons. Eachtimeasorting algorithm compares twoelements x andx (that
i j
is,itasks,“isx <x ?”),therearetwooutcomes: “yes”or“no.” Basedontheresult
i j
of this comparison, the sorting algorithm may perform some internal calculations
(which weare not counting here) and willeventually performanother comparison
between twootherelements ofS,whichagainwillhavetwooutcomes. Therefore,
wecan represent acomparison-based sorting algorithm withadecision treeT (re-
call Example 8.6). That is, each internal nodev inT corresponds toa comparison
andtheedgesfrompositionvtoitschildrencorrespondtothecomputations result-
ingfromeithera“yes”or“no”answer. Itisimportanttonotethatthehypothetical
sortingalgorithminquestionprobablyhasnoexplicitknowledgeofthetreeT. The
treesimplyrepresentsallthepossiblesequencesofcomparisonsthatasortingalgo-
rithmmightmake,startingfromtheﬁrstcomparison(associated withtheroot)and
endingwiththelastcomparison (associated withtheparentofanexternalnode).
Each possible initial order, or permutation, of the elements in S will cause
our hypothetical sorting algorithm toexecute aseries ofcomparisons, traversing a
path inT from the roottosome external node. Letusassociate witheach external
node v in T, then, the set of permutations of S that cause our sorting algorithm to
end up in v. The most important observation in our lower-bound argument is that
each external node v in T can represent the sequence of comparisons for at most12.4. StudyingSortingthroughanAlgorithmicLens 563
permutations P andP ofSareassociated withthesameexternal node, thenthere
1 2
are at least two objects x and x , such that x is before x in P but x is after x
i j i j 1 i j
inP . Atthesametime, theoutput associated withvmustbeaspeciﬁc reordering
2
ofS,witheitherx orx appearingbeforetheother. ButifP andP bothcausethe
i j 1 2
sortingalgorithmtooutputtheelementsofSinthisorder,thenthatimpliesthereis
awaytotrickthealgorithm intooutputtingx andx inthewrongorder. Sincethis
i j
cannot beallowedbyacorrect sorting algorithm, each external node ofT mustbe
associated withexactly onepermutation ofS. Weusethisproperty ofthedecision
treeassociated withasortingalgorithm toprovethefollowingresult:
Proposition 12.4: Therunningtimeofanycomparison-basedalgorithmforsort-
ingann-elementsequenceisΩ(nlogn)intheworstcase.
Justiﬁcation: The running time of a comparison-based sorting algorithm must
be greater than or equal to the height of the decision tree T associated with this
algorithm, as described above. (See Figure 12.15.) By the argument above, each
external node in T must be associated with one permutation ofS. Moreover, each
permutation of S must result in a different external node of T. The number of
permutations of n objects is n! = n(n−1)(n−2)···2·1. Thus, T must have at
leastn!externalnodes. ByProposition 8.8,theheightofT isatleastlog(n!). This
immediately justiﬁes the proposition, because there are atleast n/2 terms that are
greaterthanorequalton/2intheproductn!;hence,
(cid:17) (cid:18)
(cid:11) (cid:12)
n n n n
log(n!)≥log 2 = log ,
2 2 2
whichisΩ(nlogn).
MinimumHeight
(i.e.,worst-caserunningtime)
xi<xj?
xa<xb? xc<xd?
log(n!)
xe<xf ? xg<xh? xk<xl? xm<xn?
n!564 Chapter12. SortingandSelection
12.4.2 Linear-Time Sorting: Bucket-Sort and Radix-Sort
In the previous section, we showed that Ω(nlogn) time is necessary, in the worst
case, tosort ann-element sequence withacomparison-based sorting algorithm. A
naturalquestion toask,then,iswhetherthereareotherkindsofsortingalgorithms
that can be designed to run asymptotically faster than O(nlogn) time. Interest-
ingly, such algorithms exist, but they require special assumptions about the input
sequencetobesorted. Evenso,suchscenariosoftenariseinpractice,suchaswhen
sortingintegersfromaknownrangeorsortingcharacterstrings,sodiscussingthem
isworthwhile. Inthissection,weconsidertheproblemofsortingasequenceofen-
tries,eachakey-value pair,wherethekeyshavearestricted type.
Bucket-Sort
Consider asequence S of nentries whose keys are integers inthe range[0,N−1],
forsome integer N ≥2, and suppose thatS should be sorted according tothe keys
of the entries. Inthis case, it ispossible to sortS in O(n+N)time. Itmight seem
surprising, but this implies, for example, that if N is O(n), then we can sort S in
O(n)time. Ofcourse,thecrucialpointisthat,becauseoftherestrictiveassumption
abouttheformatoftheelements, wecanavoidusingcomparisons.
Themainidea istouse analgorithm calledbucket-sort, whichisnot based on
comparisons, but on using keys as indices into a bucket array B that has cells in-
dexed from 0 to N−1. An entry with key k is placed in the “bucket” B[k], which
itself is a sequence (of entries with keyk). After inserting each entry of the input
sequenceSintoitsbucket,wecanputtheentriesbackintoSinsortedorderbyenu-
merating the contents of the buckets B[0],B[1],...,B[N−1] in order. We describe
thebucket-sort algorithm inCodeFragment12.7.
AlgorithmbucketSort(S):
Input: SequenceSofentrieswithintegerkeysintherange[0,N−1]
Output: SequenceSsortedinnondecreasing orderofthekeys
letBbeanarrayofNsequences, eachofwhichisinitiallyempty
foreachentryeinSdo
k = thekeyofe
removeefromSandinsertitattheendofbucket(sequence)B[k]
fori = 0toN−1do
foreachentryeinsequenceB[i]do
removeefromB[i]andinsertitattheendofS12.4. StudyingSortingthroughanAlgorithmicLens 565
It is easy to see that bucket-sort runs in O(n+N) time and uses O(n+N)
space. Hence, bucket-sort is efﬁcient when the range N of values for the keys is
small compared to the sequence size n, say N =O(n) or N =O(nlogn). Still, its
performance deteriorates asN growscomparedton.
An important property of the bucket-sort algorithm is that it works correctly
evenifthere aremanydifferent elements withthesamekey. Indeed, wedescribed
itinawaythatanticipates suchoccurrences.
Stable Sorting
Whensortingkey-valuepairs,animportantissueishowequalkeysarehandled. Let
S=((k0,v0),...,(kn−1,vn−1))beasequence ofsuchentries. Wesaythatasorting
algorithm isstable if, for any two entries (k,v) and (k ,v ) of S such that k =k
i i j j i j
and (k,v) precedes (k ,v ) in S before sorting (that is, i< j), entry (k,v) also
i i j j i i
precedes entry (k ,v ) after sorting. Stability is important for a sorting algorithm
j j
because applications may want to preserve the initial order of elements with the
samekey.
Ourinformaldescription ofbucket-sort inCodeFragment12.7guarantees sta-
bilityaslongasweensurethatallsequencesactasqueues,withelementsprocessed
and removed from the front of a sequence and inserted at the back. That is, when
initiallyplacingelementsofSintobuckets,weshouldprocessSfromfronttoback,
andadd eachelement tothe endofitsbucket. Subsequently, whentransferring el-
ementsfromthebucketsbacktoS,weshouldprocesseachB[i]fromfronttoback,
withthoseelementsaddedtotheendofS.
Radix-Sort
Oneofthereasonsthatstablesortingissoimportantisthatitallowsthebucket-sort
approach tobeapplied tomoregeneral contexts thantosortintegers. Suppose, for
example, that we want to sort entries with keys that are pairs(k,l), where k and l
areintegersintherange[0,N−1],forsomeintegerN≥2. Inacontextsuchasthis,
itiscommontodeﬁneanorder onthese keysusing thelexicographic (dictionary)
convention,where(k ,l )<(k ,l )ifk <k orifk =k andl <l (seepage15).
1 1 2 2 1 2 1 2 1 2
Thisis apairwise version of the lexicographic comparison function, which can be
appliedtoequal-length character strings, ortotuplesoflengthd.
Theradix-sort algorithm sorts asequenceS ofentries withkeysthatare pairs,
by applying astable bucket-sort on the sequence twice; ﬁrstusing one component
of the pair as the key when ordering and then using the second component. But
which order is correct? Should we ﬁrst sort on the k’s (the ﬁrst component) and566 Chapter12. SortingandSelection
To gain intuition before answering this question, we consider the following
example.
Example 12.5: ConsiderthefollowingsequenceS(weshowonlythekeys):
S=((3,3),(1,5),(2,5),(1,2),(2,3),(1,7),(3,2),(2,2)).
IfwesortSstablyontheﬁrstcomponent,thenwegetthesequence
S =((1,5),(1,2),(1,7),(2,5),(2,3),(2,2),(3,3),(3,2)).
1
IfwethenstablysortthissequenceS usingthesecondcomponent,wegetthe
1
sequence
S1,2 =((1,2),(2,2),(3,2),(2,3),(3,3),(1,5),(2,5),(1,7)),
whichisunfortunatelynotasortedsequence.Ontheotherhand,ifweﬁrststably
sortSusingthesecondcomponent,thenwegetthesequence
S =((1,2),(3,2),(2,2),(3,3),(2,3),(1,5),(2,5),(1,7)).
2
IfwethenstablysortsequenceS usingtheﬁrstcomponent,wegetthesequence
2
S2,1 =((1,2),(1,5),(1,7),(2,2),(2,3),(2,5),(3,2),(3,3)),
whichisindeedsequenceSlexicographicallyordered.
So, from this example, we are led to believe that we should ﬁrst sort using
the second component and then again using the ﬁrst component. This intuition is
exactly right. By ﬁrst stably sorting by the second component and then again by
the ﬁrst component, we guarantee that if two entries are equal in the second sort
(by the ﬁrst component), then their relative order in the starting sequence (which
is sorted by the second component) is preserved. Thus, the resulting sequence is
guaranteedtobesortedlexicographically everytime. Weleavetoasimpleexercise
(R-12.18) the determination of how this approach can be extended to triples and
otherd-tuplesofnumbers. Wecansummarizethissectionasfollows:
Proposition 12.6: LetSbeasequenceofnkey-valuepairs,eachofwhichhasa
key(k ,k ,...,k ),wherek isanintegerintherange[0,N−1]forsomeinteger
1 2 d i
N ≥2.WecansortSlexicographicallyintimeO(d(n+N))usingradix-sort.
Radix sort can be applied to any key that can be viewed as a composite of
smaller pieces that are to be sorted lexicographically. Forexample, we can apply
it to sort character strings of moderate length, as each individual character can be
represented as an integer value. (Some care is needed to properly handle strings12.5. ComparingSortingAlgorithms 567
12.5 Comparing Sorting Algorithms
Atthis point, itmight be useful for us totake amoment and consider allthe algo-
rithmswehavestudiedinthisbooktosortann-elementsequence.
Considering Running Time and Other Factors
We have studied several methods, such as insertion-sort, and selection-sort, that
haveO(n2)-timebehaviorintheaverageandworstcase. Wehavealsostudiedsev-
eral methods with O(nlogn)-time behavior, including heap-sort, merge-sort, and
quick-sort. Finally, the bucket-sort and radix-sort methods run in linear time for
certaintypesofkeys. Certainly,theselection-sort algorithmisapoorchoiceinany
application, sinceitrunsinO(n2)timeeveninthebestcase. But,oftheremaining
sortingalgorithms, whichisthebest?
As with many things in life, there is no clear “best” sorting algorithm from
theremainingcandidates. Therearetrade-offsinvolvingefﬁciency,memoryusage,
andstability. Thesortingalgorithm bestsuitedforaparticular application depends
on the properties of that application. In fact, the default sorting algorithm used
by computing languages and systems has evolved greatly overtime. We can offer
some guidance and observations, therefore, based on the known properties of the
“good”sorting algorithms.
Insertion-Sort
If implemented well, the running time of insertion-sort is O(n+m), where m is
the number of inversions (that is, the number of pairs of elements out of order).
Thus,insertion-sort isanexcellent algorithm forsortingsmallsequences (say, less
than50elements),becauseinsertion-sortissimpletoprogram,andsmallsequences
necessarily have few inversions. Also, insertion-sort is quite effective for sorting
sequences thatarealready“almost”sorted. By“almost,”wemeanthatthenumber
ofinversions issmall. ButtheO(n2)-timeperformance ofinsertion-sort makesita
poorchoiceoutside ofthesespecialcontexts.
Heap-Sort
Heap-sort, on the other hand, runs in O(nlogn) time in the worst case, which is
optimalforcomparison-basedsortingmethods. Heap-sortcaneasilybemadetoex-
ecutein-place,andisanaturalchoiceonsmall-andmedium-sizedsequences,when
inputdatacanﬁtintomainmemory. However,heap-sort tendstobeoutperformed
by both quick-sort and merge-sort on larger sequences. Astandard heap-sort does568 Chapter12. SortingandSelection
Quick-Sort
Although its O(n2)-time worst-case performance makes quick-sort susceptible in
real-timeapplications wherewemustmakeguaranteesonthetimeneededtocom-
plete asorting operation, weexpect itsperformance to beO(nlogn)-time, and ex-
perimentalstudieshaveshownthatitoutperformsbothheap-sortandmerge-sorton
manytests. Quick-sortdoesnotnaturallyprovideastablesort,duetotheswapping
ofelementsduringthepartitioning step.
Fordecadesquick-sortwasthedefaultchoiceforageneral-purpose,in-memory
sortingalgorithm. Quick-sortwasincludedastheqsortsortingutilityprovidedinC
languagelibraries,andwasthebasisforsortingutilitiesonUnixoperatingsystems
formanyyears. ItwasalsothestandardalgorithmforsortingarraysinJavathrough
version6ofthatlanguage. (WediscussJava7below.)
Merge-Sort
Merge-sort runs in O(nlogn) time in the worst case. It is quite difﬁcult to make
merge-sortrunin-placeforarrays,andwithoutthatoptimizationtheextraoverhead
ofallocateatemporaryarray,andcopyingbetweenthearraysislessattractivethan
in-place implementations ofheap-sort andquick-sort forsequences thatcanﬁten-
tirelyinacomputer’s mainmemory. Evenso,merge-sort isanexcellentalgorithm
for situations where the input is stratiﬁed across various levels of the computer’s
memoryhierarchy(e.g.,cache,mainmemory,externalmemory). Inthesecontexts,
thewaythatmerge-sortprocessesrunsofdatainlongmergestreamsmakesthebest
use ofall the data brought asablock into alevel of memory, thereby reducing the
totalnumberofmemorytransfers.
TheGNUsortingutility(andmostcurrentversionsoftheLinuxoperatingsys-
tem)reliesonamultiwaymerge-sortvariant. Since2003,thestandardsortmethod
ofPython’slistclasshasbeenahybridapproachnamedTim-sort(designedbyTim
Peters), which is essentially a bottom-up merge-sort that takes advantage of some
initial runs inthe data whileusing insertion-sort tobuildadditional runs. Tim-sort
hasalsobecomethedefault algorithm forsortingarraysinJava7.
Bucket-Sort and Radix-Sort
Finally, ifanapplication involves sortingentries withsmallinteger keys,character
strings, or d-tuples ofkeys from adiscrete range, thenbucket-sort orradix-sort is
anexcellentchoice,foritrunsinO(d(n+N))time,where[0,N−1]istherangeof
integerkeys(andd=1forbucketsort). Thus,ifd(n+N)issigniﬁcantly “below”
thenlognfunction,thenthissortingmethodshouldrunfasterthanevenquick-sort,12.6. Python’sBuilt-InSortingFunctions 569
12.6 Python’s Built-In Sorting Functions
Python provides two built-in ways to sort data. The ﬁrst is the sort method of the
listclass. Asanexample,supposethatwedeﬁnethefollowinglist:
colors = [ red , green , blue , cyan , magenta , yellow ]
That method has the effect of reordering the elements of the list into order, as de-
ﬁned by the natural meaning of the < operator for those elements. In the above
example, within elements that are strings, the natural order is deﬁned alphabeti-
cally. Therefore, afteracalltocolors.sort(),theorderofthelistwouldbecome:
[ blue , cyan , green , magenta , red , yellow ]
Python also supports a built-in function, named sorted, that can be used to
produce a new ordered list containing the elements of any existing iterable con-
tainer. Goingbacktoouroriginal example, thesyntaxsorted(colors)wouldreturn
a new list of those colors, in alphabetical order, while leaving the contents of the
original list unchanged. This second form is more general because it can be ap-
plied to any iterable object as a parameter; for example, sorted( green ) returns
[ e , e , g , n , r ].
12.6.1 Sorting According to a Key Function
Therearemanysituationsinwhichwewishtosortalistofelements,butaccording
tosomeorderotherthanthenatural orderdeﬁnedbythe<operator. Forexample,
wemightwishtosortalistofstringsfromshortesttolongest(ratherthanalphabet-
ically). BothofPython’s built-in sortfunctions allow acaller tocontrol thenotion
of order that is used when sorting. This is accomplished by providing, as an op-
tional keyword parameter, areference toasecondary function thatcomputes akey
for each element of the primary sequence; then the primary elements are sorted
based on thenatural order oftheir keys. (Seepages 27and 28 ofSection 1.5.1for
adiscussionofthistechniqueinthecontextofthebuilt-inminandmaxfunctions.)
A key function must be a one-parameter function that accepts an element as a
parameter and returns a key. For example, we could use the built-in len function
whensortingstringsbylength,asacalllen(s)forstringsreturnsitslength. Tosort
our colors list based on length, we use the syntax colors.sort(key=len) to mutate
thelistorsorted(colors, key=len)togenerateaneworderedlist,whileleavingthe
original alone. Whensortedwiththelengthfunction asakey,thecontents are:
[ red , blue , cyan , green , yellow , magenta ]
Thesebuilt-infunctions alsosupportakeywordparameter,reverse,thatcanbe570 Chapter12. SortingandSelection
Decorate-Sort-Undecorate Design Pattern
Python’s support for a key function when sorting is implemented using what is
knownasthedecorate-sort-undecorate designpattern. Itproceeds in3steps:
1. Each element of the list is temporarily replaced with a “decorated” version
thatincludes theresultofthekeyfunctionapplied totheelement.
2. Thelistissortedbaseduponthenaturalorderofthekeys(Figure12.16).
3. Thedecorated elementsarereplaced bytheoriginal elements.
4 blue 5 green 7 magenta
3 red 4 cyan 6 yellow
0 1 2 3 4 5
Figure12.16: A list of “decorated” strings, using their lengths as decoration. This
listhasbeensortedbythosekeys.
Although thereisalready built-in support forPython, ifweweretoimplement
suchastrategyourselves,anaturalwaytorepresenta“decorated”elementisusing
thesamecomposition strategythatweusedforrepresentingkey-valuepairswithin
a priority queue. Code Fragment 9.1 of Section 9.2.1 includes just such an Item
class,deﬁnedsothatthe<operatorforitemsreliesuponthegivenkeys. Withsuch
a composition, we could trivially adapt any sorting algorithm to use the decorate-
sort-undecorate pattern, asdemonstrated inCodeFragment12.8withmerge-sort.
1 def decorated merge sort(data, key=None):
2 ”””Demonstration of the decorate-sort-undecorate pattern.”””
3 if key is not None:
4 for j in range(len(data)):
5 data[j] = Item(key(data[j]), data[j]) # decorate each element
6 merge sort(data) # sort with existing algorithm
7 if key is not None:
8 for j in range(len(data)):
9 data[j] = data[j]. value # undecorate each element
CodeFragment12.8: An approach for implementing the decorate-sort-undecorate
pattern based upon the array-based merge-sort of CodeFragment 12.1. The Item
classisidenticaltothatwhichwasusedinthePriorityQueueBaseclass. (SeeCode12.7. Selection 571
12.7 Selection
Asimportantasitis,sortingisnottheonlyinterestingproblemdealingwithatotal
order relation on a set of elements. There are a number of applications in which
we are interested in identifying a single element in terms of its rank relative to
the sorted order of the entire set. Examples include identifying the minimum and
maximum elements, but wemay also be interested in, say, identifying themedian
element,thatis,theelementsuchthathalfoftheotherelementsaresmallerandthe
remaining half are larger. In general, queries that ask for an element with a given
rankarecalledorderstatistics.
Deﬁning the Selection Problem
In this section, we discuss the general order-statistic problem of selecting the kth
smallest element from an unsorted collection of n comparable elements. This is
known as the selection problem. Of course, we can solve this problem by sorting
the collection and then indexing into the sorted sequence at index k−1. Using
thebestcomparison-based sorting algorithms, thisapproach wouldtake O(nlogn)
time, which is obviously an overkill for the cases where k=1 or k =n (or even
k =2, k=3, k =n−1, or k =n−5), because we can easily solve the selection
problem for these values of k in O(n) time. Thus, a natural question to ask is
whether we can achieve an O(n) running time for all values of k (including the
interesting caseofﬁndingthemedian,wherek=(cid:16)n/2(cid:17)).
12.7.1 Prune-and-Search
Wecan indeed solve theselection problem inO(n)timeforanyvalue ofk. More-
over,thetechniqueweusetoachievethisresultinvolves aninteresting algorithmic
design pattern. This design pattern is known as prune-and-search or decrease-
and-conquer. In applying this design pattern, we solve a given problem that is
deﬁned on a collection of n objects by pruning away a fraction of the n objects
and recursively solving the smaller problem. When we have ﬁnally reduced the
problem to one deﬁned on a constant-sized collection of objects, we then solve
theproblemusingsomebrute-force method. Returning backfromalltherecursive
calls completes the construction. In some cases, we can avoid using recursion, in
which case wesimply iterate theprune-and-search reduction step until wecan ap-
plyabrute-forcemethodandstop. Incidentally,thebinarysearchmethoddescribed572 Chapter12. SortingandSelection
12.7.2 Randomized Quick-Select
In applying the prune-and-search pattern to ﬁnding the kth smallest element in an
unordered sequence of n elements, we describe a simple and practical algorithm,
known as randomized quick-select. This algorithm runs in O(n) expected time,
taken over all possible random choices made by the algorithm; this expectation
does not depend whatsoever on any randomness assumptions about the input dis-
tribution. We note though that randomized quick-select runs in O(n2) time in the
worst case, the justiﬁcation of which is left as an exercise (R-12.24). We also
provide an exercise (C-12.55) for modifying randomized quick-select to deﬁne a
deterministicselection algorithm thatrunsinO(n)worst-casetime. Theexistence
of this deterministic algorithm is mostly of theoretical interest, however, since the
constant factorhiddenbythebig-Ohnotation isrelativelylargeinthatcase.
Suppose we are given an unsorted sequence S of n comparable elements to-
gether with an integer k ∈ [1,n]. At a high level, the quick-select algorithm for
ﬁnding the kth smallest element in S is similar to the randomized quick-sort algo-
rithmdescribedinSection12.3.1. Wepicka“pivot”elementfromSatrandomand
usethistosubdivideSintothreesubsequencesL,E,andG,storingtheelementsof
Sless than, equal to, andgreater thanthepivot, respectively. Intheprune step, we
determine which of these subsets contains the desired element, based onthe value
ofkandthesizesofthosesubsets. Wethenrecurontheappropriate subset, noting
thatthedesiredelement’srankinthesubsetmaydifferfromitsrankinthefullset.
Animplementation ofrandomized quick-select isshowninCodeFragment12.9.
1 def quick select(S, k):
2 ”””Return the kth smallest element of list S, for k from 1 to len(S).”””
3 if len(S) == 1:
4 return S[0]
5 pivot = random.choice(S) # pick random pivot element from S
6 L = [x for x in S if x < pivot] # elements less than pivot
7 E = [x for x in S if x == pivot] # elements equal to pivot
8 G = [x for x in S if pivot < x] # elements greater than pivot
9 if k <= len(L):
10 return quick select(L, k) # kth smallest lies in L
11 elif k <= len(L) + len(E):
12 return pivot # kth smallest equal to pivot
13 else:
14 j = k − len(L) − len(E) # new selection parameter
15 return quick select(G, j) # kth smallest is jth in G12.7. Selection 573
12.7.3 Analyzing Randomized Quick-Select
Showing that randomized quick-select runs in O(n) time requires a simple prob-
abilistic argument. The argument is based on the linearity of expectation, which
statesthatifX andY arerandomvariables andcisanumber,then
E(X+Y)=E(X)+E(Y) and E(cX)=cE(X),
whereweuseE(Z)todenote theexpected valueoftheexpressionZ.
Lett(n)betherunningtimeofrandomizedquick-selectonasequenceofsizen.
Sincethisalgorithm depends onrandom events,itsrunningtime,t(n),isarandom
variable. WewanttoboundE(t(n)),theexpectedvalueoft(n). Saythatarecursive
invocation ofouralgorithm is“good” ifitpartitionsSsothat thesize ofeach ofL
andGisatmost3n/4. Clearly,arecursivecallisgoodwithprobabilityatleast1/2.
Let g(n) denote the number of consecutive recursive calls we make, including the
present one, before we get a good one. Then we can characterize t(n) using the
followingrecurrenceequation:
t(n)≤bn·g(n)+t(3n/4),
whereb≥1isaconstant. Applyingthelinearity ofexpectation forn>1,weget
E(t(n))≤E(bn·g(n)+t(3n/4))=bn·E(g(n))+E(t(3n/4)).
Sincearecursivecallisgoodwithprobability atleast1/2,andwhetherarecursive
call is good ornot isindependent ofits parent call being good, the expected value
of g(n) is at most the expected number of times we must ﬂip a fair coin before it
comes up “heads.” That is, E(g(n)) ≤2. Thus, if we let T(n) be shorthand for
E(t(n)),thenwecanwritethecaseforn>1as
T(n)≤T(3n/4)+2bn.
To convert this relation into a closed form, let us iteratively apply this inequality
assumingnislarge. So,forexample,aftertwoapplications,
T(n)≤T((3/4)2n)+2b(3/4)n+2bn.
Atthispoint,weshouldseethatthegeneralcaseis
(cid:6)log4/3n(cid:7)
T(n)≤2bn· ∑ (3/4)i.
i=0
In other words, the expected running time is at most 2bn times a geometric sum
whosebaseisapositivenumberlessthan1. Thus,byProposition3.5,T(n)isO(n).
Proposition 12.7: Theexpectedrunningtimeofrandomizedquick-selectona
sequenceSofsizenisO(n),assumingtwoelementsofScanbecomparedinO(1)574 Chapter12. SortingandSelection
12.8 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-12.1 Giveacompletejustiﬁcation ofProposition 12.1.
R-12.2 Inthemerge-sorttreeshowninFigures12.2through12.4,someedgesare
drawnasarrows. Whatisthemeaningofadownwardarrow? Howabout
anupwardarrow?
R-12.3 Show that the running time of the merge-sort algorithm on ann-element
sequence isO(nlogn),evenwhennisnotapowerof2.
R-12.4 Is our array-based implementation of merge-sort given in Section 12.2.2
stable? Explainwhyorwhynot.
R-12.5 Isourlinked-list-based implementationofmerge-sortgiveninCodeFrag-
ment12.3stable? Explainwhyorwhynot.
R-12.6 An algorithm that sorts key-value entries by key is said to bestraggling
if,anytimetwoentriese ande haveequalkeys,bute appearsbeforee
i j i j
intheinput, thenthealgorithm placese aftere intheoutput. Describea
i j
changetothemerge-sortalgorithm inSection12.2tomakeitstraggling.
R-12.7 Suppose wearegiventwon-element sortedsequences AandBeachwith
distinctelements,butpotentiallysomeelementsthatareinbothsequences.
DescribeanO(n)-timemethodforcomputingasequencerepresentingthe
unionA∪B(withnoduplicates) asasortedsequence.
R-12.8 Suppose wemodify the deterministic version of the quick-sort algorithm
so that, instead of selecting the last element in ann-element sequence as
thepivot,wechoosetheelementatindex(cid:16)n/2(cid:17). Whatistherunningtime
ofthisversionofquick-sort onasequence thatisalreadysorted?
R-12.9 Consider a modiﬁcation of the deterministic version of the quick-sort al-
gorithm where we choose the element at index (cid:16)n/2(cid:17) as our pivot. De-
scribe the kind ofsequence that would cause this version ofquick-sort to
runinΩ(n2)time.
R-12.10 Show that the best-case running time of quick-sort on a sequence of size
nwithdistinctelementsisΩ(nlogn).
R-12.11 Suppose function inplace quick sort is executed on a sequence with du-
plicate elements. Prove that the algorithm still correctly sorts the input
sequence. What happens in the partition step when there are elements
equal to the pivot? What is the running time of the algorithm if all the12.8. Exercises 575
R-12.12 If the outermost while loop of our implementation of inplace quick sort
(line7ofCodeFragment12.6)werechangedtouseconditionleft < right
(rather than left <= right), there would be a ﬂaw. Explain the ﬂaw and
giveaspeciﬁcinputsequence onwhichsuchanimplementation fails.
R-12.13 If the conditional at line 14 of ourinplace quick sort implementation of
Code Fragment 12.6 were changed to use condition left < right (rather
than left <= right), there would be a ﬂaw. Explain the ﬂaw and give a
speciﬁcinputsequence onwhichsuchanimplementation fails.
R-12.14 Following our analysis of randomized quick-sort in Section12.3.1, show
that the probability that a given input element x belongs to more than
2lognsubproblems insizegroupiisatmost1/n2.
R-12.15 Of the n! possible inputs to a given comparison-based sorting algorithm,
what is the absolute maximum number of inputs that could be correctly
sortedwithjustncomparisons?
R-12.16 Jonathan has a comparison-based sorting algorithm that sorts the ﬁrst k
elements of a sequence of sizen in O(n)time. Givea big-Oh characteri-
zationofthebiggest thatkcanbe?
R-12.17 Isthebucket-sort algorithm in-place? Whyorwhynot?
R-12.18 Describearadix-sortmethodforlexicographicallysortingasequenceSof
triplets (k,l,m), where k, l, and m are integers inthe range [0,N−1], for
someN≥2. Howcouldthisschemebeextendedtosequencesofd-tuples
(k ,k ,...,k ),whereeachk isanintegerintherange[0,N−1]?
1 2 d i
R-12.19 Suppose S isasequence ofnvalues, each equal to0 or1. Howlong will
ittaketosortSwiththemerge-sort algorithm? Whataboutquick-sort?
R-12.20 Suppose S isasequence ofnvalues, each equal to0 or1. Howlong will
ittaketosortSstablywiththebucket-sort algorithm?
R-12.21 GivenasequenceSofnvalues, eachequalto0or1,describe anin-place
methodforsortingS.
R-12.22 Give an example input list that requires merge-sort and heap-sort to take
O(nlogn) time to sort, but insertion-sort runs inO(n) time. What if you
reversethislist?
R-12.23 Whatisthebestalgorithmforsortingeachofthefollowing: generalcom-
parable objects, long character strings, 32-bit integers, double-precision
ﬂoating-point numbers,andbytes? Justifyyouranswer.
R-12.24 Show that the worst-case running time of quick-select on an n-element576 Chapter12. SortingandSelection
Creativity
C-12.25 Linda claims to have an algorithm that takes an input sequence S and
produces anoutputsequenceT thatisasortingofthenelementsinS.
a. Giveanalgorithm,is sorted,thattestsinO(n)timeifT issorted.
b. Explain whythe algorithm is sorted is not sufﬁcient toprove apar-
ticularoutputT toLinda’salgorithm isasortingofS.
c. Describe what additional information Linda’s algorithm could out-
put so that her algorithm’s correctness could be established on any
givenSandT inO(n)time.
C-12.26 Describeandanalyzeanefﬁcientmethodforremovingallduplicatesfrom
acollectionAofnelements.
C-12.27 Augment the PositionalList class (see Section 7.4) to support a method
named merge with the following behavior. If A and B are PositionalList
instanceswhoseelementsaresorted,thesyntaxA.merge(B)shouldmerge
all elements of B into A so that A remains sorted and B becomes empty.
Your implementation must accomplish the merge by relinking existing
nodes;youarenottocreateanynewnodes.
C-12.28 Augment the PositionalList class (see Section 7.4) to support a method
named sort that sorts the elements of a list by relinking existing nodes;
you arenottocreate anynewnodes. Youmayuseyour choice ofsorting
algorithm.
C-12.29 Implement a bottom-up merge-sort for a collection of items by placing
each item in its own queue, and then repeatedly merging pairsof queues
untilallitemsaresortedwithinasinglequeue.
C-12.30 Modifyourin-placequick-sort implementationofCodeFragment12.6to
bearandomizedversionofthealgorithm, asdiscussed inSection12.3.1.
C-12.31 Consideraversionofdeterministic quick-sort wherewepickasourpivot
themedianofthed lastelements intheinputsequence ofnelements, for
a ﬁxed, constant odd number d ≥3. What is the asymptotic worst-case
running timeofquick-sort inthiscase?
C-12.32 Another way to analyze randomized quick-sort is to use a recurrence
equation. In this case, we let T(n) denote the expected running time
ofrandomized quick-sort, andweobserve that,because oftheworst-case
partitions forgoodandbadsplits,wecanwrite
1 1
T(n)≤ (T(3n/4)+T(n/4))+ (T(n−1))+bn,
2 2
wherebnisthetimeneededtopartitionalistforagivenpivotandconcate-
natetheresultsublistsaftertherecursivecallsreturn. Show,byinduction,12.8. Exercises 577
C-12.33 Our high-level description of quick-sort describes partitioning the ele-
ments into three sets L, E, and G, having keys less than, equal to, or
greater than the pivot, respectively. However, our in-place quick-sort im-
plementation of Code Fragment 12.6 does not gather all elements equal
to the pivot into a set E. An alternative strategy for an in-place, three-
way partition is as follows. Loop through the elements from left to right
maintaining indices i, j, and k and the invariant that all elements of slice
S[0:i] are strictly less than the pivot, all elements of slice S[i:j] are equal
to the pivot, and all elements of slice S[j:k] are strictly greater than the
pivot; elements of S[k:n] are yet unclassiﬁed. In each pass of the loop,
classify one additional element, performing a constant number of swaps
asneeded. Implementanin-place quick-sort usingthisstrategy.
C-12.34 Supposewearegivenann-elementsequenceSsuchthateachelementinS
representsadifferentvoteforpresident,whereeachvoteisgivenasanin-
tegerrepresenting aparticular candidate, yettheintegersmaybearbitrar-
ily large (even if the number of candidates is not). Design anO(nlogn)-
time algorithm to see who wins the election S represents, assuming the
candidate withthemostvoteswins.
C-12.35 ConsiderthevotingproblemfromExerciseC-12.34,butnowsupposethat
weknowthenumberk<nofcandidatesrunning,eventhoughtheinteger
IDs for those candidates can be arbitrarily large. Describe an O(nlogk)-
timealgorithm fordetermining whowinstheelection.
C-12.36 ConsiderthevotingproblemfromExerciseC-12.34,butnowsupposethe
integers1tokareusedtoidentifyk<ncandidates. DesignanO(n)-time
algorithm todeterminewhowinstheelection.
C-12.37 Show that any comparison-based sorting algorithm can be made to be
stablewithoutaffecting itsasymptoticrunning time.
C-12.38 Suppose we are given two sequences A and B of n elements, possibly
containing duplicates, onwhichatotalorderrelation isdeﬁned. Describe
an efﬁcient algorithm for determining ifA and B contain the same set of
elements. Whatistherunning timeofthismethod?
C-12.39 Given an array A of n integers in the range [0,n2−1], describe a simple
methodforsortingAinO(n)time.
C-12.40 Let S ,S ,...,S be k different sequences whose elements have integer
1 2 k
keysintherange[0,N−1],forsomeparameterN ≥2. Describeanalgo-
rithmthatproduces krespective sortedsequences inO(n+N)time,were
ndenotes thesumofthesizesofthosesequences.
C-12.41 Given a sequence S of n elements, on which a total order relation is de-
ﬁned, describe anefﬁcientmethod fordetermining whether there aretwo578 Chapter12. SortingandSelection
C-12.42 Let S be a sequence of n elements on which a total order relation is de-
ﬁned. Recall that an inversion in S is a pair of elements x and y such
that x appears before y in S but x>y. Describe an algorithm running in
O(nlogn)timefordetermining thenumberofinversions inS.
C-12.43 Let S be a sequence of n integers. Describe a method for printing out all
thepairsofinversionsinSinO(n+k)time,wherekisthenumberofsuch
inversions.
C-12.44 Let S be a random permutation of n distinct integers. Argue that the ex-
pectedrunningtimeofinsertion-sort onSisΩ(n2). (Hint: Notethathalf
oftheelementsrankedinthetophalfofasortedversionofSareexpected
tobeintheﬁrsthalfofS.)
C-12.45 Let A and B be two sequences of n integers each. Given an integer m,
describeanO(nlogn)-timealgorithmfordeterminingifthereisaninteger
ainAandanintegerbinBsuchthatm=a+b.
C-12.46 Given a set of n integers, describe and analyze a fast method for ﬁnding
the(cid:13)logn(cid:14)integersclosest tothemedian.
C-12.47 Bob has a set A of n nuts and a set B of n bolts, such that each nut in A
has aunique matching bolt inB. Unfortunately, the nuts inAalllook the
same, and the bolts in B all look the same as well. The only kind of a
comparison thatBobcanmakeistotakeanut-boltpair(a,b),suchthata
isinAandbisinB,andtestittoseeifthethreadsofaarelarger,smaller,
oraperfectmatchwiththethreadsofb. Describeandanalyzeanefﬁcient
algorithm forBobtomatchupallofhisnutsandbolts.
C-12.48 Ourquick-selectimplementationcanbemademorespace-efﬁcientbyini-
tiallycomputingonlythecountsforsetsL,E,andG,creatingonlythenew
subsetthatwillbeneededforrecursion. Implementsuchaversion.
C-12.49 Describeanin-placeversionofthequick-selectalgorithminpseudo-code,
assumingthatyouareallowedtomodifytheorderofelements.
C-12.50 Show how to use a deterministic O(n)-time selection algorithm to sort a
sequence ofnelementsinO(nlogn)worst-casetime.
C-12.51 GivenanunsortedsequenceSofncomparableelements,andanintegerk,
give an O(nlogk)expected-time algorithm for ﬁnding theO(k)elements
thathaverank(cid:13)n/k(cid:14),2(cid:13)n/k(cid:14),3(cid:13)n/k(cid:14), andsoon.
C-12.52 Spacealienshavegivenusafunction,alien split,thatcantakeasequence
SofnintegersandpartitionSinO(n)timeintosequencesS ,S ,...,S of
1 2 k
sizeatmost(cid:13)n/k(cid:14)each,suchthattheelementsinS arelessthanorequal
i
toeveryelement inSi+1,fori=1,2,...,k−1,foraﬁxednumber, k<n.
Showhowtousealien splittosortSinO(nlogn/logk)time.
C-12.53 Readdocumenation ofthereversekeywordparameterofPython’ssorting
functions, anddescribehowthedecorate-sort-undecorateparadigm could12.8. Exercises 579
C-12.54 Showthatrandomized quick-sort runs inO(nlogn)timewithprobability
atleast1−1/n,thatis,withhighprobability,byansweringthefollowing:
a. Foreachinputelementx,deﬁneCi,j(x)tobea0/1randomvariable
thatis1ifandonlyifelementxisin j+1subproblems thatbelong
tosizegroupi. ArguewhyweneednotdeﬁneCi,j for j>n.
b. Let Xi,j be a 0/1 random variable that is 1 with probability 1/2j,
independent of anyother events, and letL=(cid:13)log n(cid:14). Argue why
4/3
∑Li=−01∑nj=0Ci,j(x)≤∑Li=−01∑nj=0Xi,j.
c. Showthattheexpectedvalueof∑Li=−01∑nj=0Xi,j is(2−1/2n)L.
d. Show that the probability that ∑Li=0∑nj=0Xi,j >4L is at most 1/n2,
using the Chernoff boundthat states that ifX is the sum of a ﬁnite
number of independent 0/1 random variables with expected value
μ>0,thenPr(X >2μ)<(4/e)−μ,wheree=2.71828128....
e. Arguewhythepreviousclaimprovesrandomizedquick-sort runsin
O(nlogn)timewithprobability atleast1−1/n.
C-12.55 We can make the quick-select algorithm deterministic, by choosing the
pivotofann-elementsequence asfollows:
PartitionthesetSinto(cid:13)n/5(cid:14)groupsofsize5each(exceptpos-
siblyforonegroup). Sorteachlittlesetandidentifythemedian
elementinthisset. Fromthissetof(cid:13)n/5(cid:14)“baby”medians,ap-
plytheselectionalgorithmrecursivelytoﬁndthemedianofthe
baby medians. Usethiselement asthepivot andproceed asin
thequick-select algorithm.
Show that this deterministic quick-select algorithm runs in O(n) time by
answering the following questions (please ignore ﬂoor and ceiling func-
tions if that simpliﬁes the mathematics, for the asymptotics are the same
eitherway):
a. Howmanybabymediansarelessthanorequaltothechosen pivot?
Howmanyaregreaterthanorequaltothepivot?
b. For each baby median less than or equal to the pivot, how many
other elements are less than or equal to the pivot? Is the same true
forthosegreater thanorequaltothepivot?
c. Argue whythemethod for ﬁndingthe deterministic pivot andusing
ittopartitionStakesO(n)time.
d. Based on these estimates, write a recurrence equation to bound the
worst-caserunningtimet(n)forthisselectionalgorithm(notethatin
theworstcasethere aretworecursive calls—one toﬁndthemedian
ofthebabymediansandonetorecuronthelargerofLandG).580 Chapter12. SortingandSelection
Projects
P-12.56 Implementanonrecursive,in-placeversionofthequick-sortalgorithm,as
described attheendofSection12.3.2.
P-12.57 Experimentallycomparetheperformanceofin-placequick-sortandaver-
sionofquick-sort thatisnotin-place.
P-12.58 Perform a series of benchmarking tests on a version of merge-sort and
quick-sort to determine which one is faster. Your tests should include
sequences thatare“random”aswellas“almost”sorted.
P-12.59 Implement deterministic and randomized versions of the quick-sort al-
gorithm and perform a series of benchmarking tests to see which one is
faster. Yourtestsshouldincludesequencesthatarevery“random”looking
aswellasonesthatare“almost”sorted.
P-12.60 Implementanin-placeversionofinsertion-sort andanin-placeversionof
quick-sort. Perform benchmarking tests to determine the range of values
ofnwherequick-sort isonaveragebetterthaninsertion-sort.
P-12.61 Design and implement a version of the bucket-sort algorithm for sorting
a list of n entries with integer keys taken from the range [0,N−1], for
N ≥2. Thealgorithm shouldruninO(n+N)time.
P-12.62 Designandimplementananimation foroneofthesorting algorithms de-
scribedinthischapter. Youranimationshouldillustratethekeyproperties
ofthisalgorithm inanintuitivemanner.
Chapter Notes
Knuth’s classic text on Sorting and Searching [65] contains an extensive history of the
sorting problem and algorithms for solving it. Huang and Langston [53] show how to
merge two sorted lists in-place in linear time. The standard quick-sort algorithm is due
to Hoare [51]. Several optimizations for quick-sort are described by Bentley and McIl-
roy[16]. Moreinformationaboutrandomization,includingChernoffbounds,canbefound
in the appendix and the book by Motwani and Raghavan [80]. The quick-sort analysis
giveninthischapterisacombinationoftheanalysisgiveninanearlierJavaeditionofthis
bookandthe analysisofKleinbergandTardos[60]. ExerciseC-12.32is duetoLittman.
Gonnet and Baeza-Yates [44] analyze and compare experimentally several sorting algo-
rithms. The term “prune-and-search”comesoriginallyfromthe computationalgeometry
literature(such asin the work ofClarkson[26] and Megiddo[75]). The term “decrease-Chapter
13
Text Processing
Contents
13.1 Abundance of Digitized Text . . . . . . . . . . . . . . . . . 582
13.1.1 Notations for Strings and the Python str Class. . . . . . . 583
13.2 Pattern-Matching Algorithms . . . . . . . . . . . . . . . . . 584
13.2.1 Brute Force . . . . . . . . . . . . . . . . . . . . . . . . . 584
13.2.2 The Boyer-Moore Algorithm . . . . . . . . . . . . . . . . 586
13.2.3 The Knuth-Morris-Pratt Algorithm . . . . . . . . . . . . . 590
13.3 Dynamic Programming . . . . . . . . . . . . . . . . . . . . 594
13.3.1 Matrix Chain-Product . . . . . . . . . . . . . . . . . . . . 594
13.3.2 DNA and Text Sequence Alignment . . . . . . . . . . . . 597
13.4 Text Compression and the Greedy Method . . . . . . . . . 601
13.4.1 The Huﬀman Coding Algorithm . . . . . . . . . . . . . . 602
13.4.2 The Greedy Method . . . . . . . . . . . . . . . . . . . . . 603
13.5 Tries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
13.5.1 Standard Tries . . . . . . . . . . . . . . . . . . . . . . . . 604
13.5.2 Compressed Tries . . . . . . . . . . . . . . . . . . . . . . 608
13.5.3 Suﬃx Tries . . . . . . . . . . . . . . . . . . . . . . . . . 610
13.5.4 Search Engine Indexing . . . . . . . . . . . . . . . . . . . 612582 Chapter13. TextProcessing
13.1 Abundance of Digitized Text
Despite the wealth of multimedia information, text processing remains one of the
dominant functions of computers. Computer are used to edit, store, and display
documents, andtotransport documentsovertheInternet. Furthermore,digital sys-
temsareusedtoarchiveawiderangeoftextualinformation,andnewdataisbeing
generatedatarapidlyincreasingpace. Alargecorpuscanreadilysurpassapetabyte
ofdata(whichisequivalent toathousand terabytes, oramilliongigabytes). Com-
monexamplesofdigitalcollections thatinclude textualinformation are:
• SnapshotsoftheWorldWideWeb,asInternetdocumentformatsHTMLand
XMLareprimarilytextformats,withaddedtagsformultimediacontent
• Alldocuments storedlocallyonauser’scomputer
• Emailarchives
• Customerreviews
• Compilations ofstatusupdates onsocialnetworking sitessuchasFacebook
• Feedsfrommicroblogging sitessuchasTwitterandTumblr
These collections include written text from hundreds of international languages.
Furthermore, thereare large datasets (such asDNA)thatcanbeviewed computa-
tionally as“strings” eventhoughtheyarenotlanguage.
Inthischapterweexploresomeofthefundamentalalgorithmsthatcanbeused
to efﬁciently analyze and process large textual data sets. In addition to having
interesting applications, text-processing algorithms also highlight some important
algorithmic designpatterns.
We begin by examining the problem of searching for a pattern as a substring
of a larger piece of text, for example, when searching for a word in a document.
Thepattern-matching problemgivesrisetothebrute-forcemethod,whichisoften
inefﬁcientbuthaswideapplicability.
Next,weintroduceanalgorithmictechniqueknownasdynamicprogramming,
whichcanbeappliedincertainsettingstosolveaproblem inpolynomial timethat
appearsatﬁrsttorequireexponentialtimetosolve. Wedemonstratetheapplication
onthistechniquetotheproblemofﬁndingpartialmatchesbetweenstringsthatmay
besimilarbutnotperfectlyaligned. Thisproblem ariseswhenmakingsuggestions
foramisspelledword,orwhentryingtomatchrelatedgenetic samples.
Because of the massive size of textual data sets, the issue of compression is
important, both in minimizing the number of bits that need to be communicated
through a network and to reduce the long-term storage requirements for archives.
For text compression, we can apply the greedy method, which often allows us to
approximate solutions to hard problems, and for some problems (such as in text
compression) actuallygivesrisetooptimalalgorithms.
Finally, weexamineseveral special-purpose datastructures thatcanbeusedto13.1. AbundanceofDigitizedText 583
13.1.1 Notations for Strings and the Python str Class
We use character strings as a model for text when discuss algorithms for text pro-
cessing. Character strings can come from a wide variety of sources, including
scientiﬁc, linguistic, andInternet applications. Indeed, the following areexamples
ofsuchstrings:
S = "CGTAAACTGCTTTAATCAAACGC"
T = "http://www.wiley.com"
The ﬁrst string, S, comes from DNA applications, and the second string, T, is the
Internet address (URL)forthepublisher ofthisbook. WerefertoAppendix Afor
anoverviewoftheoperations supported byPython’sstrclass.
To allow fairly general notions of a string in our algorithm descriptions, we
only assume that characters of a string come from a known alphabet, which we
denote as Σ. For example, in the context of DNA, there are four symbols in the
standard alphabet, Σ={A,C,G,T}. Thisalphabet Σcan, ofcourse, beasubset of
the ASCIIorUnicode character sets, but itcould also be something more general.
Although we assume that an alphabet has a ﬁxed ﬁnite size, denoted as |Σ|, that
size can be nontrivial, as with Python’s treatment of the Unicode alphabet, which
allowsformorethanamilliondistinctcharacters. Wethereforeconsidertheimpact
of|Σ|inourasymptotic analysisoftext-processing algorithms.
Severalstring-processing operationsinvolvebreakinglargestringsintosmaller
strings. In order to be able to speak about the pieces that result from such oper-
ations, we will rely on Python’s indexing and slicing notations. For the sake of
notation, we let S denote a string of length n. In that case, we let S[j] refer to the
characteratindexjfor0≤j≤n−1. WeletnotationS[j:k]for0≤j≤k≤ndenote
theslice(orsubstring)ofSconsistingofcharactersS[j]uptoandincludingS[k−1],
but not S[k]. By this deﬁnition, note that substring S[j : j + m] has length m and
thatsubstring S[j:j]istrivially thenullstring, having length 0. Inaccordance with
Pythonconventions, thesubstringS[j:k]isalsothenullstringwhenk< j.
In order to distinguish some special kinds of substrings, let us refer to any
substring ofthe form S[0:k]for 0≤k≤nas a preﬁx of S; such apreﬁx results in
Python when the ﬁrst index is omitted from slice notation, as in S[:k]. Similarly,
any substring of the formS[j:n] for 0≤j≤n is a sufﬁx of S; such a sufﬁx results
in Python when the second index is omitted from slice notation, as in S[j:]. For
example, ifweagain takeStobethestring ofDNAgivenabove, then"CGTAA"is
apreﬁxofS, "CGC"isasufﬁxofS,and "C"isboth apreﬁx andsufﬁxofS. Note584 Chapter13. TextProcessing
13.2 Pattern-Matching Algorithms
In the classic pattern-matching problem, we are given a text string T of length n
and apattern string Pof length m,and wanttoﬁndwhetherPisasubstring ofT.
Ifso,wemaywanttoﬁndthelowestindex jwithinTatwhichPbegins,suchthat
T[j:j+m]equalsP,orperhapstoﬁndallindicesofTatwhichpatternPbegins.
The pattern-matching problem is inherent to many behaviors of Python’s str
class,suchasP in T,T.ﬁnd(P),T.index(P),T.count(P),andisasubtaskofmore
complexbehaviors suchasT.partition(P),T.split(P),andT.replace(P, Q).
In this section, we present three pattern-matching algorithms (with increasing
levels of difﬁculty). For simplicity, we model the outward semantics of our func-
tions upon the ﬁndmethod of the string class, returning the lowest index at which
thepatternbegins,or−1ifthepatternisnotfound.
13.2.1 Brute Force
The brute-force algorithmic design pattern is a powerful technique for algorithm
designwhenwehavesomethingwewishtosearchfororwhenwewishtooptimize
some function. When applying this technique in a general situation, we typically
enumerateallpossibleconﬁgurations oftheinputsinvolvedandpickthebestofall
theseenumeratedconﬁgurations.
In applying this technique to design a brute-force pattern-matching algorithm,
we derive what is probably the ﬁrst algorithm that we might think of for solving
the problem—we simply test all the possible placements of P relative to T. An
implementation ofthisalgorithm isshowninCodeFragment13.1.
1 def ﬁnd brute(T, P):
2 ”””Return the lowest index of T at which substring P begins (or else -1).”””
3 n, m = len(T), len(P) # introduce convenient notations
4 for i in range(n−m+1): # try every potential starting index within T
5 k = 0 # an index into pattern P
6 while k < m and T[i + k] == P[k]: # kth character of P matches
7 k += 1
8 if k == m: # if we reached the end of pattern,
9 return i # substring T[i:i+m] matches P
10 return −1 # failed to ﬁnd a match starting with any i
Code Fragment 13.1: An implementation of brute-force pattern-matching algo-13.2. Pattern-MatchingAlgorithms 585
Performance
The analysis of the brute-force pattern-matching algorithm could not be simpler.
It consists of two nested loops, with the outer loop indexing through all possible
starting indices ofthepattern inthetext, andtheinner loopindexing through each
character of the pattern, comparing it to its potentially corresponding character
in the text. Thus, the correctness of the brute-force pattern-matching algorithm
followsimmediatelyfromthisexhaustive searchapproach.
Therunningtimeofbrute-force patternmatchingintheworstcaseisnotgood,
however,because,foreachcandidateindexinT,wecanperformuptomcharacter
comparisons todiscoverthatPdoesnotmatchTatthecurrentindex. Referringto
Code Fragment 13.1, we see that the outer for loop is executed at most n−m+1
times, and the inner whileloop is executed at mostm times. Thus, the worst-case
running timeofthebrute-force methodisO(nm).
Example 13.1: Supposewearegiventhetextstring
T = "abacaabaccabacabaabb"
andthepatternstring
P = "abacab"
Figure13.1illustratestheexecutionofthebrute-forcepattern-matchingalgorithm
onTandP.
Text: a b a c a a b a c c a b a c a b a a b b
1 2 3 4 5 6
Pattern: a b a c a b
7
a b a c a b
8 9
a b a c a b
10
a b a c a b
11comparisonsnotshown
22 23 24 25 26 27
a b a c a b
Figure13.1: Examplerunofthebrute-force pattern-matching algorithm. Thealgo-586 Chapter13. TextProcessing
13.2.2 The Boyer-Moore Algorithm
Atﬁrst,itmightseemthatitisalwaysnecessarytoexamineeverycharacterinTin
ordertolocateapatternPasasubstring ortoruleoutitsexistence. Butthisisnot
alwaysthecase. TheBoyer-Moorepattern-matching algorithm,whichwestudyin
thissection, cansometimesavoidcomparisons betweenPandasizablefractionof
thecharacters inT. Inthissection, wedescribe asimpliﬁedversionoftheoriginal
algorithm byBoyerandMoore.
ThemainideaoftheBoyer-Moorealgorithm istoimprovetherunningtimeof
thebrute-forcealgorithmbyaddingtwopotentiallytime-savingheuristics. Roughly
stated, theseheuristics areasfollows:
Looking-GlassHeuristic: When testing a possible placement ofP against T, be-
ginthecomparisons fromtheendofPandmovebackwardtothefrontofP.
Character-JumpHeuristic: DuringthetestingofapossibleplacementofPwithin
T, amismatch oftext character T[i]=cwiththe corresponding pattern char-
acter P[k] is handled as follows. If c is not contained anywhere in P, then
shift Pcompletely pastT[i](for itcannot match any character inP). Other-
wise,shiftPuntilanoccurrence ofcharactercinPgetsalignedwithT[i].
Wewillformalize theseheuristics shortly, butatanintuitivelevel,theyworkasan
integrated team. Thelooking-glass heuristic sets up theother heuristic toallow us
toavoidcomparisonsbetweenPandwholegroupsofcharactersinT. Inthiscaseat
least,wecangettothedestinationfasterbygoingbackwards,forifweencountera
mismatchduringtheconsiderationofPatacertainlocationinT,thenwearelikely
toavoidlotsofneedlesscomparisons bysigniﬁcantlyshiftingPrelativetoTusing
thecharacter-jump heuristic. Thecharacter-jump heuristic pays offbig ifitcanbe
applied early in the testing of a potential placement of P against T. Figure 13.2
demonstrates afewsimpleapplications oftheseheuristics.
Text: · · · · e · · · · s · · · · · · · · · ·
Pattern: s u s h i
s u s h i
s u s h i
Figure 13.2: A simple example demonstrating the intuition of the Boyer-Moore
pattern-matching algorithm. The original comparison results in a mismatch with
character eof thetext. Because that character isnowhere inthe pattern, the entire
pattern is shifted beyond its location. The second comparison is also a mismatch,
butthemismatchedcharactersoccurselsewhereinthepattern. Thepatternisnext
shifted so that its last occurrence of s is aligned with the corresponding s in the13.2. Pattern-MatchingAlgorithms 587
TheexampleofFigure13.2isratherbasic,becauseitonlyinvolvesmismatches
with the last character of the pattern. More generally, when a match is found for
that last character, the algorithm continues by trying to extend the match with the
second-to-lastcharacterofthepatterninitscurrentalignment. Thatprocesscontin-
ues until either matching the entire pattern, orﬁnding amismatch atsomeinterior
position ofthepattern.
Ifamismatchisfound,andthemismatchedcharacterofthetextdoesnotoccur
in the pattern, we shift the entire pattern beyond that location, as originally illus-
trated inFigure 13.2. Ifthe mismatched character occurs elsewhere inthe pattern,
we must consider two possible subcases depending on whetherits last occurrence
isbeforeorafterthecharacterofthepatternthatwasalignedwiththemismatched.
Thosetwocasesareillustrated inFigure13.3.
Text: · · · · · · · · · · a · · · · · · · · ·
i i(cid:2)
Pattern: · a · · b ·
(a) j k
m−(j+1)
· a · · b ·
j+1
Text: · · · · · · · · · · a · · · · · · · · ·
i i(cid:2)
Pattern: · · · · b a
(b) k j
m−k
· · · · b a
k
Figure13.3: Additional rules for the character-jump heuristic of the Boyer-Moore
algorithm. We let i represent the index of the mismatched character in the text, k
represent the corresponding index in the pattern, and j represent the index of the
last occurrence of T[i] within the pattern. We distinguish two cases: (a) j < k,
in which case we shift the pattern by k− j units, and thus, index i advances by
m−(j+1) units; (b) j >k, in which case we shift the pattern by one unit, and
indexiadvances bym−kunits.
In the case of Figure 13.3(b), we slide the pattern only one unit. It would
be more productive to slide it rightward until ﬁnding another occurrence of mis-588 Chapter13. TextProcessing
another occurrence. The efﬁciency of the Boyer-Moore algorithm relies on creat-
ing a lookup table that quickly determines where a mismatched character occurs
elsewhereinthepattern. Inparticular, wedeﬁneafunctionlast(c)as
• If c is in P, last(c) is the index of the last (rightmost) occurrence ofc in P.
Otherwise,weconventionally deﬁnelast(c)=−1.
Ifweassumethatthealphabetisofﬁxed,ﬁnitesize,andthatcharacterscanbe
converted to indices of an array (for example, by using their character code), the
last function can be easily implemented as a lookup table with worst-case O(1)-
timeaccesstothevaluelast(c). However,thetablewouldhavelengthequaltothe
sizeofthealphabet(ratherthanthesizeofthepattern),andtimewouldberequired
toinitialize theentiretable.
We prefer to use a hash table to represent the last function, with only those
characters from the pattern occurring in the structure. The space usage for this
approach is proportional to the number of distinct alphabet symbols that occur in
the pattern, and thus O(m). Theexpected lookup timeremains independent of the
problem (although the worst-case bound isO(m)). Our complete implementation
oftheBoyer-Moore pattern-matching algorithm isgiveninCodeFragment13.2.
1 def ﬁnd boyer moore(T, P):
2 ”””Return the lowest index of T at which substring P begins (or else -1).”””
3 n, m = len(T), len(P) # introduce convenient notations
4 if m == 0: return 0 # trivial search for empty string
5 last = { } # build ’last’ dictionary
6 for k in range(m):
7 last[ P[k] ] = k # later occurrence overwrites
8 # align end of pattern at index m-1 of text
9 i = m−1 # an index into T
10 k = m−1 # an index into P
11 while i < n:
12 if T[i] == P[k]: # a matching character
13 if k == 0:
14 return i # pattern begins at index i of text
15 else:
16 i −= 1 # examine previous character
17 k −= 1 # of both T and P
18 else:
19 j = last.get(T[i], −1) # last(T[i]) is -1 if not found
20 i += m − min(k, j + 1) # case analysis for jump step
21 k = m − 1 # restart at end of pattern
22 return −113.2. Pattern-MatchingAlgorithms 589
The correctness of the Boyer-Moore pattern-matching algorithm follows from
thefactthateachtimethemethodmakesashift,itisguaranteed notto“skip”over
any possible matches. For last(c) is the location of the last occurrence of c in P.
In Figure 13.4, we illustrate the execution of the Boyer-Moore pattern-matching
algorithm onaninputstringsimilartoExample13.1.
c a b c d
last(c) 4 5 3− 1
Text: a b a c a a b a d c a b a c a b a a b b
1
Pattern: a b a c a b
4 3 2 13 12 11 10 9 8
a b a c a b a b a c a b
5 7
a b a c a b a b a c a b
6
a b a c a b
Figure 13.4: An illustration of the Boyer-Moore pattern-matching algorithm, in-
cluding a summary of the last(c) function. The algorithm performs 13 character
comparisons, whichareindicated withnumericallabels.
Performance
Ifusingatraditionallookuptable,theworst-caserunningtimeoftheBoyer-Moore
algorithm isO(nm+|Σ|). Namely, thecomputation ofthelastfunction takes time
O(m+|Σ|),andtheactualsearchforthepatterntakesO(nm)timeintheworstcase,
thesameasthebrute-force algorithm. (Withahashtable,thedependence on|Σ|is
removed.) Anexampleofatext-pattern pairthatachievestheworstcaseis
(cid:23) (cid:24)n(cid:25) (cid:26)
T = aaaaaa···a
(cid:23)m(cid:24)−(cid:25)1(cid:26)
P = baa···a
The worst-case performance, however, is unlikely to be achieved for English text,
for, in that case, the Boyer-Moore algorithm is often able to skip large portions
of text. Experimental evidence on English text shows that the average number of
comparisons donepercharacteris0.24foraﬁve-character patternstring.
WehaveactuallypresentedasimpliﬁedversionoftheBoyer-Moorealgorithm.
TheoriginalalgorithmachievesrunningtimeO(n+m+|Σ|)byusinganalternative
shift heuristic to the partially matched text string, whenever it shifts the pattern
more than the character-jump heuristic. This alternative shift heuristic is based on
applying the main idea from the Knuth-Morris-Pratt pattern-matching algorithm,590 Chapter13. TextProcessing
13.2.3 The Knuth-Morris-Pratt Algorithm
In examining the worst-case performances of the brute-force and Boyer-Moore
pattern-matchingalgorithmsonspeciﬁcinstancesoftheproblem,suchasthatgiven
inExample13.1,weshould noticeamajorinefﬁciency. Foracertain alignmentof
the pattern, if we ﬁnd several matching characters but then detect a mismatch, we
ignore all the information gained by the successful comparisons after restarting
withthenextincremental placementofthepattern.
TheKnuth-Morris-Pratt(or“KMP”)algorithm,discussedinthissection,avoids
thiswasteofinformation and, insodoing, itachieves arunning timeofO(n+m),
which is asymptotically optimal. That is, in the worst case any pattern-matching
algorithm will have to examine all the characters of the textand all the characters
of the pattern at least once. The main idea of the KMP algorithm is to precom-
pute self-overlaps between portions ofthe pattern sothat whenamismatch occurs
at one location, we immediately know the maximum amount to shift the pattern
beforecontinuing thesearch. AmotivatingexampleisshowninFigure13.5.
Text: a t c a m a l g a m a · · · · · · · · · · ·
Pattern: a m a l g a m a t i o n
a m a l g a m a t i o n
a m a l g a m a t i o n
Figure13.5: Amotivating examplefortheKnuth-Morris-Pratt algorithm. Ifamis-
match occurs at the indicated location, the pattern could be shifted to the second
alignment, without explicit need to recheck the partial match with the preﬁx ama.
If the mismatched character is not an l, then the next potential alignment of the
patterncantakeadvantage ofthecommona.
The Failure Function
Toimplement the KMP algorithm, we will precompute afailure function, f, that
indicates the proper shift of P upon a failed comparison. Speciﬁcally, the failure
function f(k) is deﬁned as the length of the longest preﬁx of P that is a sufﬁx
of P[1:k+1] (note that we did not include P[0] here, since we will shift at least
one unit). Intuitively, if we ﬁnd a mismatch upon character P[k+1], the function
f(k) tells us how many of the immediately preceding characters can be reused to
restart thepattern. Example13.2describes thevalue ofthefailure function forthe13.2. Pattern-MatchingAlgorithms 591
Example 13.2: Considerthepattern P = "amalgamation" fromFigure13.5.
TheKnuth-Morris-Pratt(KMP)failurefunction, f(k),forthestringPisasshown
inthefollowingtable:
k 0 1 2 3 4 5 6 7 8 9 10 11
P[k] a m a l g a m a t i o n
f(k) 0 0 1 0 0 1 2 3 0 0 0 0
Implementation
Our implementation of the KMP pattern-matching algorithm is shown in Code
Fragment 13.3. It relies on a utility function, compute kmp fail, discussed on
thenextpage,tocomputethefailurefunction efﬁciently.
The mainpart of the KMPalgorithm isitswhileloop, each iteration of which
performs a comparison between the character at index j in T and the character at
indexkinP. Iftheoutcomeofthiscomparisonisamatch,thealgorithm moveson
tothenextcharactersinbothT andP(orreportsamatchifreachingtheendofthe
pattern). If the comparison failed, the algorithm consultsthe failure function for a
new candidate character in P, or starts over with the next index in T if failing on
theﬁrstcharacter ofthepattern(sincenothing canbereused).
1 def ﬁnd kmp(T, P):
2 ”””Return the lowest index of T at which substring P begins (or else -1).”””
3 n, m = len(T), len(P) # introduce convenient notations
4 if m == 0: return 0 # trivial search for empty string
5 fail = compute kmp fail(P) # rely on utility to precompute
6 j = 0 # index into text
7 k = 0 # index into pattern
8 while j < n:
9 if T[j] == P[k]: # P[0:1+k] matched thus far
10 if k == m − 1: # match is complete
11 return j − m + 1
12 j += 1 # try to extend match
13 k += 1
14 elif k > 0:
15 k = fail[k−1] # reuse suﬃx of P[0:k]
16 else:
17 j += 1
18 return −1 # reached end without match
CodeFragment13.3: Animplementation ofthe KMP pattern-matching algorithm.592 Chapter13. TextProcessing
Constructing the KMP Failure Function
Toconstructthefailurefunction,weusethemethodshowninCodeFragment13.4,
whichisa“bootstrapping”processthatcomparesthepatterntoitselfasintheKMP
algorithm. Eachtimewehavetwocharactersthatmatch,weset f(j)=k+1. Note
that since we have j > k throughout the execution of the algorithm, f(k−1) is
alwayswelldeﬁnedwhenweneedtouseit.
1 def compute kmp fail(P):
2 ”””Utility that computes and returns KMP fail list.”””
3 m = len(P)
4 fail = [0] m # by default, presume overlap of 0 everywhere
5 j = 1
6 k = 0
7 while j < m: # compute f(j) during this pass, if nonzero
8 if P[j] == P[k]: # k + 1 characters match thus far
9 fail[j] = k + 1
10 j += 1
11 k += 1
12 elif k > 0: # k follows a matching preﬁx
13 k = fail[k−1]
14 else: # no match found starting at j
15 j += 1
16 return fail
Code Fragment13.4: An implementation of the compute kmp fail utility in sup-
port of the KMP pattern-matching algorithm. Note how the algorithm uses the
previous valuesofthefailurefunctiontoefﬁcientlycomputenewvalues.
Performance
Excluding the computation of the failure function, the running time of the KMP
algorithm isclearly proportional tothenumberofiterations ofthewhileloop. For
thesake oftheanalysis, letusdeﬁnes= j−k. Intuitively, sisthetotalamountby
whichthepatternPhasbeenshiftedwithrespecttothetextT. Notethatthroughout
the execution of the algorithm, we have s≤n. One of the following three cases
occursateachiterationoftheloop.
• IfT[j]=P[k],then jandkeachincreaseby1,andthus,sdoesnotchange.
• IfT[j](cid:15)=P[k]andk>0,then jdoesnotchangeandsincreasesbyatleast1,
since in this case s changes from j−k to j− f(k−1), which is an addition
ofk− f(k−1),whichispositivebecause f(k−1)<k.
• If T[j](cid:15)=P[k] and k=0, then j increases by 1 and s increases by 1, since k13.2. Pattern-MatchingAlgorithms 593
Thus, at each iteration of the loop, either j or s increases by at least 1 (possibly
both); hence, the total number of iterations of thewhile loop in the KMP pattern-
matching algorithm is at most 2n. Achieving this bound, of course, assumes that
wehavealreadycomputedthefailurefunction forP.
ThealgorithmforcomputingthefailurefunctionrunsinO(m)time. Itsanalysis
is analogous to that of the main KMP algorithm, yet with a pattern of length m
comparedtoitself. Thus,wehave:
Proposition 13.3: TheKnuth-Morris-Prattalgorithmperformspatternmatching
onatextstringoflengthnandapatternstringoflengthminO(n+m)time.
Thecorrectnessofthisalgorithmfollowsfromthedeﬁnitionofthefailurefunc-
tion. Any comparisons that are skipped are actually unnecessary, for the failure
function guarantees that all the ignored comparisons are redundant—they would
involve comparingthesamematchingcharacters overagain.
In Figure 13.6, we illustrate the execution of the KMP pattern-matching algo-
rithm on the same input strings as in Example 13.1. Note the use of the failure
function to avoid redoing one of the comparisons between a character of the pat-
ternandacharacterofthetext. Alsonotethatthealgorithmperformsfeweroverall
comparisons thanthebrute-force algorithm runonthesamestrings(Figure13.1).
Thefailurefunction:
k 0 1 2 3 4 5
P[k] a b a c a b
f(k) 0 0 1 0 1 2
Text: a b a c a a b a c c a b a c a b a a b b
1 2 3 4 5 6
Pattern: a b a c a b
7
a b a c a b
8 9 10 11 12
a b a c a b
nocomparison
13
performed
a b a c a b
14 15 16 17 18 19
a b a c a b
Figure13.6: An illustration of the KMP pattern-matching algorithm. Theprimary
algorithm performs 19character comparisons, whichare indicated withnumerical
labels. (Additionalcomparisonswouldbeperformedduringthecomputationofthe594 Chapter13. TextProcessing
13.3 Dynamic Programming
Inthissection, wediscussthedynamicprogrammingalgorithm-design technique.
This technique is similar to the divide-and-conquer technique (Section 12.2.1), in
that it can be applied to a wide variety of different problems. Dynamic program-
mingcanoftenbeusedtotakeproblemsthatseemtorequireexponential timeand
producepolynomial-timealgorithmstosolvethem. Inaddition,thealgorithmsthat
result from applications of the dynamic programming technique are usually quite
simple—often needinglittlemorethanafewlinesofcodetodescribesomenested
loopsforﬁllinginatable.
13.3.1 Matrix Chain-Product
Rather than starting out with an explanation of the general components of the dy-
namic programming technique, we begin by giving a classic, concrete example.
Suppose we are given a collection of n two-dimensional matrices for which we
wishtocomputethemathematicalproduct
A=A0·A1·A2···An−1,
where Ai is a di×di+1 matrix, for i = 0,1,2,...,n−1. In the standard matrix
multiplicationalgorithm(whichistheonewewilluse),tomultiplyad×e-matrixB
timesane× f-matrixC,wecomputetheproduct,A,as
e−1
A[i][j]= ∑B[i][k]·C[k][j].
k=0
This deﬁnition implies that matrix multiplication is associative, that is, it implies
that B·(C·D)=(B·C)·D. Thus, we can parenthesize the expression for A any
way we wish and we will end up with the same answer. However, we will not
necessarily perform the same number of primitive (that is, scalar) multiplications
ineachparenthesization, asisillustrated inthefollowingexample.
Example 13.4: LetBbea2×10-matrix,letCbea10×50-matrix,andletDbe
a50×20-matrix. ComputingB·(C·D) requires2·10·20+10·50·20 =10400
multiplications,whereascomputing(B·C)·Drequires2·10·50+2·50·20=3000
multiplications.
Thematrix chain-product problem is todetermine the parenthesization of the
expression deﬁning the product A that minimizes the total number of scalar mul-
tiplications performed. As the example above illustrates, the differences between
parenthesizations can be dramatic, so ﬁnding agood solution can result in signiﬁ-13.3. DynamicProgramming 595
Deﬁning Subproblems
Onewayto solve the matrix chain-product problem isto simply enumerate all the
possible ways of parenthesizing the expression for A and determine the number
of multiplications performed by each one. Unfortunately, the set of all different
parenthesizations of the expression for A is equal in number to the set of all dif-
ferent binary trees that have n leaves. This number is exponential inn. Thus, this
straightforward (“brute-force”) algorithm runsinexponential time,fortherearean
exponential numberofwaystoparenthesize anassociative arithmetic expression.
We can signiﬁcantly improve the performance achieved by thebrute-force al-
gorithm, however, by making a few observations about the nature of the matrix
chain-product problem. Theﬁrstisthattheproblemcanbesplitintosubproblems.
Inthis case, wecan deﬁneanumber ofdifferent subproblems,each ofwhich isto
computethebestparenthesizationforsomesubexpressionAi·Ai+1···Aj. Asacon-
cisenotation,weuseNi,j todenotetheminimumnumberofmultiplications needed
to compute this subexpression. Thus, the original matrix chain-product problem
can be characterized as that of computing the value of N0,n−1. This observation
is important, but we need one more in order to apply the dynamic programming
technique.
Characterizing Optimal Solutions
Theotherimportantobservationwecanmakeaboutthematrixchain-productprob-
lemisthatitispossibletocharacterize anoptimalsolutiontoaparticular subprob-
lem in terms of optimal solutions to its subproblems. We call this property the
subproblem optimalitycondition.
In the case of the matrix chain-product problem, we observe that, no mat-
ter how we parenthesize a subexpression, there has to be some ﬁnal matrix mul-
tiplication that we perform. That is, a full parenthesization of a subexpression
Ai·Ai+1···Aj has to be of the form (Ai···Ak)·(Ak+1···Aj), for some k ∈{i,i+
1,...,j−1}. Moreover, forwhicheverk isthecorrect one, theproducts(A ···A )
i k
and(Ak+1···Aj)mustalsobesolvedoptimally. Ifthiswerenotso,thentherewould
beaglobaloptimalthathadoneofthesesubproblemssolvedsuboptimally. Butthis
isimpossible,sincewecouldthenreducethetotalnumberofmultiplicationsbyre-
placingthecurrentsubproblemsolutionbyanoptimalsolutionforthesubproblem.
Thisobservation implies awayofexplicitly deﬁning theoptimization problem for
Ni,j intermsofother optimal subproblem solutions. Namely, wecancompute Ni,j
byconsidering eachplacekwherewecouldputtheﬁnalmultiplication andtaking596 Chapter13. TextProcessing
Designing a Dynamic Programming Algorithm
Wecanthereforecharacterize theoptimalsubproblem solution, Ni,j,as
Ni,j = min{Ni,k+Nk+1,j+didk+1dj+1},
i≤k<j
where Ni,i = 0, since no work is needed for a single matrix. That is, Ni,j is the
minimum, taken over allpossible places toperform the ﬁnal multiplication, ofthe
number ofmultiplications needed tocompute eachsubexpression plusthenumber
ofmultiplications neededtoperform theﬁnalmatrixmultiplication.
Notice that there is a sharing of subproblems going on that prevents us from
dividingtheproblemintocompletelyindependent subproblems (aswewouldneed
to do to apply the divide-and-conquer technique). We can, nevertheless, use the
equation for Ni,j to derive an efﬁcient algorithm by computing Ni,j values in a
bottom-up fashion, and storing intermediate solutions inatable ofNi,j values. We
can begin simply enough by assigning Ni,i =0 fori =0,1,...,n−1. Wecan then
applythegeneralequationforNi,j tocomputeNi,i+1values,sincetheydependonly
on Ni,i and Ni+1,i+1 values that are available. Given theNi,i+1 values, wecan then
compute theNi,i+2 values, and so on. Therefore, wecan buildNi,j values up from
previouslycomputedvaluesuntilwecanﬁnallycomputethevalueofN0,n−1,which
isthenumberthatwearesearching for. APythonimplementation ofthisdynamic
programming solution is given in Code Fragment 13.5; we use techniques from
Section5.6forrepresenting amultidimensional tableinPython.
1 def matrix chain(d):
2 ”””d is a list of n+1 numbers such that size of kth matrix is d[k]-by-d[k+1].
3
4 Return an n-by-n table such that N[i][j] represents the minimum number of
5 multiplications needed to compute the product of Ai through Aj inclusive.
6 ”””
7 n = len(d) − 1 # number of matrices
8 N = [[0] n for i in range(n)] # initialize n-by-n result to zero
9 for b in range(1, n): # number of products in subchain
10 for i in range(n−b): # start of subchain
11 j = i + b # end of subchain
12 N[i][j] = min(N[i][k]+N[k+1][j]+d[i] d[k+1] d[j+1] for k in range(i,j))
13 return N
Code Fragment 13.5: Dynamic programming algorithm for the matrix chain-
productproblem.
Thus,wecancomputeN0,n−1 withanalgorithmthatconsistsprimarilyofthree
nested loops (the third of which computes the min term). Each of these loops
iterates at most n times per execution, with a constant amount of additional work13.3. DynamicProgramming 597
13.3.2 DNA and Text Sequence Alignment
A common text-processing problem, which arises in genetics and software engi-
neering, istotestthesimilarity betweentwotextstrings. Inagenetics application,
thetwostringscouldcorrespondtotwostrandsofDNA,forwhichwewanttocom-
pute similarities. Likewise, in a software engineering application, the two strings
could comefromtwoversions ofsource code forthesameprogram, forwhichwe
wanttodeterminechangesmadefromoneversiontothenext. Indeed,determining
thesimilaritybetweentwostringsissocommonthattheUnixandLinuxoperating
systemshaveabuilt-in program,nameddiff,forcomparing textﬁles.
Given a string X =x0x1x2···xn−1, a subsequence of X is any string that is of
theformxi1xi2···xik, whereij <ij+1;that is, itisasequence ofcharacters thatare
notnecessarilycontiguousbutareneverthelesstakeninorderfromX. Forexample,
thestringAAAGisasubsequence ofthestringCGATAATTGAGA.
The DNA and text similarity problem we address here is thelongest common
subsequence (LCS)problem. In this problem, weare given twocharacter strings,
X =x0x1x2···xn−1 andY =y0y1y2···ym−1,oversomealphabet(suchasthealpha-
bet{A,C,G,T}commonincomputationalgenetics)andareaskedtoﬁndalongest
string S that is a subsequence of both X and Y. One way to solve the longest
commonsubsequence problem istoenumerate allsubsequences ofX andtake the
largest one that is also a subsequence ofY. Since each character of X is either in
ornotinasubsequence, there arepotentially 2n different subsequences ofX,each
ofwhichrequires O(m)timetodetermine whether itisasubsequence ofY. Thus,
thisbrute-forceapproachyieldsanexponential-time algorithmthatrunsinO(2nm)
time,whichisveryinefﬁcient. Fortunately,theLCSproblemisefﬁcientlysolvable
usingdynamicprogramming.
The Components of a Dynamic Programming Solution
As mentioned above, the dynamic programming technique is used primarily for
optimization problems, wherewewishtoﬁndthe“best” wayofdoing something.
Wecanapplythedynamicprogrammingtechniqueinsuchsituationsiftheproblem
hascertainproperties:
SimpleSubproblems: Therehastobesomewayofrepeatedlybreakingtheglobal
optimization problem intosubproblems. Moreover, thereshould beawayto
parameterize subproblems withjustafewindices, likei, j,k,andsoon.
SubproblemOptimization: Anoptimal solution totheglobal problem mustbea
composition ofoptimalsubproblem solutions.
SubproblemOverlap: Optimal solutions to unrelated subproblems can contain598 Chapter13. TextProcessing
Applying Dynamic Programming to the LCS Problem
Recall that in the LCS problem, we are given two character strings, X and Y, of
length n and m, respectively, and are asked to ﬁnd a longest stringS that is a sub-
sequence of both X andY. Since X andY are character strings, wehave a natural
setofindices withwhichtodeﬁnesubproblems—indices intothestringsX andY.
Let us deﬁne a subproblem, therefore, as that of computing the value Lj,k, which
we will use to denote the length of a longest string that is a subsequence of both
preﬁxes X[0: j] and Y[0:k]. This deﬁnition allows us to rewrite Lj,k in terms of
optimal subproblem solutions. This deﬁnition depends on which of two cases we
arein. (SeeFigure13.7.)
L10,12=1+L9,11 L9,11=max(L9,10, L8,11)
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8
X=GTTCCTAATA X=GTTCCTAAT
Y=CGATAATTGAGA Y=CGATAATTGAG
0 1 2 3 4 5 6 7 8 9 1011 0 1 2 3 4 5 6 7 8 9 10
(a) (b)
Figure13.7:Thetwocasesinthelongestcommonsubsequence algorithmforcom-
putingLj,k: (a)xj−1=yk−1;(b)xj−1(cid:15)=yk−1.
• xj−1 = yk−1. In this case, we have a match between the last character of
X[0:j] and the last character of Y[0:k]. We claim that this character be-
longs to a longest common subsequence of X[0: j] and Y[0:k]. To justify
this claim, let us suppose it is not true. There has to be some longest com-
mon subsequence xa1xa2...xac =yb1yb2...ybc. If xac =xj−1 or ybc =yk−1,
then we get the same sequence by setting a = j−1 and b =k−1. Alter-
c c
nately, ifxac (cid:15)=xj−1 andybc (cid:15)=yk−1,thenwecangetanevenlongercommon
subsequence by adding xj−1 = yk−1 to the end. Thus, a longest common
subsequence ofX[0:j]andY[0:k]endswithxj−1. Therefore, weset
Lj,k =1+Lj−1,k−1 ifxj−1=yk−1.
• xj−1 (cid:15)=yk−1. In this case, we cannot have a common subsequence that in-
cludesbothxj−1 andyk−1. Thatis,wecanhaveacommonsubsequence end
with xj−1 or one that ends with yk−1 (or possibly neither), but certainly not
both. Therefore, weset
Lj,k =max{Lj−1,k,Lj,k−1} ifxj−1(cid:15)=yk−1.
We note that because sliceY[0:0] is the empty string, Lj,0 =0 for j=0,1,...,n;13.3. DynamicProgramming 599
The LCS Algorithm
The deﬁnition of Lj,k satisﬁes subproblem optimization, for we cannot have a
longest common subsequence without also having longest common subsequences
for the subproblems. Also, it uses subproblem overlap, because a subproblem so-
lution Lj,k can be used in several other problems (namely, the problems Lj+1,k,
Lj,k+1, and Lj+1,k+1). Turning this deﬁnition of Lj,k into an algorithm is actually
quitestraightforward. Wecreatean(n+1)×(m+1)array,L,deﬁnedfor0≤ j≤n
and 0≤k≤m. We initialize all entries to 0, in particular so that all entries of the
formLj,0 andL0,k arezero. Then,weiteratively build upvaluesinLuntilwehave
Ln,m, the length of a longest common subsequence ofX andY. We give a Python
implementation ofthisalgorithm inCodeFragment13.6.
1 def LCS(X, Y):
2 ”””Return table such that L[j][k] is length of LCS for X[0:j] and Y[0:k].”””
3 n, m = len(X), len(Y) # introduce convenient notations
4 L = [[0] (m+1) for k in range(n+1)] # (n+1) x (m+1) table
5 for j in range(n):
6 for k in range(m):
7 if X[j] == Y[k]: # align this match
8 L[j+1][k+1] = L[j][k] + 1
9 else: # choose to ignore one character
10 L[j+1][k+1] = max(L[j][k+1], L[j+1][k])
11 return L
CodeFragment13.6: Dynamicprogrammingalgorithm fortheLCSproblem.
The running time of the algorithm of the LCS algorithm is easy to analyze,
for it is dominated by two nested for loops, with the outer one iterating n times
and the inner one iterating m times. Since the if-statement and assignment inside
the loop each requires O(1) primitive operations, this algorithm runs in O(nm)
time. Thus, the dynamic programming technique can be applied to the longest
common subsequence problem to improve signiﬁcantly over the exponential-time
brute-force solutiontotheLCSproblem.
The LCS function of Code Fragment 13.6 computes the length of the longest
commonsubsequence (stored asLn,m),butnotthesubsequence itself. Fortunately,
it is easy to extract the actual longest common subsequence if given the complete
table of Lj,k values computed by the LCS function. The solution can be recon-
structed backtofrontbyreverseengineering thecalculation oflength Ln,m. Atany
position Lj,k, if xj =yk, then the length is based on the common subsequence as-
sociatedwithlengthLj−1,k−1,followedbycommoncharacterxj. Wecanrecordxj600 Chapter13. TextProcessing
thenwecanmovetothelargerofLj,k−1 andLj−1,k. Wecontinuethisprocessuntil
reaching someLj,k =0 (for example, if j or k is 0 as a boundary case). A Python
implementationofthisstrategyisgiveninCodeFragment13.7. Thisfunctioncon-
structsalongestcommonsubsequenceinO(n+m)additionaltime,sinceeachpass
ofthewhileloopdecrementseither jork(orboth). Anillustrationofthealgorithm
forcomputingthelongest commonsubsequence isgiveninFigure13.8.
1 def LCS solution(X, Y, L):
2 ”””Return the longest common substring of X and Y, given LCS table L.”””
3 solution = [ ]
4 j,k = len(X), len(Y)
5 while L[j][k] > 0: # common characters remain
6 if X[j−1] == Y[k−1]:
7 solution.append(X[j−1])
8 j −= 1
9 k −= 1
10 elif L[j−1][k] >= L[j][k−1]:
11 j −=1
12 else:
13 k −= 1
14 return .join(reversed(solution)) # return left-to-right version
CodeFragment13.7: Reconstructing thelongestcommonsubsequence.
0 1 2 3 4 5 6 7 8 9 10 11 12
0 0 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 1 1 1 1 1 1 1 1 1 1 1
2 0 0 1 1 2 2 2 2 2 2 2 2 2
3 0 0 1 1 2 2 2 3 3 3 3 3 3
0 1 2 3 4 5 6 7 8 9
4 0 1 1 1 2 2 2 3 3 3 3 3 3 X=GTTCCTAATA
5 0 1 1 1 2 2 2 3 3 3 3 3 3
Y= CGATAATTGAGA
6 0 1 1 1 2 2 2 3 4 4 4 4 4
0 1 2 3 4 5 6 7 8 9 1011
7 0 1 1 2 2 3 3 3 4 4 5 5 5
8 0 1 1 2 2 3 4 4 4 4 5 5 6
9 0 1 1 2 3 3 4 5 5 5 5 5 6
10 0 1 1 2 3 4 4 5 5 5 6 6 6
Figure13.8:Illustration ofthealgorithmforconstructing alongestcommonsubse-
quencefromthearrayL. Adiagonalsteponthehighlightedpathrepresentstheuse
of a common character (with that character’s respective indices in the sequences13.4. TextCompressionandtheGreedyMethod 601
13.4 Text Compression and the Greedy Method
In this section, we consider an important text-processing task, text compression.
In this problem, we are given a string X deﬁned over some alphabet, such as the
ASCIIorUnicode character sets, andwewanttoefﬁciently encode X into asmall
binary stringY (using only the characters 0 and 1). Text compression is useful in
any situation where we wish to reduce bandwidth for digital communications, so
astominimize thetimeneeded totransmit ourtext. Likewise, text compression is
useful forstoring large documents moreefﬁciently, soastoallow aﬁxed-capacity
storagedevicetocontain asmanydocumentsaspossible.
ThemethodfortextcompressionexploredinthissectionistheHuffmancode.
Standard encoding schemes, such as ASCII, use ﬁxed-length binary strings to en-
code characters (with 7 or 8 bits in the traditional or extended ASCII systems,
respectively). The Unicode system was originally proposed as a 16-bit ﬁxed-
length representation, although common encodings reduce the space usage by al-
lowing common groups of characters, such as those from the ASCII system, with
fewer bits. The Huffman code saves space over a ﬁxed-length encoding by using
short code-word strings to encode high-frequency characters and long code-word
strings to encode low-frequency characters. Furthermore, the Huffman code uses
avariable-length encoding speciﬁcally optimized for a given string X over any al-
phabet. The optimization is based on the use of character frequencies, where we
have, for each character c, a count f(c) of the number of times c appears in the
stringX.
To encode the string X, we convert each character in X to a variable-length
code-word, and we concatenate all these code-words in order to produce the en-
codingY for X. In order to avoid ambiguities, we insist that no code-word in our
encoding be a preﬁx of another code-word in our encoding. Such a code is called
a preﬁx code, and it simpliﬁes the decoding ofY to retrieve X. (See Figure 13.9.)
Even with this restriction, the savings produced by a variable-length preﬁx code
can be signiﬁcant, particularly if there is a wide variance in character frequencies
(asisthecasefornaturallanguage textinalmosteverywrittenlanguage).
Huffman’s algorithm for producing an optimal variable-length preﬁx code for
X is based on the construction of a binary tree T that represents the code. Each
edge inT represents abitinacode-word, withanedge toaleft child representing
a “0” and an edge to a right child representing a “1.” Each leaf v is associated
with a speciﬁc character, and the code-word for that character is deﬁned by the
sequence ofbitsassociated withtheedgesinthepathfromtherootofT tov. (See
Figure 13.9.) Each leaf v has a frequency, f(v), which is simply the frequency in
X ofthecharacter associated withv. Inaddition, wegiveeachinternalnodevinT
afrequency, f(v), that isthesum ofthefrequencies ofalltheleaves inthesubtree602 Chapter13. TextProcessing
Character a b d e f h i k n o r s t u v
(a)
Frequency 9 5 1 3 7 3 1 1 1 4 1 5 1 2 1 1
46
19 27
10 12 15
9
(b) a r e 5 7 8
5 5 7
d 2 f n 4 4
3 3 4
b h 2 2 t 2
1 1 2
i k o s u v
1 1 1 1 1 1
Figure 13.9: An illustration of an example Huffman code for the input string
X ="a fast runner need never be afraid of the dark": (a)frequency
ofeachcharacter ofX;(b)HuffmantreeT forstringX. Thecodeforacharacterc
isobtained bytracing thepath fromtherootofT totheleafwherecisstored, and
associating a left child with 0 and a right child with 1. For example, the code for
“r”is011,andthecodefor“h”is10111.
13.4.1 The Huﬀman Coding Algorithm
TheHuffmancoding algorithm begins witheachofthed distinct characters ofthe
string X toencode beingtherootnode ofasingle-node binary tree. Thealgorithm
proceeds in a series of rounds. In each round, the algorithm takes the two binary
trees with the smallest frequencies and merges them into a single binary tree. It
repeatsthisprocess untilonlyonetreeisleft. (SeeCodeFragment13.8.)
Each iteration of the while loop in Huffman’s algorithm can be implemented
in O(logd) time using a priority queue represented with a heap. In addition, each
iteration takes twonodes out ofQand adds one in, aprocess that willbe repeated
d−1 times before exactly one node is left in Q. Thus, this algorithm runs in
O(n+dlogd) time. Although a full justiﬁcation of this algorithm’s correctness is
beyond our scope here, we note that its intuition comes from a simple idea—any
optimalcodecanbeconvertedintoanoptimalcodeinwhichthecode-wordsforthe
twolowest-frequencycharacters,aandb,differonlyintheirlastbit. Repeatingthe
argumentforastringwithaandbreplacedbyacharacterc,givesthefollowing:
Proposition 13.5: Huffman’salgorithmconstructsanoptimalpreﬁxcodefora13.4. TextCompressionandtheGreedyMethod 603
AlgorithmHuﬀman(X):
Input: StringX oflengthnwithd distinctcharacters
Output: CodingtreeforX
Computethefrequency f(c)ofeachcharactercofX.
InitializeapriorityqueueQ.
foreachcharactercinX do
Createasingle-node binarytreeT storingc.
InsertT intoQwithkey f(c).
whilelen(Q)>1do
(f ,T ) = Q.remove min()
1 1
(f ,T ) = Q.remove min()
2 2
CreateanewbinarytreeT withleftsubtreeT andrightsubtreeT .
1 2
InsertT intoQwithkey f + f .
1 2
(f,T) = Q.remove min()
returntreeT
CodeFragment13.8: Huffmancodingalgorithm.
13.4.2 The Greedy Method
Huffman’s algorithm for building an optimal encoding is an example application
of an algorithmic design pattern called thegreedy method. This design pattern is
applied tooptimization problems, whereweare trying to construct some structure
whileminimizingormaximizingsomeproperty ofthatstructure.
The general formula for the greedy method pattern is almost as simple as that
for the brute-force method. In order to solve a given optimization problem using
the greedy method, we proceed by a sequence of choices. The sequence starts
from some well-understood starting condition, and computes the cost for that ini-
tial condition. The pattern then asks that we iteratively make additional choices
by identifying the decision that achieves the best cost improvement from all of
the choices that are currently possible. This approach does not always lead to an
optimalsolution.
Butthereareseveralproblemsthatitdoesworkfor,andsuchproblemsaresaid
to possess the greedy-choice property. This is the property that a global optimal
condition can be reached by a series of locally optimal choices (that is, choices
that are each the current best from among the possibilities available at the time),
startingfromawell-deﬁnedstartingcondition. Theproblemofcomputinganopti-
malvariable-length preﬁxcodeisjustoneexampleofaproblemthatpossesses the604 Chapter13. TextProcessing
13.5 Tries
The pattern-matching algorithms presented in Section 13.2speed up the search in
a text by preprocessing the pattern (to compute the failure function in the Knuth-
Morris-Pratt algorithm or the last function in the Boyer-Moore algorithm). In this
section, we take a complementary approach, namely, we present string searching
algorithmsthatpreprocessthetext. Thisapproachissuitableforapplicationswhere
aseriesofqueriesisperformedonaﬁxedtext,sothattheinitialcostofpreprocess-
ingthetextiscompensated byaspeedup ineachsubsequent query(forexample, a
Web site that offers pattern matching in Shakespeare’s Hamlet or a search engine
thatoffersWebpagesontheHamlettopic).
A trie (pronounced “try”) is a tree-based data structure for storing strings in
order to support fast pattern matching. The main application for tries is in infor-
mation retrieval. Indeed, the name “trie” comes from the word “retrieval.” In an
information retrieval application, suchasasearchforacertainDNAsequence ina
genomicdatabase,wearegivenacollectionSofstrings,alldeﬁnedusingthesame
alphabet. Theprimaryqueryoperations thattriessupport arepattern matchingand
preﬁxmatching. Thelatter operation involves being givenastringX,andlooking
forallthestringsinSthatcontainX asapreﬁx.
13.5.1 Standard Tries
Let S be a set of s strings from alphabet Σ such that no string in S is a preﬁx
of another string. A standard trie for S is an ordered tree T with the following
properties (seeFigure13.10):
• EachnodeofT,excepttheroot,islabeledwithacharacterofΣ.
• Thechildren ofaninternalnodeofT havedistinct labels.
• T hassleaves,eachassociatedwithastringofS,suchthattheconcatenation
ofthelabelsofthenodesonthepathfromtheroottoaleafvofT yieldsthe
stringofSassociated withv.
Thus, atrieT represents the strings ofS withpaths from the root tothe leaves
of T. Note the importance of assuming that no string in S is a preﬁx of another
string. This ensures that each string of S is uniquely associated with a leaf of T.
(ThisissimilartotherestrictionforpreﬁxcodeswithHuffmancoding,asdescribed
in Section 13.4.) We can always satisfy this assumption by adding a special char-
acterthatisnotintheoriginal alphabetΣattheendofeachstring.
An internal node in a standard trie T can have anywhere between 1 and |Σ|
children. There is an edge going from the root r to one of its children for each
character thatisﬁrstinsomestringinthecollectionS. Inaddition, apathfromthe13.5. Tries 605
b s
e i u e t
a l d l y l o
r l l l c p
k
Figure 13.10: Standard trie for the strings {bear, bell, bid, bull, buy, sell, stock,
stop}.
ofastring X ofS. Infact, foreach character cthat canfollow thepreﬁxX[0:k]in
astringofthesetS,thereisachildofvlabeledwithcharacterc. Inthisway,atrie
concisely storesthecommonpreﬁxesthatexistamongasetofstrings.
As a special case, if there are only two characters in the alphabet, then the
trie isessentially abinary tree, withsome internal nodes possibly having only one
child(thatis,itmaybeanimproperbinarytree). Ingeneral, althoughitispossible
that an internal node has up to|Σ| children, in practice the average degree of such
nodesislikelytobemuchsmaller. Forexample,thetrieshowninFigure13.10has
several internal nodes with only one child. Onlarger data sets, the average degree
of nodes is likely to get smaller at greater depths of the tree, because there may
be fewer strings sharing the common preﬁx, and thus fewer continuations of that
pattern. Furthermore,inmanylanguages, therewillbecharactercombinations that
areunlikely tonaturally occur.
The following proposition provides some important structural properties of a
standard trie:
Proposition 13.6: AstandardtriestoringacollectionSofsstringsoftotallength
nfromanalphabetΣhasthefollowingproperties:
• TheheightofT isequaltothelengthofthelongeststringinS.
• EveryinternalnodeofT hasatmost|Σ|children.
• T hassleaves
• ThenumberofnodesofT isatmostn+1.
The worst case for the number of nodes of a trie occurs when no two strings
share a common nonempty preﬁx; that is, except for the root, all internal nodes606 Chapter13. TextProcessing
AtrieT forasetSofstringscanbeusedtoimplementasetormapwhosekeys
are the strings of S. Namely, we perform a search in T for a string X by tracing
down from the root the path indicated by the characters in X. If this path can be
traced and terminates at a leaf node, then we know X is a key in the map. For
example, in the trie in Figure 13.10, tracing the path for “bull” ends up at a leaf.
If the path cannot be traced or the path can be traced but terminates at an internal
node, then X is not a key in the map. In the example in Figure 13.10, the pathfor
“bet”cannotbetracedandthepathfor“be”endsataninternal node. Neithersuch
wordisinthemap.
It is easy to see that the running time of the search for a string of length m is
O(m·|Σ|), because we visit at most m+1 nodes of T and we spend O(|Σ|) time
ateachnodedetermining thechildhaving thesubsequent character asalabel. The
O(|Σ|) upper bound on the time to locate a child with a given label is achievable,
even if the children of a node are unordered, since there are at most |Σ| children.
We can improve the time spent at a node to be O(log|Σ|) or expected O(1), by
mappingcharacterstochildrenusingasecondarysearchtableorhashtableateach
node,orbyusingadirectlookuptableofsize|Σ|ateachnode,if|Σ|issufﬁciently
small (as is the case for DNA strings). For these reasons, we typically expect a
searchforastringoflengthmtoruninO(m)time.
From the discussion above, it follows that we can use a trie toperform a spe-
cial type of pattern matching, called wordmatching, where wewant to determine
whetheragivenpattern matchesoneofthewordsofthetextexactly. Wordmatch-
ing differs from standard pattern matching because the pattern cannot match an
arbitrary substring of the text—only one of its words. To accomplish this, each
word of the original document must be added to the trie. (See Figure 13.11.) A
simple extension of this scheme supports preﬁx-matching queries. However, ar-
bitrary occurrences of the pattern in the text (for example, the pattern is a proper
sufﬁxofawordorspanstwowords)cannotbeefﬁcientlyperformed.
To construct a standard trie for a set S of strings, we can use an incremental
algorithmthatinsertsthestringsoneatatime. Recalltheassumptionthatnostring
of S is a preﬁx of another string. To insert a string X into the current trie T, we
trace the path associated with X in T, creating a new chain of nodes to store the
remaining characters of X when we get stuck. The running time to insert X with
lengthmissimilartoasearch,withworst-caseO(m·|Σ|)performance,orexpected
O(m)ifusingsecondaryhashtablesateachnode. Thus,constructingtheentiretrie
forsetStakesexpectedO(n)time,wherenisthetotallengthofthestringsofS.
Thereisapotentialspaceinefﬁciencyinthestandardtriethathaspromptedthe
development of the compressed trie, which is also known (for historical reasons)
asthePatriciatrie. Namely,therearepotentially alotofnodesinthestandardtrie
thathaveonlyonechild,andtheexistenceofsuchnodesisawaste. Wediscussthe13.5. Tries 607
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
s e e a b e a r ? s e l l s t o c k !
23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
s e e a b u l l ? b u y s t o c k !
46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68
b i d s t o c k ! b i d s t o c k !
69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88
h e a r t h e b e l l ? s t o p !
(a)
b h s
e i u e e t
a l d l y a e l o
47,58 36 0,24
r l l r l c p
6 78 30 69 12 84
k
17,40,51,62
(b)
Figure13.11: Word matching with a standard trie: (a) text to be searched (articles
andprepositions, whicharealsoknownasstopwords, excluded); (b)standard trie
for the words in the text, with leaves augmented with indications of the index at
whichthegivenworkbegins inthetext. Forexample, theleafforthewordstock608 Chapter13. TextProcessing
13.5.2 Compressed Tries
Acompressedtrieissimilartoastandardtriebutitensuresthateachinternalnode
in the trie has at least two children. It enforces this rule bycompressing chains of
single-child nodes into individual edges. (See Figure 13.12.) Let T be a standard
trie. Wesaythat aninternal nodevof T isredundant ifvhas one child and isnot
the root. For example, the trie of Figure 13.10 has eight redundant nodes. Let us
alsosaythatachainofk≥2edges,
(v0,v1)(v1,v2)···(vk−1,vk),
isredundantif:
• v isredundant fori=1,...,k−1.
i
• v andv arenotredundant.
0 k
We can transform T into a compressed trie by replacing each redundant chain
(v0,v1)···(vk−1,vk) of k ≥2 edges into a single edge (v0,vk), relabeling vk with
theconcatenation ofthelabelsofnodesv ,...,v .
1 k
b s
e id u ell to
ar ll ll y ck p
Figure13.12: Compressed trie forthe strings{bear, bell, bid, bull, buy, sell, stock,
stop}. (Compare this withthe standard trie shown inFigure 13.10.) In addition to
compression at the leaves, notice the internal node with label to shared by words
stockandstop.
Thus,nodesinacompressed triearelabeledwithstrings, whicharesubstrings
ofstringsinthecollection,ratherthanwithindividualcharacters. Theadvantageof
acompressedtrieoverastandardtrieisthatthenumberofnodesofthecompressed
trie is proportional to the number of strings and not to theirtotal length, as shown
inthefollowingproposition (comparewithProposition 13.6).
Proposition 13.7: AcompressedtriestoringacollectionS ofsstringsfroman
alphabetofsizedhasthefollowingproperties:
• EveryinternalnodeofT hasatleasttwochildrenandmostdchildren.
• T hassleavesnodes.13.5. Tries 609
The attentive reader may wonder whether the compression of paths provides
any signiﬁcant advantage, since it is offset by a corresponding expansion of the
nodelabels. Indeed,acompressedtrieistrulyadvantageousonlywhenitisusedas
anauxiliaryindexstructure overacollection ofstringsalreadystoredinaprimary
structure, andisnotrequiredtoactuallystoreallthecharacters ofthestringsinthe
collection.
Suppose,forexample,thatthecollectionSofstringsisanarrayofstringsS[0],
S[1], ..., S[s−1]. Instead of storing the label X of a node explicitly, we represent
it implicitly by a combination of three integers (i, j:k), such that X =S[i][j :k];
that is, X is the slice of S[i] consisting of the characters from the jth up to but
not including the kth. (See the example in Figure 13.13. Also compare with the
standard trieofFigure13.11.)
0 1 2 3 4 0 1 2 3 0 1 2 3
S[0]= s e e S[4]= b u l l S[7]= h e a r
S[1]= b e a r S[5]= b u y S[8]= b e l l
S[2]= s e l l S[6]= b i d S[9]= s t o p
S[3]= s t o c k
(a)
1,0:1 7,0:4 0,0:1
1,1:2 6,1:3 4,1:2 0,1:2 3,1:3
1,2:4 8,2:4 4,2:4 5,2:3 0,2:3 2,2:4 3,3:5 9,3:4
(b)
Figure13.13: (a) Collection S of strings stored in an array. (b) Compact represen-
tationofthecompressed trieforS.
Thisadditional compression schemeallowsustoreduce thetotalspace forthe
trie itself from O(n) for the standard trie toO(s) for the compressed trie, where n
is the total length of the strings inS and s is the number of strings in S. We must
stillstorethedifferent strings inS,ofcourse, butwenevertheless reduce thespace
forthetrie.
Searching inacompressed trieisnot necessarily faster than inastandard tree,
since there is still need to compare every character of the desired pattern with the610 Chapter13. TextProcessing
13.5.3 Suﬃx Tries
One of the primary applications for tries is for the case when the strings in the
collectionSareallthesufﬁxesofastringX. Suchatrieiscalledthesufﬁxtrie(also
known as a sufﬁx tree or position tree) of string X. For example, Figure 13.14a
showsthesufﬁxtriefortheeightsufﬁxesofstring“minimize.” Forasufﬁxtrie,the
compactrepresentation presented intheprevious sectioncanbefurther simpliﬁed.
Namely, the label of each vertex is a pair(j,k) indicating the string X[j:k]. (See
Figure 13.14b.) Tosatisfy the rule that no sufﬁx ofX is a preﬁx of another sufﬁx,
wecanaddaspecialcharacter,denotedwith$,thatisnotintheoriginalalphabetΣ
attheendofX (andthustoeverysufﬁx). Thatis,ifstringX haslengthn,webuild
atrieforthesetofnstringsX[j:n],for j=0,...,n−1.
Saving Space
Usingasufﬁxtrieallowsustosavespaceoverastandardtriebyusingseveralspace
compression techniques, including thoseusedforthecompressed trie.
Theadvantageofthecompactrepresentationoftriesnowbecomesapparentfor
sufﬁxtries. SincethetotallengthofthesufﬁxesofastringX oflengthnis
n(n+1)
1+2+···+n= ,
2
storing all the sufﬁxes of X explicitly would take O(n2) space. Even so, the suf-
ﬁx trie represents these strings implicitly in O(n) space, as formally stated in the
followingproposition.
Proposition 13.8: ThecompactrepresentationofasufﬁxtrieT forastringX of
lengthnusesO(n)space.
Construction
We can construct the sufﬁx trie for a string of length n with an incremental algo-
rithm like the one given in Section 13.5.1. This construction takes O(|Σ|n2) time
because the total length of the sufﬁxes is quadratic in n. However, the (compact)
sufﬁxtrieforastringoflengthncanbeconstructedinO(n)timewithaspecialized
algorithm, different from the one for general tries. This linear-time construction
algorithm is fairly complex, however, and is not reported here. Still, we can take
advantage oftheexistence ofthisfastconstruction algorithm whenwewanttouse13.5. Tries 611
e i mi nimize ze
mize nimize ze nimize ze
(a)
7:8 1:2 0:2 2:8 6:8
4:8 2:8 6:8 2:8 6:8
0 1 2 3 4 5 6 7
m i n i m i z e
(b)
Figure13.14: (a)SufﬁxtrieT forthestringX ="minimize". (b)Compactrepre-
sentation ofT,wherepair j:kdenotes sliceX[j:k]inthereference string.
Using a Suﬃx Trie
ThesufﬁxtrieT forastringX canbeusedtoefﬁcientlyperform pattern-matching
queries on text X. Namely, we can determine whether a pattern P is a substring
of X by trying to trace a path associated withP in T. P is a substring of X if and
onlyifsuchapathcanbetraced. ThesearchdownthetrieT assumesthatnodesin
T storesomeadditional information, withrespecttothecompactrepresentation of
thesufﬁxtrie:
Ifnodevhaslabel(j,k)andY isthestringoflengthyassociated with
thepathfromtheroottov(included), thenX[k−y:k]=Y.
This property ensures that we can easily compute the start index of the pattern in612 Chapter13. TextProcessing
13.5.4 Search Engine Indexing
The World Wide Web contains a huge collection of text documents (Web pages).
Information about these pages are gathered by a program called a Web crawler,
which then stores thisinformation in aspecial dictionary database. A Websearch
engine allows users to retrieve relevant information from this database, thereby
identifying relevant pages on the Web containing given keywords. In this section,
wepresentasimpliﬁedmodelofasearchengine.
Inverted Files
The core information stored by a search engine is a dictionary, called an inverted
index or inverted ﬁle, storing key-value pairs (w,L), where w is a word and L is
a collection of pages containing word w. The keys (words) in this dictionary are
called index terms and should be a set of vocabulary entries and proper nouns as
large as possible. The elements in this dictionary are called occurrence lists and
shouldcoverasmanyWebpagesaspossible.
Wecanefﬁcientlyimplementaninvertedindexwithadatastructureconsisting
ofthefollowing:
1. Anarraystoringtheoccurrence listsoftheterms(innoparticular order).
2. Acompressedtrieforthesetofindexterms,whereeachleafstorestheindex
oftheoccurrence listoftheassociated term.
Thereasonforstoring theoccurrence listsoutside thetrieistokeepthesizeofthe
trie data structure sufﬁciently small to ﬁt in internal memory. Instead, because of
theirlargetotalsize,theoccurrence listshavetobestoredondisk.
With our data structure, a query for a single keyword is similar to a word-
matching query (Section 13.5.1). Namely, we ﬁnd the keywordin the trie and we
returntheassociated occurrence list.
When multiple keywords are given and the desired output are the pages con-
taining all the given keywords, we retrieve the occurrence list of each keyword
using the trie and return their intersection. To facilitate the intersection computa-
tion,eachoccurrencelistshouldbeimplementedwithasequencesortedbyaddress
orwithamap,toallowefﬁcientsetoperations.
In addition to the basic task of returning a list of pages containing given key-
words,searchenginesprovideanimportantadditionalservicebyrankingthepages
returned by relevance. Devising fast and accurate ranking algorithms for search
engines is a major challenge for computer researchers and electronic commerce13.6. Exercises 613
13.6 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-13.1 ListthepreﬁxesofthestringP="aaabbaaa"thatarealsosufﬁxesofP.
R-13.2 Whatisthelongest(proper) preﬁxofthestring"cgtacgttcgtacg"that
isalsoasufﬁxofthisstring?
R-13.3 Draw a ﬁgure illustrating the comparisons done by brute-force pattern
matchingforthetext"aaabaadaabaaa"andpattern"aabaaa".
R-13.4 RepeatthepreviousproblemfortheBoyer-Moorealgorithm,notcounting
thecomparisons madetocomputethelast(c)function.
R-13.5 Repeat Exercise R-13.3 for the Knuth-Morris-Pratt algorithm, not count-
ingthecomparisons madetocomputethefailurefunction.
R-13.6 Compute a map representing the last function used in the Boyer-Moore
pattern-matching algorithm forcharacters inthepattern string:
"the quick brown fox jumped over a lazy cat".
R-13.7 Compute a table representing the Knuth-Morris-Pratt failure function for
thepatternstring"cgtacgttcgtac".
R-13.8 Whatisthebestwaytomultiplyachainofmatriceswithdimensions that
are10×5,5×2,2×20,20×12,12×4,and4×60? Showyourwork.
R-13.9 In Figure 13.8, we illustrate that GTTTAA is a longest common subse-
quenceforthegivenstringsX andY. However,thatanswerisnotunique.
Giveanothercommonsubsequence ofX andY havinglengthsix.
R-13.10 Showthelongest commonsubsequence arrayLforthetwostrings:
X = "skullandbones"
Y = "lullabybabies"
Whatisalongest commonsubsequence betweenthesestrings?
R-13.11 Drawthefrequency arrayandHuffmantreeforthefollowingstring:
"dogs do not spot hot pots or cats".
R-13.12 Drawastandard trieforthefollowingsetofstrings:
{abab, baba, ccccc, bbaaaa, caa, bbaacc, cbcc, cbca}.
R-13.13 Drawacompressed trieforthestringsgivenintheprevious problem.
R-13.14 Drawthecompactrepresentation ofthesufﬁxtrieforthestring:614 Chapter13. TextProcessing
Creativity
C-13.15 Describe an example of a text T of length n and a pattern P of length
m such that force the brute-force pattern-matching algorithm achieves a
running timethatisΩ(nm).
C-13.16 Adaptthebrute-force pattern-matching algorithminordertoimplementa
function, rﬁnd brute(T,P), that returns the index at which the rightmost
occurrence ofpatternPwithintextT,ifany.
C-13.17 Redo the previous problem, adapting the Boyer-Moore pattern-matching
algorithmappropriatelytoimplementafunctionrﬁnd boyer moore(T,P).
C-13.18 RedoExerciseC-13.16,adaptingtheKnuth-Morris-Prattpattern-matching
algorithm appropriately toimplementafunctionrﬁnd kmp(T,P).
C-13.19 The count method of Python’s str class reports the maximum number of
nonoverlapping occurrencesofapatternwithinastring. Forexample,the
call abababa .count( aba ) returns 2 (not 3). Adapt the brute-force
pattern-matching algorithm to implement a function, count brute(T,P),
withsimilaroutcome.
C-13.20 Redo the previous problem, adapting the Boyer-Moore pattern-matching
algorithm inordertoimplementafunctioncount boyer moore(T,P).
C-13.21 RedoExerciseC-13.19,adaptingtheKnuth-Morris-Prattpattern-matching
algorithm appropriately toimplementafunctioncount kmp(T,P).
C-13.22 Give a justiﬁcation of why the compute kmp fail function (Code Frag-
ment13.4)runsinO(m)timeonapatternoflengthm.
C-13.23 LetT beatextoflengthn,andletPbeapatternoflengthm. Describean
O(n+m)-timemethodforﬁndingthelongestpreﬁxofPthatisasubstring
ofT.
C-13.24 SaythatapatternPoflengthmisacircularsubstringofatextT oflength
n>mifPisa(normal)substringofT,orifPisequaltotheconcatenation
of a sufﬁx of T and a preﬁx of T, that is, if there is an index 0≤k<m,
suchthatP=T[n−m+k:n]+T[0:k]. GiveanO(n+m)-timealgorithm
fordetermining whetherPisacircular substring ofT.
C-13.25 The Knuth-Morris-Pratt pattern-matching algorithm can be modiﬁed to
runfasteronbinarystrings byredeﬁning thefailurefunction as:
f(k)=thelargest j<ksuchthatP[0:j]p(cid:27) isasufﬁxofP[1:k+1],
j
where p(cid:27) denotes the complement of the jth bit of P. Describe how to
j
modifytheKMPalgorithmtobeabletotakeadvantageofthisnewfailure
functionandalsogiveamethodforcomputingthisfailurefunction. Show
that this method makes at most n comparisons between the text and the
pattern (as opposed to the 2n comparisons needed by the standard KMP13.6. Exercises 615
C-13.26 Modify the simpliﬁed Boyer-Moore algorithm presented in this chapter
usingideasfromtheKMPalgorithm sothatitrunsinO(n+m)time.
C-13.27 Designanefﬁcientalgorithm forthematrixchainmultiplication problem
that outputs afully parenthesized expression for how to multiply the ma-
tricesinthechainusingtheminimumnumberofoperations.
C-13.28 AnativeAustraliannamedAnatjariwishestocrossadesertcarryingonly
asinglewaterbottle. Hehasamapthatmarksallthewateringholesalong
theway. Assuming hecanwalkk milesononebottle ofwater, design an
efﬁcient algorithm for determining where Anatjari should reﬁll his bottle
in order to make as few stops as possible. Argue why your algorithm is
correct.
C-13.29 Describe an efﬁcient greedy algorithm for making change fora speciﬁed
valueusingaminimumnumberofcoins,assumingtherearefourdenomi-
nationsofcoins(calledquarters,dimes,nickels,andpennies),withvalues
25,10,5,and1,respectively. Arguewhyyouralgorithm iscorrect.
C-13.30 Give an example set of denominations of coins so that a greedy change-
makingalgorithm willnotusetheminimumnumberofcoins.
C-13.31 In the art gallery guarding problem we are given a line L that repre-
sents a long hallway in an art gallery. We are also given a set X =
{x0,x1,...,xn−1} of real numbers that specify the positions of paintings
in this hallway. Suppose that a single guard can protect all the paintings
within distance at most 1 of his or her position (on both sides). Design
an algorithm for ﬁnding a placement of guards that uses the minimum
numberofguardstoguardallthepaintings withpositions inX.
C-13.32 Let P be a convex polygon, a triangulation of P is an addition of diag-
onals connecting the vertices of P so that each interior face is a triangle.
The weight of a triangulation is the sum of the lengths of the diagonals.
Assumingthatwecancomputelengthsandaddandcomparethemincon-
stant time, give an efﬁcient algorithm for computing a minimum-weight
triangulation ofP.
C-13.33 Let T be a text string of length n. Describe an O(n)-time method for
ﬁndingthelongest preﬁxofT thatisasubstring ofthereversalofT.
C-13.34 Describe an efﬁcient algorithm to ﬁnd the longest palindrome that is a
sufﬁxofastringT oflengthn. Recallthatapalindromeisastringthatis
equaltoitsreversal. Whatistherunningtimeofyourmethod?
C-13.35 Given a sequence S =(x0,x1,...,xn−1) of numbers, describe an O(n2)-
time algorithm for ﬁnding a longest subsequence T = (x ,x ,...,x )
i0 i1 ik−1
of numbers, such that ij < ij+1 and xij > xij+1. That is, T is a longest
decreasing subsequence ofS.
C-13.36 GiveanefﬁcientalgorithmfordeterminingifapatternPisasubsequence616 Chapter13. TextProcessing
C-13.37 Deﬁne the edit distance between two strings X andY of length n and m,
respectively, tobethenumberofeditsthatittakestochangeX intoY. An
edit consists of a character insertion, a character deletion, or a character
replacement. Forexample,thestrings"algorithm"and"rhythm"have
edit distance 6. Design an O(nm)-time algorithm for computing the edit
distance betweenX andY.
C-13.38 Let X andY be strings of length n and m, respectively. Deﬁne B(j,k) to
bethelengthofthelongestcommonsubstringofthesufﬁxX[n−j:n]and
thesufﬁxY[m−k:m]. DesignanO(nm)-timealgorithmforcomputingall
thevaluesofB(j,k)for j=1,...,nandk=1,...,m.
C-13.39 Anna has just won acontest that allows her to takenpieces of candy out
ofacandystoreforfree. Annaisoldenoughtorealizethatsomecandyis
expensive, while other candy is relatively cheap, costing much less. The
jars of candy are numbered 0, 1, ..., m−1, so that jar j has n pieces in
j
it, with a price of c per piece. Design an O(n+m)-time algorithm that
j
allows Anna to maximize the value of the pieces of candy she takes for
herwinnings. Showthatyouralgorithmproduces themaximumvaluefor
Anna.
C-13.40 Let three integer arrays, A, B, andC, be given, each of size n. Given an
arbitrary integer k, design an O(n2logn)-time algorithm to determine if
thereexistnumbers,ainA,binB,andcinC,suchthatk=a+b+c.
C-13.41 GiveanO(n2)-timealgorithm forthepreviousproblem.
C-13.42 GivenastringX oflengthnandastringY oflengthm,describeanO(n+
m)-timealgorithm forﬁndingthelongestpreﬁxofX thatisasufﬁxofY.
C-13.43 Give an efﬁcient algorithm for deleting a string from a standard trie and
analyzeitsrunning time.
C-13.44 Give an efﬁcient algorithm for deleting a string from a compressed trie
andanalyzeitsrunning time.
C-13.45 Describe an algorithm for constructing the compact representation of a
sufﬁx trie, given its noncompact representation, and analyze its running
time.
Projects
P-13.46 Use the LCS algorithm to compute the best sequence alignmentbetween
someDNAstrings, whichyoucangetonlinefromGenBank.
P-13.47 Write aprogram that takes twocharacter strings (which could be, forex-
ample, representations ofDNAstrands) andcomputes theireditdistance,13.6. Exercises 617
P-13.48 Perform an experimental analysis of the efﬁciency (number of character
comparisonsperformed)ofthebrute-forceandKMPpattern-matchingal-
gorithmsforvarying-length patterns.
P-13.49 Perform an experimental analysis of the efﬁciency (number of charac-
ter comparisons performed) of the brute-force and Boyer-Moore pattern-
matchingalgorithms forvarying-length patterns.
P-13.50 Perform an experimental comparison of the relative speeds of the brute-
force, KMP, and Boyer-Moore pattern-matching algorithms. Document
the relative running times on large text documents that are then searched
usingvarying-length patterns.
P-13.51 Experiment with the efﬁciency of the ﬁnd method of Python’s str class
anddevelopahypothesisaboutwhichpattern-matching algorithm ituses.
Try using inputs that are likely to cause both best-case and worst-case
runningtimesforvariousalgorithms. Describeyourexperimentsandyour
conclusions.
P-13.52 Implement a compression and decompression scheme that is based on
Huffmancoding.
P-13.53 Create a class that implements a standard trie for a set of ASCII strings.
Theclass should have aconstructor that takes alist of strings asan argu-
ment,andtheclassshouldhaveamethodthattestswhetheragivenstring
isstoredinthetrie.
P-13.54 CreateaclassthatimplementsacompressedtrieforasetofASCIIstrings.
Theclass should have aconstructor that takes alist of strings asan argu-
ment,andtheclassshouldhaveamethodthattestswhetheragivenstring
isstoredinthetrie.
P-13.55 CreateaclassthatimplementsapreﬁxtrieforanASCIIstring. Theclass
shouldhaveaconstructorthattakesastringasanargument,andamethod
forpatternmatchingonthestring.
P-13.56 Implement the simpliﬁed search engine described in Section 13.5.4 for
the pages of a small Web site. Use all the words in the pages of the site
as index terms, excluding stop words such as articles, prepositions, and
pronouns.
P-13.57 Implement a search engine for the pages of a small Web site by adding
a page-ranking feature to the simpliﬁed search engine described in Sec-
tion 13.5.4. Your page-ranking feature should return the most relevant
pages ﬁrst. Use all the words in the pages of the site as index terms, ex-618 Chapter13. TextProcessing
Chapter Notes
TheKMPalgorithmisdescribedbyKnuth,Morris,andPrattintheirjournalarticle[66],
and Boyer and Moore describe their algorithm in a journal article published the same
year [18]. In their article, however, Knuth et al. [66] also prove that the Boyer-Moore
algorithmrunsinlineartime. Morerecently,Cole[27]showsthattheBoyer-Moorealgo-
rithm makesat most 3n charactercomparisonsin the worstcase, and this boundis tight.
Allof the algorithmsdiscussed abovearealso discussed in the bookchapterbyAho[4],
albeitin a moretheoreticalframework,includingthemethodsforregular-expressionpat-
ternmatching.Thereaderinterestedinfurtherstudyofstringpattern-matchingalgorithms
isreferredtothebookbyStephen[90]andthebookchaptersbyAho[4],andCrochemore
andLecroq[30].
Dynamicprogrammingwasdevelopedintheoperationsresearchcommunityandfor-
malizedbyBellman[13].
The trie was invented by Morrison [79] and is discussed extensively in the classic
Sorting and Searching book by Knuth [65]. The name “Patricia” is short for “Practical
AlgorithmtoRetrieveInformationCodedinAlphanumeric”[79]. McCreight[73] shows
how to construct sufﬁx tries in linear time. An introduction to the ﬁeld of information
retrieval, which includes a discussion of search engines for the Web, is provided in theChapter
14
Graph Algorithms
Contents
14.1 Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620
14.1.1 The Graph ADT . . . . . . . . . . . . . . . . . . . . . . . 626
14.2 Data Structures for Graphs . . . . . . . . . . . . . . . . . . 627
14.2.1 Edge List Structure . . . . . . . . . . . . . . . . . . . . . 628
14.2.2 Adjacency List Structure . . . . . . . . . . . . . . . . . . 630
14.2.3 Adjacency Map Structure . . . . . . . . . . . . . . . . . . 632
14.2.4 Adjacency Matrix Structure . . . . . . . . . . . . . . . . . 633
14.2.5 Python Implementation . . . . . . . . . . . . . . . . . . . 634
14.3 Graph Traversals . . . . . . . . . . . . . . . . . . . . . . . . 638
14.3.1 Depth-First Search . . . . . . . . . . . . . . . . . . . . . 639
14.3.2 DFS Implementation and Extensions . . . . . . . . . . . . 644
14.3.3 Breadth-First Search . . . . . . . . . . . . . . . . . . . . 648
14.4 Transitive Closure . . . . . . . . . . . . . . . . . . . . . . . 651
14.5 Directed Acyclic Graphs . . . . . . . . . . . . . . . . . . . . 655
14.5.1 Topological Ordering . . . . . . . . . . . . . . . . . . . . 655
14.6 Shortest Paths . . . . . . . . . . . . . . . . . . . . . . . . . 659
14.6.1 Weighted Graphs . . . . . . . . . . . . . . . . . . . . . . 659
14.6.2 Dijkstra’s Algorithm . . . . . . . . . . . . . . . . . . . . . 661
14.7 Minimum Spanning Trees . . . . . . . . . . . . . . . . . . . 670
14.7.1 Prim-Jarn´ık Algorithm . . . . . . . . . . . . . . . . . . . 672
14.7.2 Kruskal’s Algorithm . . . . . . . . . . . . . . . . . . . . . 676
14.7.3 Disjoint Partitions and Union-Find Structures . . . . . . . 681620 Chapter14. GraphAlgorithms
14.1 Graphs
A graph is a way of representing relationships that exist between pairs of objects.
That is, a graph is a set of objects, called vertices, together with a collection of
pairwise connections between them, called edges. Graphs have applications in
modeling many domains, including mapping, transportation, computer networks,
and electrical engineering. By the way, this notion of a “graph” should not be
confusedwithbarchartsandfunctionplots,asthesekindsof“graphs”areunrelated
tothetopicofthischapter.
Viewed abstractly, a graph G is simply a setV of vertices and a collection E
of pairs of vertices fromV, called edges. Thus, a graph is a way of representing
connectionsorrelationshipsbetweenpairsofobjectsfromsomesetV. Incidentally,
somebooksusedifferentterminology forgraphsandrefertowhatwecallvertices
asnodesandwhatwecalledgesasarcs. Weusetheterms“vertices” and“edges.”
Edges in a graph are either directed or undirected. An edge (u,v) is said to
be directed from u to v if the pair (u,v) is ordered, with u preceding v. An edge
(u,v)issaidtobeundirectedifthepair(u,v)isnotordered. Undirectededgesare
sometimes denoted with set notation, as {u,v}, but for simplicity we use the pair
notation(u,v),notingthatintheundirectedcase(u,v)isthesameas(v,u). Graphs
aretypicallyvisualizedbydrawingtheverticesasovalsorrectanglesandtheedges
as segments orcurves connecting pairs of ovals and rectangles. The following are
someexamplesofdirectedandundirected graphs.
Example 14.1: Wecanvisualizecollaborationsamongtheresearchersofacer-
taindisciplinebyconstructingagraphwhoseverticesareassociatedwiththere-
searchersthemselves,andwhoseedgesconnectpairsofverticesassociatedwith
researcherswhohavecoauthoredapaperorbook. (SeeFigure14.1.)Suchedges
areundirectedbecausecoauthorshipisasymmetricrelation;thatis,ifAhascoau-
thoredsomethingwithB,thenBnecessarilyhascoauthoredsomethingwithA.
Snoeyink Garg
Goldwasser
Goodrich Tamassia
Tollis
Vitter Preparata Chiang14.1. Graphs 621
Example 14.2: Wecanassociatewithanobject-orientedprogramagraphwhose
verticesrepresenttheclassesdeﬁnedintheprogram,andwhoseedgesindicate
inheritancebetweenclasses. Thereisanedgefromavertexv toavertexu if
theclassforv inheritsfromtheclassforu. Suchedgesaredirectedbecausethe
inheritancerelationonlygoesinonedirection(thatis,itisasymmetric).
Ifalltheedgesinagraphareundirected,thenwesaythegraphisanundirected
graph. Likewise, a directed graph, also called adigraph, is a graph whose edges
arealldirected. Agraphthathasbothdirectedandundirectededgesisoftencalled
a mixed graph. Note that an undirected or mixed graph can be converted into a
directed graph by replacing every undirected edge (u,v) by the pair of directed
edges (u,v) and (v,u). It is often useful, however, to keep undirected and mixed
graphs represented asthey are, forsuch graphs have severalapplications, asinthe
followingexample.
Example 14.3: Acitymapcanbemodeledasagraphwhoseverticesareintersec-
tionsordeadends,andwhoseedgesarestretchesofstreetswithoutintersections.
Thisgraphhasbothundirectededges,whichcorrespondtostretchesoftwo-way
streets,anddirectededges,whichcorrespondtostretchesofone-waystreets.Thus,
inthisway,agraphmodelingacitymapisamixedgraph.
Example 14.4: Physicalexamplesofgraphsarepresentintheelectricalwiring
andplumbingnetworksofabuilding. Suchnetworkscanbemodeledasgraphs,
whereeachconnector,ﬁxture,oroutletisviewedasavertex,andeachuninter-
ruptedstretchofwireorpipeisviewedasanedge.Suchgraphsareactuallycom-
ponentsofmuchlargergraphs,namelythelocalpowerandwaterdistributionnet-
works.Dependingonthespeciﬁcaspectsofthesegraphsthatweareinterestedin,
wemayconsidertheiredgesasundirectedordirected,for,inprinciple,watercan
ﬂowinapipeandcurrentcanﬂowinawireineitherdirection.
The two vertices joined by an edge are called the end vertices (or endpoints)
oftheedge. Ifanedgeisdirected,itsﬁrstendpointisitsoriginandtheotheristhe
destination of the edge. Twovertices uand vare said tobeadjacent ifthere isan
edge whose end vertices are u and v. An edge is said to be incident to a vertex if
the vertex is one of the edge’s endpoints. The outgoing edges of a vertex are the
directed edges whoseorigin isthatvertex. Theincomingedgesofavertexarethe
directed edges whose destination is that vertex. Thedegree of a vertex v, denoted
deg(v), is the number of incident edges of v. The in-degree and out-degree of a
vertex v are the number of the incoming and outgoing edges ofv, and are denoted622 Chapter14. GraphAlgorithms
Example 14.5: WecanstudyairtransportationbyconstructingagraphG,called
aﬂight network,whoseverticesareassociatedwithairports,andwhoseedges
areassociatedwithﬂights. (SeeFigure14.2.) IngraphG,theedgesaredirected
becauseagivenﬂighthasaspeciﬁctraveldirection.Theendpointsofanedgeein
Gcorrespondrespectivelytotheoriginanddestinationoftheﬂightcorresponding
toe. TwoairportsareadjacentinG ifthereisaﬂightthatﬂiesbetweenthem,
andanedgee isincidenttoavertexv inG iftheﬂightfore ﬂiestoorfromthe
airportforv.Theoutgoingedgesofavertexvcorrespondtotheoutboundﬂights
fromv’sairport,andtheincomingedgescorrespondtotheinboundﬂightstov’s
airport. Finally,thein-degreeofavertexv ofG correspondstothenumberof
inboundﬂightstov’sairport,andtheout-degreeofavertexvinGcorrespondsto
thenumberofoutboundﬂights.
SW45 BOS
5
3
W
ORD N
JFK
7
7
SFO UA120 UA8 DL335 A 1387 L247
A 3 D
0
9
DFW A
AA 49 A
LAX
AA523
AA411 MIA
Figure14.2: Example of a directed graph representing a ﬂight network. The end-
points of edge UA 120 are LAX and ORD; hence, LAX and ORD are adjacent.
Thein-degree ofDFWis3,andtheout-degree ofDFWis2.
The deﬁnition of a graph refers to the group of edges as a collection, not a
set, thus allowing twoundirected edges tohavethesameend vertices, andfor two
directed edges to have the same origin and the same destination. Such edges are
calledparalleledgesormultipleedges. Aﬂightnetworkcancontainparalleledges
(Example 14.5), such that multiple edges between the same pair of vertices could
indicate different ﬂights operating on the same route at different times of the day.
Anotherspecialtypeofedgeisonethatconnectsavertextoitself. Namely,wesay
thatanedge (undirected ordirected) isaself-loop ifitstwoendpoints coincide. A
self-loop may occur in a graph associated with a city map (Example 14.3), where
itwouldcorrespond toa“circle”(acurving streetthatreturns toitsstartingpoint).
With few exceptions, graphs do not have parallel edges or self-loops. Such
graphs are said to be simple. Thus, we can usually say that the edges of a simple
graph areasetof vertex pairs (and notjust acollection). Throughout thischapter,14.1. Graphs 623
Apathisasequenceofalternatingverticesandedgesthatstartsatavertexand
ends at a vertex such that each edge is incident to its predecessor and successor
vertex. Acycleisapaththatstartsandendsatthesamevertex,andthatincludesat
leastoneedge. Wesaythatapathissimpleifeachvertexinthepathisdistinct,and
we say that a cycle is simple if each vertex in the cycle is distinct, except for the
ﬁrstandlastone. Adirected pathisapathsuch thatalledges aredirected andare
traversed along theirdirection. Adirected cycleissimilarly deﬁned. Forexample,
inFigure14.2,(BOS,NW35,JFK,AA1387,DFW)isadirectedsimplepath,and
(LAX, UA 120, ORD, UA 877, DFW, AA 49, LAX) is a directed simple cycle.
Notethatadirected graph mayhaveacycleconsisting oftwoedgeswithopposite
direction between the same pair of vertices, for example (ORD, UA 877, DFW,
DL 335, ORD) in Figure 14.2. A directed graph is acyclic if it has no directed
cycles. For example, if we were to remove the edge UA 877 from the graph in
Figure 14.2, the remaining graph isacyclic. Ifagraph issimple, wemay omitthe
edges when describing path P or cycleC, as these are well deﬁned, in which case
Pisalistofadjacent verticesandC isacycleofadjacentvertices.
Example 14.6: GivenagraphGrepresentingacitymap(seeExample14.3),we
canmodelacoupledrivingtodinneratarecommendedrestaurantastraversinga
paththoughG.Iftheyknowtheway,anddonotaccidentallygothroughthesame
intersectiontwice,thentheytraverseasimplepathinG.Likewise,wecanmodel
theentiretripthecoupletakes,fromtheirhometotherestaurantandback,asa
cycle.Iftheygohomefromtherestaurantinacompletelydifferentwaythanhow
theywent,notevengoingthroughthesameintersectiontwice,thentheirentire
roundtripisasimplecycle. Finally,iftheytravelalongone-waystreetsfortheir
entiretrip,wecanmodeltheirnightoutasadirectedcycle.
Given vertices u and v of a (directed) graph G, we say that u reaches v, and
that vis reachable from u, if Ghas a(directed) path fromuto v. In anundirected
graph, thenotionofreachability issymmetric, thatistosay,ureaches vifanonly
ifvreachesu. However,inadirectedgraph,itispossiblethatureachesvbutvdoes
not reach u, because a directed path must be traversed according to the respective
directionsoftheedges. Agraphisconnectedif,foranytwovertices,thereisapath
(cid:4)
between them. A directed graphG is strongly connected iffor any two vertices u
(cid:4)
andvofG,ureachesvandvreaches u. (SeeFigure14.3forsomeexamples.)
AsubgraphofagraphGisagraphH whoseverticesandedgesaresubsetsof
theverticesandedgesofG,respectively. AspanningsubgraphofGisasubgraph
of G that contains all the vertices of the graph G. If a graph G is not connected,
its maximal connected subgraphs are called the connected components of G. A
forest is a graph without cycles. Atree is a connected forest, that is, a connected
graph without cycles. Aspanning treeof a graph is aspanning subgraph that is a
tree. (Notethatthisdeﬁnitionofatreeissomewhatdifferentfromtheonegivenin624 Chapter14. GraphAlgorithms
BOS BOS
ORD ORD
JFK JFK
SFO SFO
DFW DFW
LAX LAX
MIA MIA
(a) (b)
BOS BOS
ORD ORD
JFK JFK
SFO SFO
DFW DFW
LAX LAX
MIA MIA
(c) (d)
Figure14.3: Examples ofreachability inadirected graph: (a)adirectedpathfrom
BOStoLAXishighlighted;(b)adirectedcycle(ORD,MIA,DFW,LAX,ORD)is
highlighted; itsvertices induce astrongly connected subgraph; (c)thesubgraph of
the vertices and edges reachable from ORD is highlighted; (d) the removal of the
dashededgesresultsinanacyclicdirectedgraph.
Example 14.7: PerhapsthemosttalkedaboutgraphtodayistheInternet,which
canbeviewedasagraphwhoseverticesarecomputersandwhose(undirected)
edgesarecommunicationconnectionsbetweenpairsofcomputersontheInter-
net. Thecomputersandtheconnectionsbetweentheminasingledomain,like
wiley.com,formasubgraphoftheInternet.Ifthissubgraphisconnected,thentwo
usersoncomputersinthisdomaincansendemailtooneanotherwithouthaving
theirinformationpacketseverleavetheirdomain. Supposetheedgesofthissub-
graphformaspanningtree. Thisimpliesthat,ifevenasingleconnectiongoes
down(forexample,becausesomeonepullsacommunicationcableoutoftheback14.1. Graphs 625
Inthepropositionsthatfollow,weexploreafewimportantpropertiesofgraphs.
Proposition 14.8: IfGisagraphwithmedgesandvertexsetV,then
∑ deg(v)=2m.
vinV
Justiﬁcation: Anedge (u,v)iscounted twiceinthesummation above; onceby
itsendpoint uand once byitsendpoint v. Thus, thetotal contribution ofthe edges
tothedegreesoftheverticesistwicethenumberofedges.
Proposition 14.9: IfGisadirectedgraphwithmedgesandvertexsetV,then
∑ indeg(v) = ∑ outdeg(v)=m.
vinV vinV
Justiﬁcation: In a directed graph, an edge (u,v) contributes one unit to the
out-degree of its origin u and one unit to the in-degree of its destination v. Thus,
the total contribution of the edges to the out-degrees of thevertices is equal to the
numberofedges,andsimilarlyforthein-degrees.
WenextshowthatasimplegraphwithnverticeshasO(n2)edges.
Proposition 14.10: LetGbeasimplegraphwithnverticesandmedges.IfGis
undirected,thenm≤n(n−1)/2,andifGisdirected,thenm≤n(n−1).
Justiﬁcation: Suppose that G is undirected. Since no two edges can have the
same endpoints and there are no self-loops, the maximum degree of a vertex in G
isn−1 inthis case. Thus, byProposition 14.8, 2m≤n(n−1). Nowsuppose that
G is directed. Since no two edges can have the same origin and destination, and
therearenoself-loops,themaximumin-degreeofavertexinGisn−1inthiscase.
Thus,byProposition 14.9,m≤n(n−1).
Thereareanumberofsimplepropertiesoftrees,forests,andconnectedgraphs.
Proposition 14.11: LetGbeanundirectedgraphwithnverticesandmedges.
• IfGisconnected,thenm≥n−1.
• IfGisatree,thenm=n−1.626 Chapter14. GraphAlgorithms
14.1.1 The Graph ADT
A graph is a collection of vertices and edges. Wemodel the abstraction as a com-
bination of three data types: Vertex, Edge, and Graph. A Vertex is a lightweight
object that stores an arbitrary element provided by the user(e.g., an airport code);
we assume it supports a method, element(), to retrieve the stored element. An
Edge also stores an associated object (e.g., a ﬂight number, travel distance, cost),
retrievedwiththeelement()method. Inaddition,weassumethatanEdgesupports
thefollowingmethods:
endpoints(): Return a tuple (u,v) such that vertex u is the origin of
theedgeandvertexvisthedestination; foranundirected
graph, theorientation isarbitrary.
opposite(v): Assuming vertex v is one endpoint of the edge (either
originordestination), returntheotherendpoint.
TheprimaryabstractionforagraphistheGraphADT.Wepresumethatagraph
canbeeither undirected ordirected, withthedesignation declared upon construc-
tion; recall that a mixed graph can be represented as a directed graph, modeling
edge {u,v} as a pair of directed edges (u,v) and (v,u). The Graph ADT includes
thefollowingmethods:
vertex count(): Returnthenumberofverticesofthegraph.
vertices(): Returnaniteration ofalltheverticesofthegraph.
edge count(): Returnthenumberofedgesofthegraph.
edges(): Returnaniteration ofalltheedgesofthegraph.
get edge(u,v): Return the edge from vertex u to vertex v, if one exists;
otherwise returnNone. Foranundirected graph, thereis
nodifferencebetweenget edge(u,v)andget edge(v,u).
degree(v, out=True): Foranundirectedgraph,returnthenumberofedgesinci-
dent tovertexv. Foradirected graph, return thenumber
of outgoing (resp. incoming) edges incident to vertex v,
asdesignated bytheoptional parameter.
incident edges(v, out=True): Return an iteration of all edges incident to vertex v. In
the case of a directed graph, report outgoing edges by
default; report incoming edges if the optional parameter
issettoFalse.
insert vertex(x=None): CreateandreturnanewVertexstoringelementx.
insert edge(u, v, x=None): Create and return a new Edge from vertex u to vertex v,
storing elementx(Nonebydefault).
remove vertex(v): Removevertexvandallitsincidentedgesfromthegraph.14.2. DataStructuresforGraphs 627
14.2 Data Structures for Graphs
In this section, weintroduce four data structures for representing a graph. In each
representation, wemaintain acollection to store the vertices of agraph. However,
thefourrepresentations differgreatly inthewaytheyorganize theedges.
• In an edge list, we maintain an unordered list of all edges. This minimally
sufﬁces, butthere isnoefﬁcient waytolocate aparticular edge(u,v), orthe
setofalledgesincidenttoavertexv.
• In an adjacency list, wemaintain, for each vertex, a separate list containing
those edges that are incident to the vertex. The complete set of edges can
bedeterminedbytakingtheunionofthesmallersets,whiletheorganization
allowsustomoreefﬁcientlyﬁndalledgesincident toagivenvertex.
• An adjacency map is very similar to an adjacency list, but the secondary
container ofall edges incident to a vertex is organized as amap, rather than
as a list, with the adjacent vertex serving as a key. This allows for access to
aspeciﬁcedge(u,v)inO(1)expected time.
• An adjacency matrix provides worst-case O(1) access to a speciﬁc edge
(u,v) by maintaining an n×n matrix, for a graph with n vertices. Each
entryisdedicatedtostoringareferencetotheedge(u,v)foraparticularpair
ofverticesuandv;ifnosuchedgeexists,theentrywillbeNone.
A summary of the performance of these structures is given in Table 14.1. We
givefurtherexplanation ofthestructures intheremainderofthissection.
Operation Edge List Adj. List Adj. Map Adj. Matrix
vertex count() O(1) O(1) O(1) O(1)
edge count() O(1) O(1) O(1) O(1)
vertices() O(n) O(n) O(n) O(n)
edges() O(m) O(m) O(m) O(m)
get edge(u,v) O(m) O(min(d ,d )) O(1) exp. O(1)
u v
degree(v) O(m) O(1) O(1) O(n)
incident edges(v) O(m) O(d ) O(d ) O(n)
v v
insert vertex(x) O(1) O(1) O(1) O(n2)
remove vertex(v) O(m) O(d ) O(d ) O(n2)
v v
insert edge(u,v,x) O(1) O(1) O(1) exp. O(1)
remove edge(e) O(1) O(1) O(1) exp. O(1)
Table14.1: AsummaryoftherunningtimesforthemethodsofthegraphADT,us-
ingthegraphrepresentations discussed inthissection. Weletndenotethenumber
of vertices, m the number of edges, and d the degree of vertex v. Note that the
v628 Chapter14. GraphAlgorithms
14.2.1 Edge List Structure
The edge list structure is possibly the simplest, though not the most efﬁcient, rep-
resentation of a graph G. All vertex objects are stored in an unordered listV, and
all edge objects are stored in an unordered listE. We illustrate an example of the
edgeliststructure foragraphGinFigure14.4.
V E
u e
u v f
g
e
v w z w g
f h
z h
(a) (b)
Figure14.4: (a) A graph G; (b) schematic representation of the edge list structure
forG. Noticethatanedgeobjectreferstothetwovertexobjectsthatcorrespondto
itsendpoints, butthatverticesdonotrefertoincident edges.
TosupportthemanymethodsoftheGraphADT(Section14.1),weassumethe
followingadditionalfeaturesofanedgelistrepresentation. CollectionsV andE are
represented withdoublylinkedlistsusingourPositionalListclassfromChapter7.
Vertex Objects
Thevertexobjectforavertexvstoring elementxhasinstance variables for:
• Areferencetoelementx,tosupporttheelement()method.
• AreferencetothepositionofthevertexinstanceinthelistV,therebyallow-
ingvtobeefﬁcientlyremovedfromV ifitwereremovedfromthegraph.
Edge Objects
Theedgeobjectforanedgeestoringelementxhasinstance variablesfor:
• Areferencetoelementx,tosupporttheelement()method.
• References to the vertex objects associated with the endpoint vertices of e.
These allow the edge instance toprovide constant-time support for methods
endpoints()andopposite(v).
• Areference totheposition oftheedge instance inlistE,thereby allowing e14.2. DataStructuresforGraphs 629
Performance of the Edge List Structure
TheperformanceofanedgeliststructureinfulﬁllingthegraphADTissummarized
in Table 14.2. We begin by discussing the space usage, which is O(n+m) for
representing a graph with n vertices and m edges. Each individual vertex or edge
instance uses O(1) space, and the additional listsV and E use space proportional
totheirnumberofentries.
Intermsofrunningtime,theedgeliststructure doesaswellasonecouldhope
in terms of reporting the number of vertices or edges, or in producing an iteration
ofthoseverticesoredges. ByqueryingtherespectivelistV orE,thevertex count
andedge countmethodsruninO(1)time,andbyiteratingthroughtheappropriate
list,themethodsverticesandedgesrunrespectively inO(n)andO(m)time.
Themostsigniﬁcantlimitationsofanedgeliststructure, especiallywhencom-
pared to the other graph representations, are the O(m) running times of methods
get edge(u,v), degree(v), and incident edges(v). The problem is that with all
edges of the graph in an unordered list E, the only way to answer those queries
is through an exhaustive inspection of all edges. The other data structures intro-
ducedinthissection willimplementthesemethodsmoreefﬁciently.
Finally, weconsider themethodsthatupdate thegraph. Itiseasytoaddanew
vertex or a new edge to the graph in O(1) time. For example, a new edge can be
added tothe graph bycreating anEdge instance storing thegiven element asdata,
adding that instance to the positional list E, and recording its resulting Position
within E as an attribute of the edge. That stored position can later be used to
locate and remove this edge fromE inO(1) time, and thus implement the method
remove edge(e)
Itisworthdiscussing whytheremove vertex(v)methodhasarunning timeof
O(m). Asstatedinthegraph ADT,whenavertexvisremovedfromthegraph, all
edgesincidenttovmustalsoberemoved(otherwise,wewouldhaveacontradiction
ofedges thatrefertovertices that arenotpartofthegraph). Tolocate theincident
edgestothevertex,wemustexaminealledgesofE.
Operation Running Time
vertex count(), edge count() O(1)
vertices() O(n)
edges() O(m)
get edge(u,v), degree(v), incident edges(v) O(m)
insert vertex(x), insert edge(u,v,x), remove edge(e) O(1)
remove vertex(v) O(m)
Table 14.2: Running times of the methods of a graph implemented with the edge
liststructure. ThespaceusedisO(n+m),wherenisthenumberofverticesandm630 Chapter14. GraphAlgorithms
14.2.2 Adjacency List Structure
In contrast to the edge list representation of a graph, the adjacency list structure
groups the edges of a graph by storing them in smaller, secondary containers that
areassociatedwitheachindividualvertex. Speciﬁcally,foreachvertexv,wemain-
tainacollection I(v), called theincidence collection ofv, whoseentries areedges
incidenttov. (Inthecaseofadirected graph,outgoing andincomingedgescanbe
respectivelystoredintwoseparatecollections,I (v)andI (v).) Traditionally, the
out in
incidence collection I(v) for a vertex v is a list, which is why we call this way of
representing agraphtheadjacencyliststructure.
We require that the primary structure for an adjacency list maintain the col-
lection V of vertices in a way so that we can locate the secondary structure I(v)
for a given vertex v in O(1) time. This could be done by using a positional list
torepresentV, witheachVertexinstance maintaining adirect reference toitsI(v)
incidencecollection;weillustratesuchanadjacencyliststructureofagraphinFig-
ure 14.5. If vertices can be uniquely numbered from 0 ton−1, we could instead
useaprimaryarray-based structure toaccesstheappropriate secondary lists.
Theprimary beneﬁt ofanadjacency lististhat the collection I(v)contains ex-
actlythoseedgesthatshould bereportedbythemethodincident edges(v). There-
fore, we can implement this method by iterating the edges of I(v) in O(deg(v))
time, wheredeg(v) isthe degree of vertexv. Thisis thebest possible outcome for
anygraphrepresentation, becausetherearedeg(v)edgestobereported.
V
u e g
u
e g v e f
v w z
f h w f g h
z h
(a) (b)
Figure14.5: (a) An undirected graph G; (b) a schematic representation of the ad-
jacency list structure for G. CollectionV is the primary list of vertices, and each
vertex has an associated list ofincident edges. Although not diagrammed as such,
wepresumethateachedgeofthegraphisrepresented withauniqueEdgeinstance14.2. DataStructuresforGraphs 631
Performance of the Adjacency List Structure
Table 14.3 summarizes the performance of the adjacency liststructure implemen-
tation ofagraph, assuming that theprimary collectionV andallsecondary collec-
tionsI(v)areimplementedwithdoublylinkedlists.
Asymptotically, the space requirements for an adjacency list are the same as
an edge list structure, using O(n+m) space for a graph with n vertices and m
edges. The primary list of vertices uses O(n) space. The sum of the lengths of
all secondary lists is O(m), for reasons that were formalized in Propositions 14.8
and14.9. Inshort,anundirected edge(u,v)isreferencedinbothI(u)andI(v),but
itspresenceinthegraphresultsinonlyaconstant amountofadditional space.
We have already noted that the incident edges(v) method can be achieved in
O(deg(v)) time based on use of I(v). We can achieve the degree(v) method of
the graph ADT to use O(1) time, assuming collection I(v) can report its size in
similar time. To locate a speciﬁc edge for implementing get edge(u,v), we can
search through either I(u) and I(v). By choosing the smaller of the two, we get
O(min(deg(u),deg(v)))runningtime.
The rest of the bounds in Table 14.3 can be achieved with additional care. To
efﬁciently support deletions ofedges, anedge(u,v) would need tomaintain aref-
erence to its positions within both I(u) and I(v), so that it could be deleted from
those collections in O(1) time. To remove a vertex v, we must also remove any
incident edges,butatleastwecanlocatethoseedgesinO(deg(v))time.
The easiest way to support edges() in O(m) and count edges() in O(1) is to
maintain anauxiliary listE ofedges, asintheedge listrepresentation. Otherwise,
wecanimplementtheedgesmethodinO(n+m)timebyaccessingeachsecondary
listandreportingitsedges,takingcarenottoreportanundirectededge(u,v)twice.
Operation Running Time
vertex count(), edge count() O(1)
vertices() O(n)
edges() O(m)
get edge(u,v) O(min(deg(u),deg(v)))
degree(v) O(1)
incident edges(v) O(deg(v))
insert vertex(x), insert edge(u,v,x) O(1)
remove edge(e) O(1)
remove vertex(v) O(deg(v))
Table 14.3: Running times of the methods of a graph implemented with the adja-
cencyliststructure. ThespaceusedisO(n+m),wherenisthenumberofvertices632 Chapter14. GraphAlgorithms
14.2.3 Adjacency Map Structure
Intheadjacency liststructure, weassume thatthe secondary incidence collections
are implemented as unordered linked lists. Such a collection I(v) uses space pro-
portional to O(deg(v)), allows an edge to be added or removed inO(1) time, and
allows an iteration of all edges incident to vertex v in O(deg(v)) time. However,
the best implementation of get edge(u,v) requires O(min(deg(u),deg(v))) time,
becausewemustsearchthrougheitherI(u)orI(v).
Wecanimprovetheperformancebyusingahash-basedmaptoimplementI(v)
for each vertex v. Speciﬁcally, we let the opposite endpoint of each incident edge
serveasakeyinthemap,withtheedgestructureservingasthevalue. Wecallsuch
a graph representation anadjacency map. (See Figure 14.6.) Thespace usage for
an adjacency map remains O(n+m), because I(v) uses O(deg(v)) space for each
vertexv,aswiththeadjacencylist.
The advantage of the adjacency map, relative to an adjacency list, is that the
get edge(u,v)methodcanbeimplementedinexpectedO(1)timebysearchingfor
vertexuasakeyinI(v),orviceversa. Thisprovidesalikelyimprovementoverthe
adjacency list,whileretaining theworst-caseboundofO(min(deg(u),deg(v))).
In comparing the performance of adjacency map to other representations (see
Table14.1),weﬁndthatitessentially achievesoptimalrunningtimesforallmeth-
ods,makingitanexcellent all-purpose choiceasagraphrepresentation.
V
v w
u
e g
u w
u v
e f
g
e
u v z
v w z w
f h g f h
w
z
h
(a) (b)
Figure14.6: (a) An undirected graph G; (b) a schematic representation of the ad-
jacency map structure for G. Each vertex maintains a secondary map in which
neighboring verticesserveaskeys,withtheconnecting edgesasassociated values.
Althoughnotdiagrammedassuch,wepresumethatthereisauniqueEdgeinstance14.2. DataStructuresforGraphs 633
14.2.4 Adjacency Matrix Structure
TheadjacencymatrixstructureforagraphGaugmentstheedgeliststructurewith
amatrix A(that is, atwo-dimensional array, asinSection 5.6), whichallows usto
locate anedge between agivenpair ofvertices inworst-case constant time. Inthe
adjacency matrix representation, we think of the vertices as being the integers in
the set {0,1,...,n−1} and the edges as being pairs of such integers. This allows
us to store references to edges in the cells of a two-dimensional n×n array A.
Speciﬁcally, thecellA[i,j]holds areference totheedge(u,v), ifitexists, whereu
isthevertex withindexiandvisthe vertexwithindex j. Ifthere isnosuch edge,
thenA[i,j]=None. WenotethatarrayAissymmetricifgraphGisundirected, as
A[i,j]=A[j,i]forallpairsiand j. (SeeFigure14.7.)
The most signiﬁcant advantage of an adjacency matrix is that any edge (u,v)
can be accessed in worst-case O(1) time; recall that the adjacency map supports
that operation inO(1) expected time. However, several operation areless efﬁcient
with an adjacency matrix. For example, to ﬁnd the edges incident to vertex v, we
must presumably examine all n entries in the row associated withv; recall that an
adjacencylistormapcanlocatethoseedgesinoptimalO(deg(v))time. Addingor
removingverticesfromagraphisproblematic, asthematrixmustberesized.
Furthermore, the O(n2) space usage of an adjacency matrix is typically far
worse than the O(n+m) space required of the other representations. Although,
in the worst case, the number of edges in a dense graph will be proportional to
n2, most real-world graphs are sparse. In such cases, use of an adjacency matrix
is inefﬁcient. However, if a graph is dense, the constants of proportionality of an
adjacency matrix can be smaller than that of an adjacency list or map. In fact, if
edges do not have auxiliary data, a Boolean adjacency matrixcan use one bit per
edgeslot,suchthatA[i,j]=Trueifandonlyifassociated(u,v)isanedge.
0 1 2 3
u u 0 e g
e g v 1 e f
w 2 g f h
v w z
f h z 3 h
(a) (b)
Figure14.7: (a) Anundirected graphG; (b) aschematic representation of theaux-
iliaryadjacencymatrixstructureforG,inwhichnverticesaremappedtoindices0
ton−1. Althoughnotdiagrammedassuch,wepresumethatthereisauniqueEdge
instanceforeachedge,andthatitmaintainsreferencestoitsendpointvertices. We
also assume that there is asecondary edge list (not pictured), to allow theedges()634 Chapter14. GraphAlgorithms
14.2.5 Python Implementation
Inthissection,weprovideanimplementationoftheGraphADT.Ourimplementa-
tionwillsupportdirectedorundirected graphs,butforeaseofexplanation, weﬁrst
describe itinthecontextofanundirected graph.
We use a variant of the adjacency map representation. For each vertex v, we
use a Python dictionary to represent the secondary incidence map I(v). However,
wedonotexplicitly maintain listsV andE,asoriginally described intheedge list
representation. The listV is replaced by a top-level dictionary D that maps each
vertex v to its incidence map I(v); note that we can iterate through all vertices by
generating the set of keys for dictionary D. By using such a dictionary D to map
verticestothesecondaryincidencemaps,weneednotmaintainreferencestothose
incidence maps as part of the vertex structures. Also, a vertex does not need to
explicitly maintain a reference to its position in D, because it can be determined
in O(1) expected time. This greatly simpliﬁes our implementation. However, a
consequence of our design isthat someof the worst-case running timebounds for
the graph ADT operations, given in Table 14.1, become expected bounds. Rather
thanmaintainlistE,wearecontentwithtakingtheunionoftheedgesfoundinthe
various incidence maps; technically, thisruns inO(n+m)timerather thanstrictly
O(m)time,asthedictionaryDhasnkeys,evenifsomeincidencemapsareempty.
OurimplementationofthegraphADTisgiveninCodeFragments14.1through
14.3. Classes Vertex and Edge, given in Code Fragment 14.1, are rather simple,
and can be nested within the more complex Graph class. Note that we deﬁne the
hash method forbothVertexandEdgesothat thoseinstances canbeusedas
keys in Python’s hash-based sets and dictionaries. The rest of the Graph class is
giveninCodeFragments 14.2and14.3. Graphsareundirectedbydefault, but can
bedeclaredasdirectedwithanoptional parametertotheconstructor.
Internally,wemanagethedirectedcasebyhavingtwodifferenttop-leveldictio-
nary instances, outgoing and incoming, such that outgoing[v] maps to another
dictionaryrepresentingI (v),and incoming[v]mapstoarepresentation ofI (v).
out in
In order to unify our treatment of directed and undirected graphs, we continue to
use the outgoing and incoming identiﬁers in the undirected case, yet as aliases
to the same dictionary. For convenience, we deﬁne a utility named is directed to
allowustodistinguish betweenthetwocases.
Formethodsdegreeandincident edges,whicheachacceptanoptionalparam-
etertodifferentiatebetweentheoutgoingandincomingorientations,wechoosethe
appropriate map before proceeding. For method insert vertex, we always initial-
ize outgoing[v] to an empty dictionary for new vertex v. In the directed case, we
independently initialize incoming[v]as well. Forthe undirected case, that step is
unnecessaryas outgoingand incomingarealiases. Weleavetheimplementations14.2. DataStructuresforGraphs 635
1 #------------------------- nested Vertex class -------------------------
2 class Vertex:
3 ”””Lightweight vertex structure for a graph.”””
4 slots = _element
5
6 def init (self, x):
7 ”””Do not call constructor directly. Use Graphs insert vertex(x).”””
8 self. element = x
9
10 def element(self):
11 ”””Return element associated with this vertex.”””
12 return self. element
13
14 def hash (self): # will allow vertex to be a map/set key
15 return hash(id(self))
16
17 #------------------------- nested Edge class -------------------------
18 class Edge:
19 ”””Lightweight edge structure for a graph.”””
20 slots = _origin , _destination , _element
21
22 def init (self, u, v, x):
23 ”””Do not call constructor directly. Use Graphs insert edge(u,v,x).”””
24 self. origin = u
25 self. destination = v
26 self. element = x
27
28 def endpoints(self):
29 ”””Return (u,v) tuple for vertices u and v.”””
30 return (self. origin, self. destination)
31
32 def opposite(self, v):
33 ”””Return the vertex that is opposite v on this edge.”””
34 return self. destination if v is self. origin else self. origin
35
36 def element(self):
37 ”””Return element associated with this edge.”””
38 return self. element
39
40 def hash (self): # will allow edge to be a map/set key
41 return hash( (self. origin, self. destination) )636 Chapter14. GraphAlgorithms
1 class Graph:
2 ”””Representation of a simple graph using an adjacency map.”””
3
4 def init (self, directed=False):
5 ”””Create an empty graph (undirected, by default).
6
7 Graph is directed if optional paramter is set to True.
8 ”””
9 self. outgoing = { }
10 # only create second map for directed graph; use alias for undirected
11 self. incoming = { }if directed else self. outgoing
12
13 def is directed(self):
14 ”””Return True if this is a directed graph; False if undirected.
15
16 Property is based on the original declaration of the graph, not its contents.
17 ”””
18 return self. incoming is not self. outgoing # directed if maps are distinct
19
20 def vertex count(self):
21 ”””Return the number of vertices in the graph.”””
22 return len(self. outgoing)
23
24 def vertices(self):
25 ”””Return an iteration of all vertices of the graph.”””
26 return self. outgoing.keys()
27
28 def edge count(self):
29 ”””Return the number of edges in the graph.”””
30 total = sum(len(self. outgoing[v]) for v in self. outgoing)
31 # for undirected graphs, make sure not to double-count edges
32 return total if self.is directed( ) else total // 2
33
34 def edges(self):
35 ”””Return a set of all edges of the graph.”””
36 result = set( ) # avoid double-reporting edges of undirected graph
37 for secondary map in self. outgoing.values():
38 result.update(secondary map.values()) # add edges to resulting set
39 return result14.2. DataStructuresforGraphs 637
40 def get edge(self, u, v):
41 ”””Return the edge from u to v, or None if not adjacent.”””
42 return self. outgoing[u].get(v) # returns None if v not adjacent
43
44 def degree(self, v, outgoing=True):
45 ”””Return number of (outgoing) edges incident to vertex v in the graph.
46
47 If graph is directed, optional parameter used to count incoming edges.
48 ”””
49 adj = self. outgoing if outgoing else self. incoming
50 return len(adj[v])
51
52 def incident edges(self, v, outgoing=True):
53 ”””Return all (outgoing) edges incident to vertex v in the graph.
54
55 If graph is directed, optional parameter used to request incoming edges.
56 ”””
57 adj = self. outgoing if outgoing else self. incoming
58 for edge in adj[v].values():
59 yield edge
60
61 def insert vertex(self, x=None):
62 ”””Insert and return a new Vertex with element x.”””
63 v = self.Vertex(x)
64 self. outgoing[v] = { }
65 if self.is directed():
66 self. incoming[v] = { } # need distinct map for incoming edges
67 return v
68
69 def insert edge(self, u, v, x=None):
70 ”””Insert and return a new Edge from u to v with auxiliary element x.”””
71 e = self.Edge(u, v, x)
72 self. outgoing[u][v] = e
73 self. incoming[v][u] = e
CodeFragment14.3:Graphclassdeﬁnition(continued fromCodeFragment14.2).638 Chapter14. GraphAlgorithms
14.3 Graph Traversals
Greek mythology tells of an elaborate labyrinth that was built to house the mon-
strousMinotaur, whichwaspartbullandpartman. Thislabyrinth wassocomplex
that neither beast nor human could escape it. No human, that is, until the Greek
hero,Theseus,withthehelpoftheking’sdaughter, Ariadne,decidedtoimplement
a graph traversal algorithm. Theseus fastened a ball of thread to the door of the
labyrinth and unwound it as he traversed the twisting passages in search of the
monster. Theseus obviously knew about good algorithm design, for, after ﬁnding
anddefeatingthebeast,Theseuseasilyfollowedthestringbackoutofthelabyrinth
tothelovingarmsofAriadne.
Formally,atraversal isasystematic procedure forexploring agraphbyexam-
ining allof itsvertices and edges. A traversal is efﬁcient ifitvisits all the vertices
andedgesintimeproportional totheirnumber,thatis,inlineartime.
Graph traversal algorithms are key to answering many fundamental questions
about graphs involving the notion of reachability, that is, in determining how to
travel from one vertex to another while following paths of a graph. Interesting
problemsthatdealwithreachabilityinanundirectedgraphGincludethefollowing:
• Computing a path from vertex u to vertex v, or reporting that no such path
exists.
• Given a start vertex s of G, computing, for every vertex v of G, a path with
the minimum number of edges between s and v, or reporting that no such
pathexists.
• TestingwhetherGisconnected.
• Computingaspanning treeofG,ifGisconnected.
• Computingtheconnected components ofG.
• ComputingacycleinG,orreporting thatGhasnocycles.
(cid:4)
Interesting problems that deal with reachability in a directed graph G include the
following:
• Computingadirectedpathfromvertexutovertexv,orreportingthatnosuch
pathexists.
• FindingalltheverticesofG(cid:4) thatarereachable fromagivenvertexs.
• DeterminewhetherG(cid:4) isacyclic.
• DeterminewhetherG(cid:4) isstrongly connected.
In the remainder of this section, we present two efﬁcient graph traversal algo-14.3. GraphTraversals 639
14.3.1 Depth-First Search
Theﬁrsttraversalalgorithmweconsiderinthissectionisdepth-ﬁrstsearch(DFS).
Depth-ﬁrst search is useful for testing anumber of properties of graphs, including
whether there is a path from one vertex to another and whether or not a graph is
connected.
Depth-ﬁrst search in a graph G is analogous to wandering in a labyrinth with
a string and a can of paint without getting lost. We begin at a speciﬁc starting
vertex sin G, which weinitialize by ﬁxing one end of our string tosand painting
sas “visited.” The vertexsisnow our “current” vertex—call our current vertexu.
WethentraverseGbyconsidering an(arbitrary) edge(u,v)incident tothecurrent
vertex u. If the edge (u,v) leads us to a vertex v that is already visited (that is,
painted), we ignore that edge. If, on the other hand, (u,v) leads to an unvisited
vertex v, then we unroll our string, and go to v. We then paint v as “visited,” and
makeitthecurrentvertex,repeatingthecomputationabove. Eventually,wewillget
toa“dead end,” that is, acurrent vertexvsuch thatall theedges incident tovlead
to vertices already visited. To get out of this impasse, we roll our string back up,
backtracking alongtheedgethatbroughtustov,goingbacktoapreviouslyvisited
vertex u. Wethen makeuourcurrent vertexand repeat the computation above for
anyedgesincidenttouthatwehavenotyetconsidered. Ifallofu’sincidentedges
leadtovisitedvertices,thenweagainrollupourstringandbacktrack tothevertex
wecamefromtogettou,andrepeattheprocedureatthatvertex. Thus,wecontinue
tobacktrackalongthepaththatwehavetracedsofaruntilweﬁndavertexthathas
yet unexplored edges, take one such edge, and continue the traversal. Theprocess
terminates whenour backtracking leads us back to the start vertex s, and there are
nomoreunexplored edgesincident tos.
The pseudo-code for a depth-ﬁrst search traversal starting at a vertex u (see
Code Fragment 14.4) follows our analogy with string and paint. Weuse recursion
to implement the string analogy, and we assume that we have a mechanism (the
paintanalogy)todeterminewhetheravertexoredgehasbeenpreviouslyexplored.
AlgorithmDFS(G,u): {Weassumeuhasalreadybeenmarkedasvisited}
Input: AgraphGandavertexuofG
Output: Acollection ofverticesreachable fromu,withtheirdiscovery edges
foreachoutgoing edgee=(u,v)ofudo
ifvertexvhasnotbeenvisited then
Markvertexvasvisited(viaedgee).
Recursively callDFS(G,v).640 Chapter14. GraphAlgorithms
Classifying Graph Edges with DFS
Anexecution of depth-ﬁrst search can be used to analyze the structure of agraph,
based upon the way in which edges are explored during the traversal. The DFS
process naturally identiﬁes what is known as the depth-ﬁrst search tree rooted at
astarting vertexs. Whenever anedgee=(u,v) isused todiscover anew vertexv
duringtheDFSalgorithmofCodeFragment14.4,thatedgeisknownasadiscovery
edgeortreeedge,asorientedfromutov. Allotheredgesthatareconsideredduring
the execution of DFS are known as nontree edges, which take us to a previously
visitedvertex. Inthecaseofanundirectedgraph,wewillﬁndthatallnontreeedges
that are explored connect the current vertex to one that is an ancestor of it in the
DFS tree. We will call such an edge a back edge. When performing a DFS on a
directed graph,therearethreepossiblekindsofnontreeedges:
• backedges,whichconnect avertextoanancestor intheDFStree
• forwardedges, whichconnectavertextoadescendant intheDFStree
• crossedges,whichconnectavertextoavertexthatisneitheritsancestornor
itsdescendant.
An example application of the DFSalgorithm on a directed graph is shown in
Figure 14.8, demonstrating each type of nontree edge. An example application of
theDFSalgorithm onanundirected graphisshowninFigure14.9.
1
BOS
BOS
ORD ORD 5
JFK
JFK 7 2
SFO
SFO
DFW
DFW
LAX
LAX 3
4
MIA
MIA 6
(a) (b)
Figure 14.8: An example of a DFS in a directed graph, starting at vertex (BOS):
(a) intermediate step, where, for the ﬁrst time, a considered edge leads to an al-
ready visited vertex (DFW); (b) the completed DFS. The tree edges are shown
with thick lines, the back edges are shown with dashed lines,and the forward and
cross edges are shown with dotted lines. The order in which the vertices are vis-
ited is indicated by a label next to each vertex. The edge (ORD,DFW) is a back
edge, but(DFW,ORD)isaforward edge. Edge(BOS,SFO)isaforward edge, and14.3. GraphTraversals 641
A B C D A B C D
E F G H E F G H
I J K L I J K L
M N O P M N O P
(a) (b)
A B C D A B C D
E F G H E F G H
I J K L I J K L
M N O P M N O P
(c) (d)
A B C D A B C D
E F G H E F G H
I J K L I J K L
M N O P M N O P
(e) (f)
Figure14.9: Exampleofdepth-ﬁrstsearchtraversalonanundirectedgraphstarting
at vertex A. We assume that a vertex’s adjacencies are considered in alphabetical
order. Visited vertices and explored edges are highlighted, with discovery edges
drawn as solid lines and nontree (back) edges as dashed lines: (a) input graph;
(b)pathoftreeedges, tracedfromAuntilbackedge(G,C)isexamined; (c)reach-
ing F, which is a dead end; (d) after backtracking to I, resuming with edge (I,M),
andhittinganotherdeadendatO;(e)afterbacktrackingtoG,continuingwithedge642 Chapter14. GraphAlgorithms
Properties of a Depth-First Search
There are a number of observations that we can make about the depth-ﬁrst search
algorithm, many of which derive from the way the DFS algorithm partitions the
edgesofagraphGintogroups. Webeginwiththemostsigniﬁcantproperty.
Proposition 14.12: LetGbeanundirectedgraphonwhichaDFStraversalstart-
ingatavertexs hasbeenperformed. Thenthetraversalvisitsallverticesinthe
connectedcomponentofs,andthediscoveryedgesformaspanningtreeofthe
connectedcomponentofs.
Justiﬁcation: Supposethereisatleastonevertexwins’sconnectedcomponent
notvisited,andletvbetheﬁrstunvisitedvertexonsomepathfromstow(wemay
have v=w). Since v is the ﬁrst unvisited vertex on this path, it has a neighbor u
that was visited. But when wevisited u, we must have considered the edge (u,v);
hence, it cannot be correct that v is unvisited. Therefore, there are no unvisited
verticesins’sconnected component.
Since weonly follow a discovery edge when wego to an unvisited vertex, we
will never form a cycle with such edges. Therefore, the discovery edges form a
connected subgraph without cycles, hence a tree. Moreover, this is a spanning
tree because, as we have just seen, the depth-ﬁrst search visits each vertex in the
connected component ofs.
(cid:4) (cid:4)
Proposition 14.13: LetGbeadirectedgraph.Depth-ﬁrstsearchonGstartingat
(cid:4)
avertexsvisitsalltheverticesofGthatarereachablefroms.Also,theDFStree
containsdirectedpathsfromstoeveryvertexreachablefroms.
(cid:4)
Justiﬁcation: Let V be the subset of vertices of G visited by DFS starting at
s
vertex s. We want to show that V contains s and every vertex reachable from s
s
belongstoV . Supposenow,forthesakeofacontradiction, thatthereisavertexw
s
reachablefromsthatisnotinV . Consideradirectedpathfromstow,andlet(u,v)
s
be the ﬁrst edge on such a path taking us out ofV , that is, u is inV but v is not
s s
inV . When DFSreaches u, itexplores all the outgoing edges ofu, and thus must
s
reachalsovertexvviaedge (u,v). Hence,vshould beinV ,andwehaveobtained
s
acontradiction. Therefore,V mustcontain everyvertexreachable froms.
s
Weprovethesecond factbyinduction onthesteps ofthealgorithm. Weclaim
thateachtimeadiscoveryedge(u,v)isidentiﬁed,thereexistsadirectedpathfrom
s to v in the DFS tree. Since u must have previously been discovered, there exists
apath fromstou,sobyappending theedge(u,v)tothat path, wehave adirected
pathfromstov.
Note that since back edges always connect a vertex v to a previously visited
vertex u, each back edge implies a cycle in G, consisting of the discovery edges14.3. GraphTraversals 643
Running Time of Depth-First Search
Intermsofitsrunning time,depth-ﬁrst search isanefﬁcientmethodfortraversing
agraph. Notethat DFSiscalled atmostonce oneachvertex(since itgetsmarked
as visited), and therefore every edge is examined at most twice for an undirected
graph, once from each of its end vertices, and at most once in a directed graph,
from its origin vertex. If we let n ≤n be the number of vertices reachable from
s
a vertex s, and m ≤m be the number of incident edges to those vertices, a DFS
s
startingatsrunsinO(n +m )time,providedthefollowingconditionsaresatisﬁed:
s s
• The graph is represented by a data structure such that creating and iterating
through the incident edges(v) takes O(deg(v)) time, and the e.opposite(v)
method takes O(1) time. The adjacency list structure is one such structure,
buttheadjacency matrixstructure isnot.
• Wehaveawayto“mark”avertexoredgeasexplored, andtotestifavertex
or edge has been explored in O(1) time. We discuss ways of implementing
DFStoachievethisgoalinthenextsection.
Giventheassumptions above,wecansolveanumberofinteresting problems.
Proposition 14.14: LetGbeanundirectedgraphwithnverticesandmedges.A
DFStraversalofGcanbeperformedinO(n+m)time,andcanbeusedtosolve
thefollowingproblemsinO(n+m)time:
• ComputingapathbetweentwogivenverticesofG,ifoneexists.
• TestingwhetherGisconnected.
• ComputingaspanningtreeofG,ifGisconnected.
• ComputingtheconnectedcomponentsofG.
• ComputingacycleinG,orreportingthatGhasnocycles.
(cid:4)
Proposition 14.15: LetG beadirectedgraphwithn verticesandm edges. A
DFStraversalofG(cid:4) canbeperformedinO(n+m)time,andcanbeusedtosolve
thefollowingproblemsinO(n+m)time:
• ComputingadirectedpathbetweentwogivenverticesofG(cid:4),ifoneexists.
• ComputingthesetofverticesofG(cid:4) thatarereachablefromagivenvertexs.
• TestingwhetherG(cid:4) isstronglyconnected.
• ComputingadirectedcycleinG(cid:4),orreportingthatG(cid:4) isacyclic.
• Computingthetransitive closureofG(cid:4) (seeSection14.4).
The justiﬁcation of Propositions 14.14 and 14.15 is based on algorithms that
useslightlymodiﬁedversionsoftheDFSalgorithmassubroutines. Wewillexplore644 Chapter14. GraphAlgorithms
14.3.2 DFS Implementation and Extensions
We begin by providing a Python implementation of the basic depth-ﬁrst search
algorithm,originallydescribedwithpseudo-codeinCodeFragment14.4. OurDFS
function ispresented inCodeFragment14.5.
1 def DFS(g, u, discovered):
2 ”””Perform DFS of the undiscovered portion of Graph g starting at Vertex u.
3
4 discovered is a dictionary mapping each vertex to the edge that was used to
5 discover it during the DFS. (u should be ”discovered” prior to the call.)
6 Newly discovered vertices will be added to the dictionary as a result.
7 ”””
8 for e in g.incident edges(u): # for every outgoing edge from u
9 v = e.opposite(u)
10 if v not in discovered: # v is an unvisited vertex
11 discovered[v] = e # e is the tree edge that discovered v
12 DFS(g, v, discovered) # recursively explore from v
Code Fragment 14.5: Recursive implementation of depth-ﬁrst search on a graph,
startingatadesignated vertexu.
Inordertotrackwhichverticeshavebeenvisited,andtobuildarepresentation
oftheresulting DFStree, ourimplementation introduces athirdparameter, named
discovered. ThisparametershouldbeaPythondictionarythatmapsavertexofthe
graph to the tree edge that was used to discover that vertex. As a technicality, we
assume that the source vertexu occurs as a key of the dictionary, withNone as its
value. Thus,acallermightstartthetraversalasfollows:
result = {u : None} # a new dictionary, with u trivially discovered
DFS(g, u, result)
The dictionary serves two purposes. Internally, the dictionary provides a mecha-
nism for recognizing visited vertices, asthey willappear as keys inthe dictionary.
Externally, theDFS function augments this dictionary as it proceeds, and thus the
valueswithinthedictionaryaretheDFStreeedgesattheconclusionoftheprocess.
Because the dictionary is hash-based, the test, “if v not in discovered,” and
the record-keeping step, “discovered[v] = e,” run in O(1) expected time, rather
than worst-case time. In practice, this is a compromise we are willing to accept,
butitdoesviolatetheformalanalysisofthealgorithm,asgivenonpage643. Ifwe
couldassumethatverticescouldbenumbered from0ton−1,thenthosenumbers
could beused asindices into an array-based lookup table rather than ahash-based
map. Alternatively, we could store each vertex’s discovery status and associated14.3. GraphTraversals 645
Reconstructing a Path from u to v
We can use the basic DFS function as a tool to identify the (directed) path lead-
ing from vertex u to v, if v is reachable from u. This path can easily be recon-
structed fromtheinformation thatwasrecorded inthediscovery dictionary during
thetraversal. CodeFragment14.6providesanimplementationofasecondaryfunc-
tionthatproduces anorderedlistofvertices onthepathfromutov.
Toreconstructthepath,webeginattheendofthepath,examiningthediscovery
dictionary to determine what edge was used to reach vertex v, and then what the
other endpoint of that edge is. We add that vertex to a list, and then repeat the
process to determine what edge was used to discover it. Once we have traced the
path all the way back to the starting vertex u, we can reverse the list so that it is
properly oriented from u to v, and return it to the caller. This process takes time
proportionaltothelengthofthepath,andthereforeitrunsinO(n)time(inaddition
tothetimeoriginally spentcallingDFS).
1 def construct path(u, v, discovered):
2 path = [ ] # empty path by default
3 if v in discovered:
4 # we build list from v to u and then reverse it at the end
5 path.append(v)
6 walk = v
7 while walk is not u:
8 e = discovered[walk] # ﬁnd edge leading to walk
9 parent = e.opposite(walk)
10 path.append(parent)
11 walk = parent
12 path.reverse( ) # reorient path from u to v
13 return path
CodeFragment14.6: Function toreconstruct adirected pathfromutov, giventhe
trace of discovery from a DFSstarted atu. The function returns an ordered list of
verticesonthepath.
Testing for Connectivity
Wecan use the basic DFSfunction to determine whether agraph isconnected. In
thecase ofanundirected graph, wesimply startadepth-ﬁrstsearch atanarbitrary
vertexandthentestwhetherlen(discovered)equalsnattheconclusion. Ifthegraph
is connected, then by Proposition 14.12, all vertices will have been discovered;
conversely, ifthegraph isnotconnected, there mustbeatleastonevertexvthatis646 Chapter14. GraphAlgorithms
(cid:4)
Fordirectedgraph,G,wemaywishtotestwhetheritisstronglyconnected,that
is,whetherforeverypairofverticesuandv,bothureachesvandvreachesu. Ifwe
startanindependentcalltoDFSfromeachvertex,wecoulddeterminewhetherthis
wasthecase,butthosencallswhencombinedwouldruninO(n(n+m)). However,
(cid:4)
we can determine if G is strongly connected much faster than this, requiring only
twodepth-ﬁrst searches.
(cid:4)
Webeginbyperforming adepth-ﬁrst searchofourdirected graphGstartingat
(cid:4)
anarbitrary vertexs. IfthereisanyvertexofGthatisnotvisited bythistraversal,
and is not reachable from s, then the graph is not strongly connected. If this ﬁrst
(cid:4)
depth-ﬁrstsearchvisitseachvertexofG,weneedtothencheckwhethersisreach-
able from all other vertices. Conceptually, we can accomplish this by making a
(cid:4)
copyofgraphG,butwiththeorientationofalledgesreversed. Adepth-ﬁrstsearch
starting at s in the reversed graph will reach every vertex that could reach s in the
original. Inpractice, abetterapproach thanmaking anewgraphistoreimplement
a version of the DFS method that loops through all incoming edges to the current
vertex, rather than all outgoing edges. Since this algorithm makes just two DFS
traversals ofG(cid:4),itrunsinO(n+m)time.
Computing all Connected Components
When agraph isnot connected, the next goal wemayhave is toidentify allof the
connected componentsof an undirected graph, orthe strongly connected compo-
nentsofadirected graph. Webeginbydiscussing theundirected case.
If an initial call to DFS fails to reach all vertices of a graph, we can restart a
new call to DFS at one of those unvisited vertices. An implementation of such a
comprehensiveDFS allmethodisgiveninCodeFragment14.7.
1 def DFS complete(g):
2 ”””Perform DFS for entire graph and return forest as a dictionary.
3
4 Result maps each vertex v to the edge that was used to discover it.
5 (Vertices that are roots of a DFS tree are mapped to None.)
6 ”””
7 forest = { }
8 for u in g.vertices():
9 if u not in forest:
10 forest[u] = None # u will be the root of a tree
11 DFS(g, u, forest)
12 return forest
Code Fragment 14.7: Top-level function that returns a DFS forest for an entire14.3. GraphTraversals 647
AlthoughtheDFS completefunctionmakesmultiplecallstotheoriginalDFS
function, thetotaltimespent byacalltoDFS completeisO(n+m). Foranundi-
rected graph, recall from our original analysis on page 643 that a single call to
DFSstarting atvertexsrunsintimeO(n +m )wheren isthenumberofvertices
s s s
reachablefroms,andm isthenumberofincidentedgestothosevertices. Because
s
eachcalltoDFSexploresadifferentcomponent,thesumofn +m termsisn+m.
s s
TheO(n+m)totalboundappliestothedirectedcaseaswell,eventhoughthesets
of reachable vertices are not necessarily disjoint. However, because the same dis-
covery dictionary ispassed asaparameter toallDFScalls, weknow that theDFS
subroutine is called once on each vertex, and then each outgoing edge is explored
onlyonceduringtheprocess.
TheDFS completefunctioncanbeusedtoanalyzetheconnected components
ofanundirectedgraph. Thediscoverydictionary itreturnsrepresentsaDFSforest
fortheentiregraph. Wesaythisisaforestratherthanatree,becausethegraphmay
notbeconnected. Thenumberofconnected components canbedetermined bythe
number of vertices in the discovery dictionary that have None as their discovery
edge(thosearerootsofDFStrees). Aminormodiﬁcation tothecoreDFSmethod
could be used to tag each vertex with a component number when it is discovered.
(SeeExerciseC-14.44.)
The situation is more complex for ﬁnding strongly connected components of
a directed graph. There exists an approach for computing those components in
O(n+m) time, making use of two separate depth-ﬁrst search traversals, but the
detailsarebeyondthescopeofthisbook.
Detecting Cycles with DFS
For both undirected and directed graphs, a cycle exists if and only if a back edge
existsrelativetotheDFStraversalofthatgraph. Itiseasytoseethatifabackedge
exists, a cycle exists by taking the back edge from the descendant to its ancestor
and then following the tree edges back to the descendant. Conversely, if a cycle
existsinthegraph,theremustbeabackedgerelativetoaDFS(althoughwedonot
provethisfacthere).
Algorithmically, detecting a back edge in the undirected case is easy, because
all edges are either tree edges or back edges. In the case of a directed graph, ad-
ditional modiﬁcations tothecore DFSimplementation areneeded toproperly cat-
egorize a nontree edge as a back edge. When a directed edge is explored leading
toapreviouslyvisitedvertex,wemustrecognizewhetherthatvertexisanancestor
ofthe current vertex. Thisrequires someadditional bookkeeping, for example, by
tagging verticesuponwhicharecursivecalltoDFSisstillactive. Weleavedetails648 Chapter14. GraphAlgorithms
14.3.3 Breadth-First Search
The advancing and backtracking of a depth-ﬁrst search, as described in the previ-
ous section, deﬁnes a traversal that could be physically traced by a single person
exploring a graph. In this section, we consider another algorithm for traversing
a connected component of a graph, known as a breadth-ﬁrst search (BFS). The
BFS algorithm is more akin to sending out, in all directions, many explorers who
collectively traverse agraphincoordinated fashion.
A BFS proceeds in rounds and subdivides the vertices into levels. BFS starts
atvertex s, whichisatlevel0. Intheﬁrstround, wepaint as“visited,”all vertices
adjacent tothestartvertexs—these vertices areonestepawayfrom thebeginning
and are placed into level 1. In the second round, we allow all explorers to go
two steps (i.e., edges) away from the starting vertex. These new vertices, which
are adjacent to level 1 vertices and not previously assigned to a level, are placed
into level 2 and marked as “visited.” This process continues in similar fashion,
terminating whennonewverticesarefoundinalevel.
A Python implementation of BFS is given in Code Fragment 14.8. We follow
aconvention similartothatofDFS(CodeFragment14.5), using adiscovereddic-
tionary both to recognize visited vertices, and torecord the discovery edges ofthe
BFStree. Weillustrate aBFStraversalinFigure14.10.
1 def BFS(g, s, discovered):
2 ”””Perform BFS of the undiscovered portion of Graph g starting at Vertex s.
3
4 discovered is a dictionary mapping each vertex to the edge that was used to
5 discover it during the BFS (s should be mapped to None prior to the call).
6 Newly discovered vertices will be added to the dictionary as a result.
7 ”””
8 level = [s] # ﬁrst level includes only s
9 while len(level) > 0:
10 next level = [ ] # prepare to gather newly found vertices
11 for u in level:
12 for e in g.incident edges(u): # for every outgoing edge from u
13 v = e.opposite(u)
14 if v not in discovered: # v is an unvisited vertex
15 discovered[v] = e # e is the tree edge that discovered v
16 next level.append(v) # v will be further considered in next pass
17 level = next level # relabel ’next’ level to become current
CodeFragment14.8: Implementation ofbreadth-ﬁrst search onagraph, startingat14.3. GraphTraversals 649
0 0 1
A B C D A B C D
E F G H E F G H
I J K L I J K L
M N O P M N O P
(a) (b)
0 1 2 3
0 1 2
A B C D
A B C D
E F G H
E F G H
I J K L
I J K L
M N O P
M N O P
(c) (d)
0 1 2 3 0 1 2 3
A B C D A B C D
E F G H E F G H
4 4
I J K L I J K L
M N O P M N O P 5
(e) (f)
Figure14.10: Exampleofbreadth-ﬁrstsearchtraversal, wheretheedgesincidentto
avertexareconsideredinalphabeticalorderoftheadjacentvertices. Thediscovery
edges are shown with solid lines and the nontree (cross) edges are shown with
dashed lines: (a) starting thesearch atA;(b)discovery of level1; (c)discovery of650 Chapter14. GraphAlgorithms
When discussing DFS, we described a classiﬁcation of nontree edges being
either back edges, which connect a vertex to one of its ancestors, forward edges,
which connect a vertex to one of its descendants, orcross edges, which connect a
vertex to another vertex that is neither its ancestor nor itsdescendant. ForBFSon
anundirected graph, allnontree edges arecrossedges (seeExercise C-14.47), and
forBFSonadirected graph,allnontreeedgesareeitherbackedgesorcrossedges
(seeExerciseC-14.48).
The BFS traversal algorithm has a number of interesting properties, some of
whichweexploreinthepropositionthatfollows. Mostnotably,apathinabreadth-
ﬁrst search tree rooted at vertex s to any other vertex v is guaranteed to be the
shortest suchpathfromstovintermsofthenumberofedges.
Proposition 14.16: LetG beanundirectedordirectedgraphonwhichaBFS
traversalstartingatvertexshasbeenperformed.Then
• ThetraversalvisitsallverticesofGthatarereachablefroms.
• Foreachvertexvatleveli,thepathoftheBFStreeT betweensandvhasi
edges,andanyotherpathofGfromstovhasatleastiedges.
• If(u,v)isanedgethatisnotintheBFStree,thenthelevelnumberofvcan
beatmost1greaterthanthelevelnumberofu.
Weleavethejustiﬁcation ofthisproposition asanexercise(C-14.50).
The analysis of the running time of BFS is similar to the one of DFS, with
the algorithm running in O(n+m) time, or more speciﬁcally, in O(n +m ) time
s s
if n is the number of vertices reachable from vertexs, and m ≤m is the number
s s
of incident edges to those vertices. To explore the entire graph, the process can
be restarted at another vertex, akin to the DFS complete function of Code Frag-
ment 14.7. Also, the actual path from vertex s to vertex v can be reconstructed
usingtheconstruct pathfunctionofCodeFragment14.6
Proposition 14.17: LetG beagraphwithn verticesandm edgesrepresented
withtheadjacencyliststructure.ABFStraversalofGtakesO(n+m)time.
Although our implementation of BFSin Code Fragment 14.8 progresses level
by level, the BFS algorithm can also be implemented using a single FIFO queue
to represent the current fringe of the search. Starting withthe source vertex in the
queue, werepeatedly removethe vertexfrom thefront ofthequeue andinsert any
ofitsunvisited neighbors tothebackofthequeue. (SeeExerciseC-14.51.)
In comparing the capabilities of DFSand BFS,both can be usedto efﬁciently
ﬁndthesetofverticesthatarereachablefromagivensource,andtodeterminepaths
to those vertices. However, BFS guarantees that those paths use as few edges as
possible. Foranundirected graph,bothalgorithmscanbeusedtotestconnectivity,
to identify connected components, or to locate a cycle. For directed graphs, the
DFSalgorithm isbetter suited for certain tasks, such asﬁnding adirected cycle in14.4. TransitiveClosure 651
14.4 Transitive Closure
Wehaveseenthatgraph traversals canbeusedtoanswerbasicquestions ofreach-
ability in a directed graph. In particular, if we are interested in knowing whether
there is apath from vertexuto vertexvinagraph, wecan perform aDFSorBFS
traversal starting atuand observe whethervisdiscovered. Ifrepresenting agraph
withanadjacencylistoradjacencymap,wecananswerthequestionofreachability
foruandvinO(n+m)time(seePropositions 14.15and14.17).
Incertainapplications, wemaywishtoanswermanyreachability queriesmore
efﬁciently, in which case it may be worthwhile to precompute a more convenient
representation of a graph. For example, the ﬁrst step for a service that computes
driving directions from an origin to a destination might be to assess whether the
destination is reachable. Similarly, in an electricity network, we may wish to be
able to quickly determine whether current ﬂows from one particular vertex to an-
other. Motivated by such applications, we introduce the following deﬁnition. The
(cid:4) (cid:4)∗
transitive closure of a directed graph G is itself a directed graph G such that the
vertices of G(cid:4)∗ are the same as the vertices of G(cid:4), and G(cid:4)∗ has an edge (u,v), when-
everG(cid:4) hasadirectedpathfromutov(including thecasewhere(u,v)isanedgeof
(cid:4)
theoriginalG).
Ifagraphisrepresentedasanadjacencylistoradjacencymap,wecancompute
itstransitive closure inO(n(n+m))timebymaking useofngraph traversals, one
from each starting vertex. For example, a DFS starting at vertex u can be used to
determine all vertices reachable fromu, and thus a collection of edges originating
withuinthetransitiveclosure.
Intheremainderofthissection,weexploreanalternativetechniqueforcomput-
ingthetransitiveclosureofadirectedgraphthatisparticularlywellsuitedforwhen
a directed graph is represented by a data structure that supports O(1)-time lookup
(cid:4)
fortheget edge(u,v)method(forexample,theadjacency-matrix structure). LetG
beadirectedgraphwithnverticesandmedges. Wecomputethetransitiveclosure
of G(cid:4) in a series of rounds. We initialize G(cid:4) =G(cid:4). We also arbitrarily number the
0
verticesofG(cid:4) asv ,v ,...,v . Wethenbeginthecomputationoftherounds,begin-
1 2 n
(cid:4)
ning with round 1. In a generic round k, we construct directed graph G starting
k
with G(cid:4)k =G(cid:4)k−1 and adding toG(cid:4)k the directed edge(vi,vj) ifdirected graphG(cid:4)k−1
contains both the edges (v,v ) and (v ,v ). In this way, we will enforce a simple
i k k j
ruleembodiedintheproposition thatfollows.
Proposition 14.18: Fori=1,...,n,directedgraphG(cid:4) hasanedge(v,v )ifand
k i j
(cid:4)
onlyifdirectedgraphG hasadirectedpathfromv tov , whoseintermediate
i j
vertices(ifany)areintheset{v ,...,v }. Inparticular, G(cid:4) isequaltoG(cid:4)∗,the
1 k n
(cid:4)652 Chapter14. GraphAlgorithms
Proposition14.18suggestsasimplealgorithmforcomputingthetransitiveclo-
(cid:4) (cid:4)
sureofGthatisbased ontheseriesofrounds tocompute eachG . Thisalgorithm
k
is known as the Floyd-Warshall algorithm, and its pseudo-code is given in Code
Fragment 14.9. We illustrate an example run of the Floyd-Warshall algorithm in
Figure14.11.
(cid:4)
AlgorithmFloydWarshall(G):
(cid:4)
Input: Adirected graphGwithnvertices
(cid:4)∗ (cid:4)
Output: ThetransitiveclosureG ofG
letv ,v ,...,v beanarbitrary numberingoftheverticesofG(cid:4)
1 2 n
G(cid:4) = G(cid:4)
0
fork = 1tondo
G(cid:4)k = G(cid:4)k−1
foralli,jin{1,...,n}withi(cid:15)= jandi,j(cid:15)=kdo
ifbothedges(vi,vk)and(vk,vj)areinG(cid:4)k−1 then
addedge(v,v )toG(cid:4) (ifitisnotalready present)
i j k
(cid:4)
returnG
n
Code Fragment 14.9: Pseudo-code for the Floyd-Warshall algorithm. This algo-
(cid:4)∗
rithmcomputesthetransitiveclosureG ofGbyincrementally computing aseries
ofdirected graphsG(cid:4) ,G(cid:4) ,...,G(cid:4) ,fork=1,...,n.
0 1 n
From this pseudo-code, we can easily analyze the running time of the Floyd-
Warshallalgorithm assuming thatthedatastructure representing Gsupports meth-
odsget edgeandinsert edgeinO(1)time. Themainloopisexecutedntimesand
theinnerloopconsiderseachofO(n2)pairsofvertices,performingaconstant-time
computation for each one. Thus, the total running time of the Floyd-Warshall al-
gorithm is O(n3). From the description and analysis above we may immediately
derivethefollowingproposition.
(cid:4) (cid:4)
Proposition 14.19: LetGbeadirectedgraphwithnvertices,andletGberepre-
sentedbyadatastructurethatsupportslookupandupdateofadjacencyinformation
inO(1) time. ThentheFloyd-Warshallalgorithmcomputesthetransitiveclosure
G(cid:4)∗ofG(cid:4) inO(n3)time.
Performance of the Floyd-Warshall Algorithm
Asymptotically, theO(n3)running timeoftheFloyd-Warshall algorithm isnobet-
ter than that achieved by repeatedly running DFS,once from each vertex, to com-
pute the reachability. However, the Floyd-Warshall algorithm matches the asymp-
toticbounds oftherepeated DFSwhenagraphisdense, orwhenagraphissparse14.4. TransitiveClosure 653
v7 v7
BOS BOS
v4 v4
ORD ORD
JFK JFK
v2 v6 v2 v6
SFO SFO
DFW DFW
LAX LAX
v3 v3
v1 v1
MIA MIA
(a) v5 (b) v5
v7 v7
BOS BOS
v4 v4
ORD ORD
JFK JFK
v2 v6 v2 v6
SFO SFO
DFW DFW
LAX LAX
v3 v3
v1 v1
MIA MIA
(c) v5 (d) v5
v7
BOS v7 v4 BOS
v4 ORD
ORD
JFK
v2 JFK v6 v2 SFO v6
SFO
DFW
DFW LAX
LAX v3
v3 v1
v1 MIA
MIA
v5
v5
(e) (f)
Figure14.11: Sequence of directed graphs computed by the Floyd-Warshall algo-
rithm: (a)initialdirectedgraphG(cid:4) =G(cid:4) andnumberingofthevertices;(b)directed
0
graph G(cid:4) ; (c) G(cid:4) ; (d) G(cid:4) ; (e) G(cid:4) ; (f) G(cid:4) . Note that G(cid:4) = G(cid:4) = G(cid:4) . If directed
1 2 3 4 5 5 6 7
graphG(cid:4)k−1 hastheedges(vi,vk)and(vk,vj),butnottheedge(vi,vj),inthedraw-
ingofdirected graphG(cid:4) ,weshowedges(v,v )and(v ,v )withdashedlines,and
k i k k j
edge (v,v ) witha thick line. Forexample, in (b) existing edges (MIA,LAX)and
i j654 Chapter14. GraphAlgorithms
The importance of the Floyd-Warshall algorithm is that it is much easier to
implement than DFS, and much faster in practice because there are relatively few
low-level operations hidden within the asymptotic notation. The algorithm is par-
ticularly wellsuited for the useof anadjacency matrix, asasingle bitcan beused
todesignate thereachability modeledasanedge(u,v)inthetransitive closure.
However, note that repeated calls to DFS results in better asymptotic perfor-
mance when the graph is sparse and represented using an adjacency list or adja-
cency map. Inthat case, asingle DFSruns inO(n+m) time, and so thetransitive
closurecanbecomputedinO(n2+nm)time,whichispreferable toO(n3).
Python Implementation
We conclude with a Python implementation of the Floyd-Warshall algorithm, as
presented in Code Fragment 14.10. Although the original algorithm is described
using a series of directed graphs G(cid:4) ,G(cid:4) ,...,G(cid:4) , we create a single copy of the
0 1 n
original graph (using thedeepcopy method ofPython’s copymodule) andthen re-
peatedlyaddnewedgestotheclosureasweprogressthroughroundsoftheFloyd-
Warshallalgorithm.
Thealgorithmrequiresacanonicalnumberingofthegraph’svertices;therefore,
wecreatealistoftheverticesintheclosuregraph,andsubsequently indexthatlist
forourorder. Withintheoutermostloop,wemustconsiderallpairsiand j. Finally,
we optimize by only iterating through all values of j after we have veriﬁed that i
hasbeenchosensuchthat(v,v )existsinthecurrentversionofourclosure.
i k
1 def ﬂoyd warshall(g):
2 ”””Return a new graph that is the transitive closure of g.”””
3 closure = deepcopy(g) # imported from copy module
4 verts = list(closure.vertices()) # make indexable list
5 n = len(verts)
6 for k in range(n):
7 for i in range(n):
8 # verify that edge (i,k) exists in the partial closure
9 if i != k and closure.get edge(verts[i],verts[k]) is not None:
10 for j in range(n):
11 # verify that edge (k,j) exists in the partial closure
12 if i != j != k and closure.get edge(verts[k],verts[j]) is not None:
13 # if (i,j) not yet included, add it to the closure
14 if closure.get edge(verts[i],verts[j]) is None:
15 closure.insert edge(verts[i],verts[j])
16 return closure14.5. DirectedAcyclicGraphs 655
14.5 Directed Acyclic Graphs
Directed graphs without directed cycles are encountered in many applications.
Such a directed graph is often referred to as a directed acyclic graph, or DAG,
forshort. Applications ofsuchgraphsincludethefollowing:
• Prerequisites betweencourses ofadegreeprogram.
• Inheritance betweenclassesofanobject-oriented program.
• Scheduling constraints betweenthetasksofaproject.
Weexplorethislatterapplication furtherinthefollowingexample:
Example 14.20: Inordertomanagealargeproject,itisconvenienttobreakitup
intoacollectionofsmallertasks. Thetasks,however,arerarelyindependent,be-
causeschedulingconstraintsexistbetweenthem.(Forexample,inahousebuilding
project,thetaskoforderingnailsobviouslyprecedesthetaskofnailingshingles
totheroofdeck.)Clearly,schedulingconstraintscannothavecircularities,because
theywouldmaketheprojectimpossible. (Forexample,inordertogetajobyou
needtohaveworkexperience,butinordertogetworkexperienceyouneedtohave
ajob.) Theschedulingconstraintsimposerestrictionsontheorderinwhichthe
taskscanbeexecuted. Namely,ifaconstraintsaysthattaskamustbecompleted
beforetaskbisstarted,thenamustprecedebintheorderofexecutionofthetasks.
Thus,ifwemodelafeasiblesetoftasksasverticesofadirectedgraph,andwe
placeadirectededgefromutovwheneverthetaskforumustbeexecutedbefore
thetaskforv,thenwedeﬁneadirectedacyclicgraph.
14.5.1 Topological Ordering
(cid:4)
The example above motivates the following deﬁnition. LetG be a directed graph
withnvertices. AtopologicalorderingofG(cid:4) isanorderingv ,...,v ofthevertices
1 n
ofG(cid:4) such that forevery edge(v,v )ofG(cid:4), itisthecase thati< j. Thatis, atopo-
i j
(cid:4)
logicalorderingisanorderingsuchthatanydirectedpathinGtraversesverticesin
increasing order. Note that a directed graph may have more than one topological
ordering. (SeeFigure14.12.)
(cid:4)
Proposition 14.21: Ghasatopologicalorderingifandonlyifitisacyclic.
Justiﬁcation: The necessity (the “only if” part of the statement) is easy to
(cid:4)
demonstrate. Suppose G is topologically ordered. Assume, for the sake of a con-
tradiction, that G(cid:4) has a cycle consisting of edges (v ,v ),(v ,v ),...,(v ,v ).
i0 i1 i1 i2 ik−1 i0
Becauseofthetopological ordering, wemusthavei0<i1<···<ik−1<i0,which
(cid:4)656 Chapter14. GraphAlgorithms
1 4 2 1
A B A B
2 3
C C
D D
E 5 F E 4 F
3 6 6 5
G G
7 7
H H
8 8
(a) (b)
Figure14.12: Twotopological orderings ofthesameacyclicdirectedgraph.
(cid:4)
We now argue the sufﬁciency of the condition (the “if” part). Suppose G is
acyclic. We will give an algorithmic description of how to build a topological
(cid:4) (cid:4) (cid:4)
ordering for G. Since G is acyclic, G must have a vertex with no incoming edges
(that is, with in-degree 0). Let v be such a vertex. Indeed, if v did not exist,
1 1
then in tracing a directed path from an arbitrary start vertex, we would eventually
(cid:4)
encounter apreviously visited vertex, thus contradictingthe acyclicity ofG. Ifwe
(cid:4)
removev fromG,together withitsoutgoing edges, theresulting directedgraphis
1
stillacyclic. Hence,theresultingdirectedgraphalsohasavertexwithnoincoming
edges, and we let v be such a vertex. By repeating this process until the directed
2
graphbecomesempty,weobtainanorderingv ,...,v oftheverticesofG(cid:4). Because
1 n
oftheconstruction above, if(v,v )isanedgeofG(cid:4),thenv mustbedeleted before
i j i
v canbedeleted, andthus,i< j. Therefore,v ,...,v isatopological ordering.
j 1 n
Proposition 14.21’s justiﬁcation suggests an algorithm for computing a topo-
logicalorderingofadirectedgraph,whichwecalltopological sorting. Wepresent
aPythonimplementationofthetechniqueinCodeFragment14.11,andanexample
execution of thealgorithm in Figure14.13. Ourimplementation uses adictionary,
namedincount,tomapeachvertexvtoacounterthatrepresentsthecurrentnumber
ofincomingedgestov,excluding thosecomingfromverticesthathavepreviously
beenaddedtothetopologicalorder. Technically,aPythondictionaryprovidesO(1)
expected time access to entries, rather than worst-case time; as was the case with
ourgraphtraversals, thiscouldbeconvertedtoworst-casetimeifverticescouldbe
indexedfrom0ton−1,orifwestorethecounterasanelementofavertex.
As a side effect, the topological sorting algorithm of Code Fragment 14.11
(cid:4)
also tests whether the given directed graph G is acyclic. Indeed, if the algorithm
terminates without ordering all the vertices, then the subgraph of the vertices that14.5. DirectedAcyclicGraphs 657
1 def topological sort(g):
2 ”””Return a list of verticies of directed acyclic graph g in topological order.
3
4 If graph g has a cycle, the result will be incomplete.
5 ”””
6 topo = [ ] # a list of vertices placed in topological order
7 ready = [ ] # list of vertices that have no remaining constraints
8 incount = { } # keep track of in-degree for each vertex
9 for u in g.vertices():
10 incount[u] = g.degree(u, False) # parameter requests incoming degree
11 if incount[u] == 0: # if u has no incoming edges,
12 ready.append(u) # it is free of constraints
13 while len(ready) > 0:
14 u = ready.pop( ) # u is free of constraints
15 topo.append(u) # add u to the topological order
16 for e in g.incident edges(u): # consider all outgoing neighbors of u
17 v = e.opposite(u)
18 incount[v] −= 1 # v has one less constraint without u
19 if incount[v] == 0:
20 ready.append(v)
21 return topo
CodeFragment14.11:Pythonimplementationforthetopologicalsortingalgorithm.
(Weshowanexampleexecution ofthisalgorithm inFigure14.13.)
Performance of Topological Sorting
(cid:4)
Proposition 14.22: LetGbeadirectedgraphwithnverticesandmedges,using
anadjacencylistrepresentation.ThetopologicalsortingalgorithmrunsinO(n+m)
timeusingO(n)auxiliaryspace,andeithercomputesatopologicalorderingofG(cid:4)
(cid:4)
orfailstoincludesomevertices,whichindicatesthatGhasadirectedcycle.
Justiﬁcation: The initial recording of the n in-degrees uses O(n) time based
on the degree method. Say that a vertex u is visited by the topological sorting al-
gorithm when u is removed from the ready list. A vertex u can be visited only
when incount(u)is 0, which implies that allits predecessors (vertices withoutgo-
ing edges into u) were previously visited. As aconsequence, any vertex thatis on
a directed cycle will never be visited, and any other vertex will be visited exactly
once. Thealgorithmtraversesalltheoutgoingedgesofeachvisitedvertexonce,so
itsrunning timeisproportional tothenumberofoutgoing edgesofthevisited ver-
tices. Inaccordance withProposition 14.9,therunning timeis(n+m). Regarding
thespaceusage,observethatcontainerstopo,ready,andincounthaveatmostone658 Chapter14. GraphAlgorithms
0 0 1 0 1 0
A B A B A B
1 0 2
C C C
D D D
E 3 F E 2 F E 1 F
1 2 1 2 0 2
G G G
2 2 2
H 3 H 3 H 2
(a) (b) (c)
1 0 1 4 1 4
A B A B A B
2 2 2
C C C
D D D
E 1 F E 0 F E 5 F
3 2 3 1 3 0
G G G
1 1 1
H 2 H 2 H 2
(d) (e) (f)
1 4 1 4 1 4
A B A B A B
2 2 2
C C C
D D D
E 5 F E 5 F E 5 F
3 6 3 6 3 6
G G G
0 7 7
H 1 H 0 H 8
(g) (h) (i)
Figure 14.13: Example of a run of algorithm topological sort (Code Frag-
ment 14.11). The label near a vertex shows its current incount value, and its
eventual rank in the resulting topological order. The highlighted vertex is one
with incount equal to zero that will become the next vertex in the topological or-
der. Dashed lines denote edges thathave already beenexamined and whichareno14.6. ShortestPaths 659
14.6 Shortest Paths
AswesawinSection14.3.3, thebreadth-ﬁrst search strategy canbeusedtoﬁnda
shortest pathfrom somestarting vertextoeveryothervertexinaconnected graph.
This approach makes sense in cases where each edge is as good as any other, but
therearemanysituations wherethisapproach isnotappropriate.
For example, we might want to use a graph to represent the roads between
cities,andwemightbeinterested inﬁndingthefastestwaytotravelcross-country.
Inthiscase,itisprobablynotappropriateforalltheedgestobeequaltoeachother,
for some inter-city distances will likely be much larger than others. Likewise, we
mightbeusingagraphtorepresent acomputernetwork(suchastheInternet), and
we might be interested in ﬁnding the fastest way to route a data packet between
two computers. In this case, it again may not be appropriate for all the edges to
be equal to each other, for some connections in a computer network are typically
much faster than others (for example, some edges might represent low-bandwidth
connections, while others might represent high-speed, ﬁber-optic connections). It
isnatural, therefore, toconsider graphswhoseedgesarenotweightedequally.
14.6.1 Weighted Graphs
A weighted graph is a graph that has a numeric (for example, integer) labelw(e)
associated with each edge e, called the weight of edge e. For e = (u,v), we let
notationw(u,v)=w(e). WeshowanexampleofaweightedgraphinFigure14.14.
2704
1846 867
ORD BOS
187
740 JFK
SFO 1464
802
337
LAX 1090
1235
1258
DFW 1121
2342
MIA
Figure14.14: A weighted graph whose vertices represent major U.S. airports and
whoseedgeweightsrepresentdistancesinmiles. ThisgraphhasapathfromJFKto
LAXoftotalweight2,777 (going through ORDandDFW).Thisistheminimum-660 Chapter14. GraphAlgorithms
Deﬁning Shortest Paths in a Weighted Graph
Let G be a weighted graph. The length (or weight) of a path is the sum of the
weightsoftheedgesofP. Thatis,ifP=((v0,v1),(v1,v2),...,(vk−1,vk)),thenthe
lengthofP,denoted w(P),isdeﬁnedas
k−1
w(P)= ∑w(vi,vi+1).
i=0
The distance from a vertex u to a vertex v in G, denoted d(u,v), is the length of a
minimum-length path(alsocalledshortestpath)fromutov,ifsuchapathexists.
Peopleoften usetheconvention thatd(u,v)=∞ifthere isnopathatallfrom
u to v in G. Even if there is a path from u to v in G, however, if there is a cycle
in G whose total weight is negative, the distance from u to v may not be deﬁned.
For example, suppose vertices in G represent cities, and the weights of edges in
G represent how much money it costs to go from one city to another. If someone
werewilling to actually pay ustogo from say JFKtoORD,then the “cost” ofthe
edge (JFK,ORD)would be negative. If someone else were willing to pay us to go
fromORDtoJFK,thentherewouldbeanegative-weight cycleinGanddistances
would no longer be deﬁned. That is, anyone could now build a path (with cycles)
in G from any city A to another city B that ﬁrst goes to JFK and then cycles as
many times as he or she likes from JFK to ORD and back, before going on to B.
The existence of such paths would allow us to build arbitrarily low negative-cost
paths (and, in this case, make a fortune in the process). But distances cannot be
arbitrarily lownegativenumbers. Thus,anytimeweuseedgeweightstorepresent
distances, wemustbecarefulnottointroduce anynegative-weight cycles.
Suppose weare given aweighted graphG, and weare asked to ﬁnd ashortest
pathfromsomevertexstoeachothervertexinG,viewingtheweightsontheedges
as distances. In this section, we explore efﬁcient ways of ﬁnding all such shortest
paths, if they exist. The ﬁrst algorithm we discuss is for thesimple, yet common,
casewhenalltheedgeweightsinGarenonnegative(thatis,w(e)≥0foreachedge
eofG); hence, weknow inadvance that there areno negative-weight cycles in G.
Recallthatthespecialcaseofcomputingashortestpathwhenallweightsareequal
toonewassolvedwiththeBFStraversal algorithm presentedinSection14.3.3.
There is an interesting approach for solving thissingle-source problem based
onthegreedymethoddesignpattern(Section13.4.2). Recallthatinthispatternwe
solvetheproblemathandbyrepeatedlyselectingthebestchoicefromamongthose
availableineachiteration. Thisparadigmcanoftenbeusedinsituations wherewe
aretrying tooptimize somecost function overacollection ofobjects. Wecan add
objects toourcollection, oneatatime, always picking the nextonethatoptimizes14.6. ShortestPaths 661
14.6.2 Dijkstra’s Algorithm
Themainideainapplying thegreedymethodpatterntothesingle-source shortest-
path problem is toperform a“weighted” breadth-ﬁrst searchstarting at the source
vertex s. In particular, wecan use the greedy method todevelop an algorithm that
iteratively growsa“cloud”ofverticesoutofs,withtheverticesentering thecloud
in order of their distances from s. Thus, in each iteration, the next vertex chosen
is the vertex outside the cloud that is closest tos. The algorithm terminates when
no more vertices are outside the cloud (or when those outside the cloud are not
connected to those within the cloud), at which point we have ashortest path from
s to every vertex of G that is reachable from s. This approach is a simple, but
nevertheless powerful,exampleofthegreedymethoddesignpattern. Applyingthe
greedy method to the single-source, shortest-path problem, results inanalgorithm
knownasDijkstra’s algorithm.
Edge Relaxation
Letus deﬁne alabel D[v]for each vertexv inV, which weuse to approximate the
distanceinGfromstov. ThemeaningoftheselabelsisthatD[v]willalwaysstore
thelength ofthebestpathwehavefoundsofarfromstov. Initially, D[s]=0and
D[v]=∞foreachv(cid:15)=s,andwedeﬁnethesetC,whichisour“cloud”ofvertices,
to initially be the empty set. Ateach iteration of the algorithm, we select a vertex
u not inC with smallest D[u] label, and we pull u intoC. (In general, we will use
a priority queue to select among the vertices outside the cloud.) In the very ﬁrst
iteration wewill,ofcourse, pullsintoC. OnceanewvertexuispulledintoC,we
then update the label D[v] of each vertex v that is adjacent to u and is outside of
C, toreﬂect the fact that there maybe anew andbetter wayto getto vviau. This
update operation is known as a relaxation procedure, for it takes an old estimate
and checks if it can be improved to get closer to its true value. The speciﬁc edge
relaxation operation isasfollows:
EdgeRelaxation:
ifD[u]+w(u,v)<D[v]then
D[v] = D[u]+w(u,v)
Algorithm Description and Example
We give the pseudo-code for Dijkstra’s algorithm in Code Fragment 14.12, and662 Chapter14. GraphAlgorithms
AlgorithmShortestPath(G,s):
Input: AweightedgraphGwithnonnegativeedgeweights,andadistinguished
vertexsofG.
Output: Thelengthofashortest pathfromstovforeachvertexvofG.
InitializeD[s] = 0andD[v] = ∞foreachvertexv(cid:15)=s.
LetapriorityqueueQcontain alltheverticesofGusingtheDlabelsaskeys.
whileQisnotemptydo
{pullanewvertexuintothecloud}
u = valuereturned byQ.remove min()
foreachvertexvadjacenttousuchthatvisinQ do
{performtherelaxation procedure onedge(u,v)}
ifD[u]+w(u,v)<D[v]then
D[v] = D[u]+w(u,v)
ChangetoD[v]thekeyofvertexvinQ.
returnthelabelD[v]ofeachvertexv
Code Fragment 14.12: Pseudo-code for Dijkstra’s algorithm, solving the single-
sourceshortest-path problem.
∞ ∞
2704 2704
BOS BOS
867 ∞ 867 ∞
∞ 621
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
∞ 1846 621 JFK ∞ ∞ 1846 621 JFK 184
1258 1258
SFO 802 184 SFO 802 184
1464 1391 0 BWI 1090 1464 1391 0 BWI 1090
337 337
DFW ∞ DFW ∞
LAX 1235 946 LAX 1235 946
1121 1121
∞ ∞
2342 MIA 2342 MIA
∞ 946
(a) (b)
Figure14.15: Anexecution of Dijkstra’s algorithm on aweighted graph. Thestart
vertex is BWI. A box next to each vertex v stores the label D[v]. The edges of
the shortest-path tree are drawn as thick arrows, and for each vertex u outside the
“cloud”weshowthecurrentbestedgeforpullinginuwithathickline. (Continues14.6. ShortestPaths 663
371 371
2704 2704
BOS BOS
867 328 867 328
621 621
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
∞ 1846 621 JFK 184 ∞ 1846 621 JFK 184
SFO 802 184 1258 SFO 802 184 1258
1464 1391 0 BWI 1090 1464 1391 0 BWI 1090
337 337
DFW 1575 DFW 1575
LAX 1235 946 LAX 1235 946
1121 1121
∞ ∞
2342 MIA 2342 MIA
946 946
(c) (d)
371 371
2704 2704
BOS BOS
867 328 867 328
621 621
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
3075 1846 621 JFK 184 2467 1846 621 JFK 184
SFO 802 184 1258 SFO 802 184 1258
1464 1391 0 BWI 1090 1464 1391 0 BWI 1090
337 337
DFW 1575 DFW 1423
LAX 1235 946 LAX 1235 946
1121 1121
∞ ∞
2342 MIA 2342 MIA
946 946
(e) (f)
371 371
2704 2704
BOS BOS
867 328 867 328
621 621
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
2467 1846 621 JFK 184 2467 1846 621 JFK 184
1258 1258
SFO 802 184 SFO 802 184
1464 1391 0 BWI 1090 1464 1391 0 BWI 1090
337 337
DFW 1423 DFW 1423
LAX 1235 946 LAX 1235 946
1121 1121
3288 2658
2342 MIA 2342 MIA
946 946
(g) (h)
Figure14.16: Anexampleexecution ofDijkstra’s algorithm. (Continued fromFig-664 Chapter14. GraphAlgorithms
371 371
2704 2704
BOS BOS
867 328 867 328
621 621
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
2S46F7O 1846 802 621 1J8F4K 184 1258 2S46F7O 1846 802 621 1J8F4K 184 1258
337 1464 1391 0 BWI 1090 337 1464 1391 0 BWI 1090
LAX 1235 DFW 1423 946 LAX 1235 DFW 1423 946
1121 1121
2658 2658
2342 MIA 2342 MIA
946 946
(i) (j)
Figure14.17: Anexampleexecution ofDijkstra’s algorithm. (Continued fromFig-
ure14.16.)
Why It Works
The interesting aspect of the Dijkstra algorithm is that, at the moment a vertex u
is pulled into C, its label D[u] stores the correct length of a shortest path from v
tou. Thus, whenthealgorithm terminates, itwillhavecomputedtheshortest-path
distance from s to every vertex ofG. That is, it will have solved the single-source
shortest-path problem.
ItisprobablynotimmediatelyclearwhyDijkstra’salgorithmcorrectlyﬁndsthe
shortest path from the start vertex s to each other vertex u in the graph. Why is it
thatthedistancefromstouisequaltothevalueofthelabelD[u]atthetimevertex
u is removed from the priority queue Q and added to the cloud C? The answer
tothis question depends onthere being nonegative-weight edges inthe graph, for
it allows the greedy method to work correctly, as we show in the proposition that
follows.
Proposition 14.23: InDijkstra’salgorithm,wheneveravertexvispulledintothe
cloud,thelabelD[v]isequaltod(s,v),thelengthofashortestpathfromstov.
Justiﬁcation: Suppose that D[v] > d(s,v) for some vertex v in V, and let z
be the ﬁrst vertex the algorithm pulled into the cloud C (that is, removed from
Q) such that D[z]>d(s,z). There is a shortest path P from s to z (for otherwise
d(s,z)=∞=D[z]). Let us therefore consider the moment when z is pulled into
C, and letybethe ﬁrstvertex ofP (whengoing fromstoz) that isnotinC at this
moment. Let x be the predecessor of y in path P (note that we could have x=s).14.6. ShortestPaths 665
theﬁrst“wrong”vertexpicked
zpickedimplies
C
thatD[z]≤D[y]
z
D[z]>d(s,z)
s
D[x]=d(s,x)
P
y
x D[y]=d(s,y)
Figure14.18: Aschematicillustration forthejustiﬁcation ofProposition 14.23.
Moreover, D[x]=d(s,x), since z is the ﬁrst incorrect vertex. When x was pulled
intoC,wetested(andpossiblyupdated)D[y]sothatwehadatthatpoint
D[y]≤D[x]+w(x,y)=d(s,x)+w(x,y).
Butsinceyisthenextvertexontheshortest pathfromstoz,thisimpliesthat
D[y]=d(s,y).
Butwearenowatthemomentwhenwearepickingz,noty,tojoinC;hence,
D[z]≤D[y].
It should be clear that a subpath of a shortest path is itself ashortest path. Hence,
sinceyisontheshortest pathfromstoz,
d(s,y)+d(y,z)=d(s,z).
Moreover,d(y,z)≥0becausetherearenonegative-weight edges. Therefore,
D[z]≤D[y]=d(s,y)≤d(s,y)+d(y,z)=d(s,z).
Butthiscontradicts thedeﬁnitionofz;hence,therecanbenosuchvertexz.
The Running Time of Dijkstra’s Algorithm
Inthissection, weanalyze thetimecomplexityofDijkstra’s algorithm. Wedenote
with n and m the number of vertices and edges of the input graph G, respectively.
We assume that the edge weights can be added and compared in constant time.
Because of the high level of the description we gave for Dijkstra’s algorithm in
CodeFragment14.12,analyzingitsrunningtimerequiresthatwegivemoredetails
onitsimplementation. Speciﬁcally,weshouldindicatethedatastructuresusedand666 Chapter14. GraphAlgorithms
Let us ﬁrst assume that we are representing the graph G using an adjacency
list or adjacency map structure. This data structure allows us to step through the
verticesadjacenttouduringtherelaxationstepintimeproportionaltotheirnumber.
Therefore,thetimespentinthemanagementofthenestedforloop,andthenumber
ofiterations ofthatloop,is
∑ outdeg(u),
uinV
G
which is O(m) by Proposition 14.9. The outer while loop executes O(n) times,
since a new vertex is added to the cloud during each iteration. This still does not
settleallthedetailsforthealgorithmanalysis,however,forwemustsaymoreabout
how to implement the other principal data structure in the algorithm—the priority
queueQ.
Referring backtoCodeFragment14.12insearchofpriorityqueue operations,
weﬁndthatnverticesareoriginallyinsertedintothepriorityqueue;sincetheseare
the only insertions, the maximum size of the queue isn. In each of n iterations of
the while loop, a call toremove minis made to extract the vertex u with smallest
D label from Q. Then, for each neighbor v of u, we perform an edge relaxation,
and may potentially update the key of v in the queue. Thus, we actually need an
implementationofanadaptablepriorityqueue(Section9.5),inwhichcasethekey
of a vertex v is changed using the method update((cid:3),k), where (cid:3) is the locator for
the priority queue entry associated withvertexv. Inthe worstcase, there could be
onesuchupdateforeachedgeofthegraph. Overall,therunningtimeofDijkstra’s
algorithm isboundedbythesumofthefollowing:
• ninsertions intoQ.
• ncallstotheremove minmethodonQ.
• mcallstotheupdatemethodonQ.
If Q is an adaptable priority queue implemented as a heap, then each of the
above operations run in O(logn), and so the overall running time for Dijkstra’s
algorithmisO((n+m)logn). Notethatifwewishtoexpresstherunningtimeasa
function ofnonly, thenitisO(n2logn)intheworstcase.
Let us now consider an alternative implementation for the adaptable priority
queue Q using an unsorted sequence. (See Exercise P-9.58.) This, of course, re-
quires that we spend O(n) time to extract the minimum element, but it affords
very fast key updates, provided Q supports location-aware entries (Section 9.5.1).
Speciﬁcally, we can implement each key update done in a relaxation step in O(1)
time—we simply change the key value once we locate the entry in Q to update.
Hence, this implementation results in arunning time that isO(n2+m), which can14.6. ShortestPaths 667
Comparing the Two Implementations
Wehave twochoices forimplementing theadaptable priorityqueue withlocation-
aware entries in Dijkstra’s algorithm: a heap implementation, which yields a run-
ning time of O((n+m)logn), and an unsorted sequence implementation, which
yieldsarunningtimeofO(n2). Sincebothimplementationswouldbefairlysimple
to code, they are about equal in terms of the programming sophistication needed.
Thesetwoimplementations arealsoaboutequalintermsoftheconstant factors in
their worst-case running times. Looking only at these worst-case times, weprefer
the heap implementation when the number of edges in the graph is small (that is,
whenm<n2/logn),andwepreferthesequenceimplementationwhenthenumber
ofedgesislarge(thatis,whenm>n2/logn).
Proposition 14.24: GivenaweightedgraphGwithnverticesandmedges,such
thattheweightofeachedgeisnonnegative,andavertexsofG,Dijkstra’salgorithm
cancomputethedistancefromstoallotherverticesofGinthebetterofO(n2)or
O((n+m)logn)time.
Wenotethatanadvancedpriorityqueueimplementation,knownasaFibonacci
heap,canbeusedtoimplementDijkstra’salgorithm inO(m+nlogn)time.
Programming Dijkstra’s Algorithm in Python
Havinggivenapseudo-code description ofDijkstra’salgorithm,letusnowpresent
Python code for performing Dijkstra’s algorithm, assuming we are given a graph
whose edge elements are nonnegative integer weights. Our implementation of the
algorithmisintheformofafunction,shortest path lengths,thattakesagraphand
adesignated source vertex asparameters. (SeeCodeFragment14.13.) Itreturns a
dictionary, named cloud, mapping each vertex v that is reachable from the source
to its shortest-path distance d(s,v). We rely on our AdaptableHeapPriorityQueue
developed inSection9.5.2asanadaptable priority queue.
Aswehave done withother algorithms inthis chapter, werelyon dictionaries
to map vertices to associated data (in this case, mapping v to its distance bound
D[v] and its adaptable priority queue locator). The expected O(1)-time access to
elements of these dictionaries could be converted to worst-case bounds, either by
numbering vertices from 0 to n−1 to use as indices into a list, or by storing the
information withineachvertex’selement.
The pseudo-code for Dijkstra’s algorithm begins by assigning d[v] = ∞ for
each vother than thesource. Werelyonthe special valueﬂoat( inf )inPython
toprovide anumeric value that represents positive inﬁnity. However, weavoid in-
cluding vertices with this “inﬁnite” distance in the resulting cloud that is returned
bythefunction. Theuseofthisnumericlimitcouldbeavoided altogether bywait-
ingtoaddavertextothepriorityqueueuntilafteranedgethatreachesitisrelaxed.668 Chapter14. GraphAlgorithms
1 def shortest path lengths(g, src):
2 ”””Compute shortest-path distances from src to reachable vertices of g.
3
4 Graph g can be undirected or directed, but must be weighted such that
5 e.element() returns a numeric weight for each edge e.
6
7 Return dictionary mapping each reachable vertex to its distance from src.
8 ”””
9 d = { } # d[v] is upper bound from s to v
10 cloud = { } # map reachable v to its d[v] value
11 pq = AdaptableHeapPriorityQueue( ) # vertex v will have key d[v]
12 pqlocator = { } # map from vertex to its pq locator
13
14 # for each vertex v of the graph, add an entry to the priority queue, with
15 # the source having distance 0 and all others having inﬁnite distance
16 for v in g.vertices():
17 if v is src:
18 d[v] = 0
19 else:
20 d[v] = ﬂoat( inf ) # syntax for positive inﬁnity
21 pqlocator[v] = pq.add(d[v], v) # save locator for future updates
22
23 while not pq.is empty():
24 key, u = pq.remove min()
25 cloud[u] = key # its correct d[u] value
26 del pqlocator[u] # u is no longer in pq
27 for e in g.incident edges(u): # outgoing edges (u,v)
28 v = e.opposite(u)
29 if v not in cloud:
30 # perform relaxation step on edge (u,v)
31 wgt = e.element()
32 if d[u] + wgt < d[v]: # better path to v?
33 d[v] = d[u] + wgt # update the distance
34 pq.update(pqlocator[v], d[v], v) # update the pq entry
35
36 return cloud # only includes reachable vertices
CodeFragment14.13: Python implementation of Dijkstra’s algorithm for comput-
ing the shortest-path distances from a single source. We assume that e.element()14.6. ShortestPaths 669
Reconstructing the Shortest-Path Tree
Ourpseudo-code description ofDijkstra’s algorithm inCodeFragment 14.12, and
ourimplementationinCodeFragment14.13,computesthevalued[v],foreachver-
texv,thatisthelengthoftheshortest pathfromthesource vertexstov. However,
thoseformsofthealgorithmdonotexplicitlycomputetheactualpathsthatachieve
thosedistances. Thecollectionofallshortestpathsemanatingfromsourcescanbe
compactlyrepresented bywhatisknownastheshortest-path tree. Thepathsform
a rooted tree because if a shortest path froms to v passes through an intermediate
vertexu,itmustbeginwithashortestpathfromstou.
In this section, we demonstrate that the shortest-path tree rooted at source s
can be reconstructed in O(n+m) time, given the set of d[v] values produced by
Dijkstra’s algorithm using s as the source. As we did when representing the DFS
and BFStrees, wewillmap each vertexv(cid:15)=sto a parent u (possibly, u=s), such
that u is the vertex immediately before v on a shortest path froms to v. If u is the
vertexjustbeforevontheshortestpathfromstov,itmustbethat
d[u]+w(u,v)=d[v].
Conversely, if the above equation is satisﬁed, then the shortest path from s to u,
followedbytheedge(u,v)isashortest pathtov.
OurimplementationinCodeFragment14.14reconstructsthetreebasedonthis
logic, testing allincoming edges to each vertex v, looking for a(u,v) that satisﬁes
thekeyequation. TherunningtimeisO(n+m),asweconsidereachvertexandall
incomingedgestothosevertices. (SeeProposition 14.9.)
1 def shortest path tree(g, s, d):
2 ”””Reconstruct shortest-path tree rooted at vertex s, given distance map d.
3
4 Return tree as a map from each reachable vertex v (other than s) to the
5 edge e=(u,v) that is used to reach v from its parent u in the tree.
6 ”””
7 tree = { }
8 for v in d:
9 if v is not s:
10 for e in g.incident edges(v, False): # consider INCOMING edges
11 u = e.opposite(v)
12 wgt = e.element()
13 if d[v] == d[u] + wgt:
14 tree[v] = e # edge e is used to reach v
15 return tree
Code Fragment 14.14: Python function that reconstructs the shortest paths, based670 Chapter14. GraphAlgorithms
14.7 Minimum Spanning Trees
Suppose we wish to connect all the computers in a new ofﬁce building using the
least amount of cable. We can model this problem using an undirected, weighted
graph G whose vertices represent the computers, and whose edges represent all
the possible pairs (u,v) of computers, where the weight w(u,v) of edge (u,v) is
equal to the amount of cable needed to connect computeru to computer v. Rather
thancomputingashortest-pathtreefromsomeparticularvertexv,weareinterested
instead in ﬁnding atreeT that contains all thevertices ofGand has theminimum
totalweight overallsuchtrees. Algorithms forﬁndingsuchatreearethefocusof
thissection.
Problem Deﬁnition
Given an undirected, weighted graph G, we are interested in ﬁnding a tree T that
contains alltheverticesinGandminimizesthesum
w(T)= ∑ w(u,v).
(u,v)inT
Atree,suchasthis,thatcontainseveryvertexofaconnectedgraphGissaidto
beaspanningtree, andtheproblem ofcomputing aspanning treeT withsmallest
totalweightisknownastheminimumspanningtree(orMST)problem.
The development of efﬁcient algorithms for the minimum spanning tree prob-
lem predates the modern notion of computer science itself. In this section, we
discuss two classic algorithms for solving the MST problem. These algorithms
are both applications ofthegreedy method, which, aswas discussed brieﬂy in the
previous section, is based on choosing objects to join a growing collection by it-
eratively picking an object that minimizes some cost function. The ﬁrstalgorithm
we discuss is the Prim-Jarn´ık algorithm, which grows the MST from a single root
vertex, much in the same way as Dijkstra’s shortest-path algorithm. The second
algorithm we discuss is Kruskal’s algorithm, which “grows” the MST in clusters
byconsidering edgesinnondecreasing orderoftheirweights.
Inordertosimplifythedescriptionofthealgorithms,weassume,inthefollow-
ing, that the input graph G is undirected (that is, all its edges are undirected) and
simple (that is, it has no self-loops and no parallel edges). Hence, we denote the
edgesofGasunordered vertexpairs(u,v).
Beforewediscussthedetailsofthesealgorithms,however,letusgiveacrucial14.7. MinimumSpanningTrees 671
A Crucial Fact about Minimum Spanning Trees
ThetwoMSTalgorithmswediscussarebasedonthegreedymethod,whichinthis
casedepends crucially onthefollowingfact. (SeeFigure14.19.)
eBelongs to a Minimum Spanning Tree
e
V V
1 min-weight 2
“bridge” edge
Figure14.19: Anillustration ofthecrucialfactaboutminimumspanning trees.
Proposition 14.25: LetGbeaweightedconnectedgraph,andletV andV bea
1 2
partitionoftheverticesofGintotwodisjointnonemptysets.Furthermore,letebe
anedgeinGwithminimumweightfromamongthosewithoneendpointinV and
1
theotherinV .ThereisaminimumspanningtreeT thathaseasoneofitsedges.
2
Justiﬁcation: Let T be a minimum spanning tree of G. If T does not contain
edge e, the addition of e to T must create a cycle. Therefore, there is some edge
f (cid:15)=e of this cycle that has one endpoint inV and the other inV . Moreover, by
1 2
the choice ofe, w(e)≤w(f). Ifweremove f fromT∪{e}, weobtain aspanning
treewhose total weightisnomorethanbefore. SinceT wasaminimum spanning
tree,thisnewtreemustalsobeaminimumspanning tree.
In fact, if the weights in G are distinct, then the minimum spanning tree is
unique; we leave the justiﬁcation of this less crucial fact as an exercise (C-14.65).
In addition, note that Proposition 14.25 remains valid even if the graph G con-
tains negative-weight edges or negative-weight cycles, unlike the algorithms we672 Chapter14. GraphAlgorithms
´ı
14.7.1 Prim-Jarn k Algorithm
In the Prim-Jarn´ık algorithm, we grow a minimum spanning tree from a single
cluster starting from some “root” vertex s. The main idea is similar to that of
Dijkstra’s algorithm. We begin with some vertexs, deﬁning the initial “cloud” of
verticesC. Then, in each iteration, we choose a minimum-weight edgee=(u,v),
connecting a vertex u in the cloud C to a vertex v outside of C. The vertex v is
then brought into the cloudC and the process is repeated until a spanning tree is
formed. Again, the crucial fact about minimum spanning trees comes into play,
for by always choosing the smallest-weight edge joining a vertex insideC to one
outsideC,weareassured ofalwaysaddingavalidedgetotheMST.
Toefﬁcientlyimplementthisapproach,wecantakeanothercuefromDijkstra’s
algorithm. We maintain a label D[v] for each vertex v outside the cloudC, so that
D[v] stores the weight of the minimum observed edge for joining v to the cloud
C. (In Dijkstra’s algorithm, this label measured the full path length from starting
vertex s to v, including an edge (u,v).) These labels serve as keys in a priority
queue used to decide which vertex is next in line to join the cloud. We give the
pseudo-code inCodeFragment14.15.
AlgorithmPrimJarnik(G):
Input: Anundirected,weighted,connectedgraphGwithnverticesandmedges
Output: Aminimumspanning treeT forG
PickanyvertexsofG
D[s] = 0
foreachvertexv(cid:15)=sdo
D[v] = ∞
InitializeT = ∅.
Initialize a priority queue Q with an entry (D[v],(v,None)) for each vertex v,
whereD[v]isthekeyinthepriorityqueue,and(v,None)istheassociated value.
whileQisnotemptydo
(u,e) = valuereturned byQ.remove min()
ConnectvertexutoT usingedgee.
foreachedgee(cid:2)=(u,v)suchthatvisinQ do
{checkifedge(u,v)betterconnectsvtoT}
ifw(u,v)<D[v]then
D[v] = w(u,v)
ChangethekeyofvertexvinQtoD[v].
ChangethevalueofvertexvinQto(v,e(cid:2)).
returnthetreeT14.7. MinimumSpanningTrees 673
Analyzing the Prim-Jarn´ık Algorithm
The implementation issues for the Prim-Jarn´ık algorithm are similar to those for
Dijkstra’s algorithm, relying on an adaptable priority queue Q (Section 9.5.1).
We initially perform n insertions into Q, later perform n extract-min operations,
and may update a total of m priorities as part of the algorithm. Those steps are
the primary contributions to the overall running time. Witha heap-based priority
queue, eachoperation runsinO(logn)time,andtheoveralltimeforthealgorithm
is O((n+m)logn), which is O(mlogn) for a connected graph. Alternatively, we
canachieveO(n2)running timebyusinganunsorted listasapriority queue.
Illustrating the Prim-Jarn´ık Algorithm
Weillustrate thePrim-Jarn´ıkalgorithm inFigures14.20through14.21.
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(a) (b)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(c) (d)
Figure14.20:AnillustrationofthePrim-Jarn´ıkMSTalgorithm,startingwithvertex674 Chapter14. GraphAlgorithms
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(e) (f)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(g) (h)
2704
2704 BOS
BOS 867
867
849 PVD
ORD 740849144PVD 187 1846 ORD 621740 JF14K4 187
1846 621 JFK
1258
SFO 1464 802 1391 1B84WI 10901258 SF3O37 1464 802 1391 1B84WI 1090
337 DFW
LAX 1235 DFW 946 LAX 1235 1121 946
1121
2342 MIA
2342 MIA
(i) (j)
Figure14.21: An illustration of the Prim-Jarn´ık MST algorithm. (Continued from14.7. MinimumSpanningTrees 675
Python Implementation
Code Fragment 14.16 presents a Python implementation of the Prim-Jarn´ık algo-
rithm. TheMSTisreturned asanunordered listofedges.
1 def MST PrimJarnik(g):
2 ”””Compute a minimum spanning tree of weighted graph g.
3
4 Return a list of edges that comprise the MST (in arbitrary order).
5 ”””
6 d = { } # d[v] is bound on distance to tree
7 tree = [ ] # list of edges in spanning tree
8 pq = AdaptableHeapPriorityQueue( ) # d[v] maps to value (v, e=(u,v))
9 pqlocator = { } # map from vertex to its pq locator
10
11 # for each vertex v of the graph, add an entry to the priority queue, with
12 # the source having distance 0 and all others having inﬁnite distance
13 for v in g.vertices():
14 if len(d) == 0: # this is the ﬁrst node
15 d[v] = 0 # make it the root
16 else:
17 d[v] = ﬂoat( inf ) # positive inﬁnity
18 pqlocator[v] = pq.add(d[v], (v,None))
19
20 while not pq.is empty():
21 key,value = pq.remove min()
22 u,edge = value # unpack tuple from pq
23 del pqlocator[u] # u is no longer in pq
24 if edge is not None:
25 tree.append(edge) # add edge to tree
26 for link in g.incident edges(u):
27 v = link.opposite(u)
28 if v in pqlocator: # thus v not yet in tree
29 # see if edge (u,v) better connects v to the growing tree
30 wgt = link.element()
31 if wgt < d[v]: # better edge to v?
32 d[v] = wgt # update the distance
33 pq.update(pqlocator[v], d[v], (v, link)) # update the pq entry
34 return tree
CodeFragment14.16: Pythonimplementation ofthePrim-Jarn´ık algorithm forthe676 Chapter14. GraphAlgorithms
14.7.2 Kruskal’s Algorithm
Inthissection,weintroduceKruskal’salgorithmforconstructingaminimumspan-
ningtree. WhilethePrim-Jarn´ıkalgorithmbuildstheMSTbygrowingasingletree
until it spans the graph, Kruskal’s algorithm maintains aforest of clusters, repeat-
edlymergingpairsofclusters untilasingleclusterspansthegraph.
Initially, each vertex is by itself in a singleton cluster. The algorithm then
considers each edge in turn, ordered by increasing weight. If an edge e connects
twodifferent clusters, theneisaddedtothesetofedgesoftheminimumspanning
tree,andthetwoclustersconnected byearemergedintoasinglecluster. If,onthe
other hand, e connects two vertices that are already in the same cluster, then e is
discarded. Oncethe algorithm has added enough edges to formaspanning tree, it
terminatesandoutputs thistreeastheminimumspanning tree.
We give pseudo-code for Kruskal’s MST algorithm in Code Fragment 14.17
andweshowanexampleofthisalgorithm inFigures14.22,14.23,and14.24.
AlgorithmKruskal(G):
Input: Asimpleconnected weightedgraphGwithnvertices andmedges
Output: Aminimumspanning treeT forG
foreachvertexvinGdo
Deﬁneanelementary clusterC(v) = {v}.
Initialize apriorityqueueQtocontainalledgesinG,usingtheweightsaskeys.
T = ∅ {T willultimatelycontain theedgesoftheMST}
whileT hasfewerthann−1edgesdo
(u,v) = valuereturned byQ.remove min()
LetC(u)betheclustercontaining u,andletC(v)betheclustercontaining v.
ifC(u)(cid:15)=C(v)then
Addedge(u,v)toT.
MergeC(u)andC(v)intoonecluster.
returntreeT
CodeFragment14.17: Kruskal’salgorithm fortheMSTproblem.
AswasthecasewiththePrim-Jarn´ıkalgorithm,thecorrectnessofKruskal’sal-
gorithm isbased upon thecrucial fact about minimum spanning trees from Propo-
sition 14.25. Each time Kruskal’s algorithm adds an edge (u,v) to the minimum
spanning tree T, we can deﬁne a partitioning of the set of vertices V (as in the
proposition) bylettingV bethecluster containing vandlettingV contain therest
1 2
of the vertices inV. This clearly deﬁnes a disjoint partitioning of the vertices of
V and, more importantly, since we are extracting edges from Q in order by their
weights, e mustbe a minimum-weight edge withone vertex inV and the other in
1
V . Thus,Kruskal’salgorithm alwaysaddsavalidminimumspanning treeedge.14.7. MinimumSpanningTrees 677
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(a) (b)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(c) (d)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
1258 1258
SFO 802 184 SFO 802 184
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(e) (f)
Figure14.22:ExampleofanexecutionofKruskal’sMSTalgorithmonagraphwith
integerweights. Weshowtheclusters asshadedregionsandwehighlight theedge678 Chapter14. GraphAlgorithms
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(g) (h)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
SFO 802 184 1258 SFO 802 184 1258
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(i) (j)
2704 2704
BOS BOS
867 867
849 PVD 849 PVD
ORD 740 144 187 ORD 740 144 187
1846 621 JFK 1846 621 JFK
1258 1258
SFO 802 184 SFO 802 184
1464 1391 BWI 1090 1464 1391 BWI 1090
337 337
DFW DFW
LAX 1235 946 LAX 1235 946
1121 1121
2342 MIA 2342 MIA
(k) (l)
Figure14.23: An example of an execution of Kruskal’s MST algorithm. Rejected14.7. MinimumSpanningTrees 679
2704
2704 BOS
BOS 867
867
849 PVD
849 PVD ORD 740 144 187
ORD 740 144 187 1846 621 JFK
1846 621 JFK 1258
1258 SFO 802 184
SFO 802 184 1464 1391 BWI 1090
1464 1391 BWI 1090 337
337 DFW
DFW LAX 1235 946
LAX 1235 946 1121
1121
2342 MIA
2342 MIA
(m) (n)
Figure 14.24: Example of an execution of Kruskal’s MST algorithm (continued).
Theedge considered in(n)merges thelasttwoclusters, whichconcludes thisexe-
cutionofKruskal’s algorithm. (Continued fromFigure14.23.)
The Running Time of Kruskal’s Algorithm
There are two primary contributions to the running time of Kruskal’s algorithm.
Theﬁrstistheneed toconsider theedges innondecreasing order oftheir weights,
and the second is the management of the cluster partition. Analyzing its running
timerequires thatwegivemoredetailsonitsimplementation.
The ordering of edges by weight can be implemented inO(mlogm), either by
useofasorting algorithm orapriorityqueueQ. Ifthatqueueisimplementedwith
a heap, we can initialize Q in O(mlogm) time by repeated insertions, or in O(m)
time using bottom-up heap construction (see Section 9.3.6), and the subsequent
callstoremove mineachruninO(logm)time,sincethequeuehassizeO(m). We
note that since m is O(n2) for a simple graph, O(logm) is the same as O(logn).
Therefore, therunningtimeduetotheordering ofedgesisO(mlogn).
The remaining task is the management of clusters. To implement Kruskal’s
algorithm,wemustbeabletoﬁndtheclustersforverticesuandvthatareendpoints
of an edge e, to test whether those two clusters are distinct, and if so, to merge
those two clusters into one. None of the data structures we have studied thus far
are well suited for this task. However, we conclude this chapter by formalizing
the problem of managing disjoint partitions, and introducing efﬁcient union-ﬁnd
data structures. In the context of Kruskal’s algorithm, we perform at most 2m
ﬁnd operations and n−1 union operations. We will see that a simple union-ﬁnd
structure can perform that combination of operations in O(m+nlogn) time (see
Proposition 14.26),andamoreadvancedstructurecansupportanevenfastertime.
Foraconnected graph, m≥n−1, andtherefore, thebound ofO(mlogn)time
forordering the edges dominates thetimeformanaging theclusters. Weconclude680 Chapter14. GraphAlgorithms
Python Implementation
CodeFragment14.18presentsaPythonimplementationofKruskal’salgorithm. As
withourimplementation ofthePrim-Jarn´ıkalgorithm, theminimumspanning tree
isreturnedintheformofalistofedges. Asaconsequence ofKruskal’salgorithm,
thoseedgeswillbereported innondecreasing orderoftheirweights.
Our implementation assumes use of aPartition class for managing the cluster
partition. Animplementation ofthePartitionclassispresented inSection14.7.3.
1 def MST Kruskal(g):
2 ”””Compute a minimum spanning tree of a graph using Kruskal s algorithm.
3
4 Return a list of edges that comprise the MST.
5
6 The elements of the graphs edges are assumed to be weights.
7 ”””
8 tree = [ ] # list of edges in spanning tree
9 pq = HeapPriorityQueue( ) # entries are edges in G, with weights as key
10 forest = Partition( ) # keeps track of forest clusters
11 position = { } # map each node to its Partition entry
12
13 for v in g.vertices():
14 position[v] = forest.make group(v)
15
16 for e in g.edges():
17 pq.add(e.element(), e) # edge’s element is assumed to be its weight
18
19 size = g.vertex count()
20 while len(tree) != size − 1 and not pq.is empty():
21 # tree not spanning and unprocessed edges remain
22 weight,edge = pq.remove min()
23 u,v = edge.endpoints()
24 a = forest.ﬁnd(position[u])
25 b = forest.ﬁnd(position[v])
26 if a != b:
27 tree.append(edge)
28 forest.union(a,b)
29
30 return tree
CodeFragment14.18: Pythonimplementation ofKruskal’s algorithm forthemini-14.7. MinimumSpanningTrees 681
14.7.3 Disjoint Partitions and Union-Find Structures
In this section, we consider a data structure for managing apartition of elements
into a collection of disjoint sets. Our initial motivation is in support of Kruskal’s
minimumspanningtreealgorithm,inwhichaforestofdisjointtreesismaintained,
withoccasionalmergingofneighboringtrees. Moregenerally,thedisjointpartition
problem canbeapplied tovariousmodelsofdiscretegrowth.
Weformalize theproblem withthefollowingmodel. Apartition datastructure
manages a universe of elements that are organized into disjoint sets (that is, an
element belongs to one and only one of these sets). Unlike with the Set ADT or
Python’s set class, wedo not expect to be able to iterate through the contents of a
set, nor to efﬁciently test whether a given set includes a given element. To avoid
confusionwithsuchnotionsofaset,wewillrefertotheclustersofourpartitionas
groups. However, wewillnot require an explicit structure for eachgroup, instead
allowing the organization of groups to be implicit. To differentiate between one
groupandanother,weassumethatatanypointintime,eachgrouphasadesignated
entrythatwerefertoastheleaderofthegroup.
Formally, we deﬁne the methods of a partition ADT using position objects,
eachofwhichstoresanelementx. ThepartitionADTsupportsthefollowingmeth-
ods.
make group(x): Create a singleton group containing new element x and
returntheposition storingx.
union(p, q): Mergethegroupscontaining positionspandq.
ﬁnd(p): Returntheposition oftheleader ofthegroupcontaining
positionp.
Sequence Implementation
Asimple implementation ofapartition withatotalofnelements usesacollection
ofsequences, oneforeachgroup,wherethesequence foragroup Astoreselement
positions. Each position object stores a variable, element, which references its
associatedelementxandallowstheexecutionofanelement()methodinO(1)time.
In addition, each position stores a variable, group, that references the sequence
storing p, since this sequence is representing the group containing p’s element.
(SeeFigure14.25.)
Withthisrepresentation, wecaneasilyperformthemake group(x)andﬁnd(p)
operations in O(1) time, allowing the ﬁrst position in a sequence to serve as the
“leader.” Operation union(p,q) requires that we join two sequences into one and
updatethegroupreferencesofthepositionsinoneofthetwo. Wechoosetoimple-682 Chapter14. GraphAlgorithms
A B
4 1 7 9 3 6 2
C
5 11 12 10 8
Figure 14.25: Sequence-based implementation of a partition consisting of three
groups: A={1,4,7}, B={2,3,6,9}, andC={5,8,10,11,12}.
size, and inserting them in the sequence with larger size. Each time wetake a po-
sition from the smaller group aand insert it into the larger group b, weupdate the
groupreferenceforthatpositiontonowpointtob. Hence,theoperationunion(p,q)
takes time O(min(n ,n )), where n (resp. n )is the cardinality of the group con-
p q p q
taining position p(resp.q). Clearly, thistimeisO(n)iftherearenelements inthe
partition universe. However,wenextpresent anamortizedanalysis thatshowsthis
implementation tobemuchbetterthanappears fromthisworst-case analysis.
Proposition 14.26: Whenusingtheabovesequence-basedpartitionimplementa-
tion,performingaseriesofkmake group,union,andﬁndoperationsonaninitially
emptypartitioninvolvingatmostnelementstakesO(k+nlogn)time.
Justiﬁcation: Weuse the accounting method and assume that one cyber-dollar
can pay for the time to perform a ﬁnd operation, a make group operation, or the
movement ofaposition object from one sequence toanother inaunion operation.
In the case of a ﬁnd or make group operation, we charge the operation itself 1
cyber-dollar. In the case of aunion operation, weassume that 1 cyber-dollar pays
for the constant-time work in comparing the sizes of the two sequences, and that
wecharge 1 cyber-dollar to each position that wemove from the smaller group to
thelargergroup. Clearly,the1cyber-dollar chargedforeachﬁndandmake group
operation, together with the ﬁrst cyber-dollar collected for each union operation,
accounts foratotalofkcyber-dollars.
Consider, then, the number of charges made to positions on behalf of union
operations. The important observation is that each time we move a position from
one group toanother, the size ofthat position’s group atleast doubles. Thus, each
position is moved from one group to another at most logn times; hence, each po-
sition canbecharged atmostO(logn)times. Sinceweassumethatthepartition is
initially empty, there areO(n) different elements referenced in the given series of
operations, whichimpliesthatthetotaltimeformovingelements duringtheunion14.7. MinimumSpanningTrees 683
(cid:2)
A Tree-Based Partition Implementation
An alternative data structure for representing a partition uses a collection of
trees to store the n elements, where each tree is associated with a different group.
(SeeFigure14.26.) Inparticular, weimplementeachtreewithalinked datastruc-
turewhosenodesarethemselvesthegrouppositionobjects. Wevieweachposition
p as being a node having an instance variable, element, referring to its element x,
andaninstancevariable,parent,referringtoitsparentnode. Byconvention, if pis
therootofitstree,weset p’sparentreference toitself.
1 2 5
4 7 3 6 8 10
9 11
12
Figure14.26: Tree-based implementation of apartition consisting of three groups:
A={1,4,7}, B={2,3,6,9}, andC={5,8,10,11,12}.
With this partition data structure, operation ﬁnd(p) is performed by walking
up from position p tothe root of itstree, which takesO(n)time in the worst case.
Operation union(p,q) can be implemented by making one of the trees a subtree
of the other. This can be done by ﬁrst locating the two roots, and then in O(1)
additionaltimebysettingtheparentreferenceofoneroottopointtotheotherroot.
SeeFigure14.27foranexampleofbothoperations.
2 2
3 6 5 3 6 5
9 8 10 9 8 10
11 11
12 12
(a) (b)
Figure14.27: Tree-based implementation of a partition: (a) operationunion(p,q);684 Chapter14. GraphAlgorithms
Atﬁrst,thisimplementation mayseemtobenobetterthanthesequence-based
datastructure, butweaddthefollowingtwosimpleheuristicstomakeitrunfaster.
Union-by-Size: Witheachposition p,storethenumberofelementsinthesubtree
rootedat p. Inaunionoperation, maketherootofthesmallergroupbecome
achildoftheotherroot,andupdatethesizeﬁeldofthelargerroot.
PathCompression: In a ﬁnd operation, for each position q that the ﬁnd visits,
resettheparentofqtotheroot. (SeeFigure14.28.)
2 2
3 6 5 3 6 5
9 8 10 9 8 10
11 11
12 12
(a) (b)
Figure 14.28: Path-compression heuristic: (a) path traversed by operation ﬁnd on
element12;(b)restructured tree.
Asurprisingpropertyofthisdatastructure,whenimplementedusingtheunion-
by-sizeandpath-compression heuristics, isthatperformingaseriesofkoperations
involving n elements takes O(klog∗n) time, where log∗n is the log-star function,
∗
whichistheinverseofthetower-of-twosfunction. Intuitively, log nisthenumber
of times that one can iteratively take the logarithm (base 2) of a number before
gettinganumbersmallerthan2. Table14.4showsafewsamplevalues.
minimumn 2 22 =4 222 =16 2222 =65,536 22222 =265,536
∗
log n 1 2 3 4 5
∗
Table14.4: Somevaluesoflog nandcriticalvaluesforitsinverse.
Proposition 14.27: Whenusingthetree-basedpartitionrepresentationwithboth
union-by-sizeandpathcompression,performingaseriesofk make group,union,
andﬁnd operationsonaninitiallyemptypartitioninvolvingatmostn elements
takesO(klog∗n)time.
Although the analysis for this data structure is rather complex, its implemen-
tation is quite straightforward. We conclude with complete Python code for the14.7. MinimumSpanningTrees 685
1 class Partition:
2 ”””Union-ﬁnd structure for maintaining disjoint sets.”””
3
4 #------------------------- nested Position class -------------------------
5 class Position:
6 slots = _container , _element , _size , _parent
7
8 def init (self, container, e):
9 ”””Create a new position that is the leader of its own group.”””
10 self. container = container # reference to Partition instance
11 self. element = e
12 self. size = 1
13 self. parent = self # convention for a group leader
14
15 def element(self):
16 ”””Return element stored at this position.”””
17 return self. element
18
19 #------------------------- public Partition methods -------------------------
20 def make group(self, e):
21 ”””Makes a new group containing element e, and returns its Position.”””
22 return self.Position(self, e)
23
24 def ﬁnd(self, p):
25 ”””Finds the group containging p and return the position of its leader.”””
26 if p. parent != p:
27 p. parent = self.ﬁnd(p. parent) # overwrite p. parent after recursion
28 return p. parent
29
30 def union(self, p, q):
31 ”””Merges the groups containg elements p and q (if distinct).”””
32 a = self.ﬁnd(p)
33 b = self.ﬁnd(q)
34 if a is not b: # only merge if diﬀerent groups
35 if a. size > b. size:
36 b. parent = a
37 a. size += b. size
38 else:
39 a. parent = b
40 b. size += a. size
CodeFragment14.19: Pythonimplementation ofaPartitionclass using union-by-686 Chapter14. GraphAlgorithms
14.8 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-14.1 Draw a simple undirected graph G that has 12 vertices, 18 edges, and 3
connected components.
R-14.2 If G is a simple undirected graph with 12 vertices and 3 connected com-
ponents, whatisthelargestnumberofedgesitmighthave?
R-14.3 Draw an adjacency matrix representation of the undirected graph shown
inFigure14.1.
R-14.4 Draw an adjacency list representation of the undirected graph shown in
Figure14.1.
R-14.5 Draw a simple, connected, directed graph with 8 vertices and 16 edges
suchthatthein-degreeandout-degreeofeachvertexis2. Showthatthere
isasingle(nonsimple)cyclethatincludesalltheedgesofyourgraph,that
is, you can trace all the edges in their respective directions without ever
liftingyourpencil. (SuchacycleiscalledanEulertour.)
R-14.6 Suppose we represent a graph G having n vertices and m edges with the
edge list structure. Why, in this case, does the insert vertex method run
inO(1)timewhiletheremove vertexmethodrunsinO(m)time?
R-14.7 Givepseudo-codeforperformingtheoperationinsert edge(u,v,x)inO(1)
timeusingtheadjacency matrixrepresentation.
R-14.8 RepeatExerciseR-14.7fortheadjacency listrepresentation, asdescribed
inthechapter.
R-14.9 CanedgelistE beomittedfromtheadjacencymatrixrepresentationwhile
stillachieving thetimebounds giveninTable14.1? Whyorwhynot?
R-14.10 Can edge list E be omitted from the adjacency list representation while
stillachieving thetimebounds giveninTable14.3? Whyorwhynot?
R-14.11 Would you use the adjacency matrix structure or the adjacency list struc-
tureineachofthefollowingcases? Justifyyourchoice.
a. Thegraph has10,000 vertices and20,000 edges, anditisimportant
touseaslittlespaceaspossible.
b. The graph has 10,000 vertices and 20,000,000 edges, and it is im-
portanttouseaslittlespaceaspossible.
c. You need to answer the query get edge(u,v) as fast as possible, no14.8. Exercises 687
R-14.12 Explain why the DFS traversal runs inO(n2) time on an n-vertex simple
graphthatisrepresented withtheadjacency matrixstructure.
R-14.13 In order to verify that all of its nontree edges are back edges, redraw the
graph from Figure 14.8b so that the DFStree edges are drawn with solid
linesandorienteddownward,asinastandardportrayalofatree,andwith
allnontreeedgesdrawnusingdashedlines.
R-14.14 Asimpleundirectedgraphiscompleteifitcontainsanedgebetweenevery
pairofdistinct vertices. Whatdoesadepth-ﬁrst searchtreeofacomplete
graphlooklike?
R-14.15 RecallingthedeﬁnitionofacompletegraphfromExerciseR-14.14,what
doesabreadth-ﬁrst searchtreeofacompletegraphlooklike?
R-14.16 LetGbeanundirected graphwhosevertices aretheintegers1through 8,
andlettheadjacentverticesofeachvertexbegivenbythetablebelow:
vertex adjacentvertices
1 (2,3,4)
2 (1,3,4)
3 (1,2,4)
4 (1,2,3,6)
5 (6,7,8)
6 (4,5,7)
7 (5,6,8)
8 (5,7)
Assumethat,inatraversalofG,theadjacentverticesofagivenvertexare
returned inthesameorderastheyarelistedinthetableabove.
a. DrawG.
b. Give the sequence of vertices of G visited using a DFS traversal
starting atvertex1.
c. Give the sequence of vertices visited using a BFS traversal starting
atvertex1.
R-14.17 Drawthetransitive closureofthedirected graphshowninFigure14.2.
R-14.18 IftheverticesofthegraphfromFigure14.11arenumberedas(v =JFK,
1
v =LAX, v =MIA, v =BOS, v =ORD, v =SFO, v =DFW), in
2 3 4 5 6 7
what order would edges be added to the transitive closure during the
Floyd-Warshall algorithm?
R-14.19 Howmanyedgesareinthetransitive closure ofagraphthat consists ofa
simpledirected pathofnvertices?
R-14.20 Given an n-node complete binary treeT, rooted at a given position, con-
(cid:4)
sider a directed graph G having the nodes of T as its vertices. For each
(cid:4)
parent-child pair in T, create a directed edge in G from the parent to the688 Chapter14. GraphAlgorithms
R-14.21 Compute a topological ordering for the directed graph drawn with solid
edgesinFigure14.3d.
R-14.22 Boblovesforeignlanguagesandwantstoplanhiscoursescheduleforthe
following years. He is interested in the following nine language courses:
LA15, LA16, LA22, LA31, LA32, LA126, LA127, LA141, and LA169.
Thecourseprerequisites are:
• LA15: (none)
• LA16: LA15
• LA22: (none)
• LA31: LA15
• LA32: LA16,LA31
• LA126: LA22,LA32
• LA127: LA16
• LA141: LA22,LA16
• LA169: LA32
InwhatordercanBobtakethesecourses, respecting theprerequisites?
R-14.23 Draw a simple, connected, weighted graph with 8 vertices and16 edges,
eachwithuniqueedgeweights. Identifyonevertexasa“start”vertexand
illustrate arunning ofDijkstra’salgorithm onthisgraph.
R-14.24 Showhowtomodifythepseudo-codeforDijkstra’salgorithmforthecase
whenthegraphisdirectedandwewanttocomputeshortestdirectedpaths
fromthesourcevertextoalltheothervertices.
R-14.25 Drawasimple,connected,undirected, weightedgraphwith8verticesand
16 edges, each with unique edge weights. Illustrate the execution of the
Prim-Jarn´ık algorithm for computing the minimum spanning tree of this
graph.
R-14.26 Repeattheprevious problemforKruskal’salgorithm.
R-14.27 There are eight small islands in alake, and the state wants tobuild seven
bridgestoconnectthemsothateachislandcanbereachedfromanyother
one viaone ormorebridges. Thecostofconstructing abridgeispropor-
tionaltoitslength. Thedistancesbetweenpairsofislandsaregiveninthe
followingtable.
1 2 3 4 5 6 7 8
1 - 240 210 340 280 200 345 120
2 - - 265 175 215 180 185 155
3 - - - 260 115 350 435 195
4 - - - - 160 330 295 230
5 - - - - - 360 400 170
6 - - - - - - 175 205
7 - - - - - - - 305
8 - - - - - - - -14.8. Exercises 689
R-14.28 Describe the meaning of the graphical conventions used in Figure 14.9
illustrating a DFS traversal. What do the line thicknesses signify? What
dothearrowssignify? Howaboutdashed lines?
R-14.29 Repeat Exercise R-14.28 for Figure 14.8 that illustrates a directed DFS
traversal.
R-14.30 RepeatExerciseR-14.28forFigure14.10thatillustratesaBFStraversal.
R-14.31 Repeat ExerciseR-14.28 forFigure 14.11illustrating the Floyd-Warshall
algorithm.
R-14.32 Repeat Exercise R-14.28 for Figure 14.13 that illustrates the topological
sortingalgorithm.
R-14.33 RepeatExerciseR-14.28forFigures14.15and14.16illustratingDijkstra’s
algorithm.
R-14.34 Repeat Exercise R-14.28 for Figures 14.20 and 14.21 that illustrate the
Prim-Jarn´ıkalgorithm.
R-14.35 Repeat Exercise R-14.28 for Figures 14.22 through 14.24 that illustrate
Kruskal’salgorithm.
R-14.36 George claims he has a fast way to do path compression in a partition
structure,startingataposition p. Heputs pintoalistL,andstartsfollow-
ingparent pointers. Eachtimeheencounters anewposition,q,headds q
toLandupdatestheparentpointerofeachnodeinLtopointtoq’sparent.
ShowthatGeorge’salgorithm runsinΩ(h2)timeonapathoflengthh.
Creativity
C-14.37 Give a Python implementation of the remove vertex(v) method for our
adjacency map implementation of Section 14.2.5, making sure your im-
plementationworksforbothdirectedandundirectedgraphs. Yourmethod
shouldruninO(deg(v))time.
C-14.38 GiveaPythonimplementation oftheremove edge(e)methodforourad-
jacency map implementation of Section 14.2.5, making sure your imple-
mentation works for both directed and undirected graphs. Your method
shouldruninO(1)time.
C-14.39 Suppose we wish to represent an n-vertex graph G using the edge list
structure,assumingthatweidentifytheverticeswiththeintegersintheset
{0,1,...,n−1}. Describe how to implement the collection E to support
O(logn)-time performance for the get edge(u,v) method. How are you
implementing themethodinthiscase?
C-14.40 LetT bethespanningtreerootedatthestartvertexproducedbythedepth-
ﬁrstsearch ofaconnected, undirected graphG. Arguewhyeveryedgeof
G not in T goes from a vertex in T to one of its ancestors, that is, it is a690 Chapter14. GraphAlgorithms
C-14.41 Oursolution toreporting apathfromutovinCodeFragment14.6could
be made more efﬁcient in practice if the DFSprocess ended as soon as v
is discovered. Describe how to modify our code base to implement this
optimization.
C-14.42 Let G be an undirected graph G with n vertices and m edges. Describe
anO(n+m)-timealgorithmfortraversingeachedgeofGexactlyoncein
eachdirection.
(cid:4)
C-14.43 Implement an algorithm that returns a cycle in adirected graph G, if one
exists.
C-14.44 Write a function, components(g), for undirected graph g, that returns a
dictionarymappingeachvertextoanintegerthatservesasanidentiﬁerfor
its connected component. That is, two vertices should be mapped to the
sameidentiﬁerifandonlyiftheyareinthesameconnected component.
C-14.45 Saythatamazeisconstructedcorrectlyifthereisonepathfromthestart
to the ﬁnish, the entire maze is reachable from the start, andthere are no
loops around any portions of the maze. Given a maze drawn in an n×n
grid, how can we determine if it is constructed correctly? What is the
running timeofthisalgorithm?
C-14.46 Computer networks should avoid single points offailure, thatis, network
vertices that can disconnect the network if they fail. We say an undi-
rected, connected graph G is biconnected if it contains no vertex whose
removalwoulddivideGintotwoormoreconnectedcomponents. Givean
algorithm for adding at mostn edges toa connected graph G, with n≥3
vertices and m≥n−1 edges, to guarantee that G is biconnected. Your
algorithm should runinO(n+m)time.
C-14.47 Explainwhyallnontree edgesarecrossedges, withrespect toaBFStree
constructed foranundirected graph.
C-14.48 ExplainwhytherearenoforwardnontreeedgeswithrespecttoaBFStree
constructed foradirectedgraph.
C-14.49 Show that if T is aBFStree produced for a connected graphG, then, for
eachvertexvatleveli,thepathofT betweensandvhasiedges,andany
otherpathofGbetweensandvhasatleastiedges.
C-14.50 JustifyProposition 14.16.
C-14.51 Provideanimplementation oftheBFSalgorithm thatusesaFIFOqueue,
ratherthanalevel-by-levelformulation,tomanageverticesthathavebeen
discovered untilthetimewhentheirneighbors areconsidered.
C-14.52 AgraphGisbipartiteifitsverticescanbepartitionedintotwosetsX and
Y such that every edge in G has one end vertex in X and the other inY.
Designandanalyzeanefﬁcientalgorithmfordeterminingifanundirected14.8. Exercises 691
(cid:4)
C-14.53 An Euler tour of a directed graph G with n vertices and m edges is a
(cid:4)
cyclethattraverseseachedgeofGexactlyonceaccordingtoitsdirection.
(cid:4)
Such a tour always exists if G is connected and the in-degree equals the
out-degree ofeachvertex inG(cid:4). Describe anO(n+m)-timealgorithm for
(cid:4)
ﬁndinganEulertourofsuchadirectedgraphG.
C-14.54 AcompanynamedRT&Thasanetworkofnswitchingstationsconnected
bymhigh-speed communication links. Eachcustomer’s phoneisdirectly
connected to one station in his or her area. The engineers of RT&Thave
developed a prototype video-phone system that allows two customers to
see each other during a phone call. In order to have acceptable image
quality, however, the number of links used to transmit video signals be-
tween the two parties cannot exceed 4. Suppose that RT&T’snetwork is
represented by a graph. Design an efﬁcient algorithm that computes, for
eachstation, thesetofstations itcanreachusingnomorethan4links.
C-14.55 The time delay of a long-distance call can be determined by multiplying
asmallﬁxedconstant bythenumberofcommunication links onthetele-
phone network between the caller and callee. Suppose the telephone net-
workofacompany namedRT&Tisatree. Theengineers ofRT&Twant
tocompute themaximumpossible timedelay thatmaybeexperienced in
a long-distance call. Given a tree T, the diameter of T is the length of
a longest path between two nodes of T. Give an efﬁcient algorithm for
computing thediameterofT.
C-14.56 TamarindoUniversityandmanyotherschoolsworldwidearedoingajoint
project on multimedia. A computer network is built to connect these
schools using communication links that form a tree. The schools decide
to install a ﬁle server at one of the schools to share data among all the
schools. Since the transmission time on a link is dominated by the link
setupandsynchronization, thecostofadatatransferisproportionaltothe
numberoflinksused. Hence,itisdesirabletochoosea“central”location
for the ﬁle server. Givena treeT and anode v of T, the eccentricity of v
isthelengthofalongestpathfromvtoanyothernodeofT. AnodeofT
withminimumeccentricity iscalledacenterofT.
a. Designanefﬁcientalgorithmthat,givenann-nodetreeT,computes
acenterofT.
b. Is the center unique? If not, how many distinct centers can a tree
have?
(cid:4)
C-14.57 Saythat ann-vertex directed acyclic graphG iscompact if there issome
wayofnumberingtheverticesofG(cid:4) withtheintegersfrom0ton−1such
that G(cid:4) contains the edge (i,j) if and only ifi< j, for all i,j in [0,n−1].692 Chapter14. GraphAlgorithms
(cid:4)
C-14.58 Let G be a weighted directed graph with n vertices. Design a variation
of Floyd-Warshall’s algorithm for computing the lengths of the shortest
pathsfromeachvertextoeveryothervertexinO(n3)time.
C-14.59 Design an efﬁcient algorithm for ﬁnding a longest directed path from a
(cid:4)
vertexstoavertext ofanacyclicweighteddirectedgraphG. Specifythe
graph representation used and any auxiliary data structures used. Also,
analyzethetimecomplexityofyouralgorithm.
C-14.60 An independent set of an undirected graph G=(V,E) is a subset I ofV
suchthatnotwoverticesinI areadjacent. Thatis,ifuandvareinI,then
(u,v) is not in E. A maximal independent set M is an independent set
such that, ifweweretoadd anyadditional vertex toM,then itwould not
be independent any more. Every graph has a maximal independent set.
(Canyouseethis? Thisquestionisnotpartoftheexercise,butitisworth
thinking about.) Give an efﬁcient algorithm that computes a maximal
independent setforagraphG. Whatisthismethod’srunning time?
C-14.61 Give an example of an n-vertex simple graph G that causes Dijkstra’s
algorithm toruninΩ(n2logn)timewhenitsimplementedwithaheap.
(cid:4)
C-14.62 Give an example of a weighted directed graph G with negative-weight
edges, butnonegative-weight cycle, suchthatDijkstra’s algorithm incor-
rectlycomputestheshortest-path distances fromsomestartvertexs.
C-14.63 Consider the following greedy strategy for ﬁnding a shortest path from
vertexstarttovertexgoalinagivenconnected graph.
1: Initializepathtostart.
2: Initialize setvisitedto{start}.
3: Ifstart=goal, returnpathandexit. Otherwise,continue.
4: Findtheedge(start,v)ofminimumweightsuchthatvisadjacentto
startandvisnotinvisited.
5: Addvtopath.
6: Addvtovisited.
7: Setstartequaltovandgotostep3.
Does this greedy strategy always ﬁnd a shortest path fromstart to goal?
Eitherexplainintuitively whyitworks,orgiveacounterexample.
C-14.64 Ourimplementationofshortest path lengthsinCodeFragment14.13re-
liesonuseof“inﬁnity”asanumericvalue,torepresentthedistancebound
for vertices that are not (yet) known to be reachable from the source.
Reimplement thatfunction without such asentinel, sothatvertices, other
than the source, are notadded tothe priority queue until itis evident that
theyarereachable.
C-14.65 Showthatifalltheweightsinaconnected weightedgraphGaredistinct,14.8. Exercises 693
C-14.66 AnoldMSTmethod, calledBaru˚vka’s algorithm, worksas followson a
graphGhavingnverticesandmedgeswithdistinctweights:
LetT beasubgraph ofGinitiallycontaining justtheverticesinV.
whileT hasfewerthann−1edgesdo
foreachconnected componentC ofT do
i
Findthelowest-weight edge(u,v)inE withuinC andvnotin
i
C.
i
Add(u,v)toT (unless itisalready inT).
returnT
Provethatthisalgorithm iscorrectandthatitrunsinO(mlogn)time.
C-14.67 LetGbeagraphwithnverticesandmedgessuchthatalltheedgeweights
inGareintegers intherange[1,n]. Giveanalgorithm forﬁndingamini-
mumspanning treeforGinO(mlog∗n)time.
C-14.68 Consideradiagramofatelephonenetwork,whichisagraphGwhosever-
ticesrepresentswitchingcenters, andwhoseedgesrepresent communica-
tion lines joining pairs of centers. Edges are marked by their bandwidth,
and the bandwidth of a path is equal to the lowest bandwidth among the
path’s edges. Give an algorithm that, given a network and two switch-
ingcentersaandb,outputsthemaximumbandwidth ofapathbetweena
andb.
C-14.69 NASAwantstolinknstationsspreadoverthecountryusingcommunica-
tion channels. Each pair of stations has a different bandwidth available,
whichisknownapriori. NASAwantstoselectn−1channels (themini-
mumpossible)insuchawaythatallthestationsarelinkedbythechannels
and the total bandwidth (deﬁned as thesum ofthe individual bandwidths
of the channels) is maximum. Give an efﬁcient algorithm for this prob-
lemanddetermineitsworst-casetimecomplexity. Considertheweighted
graph G=(V,E), whereV is the set of stations andE is the set of chan-
nelsbetweenthestations. Deﬁnetheweightw(e)ofanedgeeinE asthe
bandwidth ofthecorresponding channel.
C-14.70 Inside the Castle ofAsymptopia there isamaze, and along each corridor
of the maze there is a bag of gold coins. The amount of gold in each
bagvaries. Anobleknight, namedSirPaul,willbegiventheopportunity
to walk through the maze, picking up bags of gold. He may enter the
maze only through a door marked “ENTER” and exit through another
door marked “EXIT.” While in the maze he may not retrace his steps.
Eachcorridor ofthemazehasanarrowpaintedonthewall. SirPaulmay
only go down the corridor in the direction of the arrow. Thereis no way
to traverse a“loop” in the maze. Given amap of the maze, including the
amount of gold in each corridor, describe an algorithm to help Sir Paul694 Chapter14. GraphAlgorithms
C-14.71 Supposeyouaregivenatimetable, whichconsistsof:
• A set A of n airports, and for each airport a in A, a minimum con-
nectingtimec(a).
• AsetF ofmﬂights,andthefollowing,foreachﬂight f inF:
◦ Originairporta (f)inA
1
◦ Destination airporta (f)inA
2
◦ Departuretimet (f)
1
◦ Arrivaltimet (f)
2
Describe an efﬁcient algorithm for the ﬂight scheduling problem. In this
problem,wearegivenairportsaandb,andatimet,andwewishtocom-
pute asequence ofﬂights thatallows onetoarrive attheearliest possible
time in b when departing from a at or after timet. Minimum connecting
timesatintermediateairportsmustbeobserved. Whatistherunningtime
ofyouralgorithm asafunctionofnandm?
(cid:4)
C-14.72 SupposewearegivenadirectedgraphGwithnvertices,andletM bethe
n×nadjacencymatrixcorresponding toG(cid:4).
a. Lettheproduct ofM withitself(M2)bedeﬁned, for1≤i,j≤n,as
follows:
M2(i,j)=M(i,1)(cid:25)M(1,j)⊕···⊕M(i,n)(cid:25)M(n,j),
where “⊕” is the Boolean or operator and “(cid:25)” is Boolean and.
Given this deﬁnition, what does M2(i,j) =1 imply about the ver-
ticesiand j? WhatifM2(i,j)=0?
b. Suppose M4 istheproduct ofM2 withitself. Whatdotheentries of
M4 signify? How about the entries of M5 =(M4)(M)? In general,
whatinformation iscontained inthematrixMp?
(cid:4)
c. Nowsuppose thatGisweightedandassumethefollowing:
1: for1≤i≤n,M(i,i)=0.
2: for1≤i,j≤n,M(i,j)=weight(i,j)if(i,j)isinE.
3: for1≤i,j≤n,M(i,j)=∞if(i,j)isnotinE.
Also,letM2 bedeﬁned,for1≤i,j≤n,asfollows:
M2(i,j)=min{M(i,1)+M(1,j),...,M(i,n)+M(n,j)}.
If M2(i,j) = k, what may we conclude about the relationship be-
tweenverticesiand j?
C-14.73 Karen has a new way to do path compression in a tree-based union/ﬁnd
partition data structure starting at a position p. She puts all the positions
that are on the path from pto the root in asetS. Then she scans through14.8. Exercises 695
pointer (recall that the parent pointer of the root points to itself). If this
pass changed the value of any position’s parent pointer, then she repeats
this process, and goes on repeating this process until she makes a scan
through S that does not change any position’s parent value. Show that
Karen’s algorithm is correct and analyze its running time for a path of
lengthh.
Projects
P-14.74 Use an adjacency matrix to implement a class supporting a simpliﬁed
graph ADT that does not include update methods. Your class should in-
clude a constructor method that takes two collections—a collection V of
vertex elements and a collection E of pairs of vertex elements—and pro-
ducesthegraphGthatthesetwocollections represent.
P-14.75 Implement the simpliﬁed graph ADTdescribed inProject P-14.74, using
theedgeliststructure.
P-14.76 Implement the simpliﬁed graph ADTdescribed inProject P-14.74, using
theadjacency liststructure.
P-14.77 Extend the class of Project P-14.76 to support the update methods of the
graphADT.
P-14.78 Design an experimental comparison of repeated DFS traversals versus
the Floyd-Warshall algorithm for computing the transitive closure of a
directed graph.
P-14.79 Perform an experimental comparison of two of the minimum spanning
tree algorithms discussed in this chapter (Kruskal and Prim-Jarn´ık). De-
velop an extensive set of experiments to test the running times of these
algorithms usingrandomly generated graphs.
P-14.80 Onewaytoconstruct amazestarts withann×ngrid such that each grid
cell is bounded by four unit-length walls. Wethen remove twoboundary
unit-length walls, to represent the start and ﬁnish. For each remaining
unit-length wall not on the boundary, we assign a random value and cre-
ate a graph G, called the dual, such that each grid cell is a vertex in G
and there is an edge joining the vertices for two cells if and only if the
cells share a common wall. The weight of each edge is the weight of the
corresponding wall. We construct the maze by ﬁnding a minimum span-
ning tree T for G and removing all the walls corresponding to edges in
T. Write a program that uses this algorithm to generate mazes and then
solvesthem. Minimally,yourprogramshoulddrawthemazeand,ideally,696 Chapter14. GraphAlgorithms
P-14.81 Writeaprogram thatbuildstheroutingtablesforthenodesinacomputer
network, basedonshortest-path routing, wherepathdistance ismeasured
by hop count, that is, the number of edges in a path. The input for this
problem is the connectivity information for all the nodes inthe network,
asinthefollowingexample:
241.12.31.14: 241.12.31.15 241.12.31.18 241.12.31.19
which indicates three network nodes that are connected to 241.12.31.14,
thatis,threenodesthatareonehopaway. Theroutingtableforthenodeat
address Aisasetofpairs(B,C),whichindicates that, toroute amessage
from A to B, the next node to send to (on the shortest path from A to B)
isC. Your program should output the routing table for each node in the
network, given an input list of node connectivity lists, each of which is
inputinthesyntaxasshownabove,oneperline.
Chapter Notes
Thedepth-ﬁrstsearchmethodisapartofthe“folklore”ofcomputerscience,butHopcroft
and Tarjan [52, 94] are the ones who showed how useful this algorithm is for solving
several different graph problems. Knuth [64] discusses the topological sorting problem.
The simple linear-time algorithm that we describe for determining if a directed graph is
stronglyconnectedis due to Kosaraju. The Floyd-Warshallalgorithmappearsin a paper
byFloyd[38]andisbaseduponatheoremofWarshall[102].
The ﬁrst known minimum spanning tree algorithm is due to Baru˚vka [9], and was
publishedin1926. ThePrim-Jarn´ıkalgorithmwasﬁrstpublishedinCzechbyJarn´ık[55]
in 1930 and in English in 1957 by Prim [85]. Kruskalpublishedhis minimum spanning
tree algorithm in 1956 [67]. The reader interested in further study of the history of the
minimum spanning tree problem is referred to the paper by Graham and Hell [47]. The
currentasymptoticallyfastest minimumspanningtree algorithmis a randomizedmethod
ofKarger,Klein,andTarjan[57]thatrunsinO(m)expectedtime. Dijkstra[35]published
his single-source, shortest-path algorithmin 1959. The runningtime for the Prim-Jarn´ık
algorithm,andalsothatofDijkstra’salgorithm,canactuallybeimprovedtobeO(nlogn+
m)byimplementingthequeueQwitheitheroftwomoresophisticateddatastructures,the
“FibonacciHeap”[40]orthe“RelaxedHeap”[37].
Tolearnaboutdifferentalgorithmsfordrawinggraphs,pleaseseethebookchapterby
TamassiaandLiotta[92]andthebookbyDiBattista,Eades,TamassiaandTollis[34]. The
reader interested in further study of graph algorithms is referred to the books by Ahuja,
Magnanti, and Orlin [7], Cormen, Leiserson, Rivest and Stein [29], Mehlhorn [77], andChapter
15
Memory Management and B-Trees
Contents
15.1 Memory Management . . . . . . . . . . . . . . . . . . . . . 698
15.1.1 Memory Allocation . . . . . . . . . . . . . . . . . . . . . 699
15.1.2 Garbage Collection . . . . . . . . . . . . . . . . . . . . . 700
15.1.3 Additional Memory Used by the Python Interpreter . . . . 703
15.2 Memory Hierarchies and Caching . . . . . . . . . . . . . . 705
15.2.1 Memory Systems . . . . . . . . . . . . . . . . . . . . . . 705
15.2.2 Caching Strategies . . . . . . . . . . . . . . . . . . . . . 706
15.3 External Searching and B-Trees . . . . . . . . . . . . . . . 711
15.3.1 (a,b) Trees. . . . . . . . . . . . . . . . . . . . . . . . . . 712
15.3.2 B-Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . 714
15.4 External-Memory Sorting . . . . . . . . . . . . . . . . . . . 715
15.4.1 Multiway Merging . . . . . . . . . . . . . . . . . . . . . . 716698 Chapter15. MemoryManagementandB-Trees
Ourstudy of data structures thus far has focused primarily upon the efﬁciency
of computations, as measured by the number of primitive operations that are exe-
cuted on a central processing unit (CPU). In practice, the performance of a com-
putersystemisalsogreatlyimpactedbythemanagementofthecomputer’smemory
systems. Inouranalysisofdatastructures,wehaveprovidedasymptoticboundsfor
theoverallamountofmemoryusedbyadatastructure. Inthischapter,weconsider
moresubtleissuesinvolving theuseofacomputer’s memorysystem.
Weﬁrstdiscusswaysinwhichmemoryisallocatedanddeallocated duringthe
execution of a computer program, and the impact that this has on the program’s
performance. Second,wediscussthecomplexityofmultilevelmemoryhierarchies
in today’s computer systems. Although we often abstract a computer’s memory
as consisting of a single pool of interchangeable locations, in practice, the data
used by an executing program is stored and transferred between a combination
of physical memories (e.g., CPU registers, caches, internal memory, and external
memory). We consider the use of classic data structures in the algorithms used to
manage memory, and how the use of memory hierarchies impacts the choice of
datastructures andalgorithms forclassicproblemssuchassearching andsorting.
15.1 Memory Management
In order to implement any data structure on an actual computer, we need to use
computermemory. Computermemoryisorganized intoasequenceofwords,each
ofwhichtypicallyconsistsof4,8,or16bytes(dependingonthecomputer). These
memory words are numbered from 0 to N−1, where N is the number of mem-
ory words available to the computer. The number associated with each memory
word is known as its memory address. Thus, the memory in a computer can be
viewed as basically one giant array of memory words. Forexample, in Figure 5.1
ofSection5.2,weportrayed asectionofthecomputer’s memoryasfollows:
4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 6
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
In order to run programs and store information, the computer’s memory must
be managed so as to determine what data is stored in what memory cells. Inthis
section,wediscussthebasicsofmemorymanagement,mostnotablydescribingthe
wayinwhichmemoryisallocated tostore newobjects, thewayinwhichportions
ofmemory aredeallocated and reclaimed, whenno longer needed, and thewayin15.1. MemoryManagement 699
15.1.1 Memory Allocation
With Python, all objects are stored in a pool of memory, known as the memory
heaporPythonheap(whichshouldnotbeconfusedwiththe“heap”datastructure
presented inChapter9). Whenacommandsuchas
w = Widget()
is executed, assuming Widget is the name of a class, a new instance of the class
is created and stored somewhere within the memory heap. The Python interpreter
is responsible for negotiating the use of space with the operating system and for
managingtheuseofthememoryheapwhenexecutingaPythonprogram.
Thestorageavailableinthememoryheapisdividedintoblocks,whicharecon-
tiguous array-like “chunks” ofmemorythat maybeofvariable orﬁxedsizes. The
system must be implemented so that it can quickly allocate memory for new ob-
jects. Onepopular methodistokeepcontiguous “holes” ofavailable freememory
in a linked list, called the free list. The links joining these holes are stored inside
theholesthemselves,sincetheirmemoryisnotbeingused. Asmemoryisallocated
and deallocated, the collection of holes in the free lists changes, with the unused
memorybeingseparatedintodisjointholesdividedbyblocksofusedmemory. This
separation ofunused memory into separate holes isknown asfragmentation. The
problem isthat it becomes moredifﬁcult toﬁndlarge continuous chunks of mem-
ory, when needed, even though an equivalent amount of memory may be unused
(yetfragmented). Therefore, wewouldliketominimizefragmentation asmuchas
possible.
There are two kinds of fragmentation that can occur. Internal fragmentation
occurs when a portion of an allocated memory block is unused. For example, a
program may request an array of size 1000, but only use the ﬁrst 100 cells of this
array. There is not much that a run-time environment can do to reduce internal
fragmentation. External fragmentation, ontheother hand, occurs whenthere isa
signiﬁcant amount of unused memory between several contiguous blocks of allo-
cated memory. Since the run-time environment has control over where to allocate
memorywhenitisrequested, therun-timeenvironment shouldallocatememoryin
awaytotrytoreduceexternalfragmentation asmuchasreasonably possible.
Several heuristics have been suggested for allocating memory from the heap
so as to minimize external fragmentation. Thebest-ﬁt algorithm searches the en-
tire free list to ﬁnd the hole whose size is closest to the amount of memory being
requested. The ﬁrst-ﬁt algorithm searches from the beginning of the free list for
the ﬁrst hole that is large enough. The next-ﬁt algorithm is similar, in that it also
searches the free list for the ﬁrst hole that is large enough, but it begins its search
from where it left off previously, viewing the free list as a circularly linked list
(Section 7.2). Theworst-ﬁtalgorithmsearches thefree listtoﬁndthe largest hole700 Chapter15. MemoryManagementandB-Trees
if this list were maintained as a priority queue (Chapter 9). In each algorithm, the
requested amount of memory is subtracted from the chosen memory hole and the
leftoverpartofthatholeisreturned tothefreelist.
Although it might sound good at ﬁrst, the best-ﬁt algorithm tends to produce
the worst external fragmentation, since the leftover partsof the chosen holes tend
to be small. The ﬁrst-ﬁt algorithm is fast, but it tends to produce a lot of external
fragmentation at the front of the free list, which slows downfuture searches. The
next-ﬁtalgorithmspreadsfragmentationmoreevenlythroughoutthememoryheap,
thus keeping search times low. This spreading also makesit moredifﬁcult toallo-
cate large blocks, however. Theworst-ﬁtalgorithm attempts toavoid this problem
bykeepingcontiguous sections offreememoryaslargeaspossible.
15.1.2 Garbage Collection
Insomelanguages, like Cand C++,the memoryspace forobjects mustbeexplic-
itlydeallocated bytheprogrammer, whichisadutyoftenoverlooked bybeginning
programmers and is the source of frustrating programming errors even for experi-
encedprogrammers. ThedesignersofPythoninsteadplacedtheburdenofmemory
management entirely on the interpreter. The process of detecting “stale” objects,
deallocating the space devoted to those objects, and returning the reclaimed space
tothefreelistisknownasgarbage collection.
To perform automated garbage collection, there must ﬁrst be a way to detect
those objects that are no longer necessary. Since the interpreter cannot feasibly
analyze the semantics of an arbitrary Python program, it relies on the following
conservativeruleforreclaimingobjects. Inorderforaprogramtoaccessanobject,
itmusthaveadirectorindirectreferencetothatobject. Wewilldeﬁnesuchobjects
tobeliveobjects. Indeﬁning aliveobject, adirect referencetoanobject isinthe
formofanidentiﬁerinanactivenamespace(i.e.,theglobalnamespace,orthelocal
namespace foranyactive function). Forexample, immediately after thecommand
w = Widget() is executed, identiﬁer w will be deﬁned in the current namespace
as a reference to the new widget object. We refer to all such objects with direct
references as root objects. An indirect reference to a live object is a reference
that occurs within the state of some other live object. For example, if the widget
instanceinourearlierexamplemaintainsalistasanattribute, thatlistisalsoalive
object (as it can be reached indirectly through use of identiﬁer w). The set of live
objects aredeﬁned recursively; thus, anyobjects thatarereferenced within thelist
thatisreferenced bythewidgetarealsoclassiﬁedasliveobjects.
ThePythoninterpreterassumesthatliveobjectsaretheactiveobjectscurrently
beingusedbytherunningprogram;theseobjectsshouldnotbedeallocated. Other
objects canbe garbage collected. Python relies on thefollowing twostrategies for15.1. MemoryManagement 701
Reference Counts
WithinthestateofeveryPythonobjectisanintegerknownasitsreference count.
Thisisthecountofhowmanyreferencestotheobjectexistanywhereinthesystem.
Everytimeareferenceisassignedtothisobject,itsreferencecountisincremented,
andeverytimeoneofthosereferencesisreassignedtosomethingelse,thereference
count for theformer object is decremented. Themaintenance ofareference count
for each object adds O(1) space per object, and the increments and decrements to
thecountaddO(1)additional computation timepersuchoperations.
The Python interpreter allows a running program to examine an object’s ref-
erence count. Within the sys module there is a function named getrefcount that
returns anintegerequaltothereference countfortheobjectsentasaparameter. It
isworthnotingthatbecausetheformalparameterofthatfunctionisassignedtothe
actualparameter sentbythecaller, thereistemporarily oneadditional reference to
thatobjectinthelocalnamespaceofthefunctionatthetimethecountisreported.
Theadvantage ofhaving areference countforeach object isthatifanobject’s
count is ever decremented to zero, that object cannot possibly be alive object and
therefore the system can immediately deallocate the object (or place it in a queue
ofobjects thatarereadytobedeallocated).
Cycle Detection
Although it is clear that an object with a reference count of zero cannot be a live
object, it is important to recognize that an object with a nonzero reference count
neednotqualifyaslive. Theremayexistagroupofobjectsthathavereferences to
eachother, eventhoughnoneofthoseobjects arereachable fromarootobject.
Forexample, arunning Python program may have an identiﬁer, data, that is a
reference to a sequence implemented using a doubly linked list. In this case, the
list referenced bydataisaroot object, theheader and trailer nodes that are stored
as attributes of the list are live objects, as are all the intermediate nodes of the list
that are indirectly referenced and all the elements that are referenced as elements
of those nodes. Ifthe identiﬁer, data, were togo out ofscope, or tobe reassigned
to some other object, the reference count for the list instance may go to zero and
be garbage collected, but the reference counts for all of the nodes would remain
nonzero, stopping themfrombeinggarbagecollected bythesimpleruleabove.
Every so often, in particular when the available space in the memory heap is
becoming scarce, the Python interpreter uses a more advanced form of garbage
collection to reclaim objects that are unreachable, despite their nonzero reference
counts. There are different algorithms for implementing cycle detection. (The
mechanics of garbage collection in Python are abstracted in the gc module, and
mayvarydepending ontheimplementation oftheinterpreter.) Aclassicalgorithm702 Chapter15. MemoryManagementandB-Trees
The Mark-Sweep Algorithm
In the mark-sweep garbage collection algorithm, we associate a “mark” bit with
each object that identiﬁes whether that object is live. Whenwedetermine atsome
point that garbage collection is needed, we suspend all other activity and clear
the mark bits of all the objects currently allocated in the memory heap. We then
tracethroughtheactivenamespaces andwemarkalltherootobjects as“live.” We
mustthendeterminealltheotherliveobjects—theonesthatarereachablefromthe
root objects. To do this efﬁciently, we can perform a depth-ﬁrst search (see Sec-
tion14.3.1)onthedirectedgraphthatisdeﬁnedbyobjectsreferenceotherobjects.
In this case, each object in the memory heap is viewed as a vertex in a directed
graph, and the reference from one object to another is viewedas a directed edge.
ByperformingadirectedDFSfromeachrootobject,wecancorrectlyidentifyand
mark each live object. This process is known as the “mark” phase. Once this pro-
cesshascompleted, wethenscanthroughthememoryheapandreclaimanyspace
thatisbeingusedforanobjectthathasnotbeenmarked. Atthistime,wecanalso
optionally coalesce alltheallocated space inthememoryheapinto asingle block,
thereby eliminating external fragmentation for the time being. This scanning and
reclamation process is known as the “sweep” phase, and when it completes, we
resume running the suspended program. Thus, the mark-sweep garbage collec-
tionalgorithmwillreclaimunusedspaceintimeproportional tothenumberoflive
objectsandtheirreferences plusthesizeofthememoryheap.
Performing DFS In-Place
The mark-sweep algorithm correctly reclaims unused space in the memory heap,
but there is an important issue we must face during the mark phase. Since we are
reclaimingmemoryspaceatatimewhenavailablememoryisscarce,wemusttake
care not to use extra space during the garbage collection itself. The trouble is that
theDFSalgorithm,intherecursivewaywehavedescribeditinSection14.3.1,can
usespaceproportionaltothenumberofverticesinthegraph. Inthecaseofgarbage
collection, theverticesinourgrapharetheobjects inthememoryheap;hence, we
probably donothavethismuchmemorytouse. Soouronlyalternative istoﬁnda
waytoperformDFSin-placeratherthanrecursively, thatis,wemustperformDFS
usingonlyaconstant amountofadditional storage.
The main idea for performing DFS in-place is to simulate the recursion stack
using the edges of the graph (which in the case of garbage collection correspond
to object references). When we traverse an edge from a visited vertex v to a new
vertexw,wechange theedge(v,w)stored inv’sadjacency listtopointback tov’s
parent in the DFS tree. When we return back tov (simulating the return from the
“recursive” callatw),wecanthenswitchtheedgewemodiﬁedtopointbacktow,15.1. MemoryManagement 703
15.1.3 Additional Memory Used by the Python Interpreter
Wehavediscussed,inSection15.1.1,howthePythoninterpreterallocatesmemory
for objects within a memory heap. However, this is not the only memory that is
used when executing a Python program. In this section, we discuss some other
importantusesofmemory.
The Run-Time Call Stack
Stacks have a most important application to the run-time environment of Python
programs. A running Python program has a private stack, known as the call stack
or Python interpreter stack, that is used to keep track of the nested sequence of
currently active (that is, nonterminated) invocations of functions. Each entry of
the stack is a structure known as anactivation record or frame, storing important
information aboutaninvocation ofafunction.
Atthe top of the call stack is the activation record of therunningcall, that is,
the function activation that currently has control of the execution. The remaining
elements of the stack are activation records of the suspended calls, that is, func-
tions that have invoked another function and are currently waiting for that other
functiontoreturncontrolwhenitterminates. Theorderoftheelementsinthestack
corresponds to the chain of invocations of the currently active functions. When a
new function is called, an activation record for that call is pushed onto the stack.
When it terminates, its activation record is popped from thestack and the Python
interpreter resumestheprocessing ofthepreviously suspended call.
Each activation record includes a dictionary representing the local namespace
for the function call. (See Sections 1.10 and 2.5 for further discussion of name-
spaces). The namespace maps identiﬁers, which serve as parameters and local
variables, toobject values, although the objects being referenced still reside in the
memoryheap. Theactivation recordforafunction callalsoincludesareferenceto
thefunctiondeﬁnitionitself,andaspecialvariable,knownastheprogramcounter,
to maintain the address of the statement within the function that is currently exe-
cuting. When one function returns control to another, the stored program counter
forthesuspended function allowstheinterpreter toproperly continue execution of
thatfunction.
Implementing Recursion
One of the beneﬁts of using a stack to implement the nesting of function calls is
that it allows programs to use recursion. That is, it allows a function to call it-
self, as discussed in Chapter 4. We implicitly described the concept of the call704 Chapter15. MemoryManagementandB-Trees
that chapter. Interestingly, early programming languages, such as Cobol and For-
tran, did not originally usecall stacks toimplement function calls. Butbecause of
the elegance and efﬁciency that recursion allows, almost all modern programming
languages utilize a call stack for function calls, including the current versions of
classiclanguages likeCobolandFortran.
Eachboxofarecursive tracecorresponds toanactivation recordthatisplaced
on the call stack during the execution of a recursive function. At any point in
time,thecontentofthecallstackcorresponds tothechainofboxesfromtheinitial
function invocation to the current one. Tobetter illustrate how acall stack is used
by recursive functions, we refer back to the Python implementation of the classic
recursivedeﬁnition ofthefactorial function,
n!=n(n−1)(n−2)···1,
with the code originally given in Code Fragment 4.1, and the recursive trace in
Figure 4.1. The ﬁrst time we call factorial, its activation record includes a name-
space storing the parameter value n. The function recursively calls itself to com-
pute(n−1)!,causinganewactivation record,withitsownnamespaceandparam-
eter,tobepushedontothecallstack. Inturn,thisrecursiveinvocationcallsitselfto
compute (n−2)!, and so on. The chain of recursive invocations, and thus thecall
stack, grows up to size n+1, with the most deeply nested call being factorial(0),
which returns 1 without any further recursion. The run-time stack allows several
invocations ofthefactorialfunctiontoexistsimultaneously. Eachhasanactivation
recordthatstoresthevalueofitsparameter,andeventuallythevaluetobereturned.
Whentheﬁrstrecursivecalleventuallyterminates,itreturns(n−1)!,whichisthen
multiplied byntocomputen!fortheoriginalcallofthefactorialmethod.
The Operand Stack
Interestingly, there is actually another place where the Python interpreter uses a
stack. Arithmetic expressions, such as ((a+b)∗(c+d))/e, are evaluated by the
interpreter usinganoperandstack. InSection8.5wedescribedhowtoevaluatean
arithmeticexpression usingapostorder traversal ofanexplicitexpression tree. We
describedthatalgorithminarecursiveway;however,thisrecursivedescriptioncan
besimulatedusinganonrecursive processthatmaintainsanexplicitoperandstack.
A simple binary operation, such as a+b, is computed by pushing a on the stack,
pushing b on the stack, and then calling an instruction that pops the top two items
from the stack, performs the binary operation on them, and pushes the result back
ontothestack. Likewise,instructions forwritingandreadingelementstoandfrom15.2. MemoryHierarchiesandCaching 705
15.2 Memory Hierarchies and Caching
With the increased use of computing in society, software applications must man-
age extremely large data sets. Such applications include the processing of online
ﬁnancial transactions, the organization and maintenance of databases, and analy-
sesofcustomers’ purchasing histories andpreferences. Theamountofdatacanbe
so large that the overall performance of algorithms and datastructures sometimes
depends moreonthetimetoaccessthedatathanonthespeedoftheCPU.
15.2.1 Memory Systems
In order to accommodate large data sets, computers have a hierarchy of differ-
ent kinds of memories, which vary in terms of their size and distance from the
CPU. Closest to the CPU are the internal registers that the CPU itself uses. Ac-
cess to such locations is very fast, but there are relatively few such locations. At
the second level in the hierarchy are one or more memory caches. This memory
is considerably larger than the register set of a CPU,but accessing it takes longer.
Atthe third level in the hierarchy is theinternal memory, which is also known as
main memory or core memory. The internal memory is considerably larger than
the cache memory, but also requires more time to access. Another level in the hi-
erarchy is theexternal memory, which usually consists of disks, CD drives, DVD
drives,and/ortapes. Thismemoryisverylarge,butitisalsoveryslow. Datastored
through an external network can be viewed as yet another level in this hierarchy,
with even greater storage capacity, but even slower access. Thus, the memory hi-
erarchy for computers can be viewed as consisting of ﬁve or more levels, each of
which is larger and slower than the previous level. (See Figure 15.1.) During the
execution ofaprogram, data isroutinely copied from onelevelofthehierarchy to
aneighboring level,andthesetransfers canbecomeacomputational bottleneck.
Network Storage Faster
ExternalMemory
InternalMemory
Caches
Bigger Registers
CPU706 Chapter15. MemoryManagementandB-Trees
15.2.2 Caching Strategies
The signiﬁcance of the memory hierarchy on the performance of a program de-
pends greatly upon thesize of the problem weare trying tosolve and thephysical
characteristics of the computer system. Often, the bottleneck occurs between two
levels of the memoryhierarchy—the one that can hold all dataitems and the level
just below that one. For a problem that can ﬁt entirely in main memory, the two
mostimportantlevelsarethecachememoryandtheinternalmemory. Accesstimes
forinternal memorycanbeasmuchas10to100timeslongerthanthoseforcache
memory. It is desirable, therefore, to be able to perform most memory accesses
in cache memory. For a problem that does not ﬁt entirely in main memory, on
the other hand, the two most important levels are the internal memory and the ex-
ternal memory. Here the differences are even more dramatic, for access times for
disks, theusual general-purpose external-memory device,aretypically asmuchas
100000to1000000 timeslongerthanthoseforinternal memory.
Toputthislatterﬁgureintoperspective,imaginethereisastudentinBaltimore
who wants to send a request-for-money message to his parents in Chicago. If the
student sends his parents an email message, it can arrive at their home computer
in about ﬁve seconds. Think of this mode of communication as corresponding to
aninternal-memory accessbyaCPU.Amodeofcommunicationcorresponding to
an external-memory access that is 500,000 times slower would be for the student
to walk to Chicago and deliver his message in person, which would take about a
month if he can average 20 miles per day. Thus, we should make as few accesses
toexternal memoryaspossible.
Mostalgorithms are notdesigned withthe memoryhierarchy inmind, inspite
of the great variance between access times for the different levels. Indeed, all of
thealgorithm analyses described inthisbooksofarhaveassumedthatallmemory
accesses are equal. Thisassumption might seem, at ﬁrst, tobeagreat oversight—
andoneweareonlyaddressingnowintheﬁnalchapter—buttherearegoodreasons
whyitisactually areasonable assumptiontomake.
Onejustiﬁcation forthisassumption isthatitisoftennecessary toassumethat
allmemoryaccessestakethesameamountoftime,sincespeciﬁcdevice-dependent
information about memory sizes is often hard to come by. In fact, information
about memory size may be difﬁcult to get. For example, a Python program that
is designed to run on many different computer platforms cannot easily be deﬁned
in terms of a speciﬁc computer architecture conﬁguration. We can certainly use
architecture-speciﬁc information, if we have it (and we will show how to exploit
such information later in this chapter). But once we have optimized our software
for a certain architecture conﬁguration, our software will no longer be device-
independent. Fortunately, such optimizations are not always necessary, primarily15.2. MemoryHierarchiesandCaching 707
Caching and Blocking
Another justiﬁcation for the memory-access equality assumption is that operating
system designers have developed general mechanisms that allow most memory
accesses to be fast. These mechanisms are based on two important locality-of-
referenceproperties thatmostsoftwarepossesses:
• Temporal locality: If a program accesses a certain memory location, then
there is increased likelihood that it accesses that same location again in the
near future. For example, it is common to use the value of a counter vari-
ableinseveraldifferentexpressions,includingonetoincrementthecounter’s
value. Infact,acommonadageamongcomputerarchitectsisthataprogram
spends90percentofitstimein10percentofitscode.
• Spatiallocality: Ifaprogramaccessesacertainmemorylocation,thenthere
isincreased likelihood thatitsoon accesses other locations thatarenearthis
one. For example, a program using an array may be likely to access the
locations ofthisarrayinasequential ornear-sequential manner.
Computerscientistsandengineers haveperformedextensivesoftwareproﬁlingex-
periments to justify the claim that most software possesses both of these kinds of
localityofreference. Forexample,anestedforloopusedtorepeatedlyscanthrough
anarraywillexhibitbothkindsoflocality.
Temporal and spatial localities have, in turn, given rise to two fundamental
design choices for multilevel computer memory systems (which are present in the
interface between cache memory and internal memory, and also in the interface
betweeninternalmemoryandexternalmemory).
Theﬁrstdesign choice iscalledvirtualmemory. Thisconcept consists ofpro-
vidinganaddressspaceaslargeasthecapacityofthesecondary-levelmemory,and
oftransferringdatalocatedinthesecondarylevelintotheprimarylevel,whenthey
are addressed. Virtual memory does not limit the programmerto the constraint of
the internal memory size. The concept of bringing data into primary memory is
called caching, anditismotivated bytemporal locality. Bybringing datainto pri-
mary memory, we are hoping that it will be accessed again soon, and we will be
abletorespondquicklytoalltherequestsforthisdatathatcomeinthenearfuture.
The second design choice is motivated by spatial locality. Speciﬁcally, if data
stored at a secondary-level memory location (cid:3) is accessed, then we bring into
primary-level memory a large block of contiguous locations that include the lo-
cation(cid:3). (SeeFigure15.2.) Thisconcept isknownasblocking, anditismotivated
bytheexpectationthatothersecondary-level memorylocationscloseto(cid:3)willsoon
be accessed. In the interface between cache memory and internal memory, such
blocks are often called cache lines, and in the interface between internal memory708 Chapter15. MemoryManagementandB-Trees
A block on disk
A block in the external memory address space
0 1 2 3 ... 1024 ... 2048 ...
Figure15.2: Blocksinexternalmemory.
When implemented with caching and blocking, virtual memory often allows
us to perceive secondary-level memory as being faster than it really is. There is
still a problem, however. Primary-level memory is much smaller than secondary-
level memory. Moreover, because memory systems use blocking, any program
of substance will likely reach a point where it requests data from secondary-level
memory, but the primary memory is already full of blocks. In order to fulﬁll the
requestandmaintainouruseofcachingandblocking,wemustremovesomeblock
from primary memory to make room for a new block from secondary memory in
this case. Deciding which block to evict brings up a number of interesting data
structure andalgorithm designissues.
Caching in Web Browsers
Formotivation, weconsider arelated problem thatarises whenrevisiting informa-
tion presented in Web pages. To exploit temporal locality ofreference, it is often
advantageous to store copies of Web pages in a cache memory, so these pages
canbequickly retrievedwhenrequested again. Thiseffectively createsatwo-level
memoryhierarchy, withthecacheservingasthesmaller,quickerinternalmemory,
andthenetworkbeingtheexternalmemory. Inparticular, supposewehaveacache
memorythathasm“slots”thatcancontainWebpages. WeassumethataWebpage
canbeplacedinanyslotofthecache. Thisisknownasafullyassociative cache.
Asabrowser executes, itrequests different Webpages. Eachtimethebrowser
requests such a Web page p, the browser determines (using a quick test) if p is
unchanged and currently contained in the cache. If p is contained in the cache,
then the browser satisﬁes the request using the cached copy. If p is not in the
cache, however, the page for p is requested over the Internet and transferred into
the cache. If one of the m slots in the cache is available, then the browser assigns
p to one of the empty slots. But if all the m cells of the cache are occupied, then
the computer must determine which previously viewed Web page to evict before
bringingin ptotakeitsplace. Thereare,ofcourse,manydifferentpoliciesthatcan15.2. MemoryHierarchiesandCaching 709
Page Replacement Algorithms
Some of the better-known page replacement policies include the following (see
Figure15.3):
• First-in, ﬁrst-out (FIFO): Evict the page that has been in the cache the
longest,thatis,thepagethatwastransferredtothecachefurthestinthepast.
• Leastrecentlyused(LRU):Evictthepagewhoselastrequestoccurred fur-
thestinthepast.
Inaddition, wecanconsiderasimpleandpurelyrandomstrategy:
• Random: Chooseapageatrandom toevictfromthecache.
New block Old block (chosen at random)
Random policy:
New block Old block (present longest)
FIFO policy:
insert time: 8:00am 7:48am 9:05am 7:10am 7:30am 10:10am 8:45am
New block Old block (least recently used)
LRU policy:
last used: 7:25am 8:12am 9:22am 6:50am 8:20am 10:02am 9:50am
Figure15.3: Therandom,FIFO,andLRUpagereplacement policies.
Therandom strategy is one ofthe easiest policies toimplement, for it only re-
quires a random or pseudo-random number generator. The overhead involved in
implementing this policy is an O(1) additional amount of work per page replace-
ment. Moreover,thereisnoadditionaloverheadforeachpagerequest,otherthanto
determine whetherapagerequest isinthecacheornot. Still,thispolicymakesno710 Chapter15. MemoryManagementandB-Trees
The FIFO strategy is quite simple to implement, as it only requires a queue
Q to store references to the pages in the cache. Pages are enqueued in Q when
they are referenced by a browser, and then are brought into the cache. When a
pageneeds tobeevicted, thecomputer simplyperforms adequeue operation onQ
to determine which page to evict. Thus, this policy also requires O(1) additional
work per page replacement. Also, the FIFO policy incurs no additional overhead
forpagerequests. Moreover,ittriestotakesomeadvantageoftemporallocality.
TheLRUstrategygoesastepfurtherthantheFIFOstrategy,fortheLRUstrat-
egyexplicitly takes advantage oftemporal locality asmuchaspossible, byalways
evicting the page that wasleast-recently used. From apolicy point of view, this is
an excellent approach, but it iscostly from an implementation point ofview. That
is, its way of optimizing temporal and spatial locality is fairly costly. Implement-
ingtheLRUstrategyrequirestheuseofanadaptablepriorityqueueQthatsupports
updatingthepriorityofexistingpages. IfQisimplementedwithasortedsequence
based on a linked list, then the overhead for each page request and page replace-
ment is O(1). When we insert a page in Q or update its key, the page is assigned
the highest key in Q and is placed at the end of the list, which can also be done
in O(1) time. Even though the LRU strategy has constant-time overhead, using
theimplementation above, theconstant factors involved, intermsoftheadditional
time overhead and the extra space for the priority queue Q, make this policy less
attractivefromapractical pointofview.
Since these different page replacement policies have different trade-offs be-
tween implementation difﬁculty and the degree to which theyseem to take advan-
tage of localities, it is natural for us to ask for some kind ofcomparative analysis
ofthesemethodstoseewhichone,ifany,isthebest.
From a worst-case point of view, the FIFO and LRU strategies have fairly
unattractive competitive behavior. For example, suppose we have a cache con-
taining m pages, and consider the FIFO and LRU methods for performing page
replacement for a program that has a loop that repeatedly requests m+1 pages in
acyclicorder. BoththeFIFOandLRUpolicies perform badlyonsuchasequence
ofpage requests, because they perform apage replacement onevery page request.
Thus, from a worst-case point of view, these policies are almost the worst we can
imagine—they requireapagereplacement oneverypagerequest.
This worst-case analysis is a little too pessimistic, however, for it focuses on
each protocol’s behavior for one bad sequence of page requests. An ideal analy-
sis would be to compare these methods over all possible page-request sequences.
Of course, this is impossible to do exhaustively, but there have been a great num-
berofexperimental simulations doneonpage-request sequences derived fromreal
programs. Based on these experimental comparisons, the LRU strategy has been
shown tobe usually superior to the FIFOstrategy, whichis usually better than the15.3. ExternalSearchingandB-Trees 711
15.3 External Searching and B-Trees
Consider theproblem ofmaintaining alarge collection ofitemsthatdoesnotﬁtin
mainmemory,suchasatypicaldatabase. Inthiscontext,werefertothesecondary-
memoryblocksasdiskblocks. Likewise,werefertothetransferofablockbetween
secondary memory and primary memory as a disk transfer. Recalling the great
time difference that exists between main memory accesses and disk accesses, the
main goal of maintaining such a collection in external memory is to minimize the
number of disk transfers needed to perform a query or update. We refer to this
countastheI/Ocomplexityofthealgorithm involved.
Some Ineﬃcient External-Memory Representations
Atypicaloperationwewouldliketosupportisthesearchforakeyinamap. Ifwe
were to store n items unordered in a doubly linked list, searching for a particular
key within the list requires n transfers in the worst case, since each link hop we
perform onthelinkedlistmightaccessadifferentblockofmemory.
Wecanreducethenumberofblocktransfersbyusinganarray-basedsequence.
AsequentialsearchofanarraycanbeperformedusingonlyO(n/B)blocktransfers
because of spatial locality of reference, where B denotes the number of elements
that ﬁt into a block. This is because the block transfer when accessing the ﬁrst
element of the array actually retrieves the ﬁrst B elements, and so on with each
successive block. It is worth noting that the bound of O(n/B) transfers is only
achieved when using a compact array representation (see Section 5.2.2). The
standardPythonlistclassisareferentialcontainer,andsoeventhoughthesequence
of references are stored in an array, the actual elements that must be examined
during a search are not generally stored sequentially in memory, resulting in n
transfers intheworstcase.
Wecouldalternatelystoreasequenceusingasortedarray. Inthiscase,asearch
performs O(log n) transfers, viabinary search, which is anice improvement. But
2
we do not get signiﬁcant beneﬁt from block transfers because each query during
a binary search is likely in a different block of the sequence. As usual, update
operations areexpensiveforasortedarray.
Sincethesesimpleimplementations areI/Oinefﬁcient, weshould consider the
logarithmic-time internal-memory strategies thatusebalancedbinarytrees(forex-
ample, AVL trees or red-black trees) or other search structures with logarithmic
average-case query and update times (for example, skip lists orsplay trees). Typi-
cally,eachnodeaccessedforaqueryorupdateinoneofthesestructures willbein
a different block. Thus, these methods all require O(log n) transfers in the worst
2
casetoperformaqueryorupdateoperation. Butwecandobetter! Wecanperform
mapqueries andupdatesusingonlyO(log n)=O(logn/logB)transfers.712 Chapter15. MemoryManagementandB-Trees
a b
15.3.1 ( , ) Trees
Toreducethenumberofexternal-memory accesses whensearching, wecanrepre-
sent our map using a multiway search tree (Section 11.5.1). This approach gives
risetoageneralization ofthe(2,4)treedatastructure knownasthe(a,b)tree.
An(a,b)treeisamultiwaysearch treesuchthateach nodehasbetweenaand
bchildrenandstoresbetweena−1andb−1entries. Thealgorithmsforsearching,
inserting, andremovingentriesinan(a,b)treearestraightforward generalizations
ofthecorrespondingonesfor(2,4)trees. Theadvantageofgeneralizing(2,4)trees
to(a,b)treesisthatageneralizedclassoftreesprovidesaﬂexiblesearchstructure,
where the size of the nodes and the running time of the various map operations
dependsontheparametersaandb. Bysettingtheparametersaandbappropriately
withrespect tothesizeofdisk blocks, wecanderive adatastructure that achieves
goodexternal-memory performance.
Deﬁnition of an (a,b) Tree
An (a,b) tree, where parameters a and b are integers such that 2≤a≤(b+1)/2,
isamultiwaysearchtreeT withthefollowingadditional restrictions:
SizeProperty: Each internal node has atleast achildren, unless itis theroot, and
hasatmostbchildren.
DepthProperty: Alltheexternalnodeshavethesamedepth.
Proposition 15.1: Theheightofan(a,b)treestoringnentriesisΩ(logn/logb)
andO(logn/loga).
Justiﬁcation: LetT bean(a,b)treestoringnentries, andlethbetheheightof
T. Wejustifytheproposition byestablishing thefollowingboundsonh:
1 1 n+1
log(n+1)≤h≤ log +1.
logb loga 2
(cid:2)(cid:2)
By the size and depth properties, the number n of external nodes of T is at least
2ah−1 andatmostbh. ByProposition 11.7,n(cid:2)(cid:2)=n+1. Thus,
2ah−1 ≤n+1≤bh.
Takingthelogarithm inbase2ofeachterm,weget
(h−1)loga+1≤log(n+1)≤hlogb.15.3. ExternalSearchingandB-Trees 713
Search and Update Operations
We recall that in a multiway search tree T, each node v of T holds a secondary
structure M(v), which is itself a map (Section 11.5.1). If T is an (a,b) tree, then
M(v) stores at most b entries. Let f(b) denote the time for performing a search
in a map, M(v). The search algorithm in an (a,b) tree is exactly like the one for
multiwaysearchtreesgiveninSection11.5.1. Hence,searching inan(a,b)treeT
withnentries takesO(f(b)logn)time. Notethatifbisconsidered aconstant (and
loga
thusaisalso),thenthesearchtimeisO(logn).
The main application of (a,b) trees is for maps stored in external memory.
Namely, to minimize disk accesses, we select the parameters a and b so that each
treenodeoccupies asinglediskblock(sothat f(b)=1ifwewishtosimplycount
block transfers). Providing the right a and b values in this context gives rise to
a data structure known as the B-tree, which we will describe shortly. Before we
describe this structure, however, let us discuss how insertions and removals are
handled in(a,b)trees.
The insertion algorithm for an (a,b) tree is similar to that for a (2,4) tree.
An overﬂow occurs when an entry is inserted into ab-node w, which becomes an
illegal (b+1)-node. (Recall that a node in a multiway tree is ad-node if it has d
children.) Toremedyanoverﬂow,wesplitnodewbymovingthemedianentryofw
intotheparentofwandreplacingwwitha(cid:13)(b+1)/2(cid:14)-node w(cid:2)anda(cid:16)(b+1)/2(cid:17)-
node w(cid:2)(cid:2). We can now see the reason for requiring a≤(b+1)/2 in the deﬁnition
of an (a,b) tree. Note that as a consequence of the split, we need to build the
secondary structuresM(w(cid:2))andM(w(cid:2)(cid:2)).
Removing an entry from an (a,b) tree is similar to what was done for (2,4)
trees. Anunderﬂowoccurswhenakeyisremovedfromana-nodew,distinctfrom
theroot,whichcauseswtobecomeanillegal(a−1)-node. Toremedyanunderﬂow,
we perform a transfer with a sibling of w that is not an a-node or we perform a
(cid:2)
fusion of w with a sibling that is an a-node. The new node w resulting from the
fusionisa(2a−1)-node, whichisanotherreasonforrequiringa≤(b+1)/2.
Table15.1showstheperformance ofamaprealizedwithan(a,b)tree.
Operation Ru(cid:11)nningTim(cid:12)e
M[k] O f(b) logn
(cid:11)loga (cid:12)
M[k] = v O g(b) logn
(cid:11)loga (cid:12)
g(b)
del M[k] O logn
loga
Table15.1:Timeboundsforann-entrymaprealizedbyan(a,b)treeT. Weassume
thesecondarystructureofthenodesofT supportsearchin f(b)time,andsplitand
fusion operations in g(b) time, for some functions f(b) and g(b), which can be714 Chapter15. MemoryManagementandB-Trees
15.3.2 B-Trees
A version of the (a,b) tree data structure, which is the best-known method for
maintainingamapinexternalmemory,iscalledthe“B-tree.” (SeeFigure15.4.) A
B-tree of order d is an (a,b) tree with a=(cid:13)d/2(cid:14) and b=d. Since we discussed
the standard map query and update methods for(a,b) trees above, we restrict our
discussion heretotheI/OcomplexityofB-trees.
42 65
22 37 46 58 72 80 93
11 12 24 29 38 40 41 43 45 48 50 51 53 56 59 63 66 70 74 75 83 85 86 95 98
Figure15.4: AB-treeoforder6.
Animportantproperty ofB-treesisthatwecanchoosed sothatthed children
references and the d−1 keys stored at a node can ﬁt compactly into a single disk
block, implying thatd isproportional toB. Thischoice allowsustoassumethata
andbarealsoproportional toBintheanalysis ofthesearchandupdateoperations
on(a,b)trees. Thus, f(b)andg(b) arebothO(1), foreach timeweaccess anode
to perform a search or an update operation, we need only perform a single disk
transfer.
As we have already observed above, each search or update requires that we
examine at mostO(1) nodes for each level of the tree. Therefore, any map search
orupdateoperationonaB-treerequiresonlyO(log n),thatis,O(logn/logB),
(cid:6)d/2(cid:7)
disktransfers. Forexample,aninsertoperation proceeds downtheB-treetolocate
thenodeinwhichtoinsertthenewentry. Ifthenodewouldoverﬂow(tohaved+1
children) because of this addition, then this node issplit into two nodes that have
(cid:16)(d+1)/2(cid:17) and (cid:13)(d+1)/2(cid:14) children, respectively. This process is then repeated
atthenextlevelup,andwillcontinue foratmostO(log n)levels.
B
Likewise,ifaremoveoperationresultsinanodeunderﬂow(tohave(cid:13)d/2(cid:14)−1
children), then we move references from a sibling node with at least (cid:13)d/2(cid:14)+1
children or weperform afusion operation ofthis node withits sibling (and repeat
this computation at the parent). Aswith the insert operation, this will continue up
the B-tree for at most O(log n) levels. The requirement that each internal node
B
haveatleast(cid:13)d/2(cid:14)childrenimpliesthateachdiskblockusedtosupportaB-treeis
atleasthalffull. Thus,wehavethefollowing:
Proposition 15.2: AB-treewithnentrieshasI/OcomplexityO(log n)forsearch
B15.4. External-MemorySorting 715
15.4 External-Memory Sorting
Inadditiontodatastructures,suchasmaps,thatneedtobeimplementedinexternal
memory,therearemanyalgorithmsthatmustalsooperateoninputsetsthataretoo
large to ﬁt entirely into internal memory. In this case, the objective is to solve the
algorithmic problem using as few block transfers as possible. The most classic
domainforsuchexternal-memory algorithms isthesortingproblem.
Multiway Merge-Sort
Anefﬁcient wayto sort asetS of nobjects inexternal memoryamounts to asim-
pleexternal-memoryvariationonthefamiliarmerge-sortalgorithm. Themainidea
behind this variation is to merge many recursively sorted lists at a time, thereby
reducing the number of levels of recursion. Speciﬁcally, a high-level description
of this multiway merge-sort method is to divide S into d subsets S , S , ..., S of
1 2 d
roughly equal size, recursively sort each subsetS,and then simultaneously merge
i
alld sortedlistsintoasortedrepresentation ofS. Ifwecanperformthemergepro-
cess using onlyO(n/B)disktransfers, then, forlarge enough values ofn, thetotal
numberoftransfersperformedbythisalgorithm satisﬁesthefollowingrecurrence:
t(n)=d·t(n/d)+cn/B,
for some constant c ≥ 1. We can stop the recursion when n ≤ B, since we can
perform a single block transfer at this point, getting all ofthe objects into internal
memory, and then sort the set with an efﬁcient internal-memory algorithm. Thus,
thestopping criterionfort(n)is
t(n)=1 ifn/B≤1.
Thisimpliesaclosed-form solution thatt(n)isO((n/B)log (n/B)),whichis
d
O((n/B)log(n/B)/logd).
Thus,ifwecanchoosedtobeΘ(M/B),whereMisthesizeoftheinternalmemory,
then the worst-case number of block transfers performed by this multiway merge-
sortalgorithm willbequitelow. Forreasons giveninthenextsection, wechoose
d=(M/B)−1.
Theonlyaspectofthisalgorithm lefttospecify, then,ishowtoperformthed-way716 Chapter15. MemoryManagementandB-Trees
15.4.1 Multiway Merging
In a standard merge-sort (Section 12.2), the merge process combines two sorted
sequences into onebyrepeatedly taking thesmalleroftheitemsatthefrontofthe
two respective lists. In ad-way merge, werepeatedly ﬁnd the smallest among the
itemsatthefrontofthed sequences andplaceitasthenextelementofthemerged
sequence. Wecontinue untilallelementsareincluded.
In the context of an external-memory sorting algorithm, if main memory has
size M and each block has size B, we can store up to M/B blocks within main
memory at any given time. We speciﬁcally choose d =(M/B)−1 so that we can
afford to keep one block from each input sequence in main memory at any given
time, and to have one additional block touse as abuffer for the merged sequence.
(SeeFigure15.5.)
12 24 26 34 41 49 50 57 60
25 27 40 43 44 53 56
7 8 10 11 Q 30 39 42 45 54 65
13 16 19 33 37 46 52 58 66 75
17 18 29 35 48 51 59 72 78 88
Figure15.5: Ad-waymerge withd =5and B=4. Blocks that currently reside in
mainmemoryareshaded.
We maintain the smallest unprocessed element from each input sequence in
mainmemory,requestingthenextblockfromasequencewhentheprecedingblock
has been exhausted. Similarly, we use one block of internal memory to buffer the
merged sequence, ﬂushing that block to external memory when full. In this way,
the total number of transfers performed during a single d-way merge is O(n/B),
sincewescaneachblockoflistS once,andwewriteouteachblockofthemerged
i
(cid:2)
list S once. In terms of computation time, choosing the smallest of d values can
trivially be performed using O(d) operations. If we are willing to devote O(d)
internalmemory,wecanmaintainapriorityqueueidentifyingthesmallestelement
from each sequence, thereby performing each step of the merge in O(logd) time
byremovingtheminimumelementandreplacingitwiththenextelementfromthe
samesequence. Hence,theinternal timeforthed-waymergeisO(nlogd).
Proposition 15.3: Givenanarray-basedsequenceS ofn elementsstoredcom-
pactlyinexternalmemory,wecansortSwithO((n/B)log(n/B)/log(M/B))block
transfersandO(nlogn)internalcomputations,whereM isthesizeoftheinternal15.5. Exercises 717
15.5 Exercises
Forhelpwithexercises,pleasevisitthesite,www.wiley.com/college/goodrich.
Reinforcement
R-15.1 Juliajustboughtanewcomputerthatuses64-bitintegerstoaddressmem-
ory cells. Argue why Julia will never in her life be able to upgrade the
main memory of her computer so that it is the maximum-size possible,
assumingthatyouhavetohavedistinct atomstorepresent differentbits.
R-15.2 Describe, in detail, algorithms for adding an item to, or deleting an item
from,an(a,b)tree.
R-15.3 SupposeT isamultiwaytreeinwhicheachinternalnodehasatleastﬁve
and at most eight children. For what values ofa and b is T a valid (a,b)
tree?
R-15.4 For what values of d is the tree T of the previous exercise an order-d
B-tree?
R-15.5 Consideraninitiallyemptymemorycacheconsisting offourpages. How
many page misses does the LRU algorithm incur on the following page
requestsequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?
R-15.6 Consideraninitiallyemptymemorycacheconsisting offourpages. How
many page misses does the FIFO algorithm incur on the following page
requestsequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?
R-15.7 Consideraninitiallyemptymemorycacheconsistingoffourpages. What
isthemaximumnumberofpagemissesthattherandom algorithm incurs
on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?
Showalloftherandomchoicesthealgorithm madeinthiscase.
R-15.8 Drawtheresultofinserting, intoaninitiallyemptyorder-7B-tree,entries
with keys (4,40,23,50,11,34,62,78,66,22,90,59,25,72,64,77,39,12),
inthisorder.
Creativity
C-15.9 Describeanefﬁcientexternal-memory algorithm forremovingallthedu-
plicateentriesinanarraylistofsizen.
C-15.10 Describe anexternal-memory data structure toimplement the stack ADT
sothatthetotalnumber ofdisk transfers needed toprocess asequence of718 Chapter15. MemoryManagementandB-Trees
C-15.11 Describeanexternal-memorydatastructuretoimplementthequeueADT
sothatthetotalnumber ofdisk transfers needed toprocess asequence of
kenqueueanddequeueoperations isO(k/B).
C-15.12 Describe an external-memory version of the PositionalList ADT (Sec-
tion 7.4), with block size B, such that an iteration of a list of length n is
completedusingO(n/B)transfersintheworstcase,andallothermethods
oftheADTrequireonlyO(1)transfers.
C-15.13 Change the rules that deﬁne red-black trees so that each red-black tree T
hasacorresponding (4,8)tree,andviceversa.
C-15.14 DescribeamodiﬁedversionoftheB-treeinsertion algorithm sothateach
timewecreateanoverﬂowbecauseofasplitofanodew,weredistribute
keysamongallofw’ssiblings,sothateachsiblingholdsroughlythesame
numberofkeys(possibly cascading thesplituptotheparentofw). What
istheminimumfractionofeachblockthatwillalwaysbeﬁlledusingthis
scheme?
C-15.15 Another possible external-memory map implementation is to use a skip
list,buttocollectconsecutivegroupsofO(B)nodes,inindividualblocks,
on any level in the skip list. In particular, we deﬁne an order-d B-skip
list to be such a representation of a skip list structure, where each block
contains at least (cid:13)d/2(cid:14) list nodes and at most d list nodes. Let us also
choosedinthiscasetobethemaximumnumberoflistnodesfromalevel
of a skip list that can ﬁtinto one block. Describe how we should modify
the skip-list insertion and removal algorithms for aB-skip list so that the
expected heightofthestructure isO(logn/logB).
C-15.16 DescribehowtouseaB-treetoimplementthepartition(union-ﬁnd)ADT
(from Section 14.7.3) so that the union and ﬁnd operations each use at
mostO(logn/logB)disktransfers.
C-15.17 Suppose we are given a sequence S of n elements with integer keys such
that some elements in S are colored “blue” and some elements in S are
colored “red.” In addition, say that a red element e pairs with a blue
element f iftheyhavethesamekeyvalue. Describeanefﬁcientexternal-
memoryalgorithm forﬁnding all thered-blue pairs inS. Howmanydisk
transfers doesyouralgorithm perform?
C-15.18 Consider the page caching problem where the memory cache canhold m
pages, and we are given a sequence P of n requests taken from a pool
of m+1 possible pages. Describe the optimal strategy for the ofﬂine
algorithm and show that it causes at most m+n/m page misses in total,
starting fromanemptycache.
C-15.19 Describeanefﬁcientexternal-memory algorithm thatdetermineswhetherChapterNotes 719
C-15.20 Consider the page caching strategy based on the least frequently used
(LFU) rule, where the page in the cache that has been accessed the least
often is theone that isevicted when anewpage isrequested. Ifthere are
ties, LFUevicts the least frequently used page that has beenin the cache
thelongest. ShowthatthereisasequencePofnrequeststhatcausesLFU
tomissΩ(n)timesforacacheofmpages,whereastheoptimalalgorithm
willmissonlyO(m)times.
C-15.21 Suppose that instead of having the node-search function f(d)=1 in an
order-d B-tree T, we have f(d)=logd. What does the asymptotic run-
ningtimeofperforming asearchinT nowbecome?
Projects
P-15.22 WriteaPythonclassthatsimulatesthebest-ﬁt,worst-ﬁt,ﬁrst-ﬁt,andnext-
ﬁtalgorithmsformemorymanagement. Determineexperimentally which
methodisthebestundervarioussequences ofmemoryrequests.
P-15.23 Write aPython class that implements allthe methods of theordered map
ADTbymeansofan(a,b)tree,whereaandbareintegerconstantspassed
asparameterstoaconstructor.
P-15.24 Implement the B-tree data structure, assuming a block size of 1024 and
integer keys. Test the number of “disk transfers” needed to process a
sequence ofmapoperations.
Chapter Notes
The reader interested in the study of the architecture of hierarchical memory systems is
referred to the book chapter by Burger et al. [21] or the book by Hennessy and Patter-
son[50]. Themark-sweepgarbagecollectionmethodwedescribeisoneofmanydifferent
algorithmsforperforminggarbagecollection. We encouragethe readerinterestedin fur-
therstudyofgarbagecollectionto examinethebookbyJonesandLins[56]. Knuth[62]
hasverynicediscussionsaboutexternal-memorysortingandsearching,andUllman[97]
discussesexternalmemorystructuresfordatabasesystems. ThehandbookbyGonnetand
Baeza-Yates [44] comparesthe performanceof a numberof differentsorting algorithms,
manyofwhichareexternal-memoryalgorithms. B-treeswereinventedbyBayerandMc-
Creight [11] and Comer [28] provides a very nice overview of this data structure. The
booksbyMehlhorn[76]andSamet[87]alsohavenicediscussionsaboutB-treesandtheir
variants.AggarwalandVitter[3]studytheI/Ocomplexityofsortingandrelatedproblems,
establishing upper and lower bounds. Goodrich et al. [46] study the I/O complexity of
several computationalgeometryproblems. The reader interested in further study of I/O-Appendix
A
Character Strings in Python
Astringisasequence ofcharacters thatcomefromsomealphabet. InPython, the
built-in strclass represents strings based upontheUnicode international character
set, a 16-bit character encoding that covers most written languages. Unicode is
an extension of the 7-bit ASCII character set that includes the basic Latin alpha-
bet, numerals, and common symbols. Strings are particularly important in most
programming applications, astextisoftenusedforinputandoutput.
AbasicintroductiontothestrclasswasprovidedinSection1.2.3,includinguse
ofstringliterals, suchas hello ,andthesyntaxstr(obj)thatisusedtoconstruct
a string representation of a typical object. Common operators that are supported
by strings, such as the use of + for concatenation, were further discussed in Sec-
tion 1.3. Thisappendix serves asamoredetailed reference,describing convenient
behaviors thatstrings support fortheprocessing oftext. Toorganize our overview
of the str class behaviors, we group them into the following broad categories of
functionality.
Searching for Substrings
The operator syntax, pattern in s, can be used to determine if the given pattern
occurs as a substring of string s. Table A.1 describes several related methods that
determine the number of such occurrences, and the index at which the leftmost or
rightmost such occurrence begins. Each of the functions in this table accepts two
optional parameters, start and end, which are indices that effectively restrict the
search to the implicit slice s[start:end]. For example, the call s.ﬁnd(pattern, 5)
restricts thesearchtos[5: ].
CallingSyntax Description
s.count(pattern) Returnthenumberofnon-overlappingoccurrencesofpattern
s.ﬁnd(pattern) Returntheindexstartingtheleftmostoccurrenceofpattern;else-1
s.index(pattern) Similartoﬁnd,butraiseValueErrorifnotfound
s.rﬁnd(pattern) Returntheindexstartingtherightmostoccurrenceofpattern;else-1
s.rindex(pattern) Similartorﬁnd,butraiseValueErrorifnotfound722 AppendixA. CharacterStringsinPython
Constructing Related Strings
StringsinPythonareimmutable,sononeoftheirmethodsmodifyanexistingstring
instance. However,manymethodsreturn anewlyconstructedstringthatisclosely
relatedtoanexistingone. TableA.2providesasummaryofsuchmethods,includ-
ingthose thatreplace agiven pattern withanother, thatvarythecase ofalphabetic
characters,thatproduceaﬁxed-widthstringwithdesiredjustiﬁcation,andthatpro-
duceacopyofastringwithextraneous characters stripped fromeitherend.
CallingSyntax Description
s.replace(old, new) Returnacopyofswithalloccurrencesofoldreplacedbynew
s.capitalize() Returnacopyofswithitsﬁrstcharacterhavinguppercase
s.upper() Returnacopyofswithallalphabeticcharactersinuppercase
s.lower() Returnacopyofswithallalphabeticcharactersinlowercase
s.center(width) Returnacopyofs,paddedtowidth,centeredamongspaces
s.ljust(width) Returnacopyofs,paddedtowidthwithtrailingspaces
s.rjust(width) Returnacopyofs,paddedtowidthwithleadingspaces
s.zﬁll(width) Returnacopyofs,paddedtowidthwithleadingzeros
s.strip() Returnacopyofs,withleadingandtrailingwhitespaceremoved
s.lstrip() Returnacopyofs,withleadingwhitespaceremoved
s.rstrip() Returnacopyofs,withtrailingwhitespaceremoved
TableA.2: Stringmethodsthatproduce relatedstrings.
Several of these methods accept optional parameters not detailed in the table.
Forexample,thereplacemethodreplacesallnonoverlappingoccurrencesoftheold
pattern bydefault, butanoptional parameter canlimitthenumberofreplacements
that are performed. The methods that center or justify a text use spaces as the
default ﬁll character when padding, but an alternate ﬁll character can be speciﬁed
asanoptionalparameter. Similarly,allvariantsofthestripmethodsremoveleading
and trailing whitespace by default, but an optional string parameter designates the
choiceofcharacters thatshouldberemovedfromtheends.
Testing Boolean Conditions
Table A.3 includes methods that test for a Boolean property of a string, such as
whether it begins or ends with a pattern, or whether its characters qualify as be-
ing alphabetic, numeric, whitespace, etc. For the standard ASCII character set,
alphabeticcharactersaretheuppercaseA–Z,andlowercasea–z,numericdigitsare
0–9, and whitespace includes the space character, tab character, newline, and car-
riagereturn. ConventionsforwhatareconsideredalphabeticandnumericcharacterAppendixA.CharacterStringsinPython 723
CallingSyntax Description
s.startswith(pattern) ReturnTrueifpatternisapreﬁxofstrings
s.endswith(pattern) ReturnTrueifpatternisasufﬁxofstrings
s.isspace() ReturnTrueifallcharactersofnonemptystringarewhitespace
s.isalpha() ReturnTrueifallcharactersofnonemptystringarealphabetic
s.islower() ReturnTrueifthereareoneormorealphabeticcharacters,
allofwhicharelowercased
s.isupper() ReturnTrueifthereareoneormorealphabeticcharacters,
allofwhichareuppercased
s.isdigit() ReturnTrueifallcharactersofnonemptystringarein0–9
s.isdecimal() ReturnTrueifallcharactersofnonemptystringrepresent
digits0–9,includingUnicodeequivalents
s.isnumeric() ReturnTrueifallcharactersofnonemptystringarenumeric
Unicodecharacters(e.g.,0–9,equivalents,fractioncharacters)
s.isalnum() ReturnTrueifallcharactersofnonemptystringareeither
alphabeticornumeric(asperabovedeﬁnitions)
TableA.3: MethodsthattestBooleanproperties ofstrings.
Splitting and Joining Strings
Table A.4 describes several important methods of Python’s string class, used to
compose a sequence of strings together using a delimiter to separate each pair, or
totake anexisting string and determine adecomposition of that string based upon
existence ofagivenseparating pattern.
CallingSyntax Description
sep.join(strings) Returnthecompositionofthegivensequenceofstrings,
insertingsepasdelimiterbetweeneachpair
s.splitlines() Returnalistofsubstringsofs,asdelimitedbynewlines
s.split(sep, count) Returnalistofsubstringsofs,asdelimitedbytheﬁrstcount
occurrencesofsep. Ifcountisnotspeciﬁed,splitonall
occurrences.Ifsepisnotspeciﬁed,usewhitespaceasdelimiter.
s.rsplit(sep, count) Similartosplit,butusingtherightmostoccurrencesofsep
s.partition(sep) Return(head, sep, tail)suchthats = head + sep + tail,
usingleftmostoccurrenceofsep,ifany;elsereturn(s, , )
s.rpartition(sep) Return(head, sep, tail)suchthats = head + sep + tail,
usingrightmostoccurrenceofsep,ifany;elsereturn( , , s)
TableA.4: Methodsforsplittingandjoining strings.
Thejoinmethodisusedtoassembleastringfromaseriesofpieces. Anexam-
pleofitsusage is and .join([ red , green , blue ]),whichproduces the
result red and green and blue . Notewellthatspaceswereembeddedinthe
separatorstring. Incontrast,thecommand and .join([ red , green , blue ])724 AppendixA. CharacterStringsinPython
Theother methodsdiscussed inTableA.4serveadualpurposetojoin,asthey
begin with a string and produce a sequence of substrings based upon a given de-
limiter. Forexample, the call red and green and blue .split( and ) pro-
ducestheresult[ red , green , blue ]. Ifnodelimiter(orNone)isspeciﬁed,
split uses whitespace as a delimiter; thus, red and green and blue .split()
produces[ red , and , green , and , blue ].
String Formatting
Theformatmethodofthestrclasscomposesastringthatincludesoneormorefor-
matted arguments. The method is invoked with asyntax s.format(arg0, arg1, ...),
where s serves as a formatting string that expresses the desired result with one
or more placeholders in which the arguments will be substituted. As a simple
example, theexpression {} had a little {} .format( Mary , lamb )pro-
duces the result Mary had a little lamb . The pairs of curly braces in the
formatting string are the placeholders for ﬁelds that will be substituted into the
result. By default, the arguments sent to the function are substituted using posi-
tional order; hence, Mary wasthe ﬁrstsubstitute and lamb the second. How-
ever, the substitution patterns may be explicitly numbered to alter the order, or
to use a single argument in more than one location. For example, the expres-
sion {0}, {0}, {0} your {1} .format( row , boat ) produces the result
row, row, row your boat .
All substitution patterns allow use of annotations to pad anargument to apar-
ticularwidth,usingachoiceofﬁllcharacterandjustiﬁcationmode. Anexampleof
such an annotation is {:-^20} .format( hello ). In this example, the hyphen
(-) serves as a ﬁll character, the caret (^) designates a desire for the string to be
centered, and 20 is the desired width for the argument. This example results in
thestring -------hello-------- . Bydefault, spaceisusedasaﬁllcharacter
andanimplied<characterdictatesleft-justiﬁcation; anexplicit>characterwould
dictateright-justiﬁcation.
There are additional formatting options for numeric types. A number will be
padded with zeros rather than spaces if its width description is prefaced with a
zero. For example, a date can be formatted in traditional “YYYY/MM/DD”form
as {}/{:02}/{:02} .format(year, month, day). Integers can be converted to
binary, octal, or hexadecimal by respectively adding the character b, o, or x as a
sufﬁxtotheannotation. Thedisplayedprecisionofaﬂoating-pointnumberisspec-
iﬁedwithadecimal point andthesubsequent number ofdesired digits. Forexam-
ple,theexpression {:.3}.format(2/3) producesthestring 0.667 ,rounded
to three digits after the decimal point. A programmer can explicitly designate use
of ﬁxed-point representation (e.g., 0.667 ) by adding the character f as a sufﬁx,Appendix
B
Useful Mathematical Facts
In this appendix we give several useful mathematical facts. We begin with some
combinatorial deﬁnitionsandfacts.
Logarithms and Exponents
Thelogarithm function isdeﬁnedas
log a=c if a=bc.
b
Thefollowingidentities holdforlogarithmsandexponents:
1. log ac=log a+log c
b b b
2. log a/c=log a−log c
b b b
3. log ac=clog a
b b
4. log a=(log a)/log b
b c c
5. blogca=alogcb
6. (ba)c=bac
7. babc=ba+c
8. ba/bc =ba−c
Inaddition, wehavethefollowing:
Proposition B.1: Ifa>0,b>0,andc>a+b,then
loga+logb<2logc−2.
Justiﬁcation: Itisenoughtoshowthatab<c2/4. Wecanwrite
a2+2ab+b2−a2+2ab−b2
ab =
4
(a+b)2−(a−b)2 (a+b)2 c2
= ≤ < .
4 4 4
Thenaturallogarithmfunctionlnx=log x,wheree=2.71828...,isthevalue
e
ofthefollowingprogression:
1 1 1
e=1+ + + +···.726 AppendixB. UsefulMathematicalFacts
Inaddition,
x x2 x3
ex=1+ + + +···
1! 2! 3!
x2 x3 x4
ln(1+x)=x− + − +···.
2! 3! 4!
There are a number of useful inequalities relating to these functions (which
derivefromthesedeﬁnitions).
Proposition B.2: Ifx>−1,
x
≤ln(1+x)≤x.
1+x
Proposition B.3: For0≤x<1,
1
1+x≤ex ≤ .
1−x
Proposition B.4: Foranytwopositiverealnumbersxandn,
(cid:11) (cid:12) (cid:11) (cid:12)
x n x n+x/2
1+ ≤ex ≤ 1+ .
n n
Integer Functions and Relations
The“ﬂoor”and“ceiling” functions aredeﬁnedrespectivelyasfollows:
1. (cid:16)x(cid:17)=thelargestintegerlessthanorequaltox.
2. (cid:13)x(cid:14)=thesmallestintegergreaterthanorequaltox.
Themodulooperatorisdeﬁnedforintegersa≥0andb>0as
(cid:28) (cid:29)
a
a mod b=a− b.
b
Thefactorialfunction isdeﬁnedas
n!=1·2·3·····(n−1)n.
Thebinomialcoefﬁcientis
(cid:17) (cid:18)
n n!
= ,
k k!(n−k)!
whichisequaltothenumberofdifferentcombinationsonecandeﬁnebychoosing
k different items from a collection of n items (where the order does not matter).
Thename“binomialcoefﬁcient” derivesfromthebinomialexpansion:
(cid:17) (cid:18)
(a+b)n= ∑n n akbn−k.
k
k=0AppendixB.UsefulMathematicalFacts 727
Proposition B.5: If0≤k≤n,then
(cid:17) (cid:18)
(cid:11) (cid:12)
n k n nk
≤ ≤ .
k k k!
Proposition B.6 (Stirling’s Approximation):
(cid:17) (cid:18)
√ (cid:11) (cid:12)
n n 1
n!= 2πn 1+ +ε(n) ,
e 12n
whereε(n)isO(1/n2).
TheFibonacci progression isanumeric progression such thatF =0, F =1,
0 1
andFn=Fn−1+Fn−2 forn≥2.
Proposition B.√7: IfFnisdeﬁnedbytheFibonacciprogression,thenFnisΘ(gn),
whereg=(1+ 5)/2istheso-calledgoldenratio.
Summations
Thereareanumberofusefulfactsaboutsummations.
Proposition B.8: Factoringsummations:
n n
∑af(i)=a∑ f(i),
i=1 i=1
providedadoesnotdependuponi.
Proposition B.9: Reversingtheorder:
n m m n
∑ ∑ f(i,j)= ∑ ∑ f(i,j).
i=1j=1 j=1i=1
Onespecialformofisatelescoping sum:
n
∑(f(i)− f(i−1))= f(n)− f(0),
i=1
whicharisesoftenintheamortized analysisofadatastructure oralgorithm.
The following are some other facts about summations that arise often in the
analysis ofdatastructures andalgorithms.
Proposition B.10: ∑n i=n(n+1)/2.
i=1
Proposition B.11: ∑n i2=n(n+1)(2n+1)/6.728 AppendixB. UsefulMathematicalFacts
Proposition B.12: Ifk≥1isanintegerconstant,then
n
∑ikisΘ(nk+1).
i=1
Another common summation is the geometric sum, ∑n ai, for any ﬁxed real
i=0
number0<a(cid:15)=1.
Proposition B.13:
∑n ai= an+1−1,
a−1
i=0
foranyrealnumber0<a(cid:15)=1.
Proposition B.14:
∞
∑ai= 1
1−a
i=0
foranyrealnumber0<a<1.
Thereisalsoacombination ofthetwocommonforms, called the linearexpo-
nentialsummation, whichhasthefollowingexpansion:
Proposition B.15: For0<a(cid:15)=1,andn≥2,
∑n iai= a−(n+1)a(n+1)+na(n+2).
(1−a)2
i=1
Thenth HarmonicnumberH isdeﬁnedas
n
H = ∑n 1.
n
i
i=1
Proposition B.16: IfH isthenthharmonicnumber,thenH islnn+Θ(1).
n n
Basic Probability
We review some basic facts from probability theory. The most basic is that any
statement about a probability is deﬁned upon a sample space S, which is deﬁned
as the set of all possible outcomes from some experiment. We leave the terms
“outcomes” and“experiment” undeﬁnedinanyformalsense.
Example B.17: Consideranexperimentthatconsistsoftheoutcomefromﬂip-
pingacoinﬁvetimes.Thissamplespacehas25 differentoutcomes,oneforeach
differentorderingofpossibleﬂipsthatcanoccur.AppendixB.UsefulMathematicalFacts 729
Example B.18: Consideranexperimentthatconsistsofﬂippingacoinuntilit
comesupheads.Thissamplespaceisinﬁnite,witheachoutcomebeingasequence
ofitailsfollowedbyasingleﬂipthatcomesupheads,fori=1,2,3,....
A probability space is a sample space S together with a probability function
Pr that maps subsets of S to real numbers in the interval [0,1]. It captures math-
ematically the notion of the probability of certain “events” occurring. Formally,
eachsubsetAofSiscalled anevent,andtheprobability function Prisassumedto
possessthefollowingbasicproperties withrespect toeventsdeﬁnedfromS:
1. Pr(∅)=0.
2. Pr(S)=1.
3. 0≤Pr(A)≤1,foranyA⊆S.
4. IfA,B⊆SandA∩B=∅,thenPr(A∪B)=Pr(A)+Pr(B).
TwoeventsAandBareindependentif
Pr(A∩B)=Pr(A)·Pr(B).
Acollection ofevents{A ,A ,...,A }ismutuallyindependentif
1 2 n
Pr(A ∩A ∩···∩A )=Pr(A )Pr(A )···Pr(A ).
i1 i2 ik i1 i2 ik
foranysubset{A ,A ,...,A }.
i1 i2 ik
TheconditionalprobabilitythataneventAoccurs,givenaneventB,isdenoted
asPr(A|B),andisdeﬁnedastheratio
Pr(A∩B)
,
Pr(B)
assumingthatPr(B)>0.
Anelegant wayfor dealing with events is interms ofrandom variables. Intu-
itively, random variables are variables whose values depend upon the outcome of
someexperiment. Formally,arandomvariableisafunctionX thatmapsoutcomes
from some sample space S to real numbers. An indicator random variable is a
random variable that maps outcomes to the set{0,1}. Often in data structure and
algorithm analysis weusearandom variableX tocharacterize therunning timeof
arandomized algorithm. Inthiscase, thesamplespaceSisdeﬁnedbyallpossible
outcomesoftherandom sourcesusedinthealgorithm.
We are most interested in the typical, average, or “expected” value of such a
randomvariable. Theexpected valueofarandom variableX isdeﬁnedas
E(X)=∑xPr(X =x),
x
wherethesummationisdeﬁnedovertherangeofX (whichinthiscaseisassumed730 AppendixB. UsefulMathematicalFacts
Proposition B.19 (The Linearity of Expectation): LetX andY betworan-
domvariablesandletcbeanumber.Then
E(X+Y)=E(X)+E(Y) and E(cX)=cE(X).
Example B.20: LetX bearandomvariablethatassignstheoutcomeoftheroll
oftwofairdicetothesumofthenumberofdotsshowing.ThenE(X)=7.
Justiﬁcation: Tojustifythisclaim,letX andX berandomvariablescorre-
1 2
spondingtothenumberofdotsoneachdie. Thus,X = X (i.e.,theyaretwo
1 2
instancesofthesamefunction)andE(X)=E(X +X )=E(X )+E(X ). Each
1 2 1 2
outcomeoftherollofafairdieoccurswithprobability1/6.Thus,
1 2 3 4 5 6 7
E(X)= + + + + + = ,
i
6 6 6 6 6 6 2
fori=1,2.Therefore,E(X)=7.
Tworandom variablesX andY areindependentif
Pr(X =x|Y =y)=Pr(X =x),
forallrealnumbersxandy.
Proposition B.21: IftworandomvariablesX andY areindependent,then
E(XY)=E(X)E(Y).
Example B.22: LetX bearandomvariablethatassignstheoutcomeofarollof
twofairdicetotheproductofthenumberofdotsshowing.ThenE(X)=49/4.
Justiﬁcation: LetX andX berandomvariablesdenotingthenumberofdots
1 2
oneachdie.ThevariablesX andX areclearlyindependent;hence
1 2
E(X)=E(X X )=E(X )E(X )=(7/2)2 =49/4.
1 2 1 2
ThefollowingboundandcorollariesthatfollowfromitareknownasChernoff
bounds.
Proposition B.23: LetX bethesumofaﬁnitenumberofindependent0/1ran-
domvariablesandletμ>0betheexpectedvalueofX.Then,forδ>0,
(cid:30) (cid:31)
δ μ
e
Pr(X >(1+δ)μ)< .AppendixB.UsefulMathematicalFacts 731
Useful Mathematical Techniques
Tocomparethegrowthratesofdifferentfunctions, itissometimeshelpfultoapply
thefollowingrule.
Proposition B.24 (L’Hoˆpital’s Rule): Ifwehavelimn→∞ f(n)=+∞andwe
have limn→∞g(n)=+∞,then limn→∞ f(n)/g(n)=limn→∞ f(cid:2)(n)/g(cid:2)(n),where
f(cid:2)(n)andg(cid:2)(n)respectivelydenotethederivativesoff(n)andg(n).
Inderiving anupper orlowerbound forasummation, itisoften useful tosplit
asummationasfollows:
n j n
∑ f(i)=∑ f(i)+ ∑ f(i).
i=1 i=1 i=j+1
Another useful technique is to bound a sum by an integral. If f is a nonde-
creasing function, then,assumingthefollowingtermsaredeﬁned,
Z Z
b b b+1
f(x)dx≤ ∑ f(i)≤ f(x)dx.
a−1 i=a a
There is a general form of recurrence relation that arises in the analysis of
divide-and-conquer algorithms:
T(n)=aT(n/b)+ f(n),
forconstantsa≥1andb>1.
Proposition B.25: LetT(n)bedeﬁnedasabove.Then
1. If f(n)isO(nlogba−ε),forsomeconstantε>0,thenT(n)isΘ(nlogba).
2. Iff(n)isΘ(nlogbalogkn),foraﬁxednonnegativeintegerk≥0,thenT(n)is
Θ(nlogbalogk+1n).
3. Iff(n)isΩ(nlogba+ε),forsomeconstantε>0,andifaf(n/b)≤cf(n),then
T(n)isΘ(f(n)).
This proposition is known as the master method for characterizing divide-and-Bibliography
[1] H. Abelson, G. J. Sussman, and J. Sussman, Structure andInterpretationof Com-
puterPrograms. Cambridge,MA:MITPress,2nded.,1996.
[2] G. M. Adel’son-Vel’skii and Y. M. Landis, “An algorithm for the organization of
information,”DokladyAkademiiNaukSSSR,vol.146,pp.263–266,1962. English
translationinSovietMath.Dokl.,3,1259–1262.
[3] A. Aggarwaland J. S. Vitter, “The input/outputcomplexity of sorting and related
problems,”Commun.ACM,vol.31,pp.1116–1127,1988.
[4] A. V. Aho, “Algorithms for ﬁnding patterns in strings,” in Handbook of Theoreti-
cal Computer Science (J. van Leeuwen, ed.), vol. A. Algorithmsand Complexity,
pp.255–300,Amsterdam:Elsevier,1990.
[5] A.V.Aho,J.E.Hopcroft,andJ.D.Ullman,TheDesignandAnalysisofComputer
Algorithms. Reading,MA:Addison-Wesley,1974.
[6] A.V.Aho,J.E.Hopcroft,andJ.D.Ullman,DataStructuresandAlgorithms. Read-
ing,MA:Addison-Wesley,1983.
[7] R.K.Ahuja,T.L.Magnanti,andJ.B.Orlin,NetworkFlows: Theory,Algorithms,
andApplications. EnglewoodCliffs,NJ:PrenticeHall,1993.
[8] R.Baeza-YatesandB.Ribeiro-Neto,ModernInformationRetrieval. Reading,MA:
Addison-Wesley,1999.
[9] O. Baru˚vka, “O jistem problemu minimalnim,” Praca Moravske Prirodovedecke
Spolecnosti,vol.3,pp.37–58,1926. (inCzech).
[10] R.Bayer,“SymmetricbinaryB-trees: Datastructureandmaintenance,”ActaInfor-
matica,vol.1,no.4,pp.290–306,1972.
[11] R. Bayer and McCreight, “Organization of large ordered indexes,” Acta Inform.,
vol.1,pp.173–189,1972.
[12] D.M.Beazley,PythonEssentialReference. Addison-WesleyProfessional,4thed.,
2009.
[13] R.E.Bellman,DynamicProgramming. Princeton,NJ:PrincetonUniversityPress,
1957.
[14] J.L.Bentley,“Programmingpearls:Writingcorrectprograms,”Communicationsof
theACM,vol.26,pp.1040–1045,1983.
[15] J.L.Bentley,“Programmingpearls: Thanks,heaps,”CommunicationsoftheACM,
vol.28,pp.245–250,1985.
[16] J.L.BentleyandM.D.McIlroy,“Engineeringasortfunction,”Software—Practice
andExperience,vol.23,no.11,pp.1249–1265,1993.
[17] G.Booch,Object-OrientedAnalysisandDesignwithApplications. RedwoodCity,Bibliography 733
[18] R. S.BoyerandJ.S.Moore,“Afaststringsearchingalgorithm,”Communications
oftheACM,vol.20,no.10,pp.762–772,1977.
[19] G.Brassard,“Crusadeforabetternotation,”SIGACTNews,vol.17,no.1,pp.60–
64,1985.
[20] T.Budd,AnIntroductiontoObject-OrientedProgramming.Reading,MA:Addison-
Wesley,1991.
[21] D. Burger, J. R. Goodman, and G. S. Sohi, “Memory systems,” in The Computer
Science and Engineering Handbook(A. B. Tucker, Jr., ed.), ch. 18, pp. 447–461,
CRCPress,1997.
[22] J. Campbell, P. Gries, J. Montojo,andG. Wilson,PracticalProgramming: AnIn-
troductiontoComputerScience. PragmaticBookshelf,2009.
[23] L.CardelliandP.Wegner,“Onunderstandingtypes,dataabstractionandpolymor-
phism,”ACMComputingSurveys,vol.17,no.4,pp.471–522,1985.
[24] S.Carlsson,“Averagecaseresultsonheapsort,”BIT,vol.27,pp.2–17,1987.
[25] V.Cedar,TheQuickPythonBook. ManningPublications,2nded.,2010.
[26] K. L. Clarkson, “Linear programming in O(n3d2) time,” Inform. Process. Lett.,
vol.22,pp.21–24,1986.
[27] R. Cole, “Tight bounds on the complexity of the Boyer-Moore pattern matching
algorithm,”SIAMJ.Comput.,vol.23,no.5,pp.1075–1091,1994.
[28] D.Comer,“TheubiquitousB-tree,”ACMComput.Surv.,vol.11,pp.121–137,1979.
[29] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to Algo-
rithms. Cambridge,MA:MITPress,3rded.,2009.
[30] M.CrochemoreandT.Lecroq,“Patternmatchingandtextcompressionalgorithms,”
inTheComputerScienceandEngineeringHandbook(A.B.Tucker,Jr.,ed.),ch.8,
pp.162–202,CRCPress,1997.
[31] S. CrosbyandD.Wallach, “Denialofservicevia algorithmiccomplexityattacks,”
inProc.12thUsenixSecuritySymp.,pp.29–44,2003.
[32] M. Dawson, PythonProgrammingfor the AbsoluteBeginner. Course Technology
PTR,3rded.,2010.
[33] S.A.Demurjian,Sr.,“Softwaredesign,”inTheComputerScienceandEngineering
Handbook(A.B.Tucker,Jr.,ed.),ch.108,pp.2323–2351,CRCPress,1997.
[34] G.DiBattista,P.Eades,R.Tamassia,andI.G.Tollis,GraphDrawing.UpperSaddle
River,NJ:PrenticeHall,1999.
[35] E. W. Dijkstra, “A note on two problems in connexion with graphs,” Numerische
Mathematik,vol.1,pp.269–271,1959.
[36] E. W. Dijkstra, “Recursive programming,” Numerische Mathematik, vol. 2, no. 1,
pp.312–318,1960.
[37] J.R.Driscoll,H.N.Gabow,R.Shrairaman,andR.E.Tarjan,“Relaxedheaps: An
alternativetoFibonacciheapswithapplicationstoparallelcomputation,”Commun.
ACM,vol.31,pp.1343–1354,1988.
[38] R. W. Floyd, “Algorithm 97: Shortest path,”Communicationsof the ACM, vol. 5,
no.6,p.345,1962.
[39] R. W. Floyd, “Algorithm 245: Treesort 3,” Communications of the ACM, vol. 7,
no.12,p.701,1964.
[40] M.L.FredmanandR.E.Tarjan,“Fibonacciheapsandtheirusesinimprovednet-734 Bibliography
[41] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns: Elements of
ReusableObject-OrientedSoftware. Reading,MA:Addison-Wesley,1995.
[42] A.GoldbergandD.Robson,Smalltalk-80:TheLanguage. Reading,MA:Addison-
Wesley,1989.
[43] M.H.GoldwasserandD.Letscher,Object-OrientedProgramminginPython.Upper
SaddleRiver,NJ:PrenticeHall,2008.
[44] G.H.GonnetandR.Baeza-Yates,HandbookofAlgorithmsandDataStructuresin
PascalandC. Reading,MA:Addison-Wesley,1991.
[45] G.H.GonnetandJ.I.Munro,“Heapsonheaps,”SIAMJ.Comput.,vol.15,no.4,
pp.964–971,1986.
[46] M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter, “External-memory
computationalgeometry,”inProc.34thAnnu.IEEESympos.Found.Comput.Sci.,
pp.714–723,1993.
[47] R.L.GrahamandP.Hell,“Onthehistoryoftheminimumspanningtreeproblem,”
AnnalsoftheHistoryofComputing,vol.7,no.1,pp.43–57,1985.
[48] L. J. Guibas and R. Sedgewick, “A dichromatic frameworkfor balanced trees,” in
Proc.19thAnnu.IEEESympos.Found.Comput.Sci.,LectureNotesComput.Sci.,
pp.8–21,Springer-Verlag,1978.
[49] Y. Gurevich, “What does O(n) mean?,” SIGACT News, vol. 17, no. 4, pp. 61–63,
1986.
[50] J. Hennessy and D. Patterson, Computer Architecture: A Quantitative Approach.
SanFrancisco:MorganKaufmann,2nded.,1996.
[51] C.A.R.Hoare,“Quicksort,”TheComputerJournal,vol.5,pp.10–15,1962.
[52] J.E.HopcroftandR.E.Tarjan,“Efﬁcientalgorithmsforgraphmanipulation,”Com-
municationsoftheACM,vol.16,no.6,pp.372–378,1973.
[53] B.-C.HuangandM.Langston,“Practicalin-placemerging,”Communicationsofthe
ACM,vol.31,no.3,pp.348–352,1988.
[54] J. Ja´Ja´, An Introduction to Parallel Algorithms. Reading, MA: Addison-Wesley,
1992.
[55] V. Jarn´ık, “O jistem problemu minimalnim,” Praca Moravske Prirodovedecke
Spolecnosti,vol.6,pp.57–63,1930. (inCzech).
[56] R.JonesandR.Lins,GarbageCollection:AlgorithmsforAutomaticDynamicMem-
oryManagement. JohnWileyandSons,1996.
[57] D.R.Karger,P.Klein,andR.E.Tarjan,“Arandomizedlinear-timealgorithmtoﬁnd
minimumspanningtrees,”JournaloftheACM,vol.42,pp.321–328,1995.
[58] R. M. Karp and V. Ramachandran, “Parallel algorithms for shared memory ma-
chines,” in Handbook of Theoretical Computer Science (J. van Leeuwen, ed.),
pp.869–941,Amsterdam:Elsevier/TheMITPress,1990.
[59] P. Kirschenhofer and H. Prodinger, “The path length of random skip lists,” Acta
Informatica,vol.31,pp.775–792,1994.
[60] J. Kleinberg and E´. Tardos, Algorithm Design. Reading, MA: Addison-Wesley,
2006.
[61] A.KlinkandJ.Wa¨lde,“Efﬁcientdenialofserviceattacksonwebapplicationplat-
forms.”2011.
[62] D. E. Knuth,SortingandSearching,vol.3of TheArtofComputerProgramming.Bibliography 735
[63] D.E.Knuth,“Bigomicronandbigomegaandbigtheta,”inSIGACTNews,vol.8,
pp.18–24,1976.
[64] D.E.Knuth,FundamentalAlgorithms,vol.1ofTheArtofComputerProgramming.
Reading,MA:Addison-Wesley,3rded.,1997.
[65] D. E. Knuth,SortingandSearching,vol.3of TheArtofComputerProgramming.
Reading,MA:Addison-Wesley,2nded.,1998.
[66] D. E. Knuth, J. H. Morris, Jr., and V. R. Pratt, “Fast pattern matching in strings,”
SIAMJ.Comput.,vol.6,no.1,pp.323–350,1977.
[67] J. B. Kruskal, Jr., “On the shortest spanning subtree of a graph and the traveling
salesmanproblem,”Proc.Amer.Math.Soc.,vol.7,pp.48–50,1956.
[68] R.Lesuisse,“Somelessonsdrawnfromthehistoryofthebinarysearchalgorithm,”
TheComputerJournal,vol.26,pp.154–163,1983.
[69] N.G.LevesonandC.S.Turner,“AninvestigationoftheTherac-25accidents,”IEEE
Computer,vol.26,no.7,pp.18–41,1993.
[70] A. Levitin, “Do we teach the right algorithm design techniques?,” in 30th ACM
SIGCSESymp.onComputerScienceEducation,pp.179–183,1999.
[71] B. Liskov and J. Guttag, Abstraction and Speciﬁcation in Program Development.
Cambridge,MA/NewYork:TheMITPress/McGraw-Hill,1986.
[72] M.Lutz,ProgrammingPython. O’ReillyMedia,4thed.,2011.
[73] E.M.McCreight,“Aspace-economicalsufﬁxtreeconstructionalgorithm,”Journal
ofAlgorithms,vol.23,no.2,pp.262–272,1976.
[74] C.J.H.McDiarmidandB.A.Reed,“Buildingheapsfast,”JournalofAlgorithms,
vol.10,no.3,pp.352–365,1989.
[75] N. Megiddo,“Linear programmingin linear time whenthe dimensionis ﬁxed,” J.
ACM,vol.31,pp.114–127,1984.
[76] K. Mehlhorn, Data Structures and Algorithms 1: Sorting and Searching, vol. 1
of EATCS Monographs on Theoretical Computer Science. Heidelberg, Germany:
Springer-Verlag,1984.
[77] K. Mehlhorn, Data Structures and Algorithms 2: Graph Algorithms and NP-
Completeness,vol.2ofEATCSMonographsonTheoreticalComputerScience.Hei-
delberg,Germany:Springer-Verlag,1984.
[78] K.MehlhornandA.Tsakalidis,“Datastructures,”inHandbookofTheoreticalCom-
puterScience(J.vanLeeuwen,ed.),vol.A.AlgorithmsandComplexity,pp.301–
341,Amsterdam:Elsevier,1990.
[79] D. R. Morrison,“PATRICIA—practicalalgorithmto retrieveinformationcodedin
alphanumeric,”JournaloftheACM,vol.15,no.4,pp.514–534,1968.
[80] R.MotwaniandP.Raghavan,RandomizedAlgorithms. NewYork,NY:Cambridge
UniversityPress,1995.
[81] T. Papadakis, J. I. Munro, and P. V. Poblete, “Average search and update costs in
skiplists,”BIT,vol.32,pp.316–332,1992.
[82] L.Perkovic,IntroductiontoComputingUsingPython:AnApplicationDevelopment
Focus. Wiley,2011.
[83] D.Phillips,Python3: ObjectOrientedProgramming. PacktPublishing,2010.
[84] P.V.Poblete,J.I.Munro,andT.Papadakis,“Thebinomialtransformanditsappli-
cationtotheanalysisofskiplists,” inProceedingsoftheEuropeanSymposiumon736 Bibliography
[85] R. C. Prim, “Shortest connection networks and some generalizations,” Bell Syst.
Tech.J.,vol.36,pp.1389–1401,1957.
[86] W.Pugh,“Skiplists: aprobabilisticalternativetobalancedtrees,” Commun.ACM,
vol.33,no.6,pp.668–676,1990.
[87] H. Samet, The Design and Analysis of Spatial Data Structures. Reading, MA:
Addison-Wesley,1990.
[88] R. Schafferand R. Sedgewick, “The analysis of heapsort,”Journalof Algorithms,
vol.15,no.1,pp.76–100,1993.
[89] D.D.SleatorandR.E.Tarjan,“Self-adjustingbinarysearchtrees,”J.ACM,vol.32,
no.3,pp.652–686,1985.
[90] G.A.Stephen,StringSearchingAlgorithms. WorldScientiﬁcPress,1994.
[91] M.Summerﬁeld,ProgramminginPython3:ACompleteIntroductiontothePython
Language. Addison-WesleyProfessional,2nded.,2009.
[92] R.TamassiaandG.Liotta,“Graphdrawing,”inHandbookofDiscreteandCompu-
tationalGeometry(J. E.GoodmanandJ. O’Rourke,eds.), ch.52, pp.1163–1186,
CRCPressLLC,2nded.,2004.
[93] R.TarjanandU.Vishkin,“Anefﬁcientparallelbiconnectivityalgorithm,”SIAMJ.
Comput.,vol.14,pp.862–874,1985.
[94] R. E. Tarjan, “Depth ﬁrst search and linear graph algorithms,” SIAM J. Comput.,
vol.1,no.2,pp.146–160,1972.
[95] R. E. Tarjan, Data StructuresandNetwork Algorithms, vol. 44 of CBMS-NSF Re-
gional Conference Series in Applied Mathematics. Philadelphia, PA: Society for
IndustrialandAppliedMathematics,1983.
[96] A. B. Tucker,Jr., The ComputerScienceandEngineeringHandbook. CRC Press,
1997.
[97] J. D. Ullman, Principles of Database Systems. Potomac, MD: Computer Science
Press,1983.
[98] J.vanLeeuwen,“Graphalgorithms,”inHandbookofTheoreticalComputerScience
(J. van Leeuwen, ed.), vol. A. Algorithms and Complexity, pp. 525–632, Amster-
dam:Elsevier,1990.
[99] J.S.Vitter,“Efﬁcientmemoryaccessinlarge-scalecomputation,”inProc.8thSym-
pos. Theoret. Aspects Comput. Sci., Lecture Notes Comput. Sci., Springer-Verlag,
1991.
[100] J.S.VitterandW.C.Chen,DesignandAnalysisofCoalescedHashing. NewYork:
OxfordUniversityPress,1987.
[101] J.S.VitterandP.Flajolet,“Average-caseanalysisofalgorithmsanddatastructures,”
inAlgorithmsandComplexity(J.vanLeeuwen,ed.),vol.AofHandbookofTheo-
reticalComputerScience,pp.431–524,Amsterdam:Elsevier,1990.
[102] S. Warshall, “A theorem on boolean matrices,” Journalof the ACM, vol. 9, no. 1,
pp.11–12,1962.
[103] J.W.J.Williams,“Algorithm232: Heapsort,”CommunicationsoftheACM,vol.7,
no.6,pp.347–348,1964.
[104] D.Wood,DataStructures,Algorithms,andPerformance. Reading,MA:Addison-
Wesley,1993.
[105] J. Zelle, Python Programming: An Introduciton to Computer Science. Franklin,Index
#character,3 init ,71
∼operator,14,75 int ,75
%operator,13–14,75,242 invert ,75
&operator,14,75 ior ,449
operator,13,14,75 isub ,75
operator,75 iter ,75,76,87,88,306,403
=operator,75 le ,75
+operator,13,14,75 len ,75,76,79,95,403
+=operator,16,75 lshift ,75
−operator,13,75 lt ,75,76
−=operator,75 mod ,75
/operator,13,75 mul ,74,75
//operator,13–14,75 name ,68,73
<operator,13,15,75,76 ne ,75,76
<<operator,14,75,413 neg ,75
<=operator,13,15,75,76 next ,75,79,87,88
=operator,4 or ,75,449
==operator,12,15,75,76 pos ,75
>operator,13,15,75,76 pow ,75
>=operator,13,15,75 radd ,75,76
>>operator,14,75,413 rand ,75
ˆoperator,14,75,412 repr ,75
abs ,75 reversed ,75,295,427
add ,74–76 rﬂoordiv ,75
and ,75 rlshift ,75
bool ,74–76 rmod ,75
call ,75 rmul ,74,75
contains ,75,76,95,203,403 ror ,75
delitem ,75,403,460 rpow ,75
eq ,75,76 rrshift ,75
ﬂoat ,75 rshift ,75
ﬂoordiv ,75 rsub ,75
ge ,75 rtruediv ,75
getitem , 75, 79, 80, 93, 95, 211, setitem ,75,403,460
212,403,460 slots ,99,261,287
gt ,75 str ,74,75,211,212
hash ,75,415 sub ,75
iadd ,75 truediv ,75
imul ,75 xor ,75738 Index
abcmodule,60,93,306 andoperator,12
Abelson,Hal,182 anyfunction,29
absfunction,29,75 arc,620
abstractbaseclass,60,93–95,306,317, arithmeticoperators,13
406 arithmeticprogression,89,199–200
abstractdatatype,v,59 ArithmeticError,83,303
deque,247–248 array,9,183–222,223,227
graph,620–626 compact,190,711
map,402–408 dynamic,192–201,246
partition,681–684 arraymodule,191
positionallist,279–281 ArrayQueue class, 242–246, 248, 292,
priorityqueue,364 306
queue,240 ASCII,721
sortedmap,427 assignmentstatement,4,24
stack,230–231 chained,17
tree,305–306 extended,16
abstraction,58–60 simultaneous,45,91
(a,b)tree,712–714 asymptoticnotation,123–127,136
accessfrequency,286 big-Oh,123–127
accessors,6 big-Omega,127,197
activationrecord,23,151,703 big-Theta,127
actualparameter,24 AttributeError,33,100
acyclicgraph,623 AVLtree,481–488
adaptability,57,58 balancefactor,531
adaptable priority queue, 390–395, 666, height-balanceproperty,481
667
AdaptableHeapPriorityQueueclass, backedge,647,689
392–394,667 backslashcharacter,3
adapterdesignpattern,231 Baeza-Yates,Ricardo,535,580,618,719
Adel’son-Vel’skii,Georgii,481,535 Baru˚vka,Otakar,693,696
adjacencylist,627,630–631 baseclass,82
adjacencymap,627,632,634 BaseException,83,303
adjacencymatrix,627,633 Bayer,Rudolf,535,719
ADT,seeabstractdatatype Beazley,David,55
Aggarwal,Alok,719 Bellman,Richard,618
Aho,Alfred,254,298,535,618 Bentley,Jon,182,400,580
Ahuja,Ravindra,696 best-ﬁtalgorithm,699
algorithm,110 BFS,seebreadth-ﬁrstsearch
algorithmanalysis,123–136 biconnectedgraph,690
average-case,114 big-Ohnotation,123–127
worst-case,114 big-Omeganotation,127,197
alias,5,12,101,189 big-Thetanotation,127
allfunction,29 binaryheap,370–384
alphabet,583 binaryrecursion,174
amortization,164,197–200,234,237,246, binarysearch,155–156,162–163,
376,681–684 428–433,571Index 739
insertion,465 chainedassignment,17
removal,466–467 chainedoperators,17
rotation,475 ChainHashMapclass,424
trinoderestructuring,476 character-jumpheuristic,586
binarytree,311–324,539 Chen,Wen-Chin,458
array-basedrepresentation,325–326 Chernoffbound,579,580,730
complete,370 childclass,82
full,311 childnode,301
improper,311 chrfunction,29
level,315 circularlylinkedlist,266–269,296
linkedstructure,317–324 CircularQueueclass,268–269,306
proper,311 Clarkson,Kenneth,580
BinaryEulerTourclass,346–347 class,4,57
BinaryTreeclass,303,313–314,317,318, abstractbase,60,93–95,306
335,336 base,82
binomialexpansion,726 child,82
bipartitegraph,690 concrete,60,93
bitwiseoperators,14 diagram,63
Booch,Grady,108,298 nested,98–99
boolclass,7,12 parent,82
Booleanexpressions,12 sub,82
bootstrapping,504 super,82
Boyer,Robert,618 clustering,419
Boyer-Moorealgorithm,586–589 Cole,Richard,618
Brassard,Gilles,147 collectionsmodule,35,93,249,406,450
breadth-ﬁrstsearch,648–650 dequeclass,249,251,267
breadth-ﬁrsttreetraversal,335–336 collisionresolution,411,417–419
breakstatement,22 Comer,Douglas,719
bruteforce,584 commentsyntaxinPython,3
B-tree,714 compactarray,190,711
bubble-sort,297 comparisonoperators,13
bucket-sort,564–565 completebinarytree,370
Budd,Timothy,108,298 completegraph,687
built-inclasses,7 compositiondesignpattern,287
built-infunctions,28 compressionfunction,411,416
Burger,Doug,719 concreteclass,60,93
byte,185 conditionalexpression,42
conditionalprobability,729
caching,705–710 conditionalstatements,18
Caesarcipher,216–218 connectedcomponents,623,643,646
callstack,703 constructor,6
Campbell,Jennifer,55 continuestatement,22
Cardelli,Luca,108,254 contradiction,137
Carlsonn,Svante,400 contrapositive,137
Cedar,Vern,55 copymodule,49,102,188
ceilingfunction,116,122,726 copyingobjects,101–103740 Index
Cormen,Thomas,535,696 greedymethod,603
Counterclass,450 position,279–281
CPU,111 prune-and-search,571–573
CRCcards,63 templatemethod,93,342,406,448,
CreditCardclass,63,69–73,73,83–86 478
Crochemore,Maxime,618 DFS,seedepth-ﬁrstsearch
cryptography,216–218 DiBattista,Giuseppe,361,696
ctypesmodule,191,195 diameter,358
cubicfunction,119 dictclass,7,11,402
cyber-dollar,197–199,497–500,682 dictionary,11,16,402–408,seealsomap
cycle,623 dictionarycomprehension,43
directed,623 Dijkstra’salgorithm,661–669
cyclic-shifthashcode,413–414 Dijkstra,Edsger,182,696
dirfunction,46
DAG,seedirectedacyclicgraph directedacyclicgraph,655–657
datapackets,227 diskusage,157–160,163–164,340
datastructure,110 divide-and-conquer,538–542,550–551
Dawson,Michael,55 divisionmethodforhashcodes,416
debugging,62 documentation,66
decisiontree,311,463,562 doublehashing,419
decorate-sort-undecorate design pattern, double-endedqueue,seedeque
570 doublylinkedlist,260,270–276
decrease-and-conquer,571 DoublyLinkedBaseclass,273–275,278
decryption,216 down-heapbubbling,374
deepcopy,102,188 ducktyping,60,306
deepcopyfunction,102,188 dynamicarray,192–201,246
defkeyword,23 shrinking,200,246
degreeofavertex,621 DynamicArrayclass,195–196,204,206,
deloperator,15,75 224,225,245
DeMorgan’sLaw,137 dynamicbinding,100
Demurjian,Steven,108,254 dynamicdispatch,100
depthofatree,308–310 dynamicprogramming,594–600
depth-ﬁrstsearch(DFS),639–647 dynamicallytyped,5
deque,247–249
abstractdatatype,247–248 Eades,Peter,361,696
linked-listimplementation,249,275 edge,302,620
dequeclass,249,251 destination,621
descendant,302 endpoint,621
designpatterns,v,61 incident,621
adapter,231 multiple,622
amortization,197–200 origin,621
bruteforce,584 outgoing,621
composition,287,365,407 parallel,622
divide-and-conquer,538–542,550– self-loop,622
551 edgelist,627–629
dynamicprogramming,594–600 edgerelaxation,661Index 741
elementuniquenessproblem,135–136,165 ﬂowchart,19
elifkeyword,18 Floyd,Robert,400,696
Emptyexceptionclass,232,242,303 Floyd-Warshallalgorithm,652–654,696
encapsulation,58,60 forloop,21
encryption,216 forest,623
endpoints,621 formalparameter,24
EOFError,33,37,38 fractal,152
escapecharacter,10 fragmentationofmemory,699
Euclideannorm,53 freelist,699
Eulertourofagraph,686,691 frozensetclass,7,11,446
Eulertourtreetraversal,341–347,361 fullbinarytree,311
EulerTourclass,342–345 function,23–28
event,729 body,23
exceptstatement,36–38 built-in,28
exception,33–38,83 signature,23
catching,36–38
raising,34–35 gametree,330,361
Exceptionclass,33,83,232,303 GameEntryclass,210
expectedvalue,729 Gamma,Erich,108
exponentialfunction,120–121,172–173 garbage collection, 209, 245, 275, 700–
expressiontree,312,348–351 702
expressions,12–17 mark-sweep,701,702
ExpressionTreeclass,348–351 Gauss,Carl,118
externalmemory,705–716,719 gcmodule,701
external-memoryalgorithm,705–716 generator,40–41,79
external-memorysorting,715–716 generatorcomprehension,43,209
geometricprogression,90,199
factorialfunction,150–151,161,166–167, geometricsum,121,728
726 getsizeoffunction,190,192–194
factoringanumber,40–41 globalscope,46,96
factorymethodpattern,479 Goldberg,Adele,298
False,7 Goldwasser,Michael,55,108
favoriteslist,286–291 Gonnet,Gaston,400,535,580,719
FavoritesListclass,287–288 Goodrich,Michael,719
FavoritesListMTFclass,290,399 grade-pointaverage(GPA),3,26
Fibonacciheap,667 Graham,Ronald,696
Fibonacciseries,41,45,90–91,727 graph,620–696
FIFO,239,363 abstractdatatype,620–626
ﬁleproxy,31–32 acyclic,623
ﬁlesystem,157–160,302,340 breadth-ﬁrstsearch,648–650
ﬁnally,38 connected,623,638
ﬁrst-classobject,47 datastructures,627–634
ﬁrst-ﬁtalgorithm,699 adjacencylist,627,630–631
ﬁrst-in,ﬁrst-out(FIFO),239,363 adjacencymap,627,632,634
Flajolet,Philippe,147 adjacencymatrix,627,633
ﬂoatclass,7,8 edgelist,627–629742 Index
directed,620,621,657 I/Ocomplexity,711
acyclic,655–657 idfunction,29
stronglyconnected,623 identiﬁer,4
mixed,621 IDLE,2
reachability,651–654 immutabletype,7,11,415
shortestpaths,654 impliedmethod,76
simple,622 importstatement,48
traversal,638–650 inoperator,14–15,75
undirected,620,621 in-degree,621
weighted,659–696 in-placealgorithm,389,396,559,702
greedymethod,603,660,661 incidencecollection,630
Guibas,Leonidas,535 incident,621
Guttag,John,108,254,298 incomingedges,621
independent,729,730
Harmonicnumber,131,180,728 index,186
hashcode,411–415 negative,14
cyclic-shift,413–414 zero-indexing,9,14
polynomial,413 IndexError,20,33,34,83,232,303
hashfunction,415 induction,138–139,162
hashtable,410–426 inﬁxnotation,359
clustering,419 inheritance,82–95
collision,411 multiple,468
collisionresolution,417–419 inordertreetraversal,331,335–336,461,
doublehashing,419 476
linearprobing,418 inputfunction,29,30–31
quadraticprobing,419 insertion-sort,214–215,285–286,387
HashMapBaseclass,422–423 instance,57
headersentinel,270 instantiation,6
heap,370–384 intclass,7,8
bottom-upconstruction,380–384 integrateddevelopmentenvironment,2
heap-sort,384,388–389 internalmemory,705
HeapPriorityQueueclass,377–378,382 Internet,227
heapqmodule,384 interpreter,2
heightofatree,309–310,474 inversion,567,578
height-balanceproperty,481,483 invertedﬁle,456
Hell,Pavol,696 IOError,33,37
Hennessy,John,719 is notoperator,12
heuristic,289 isoperator,12,76
hierarchy,82 isinstancefunction,29,34
Hoare,C.A.R.,580 isomorphism,355
hook,342,468,478 iterabletype,9,21,35,39
Hopcroft,John,254,298,535,696 iterator,39–40,76,79,87
Hopper,Grace,36
Horner’smethod,146 Ja´Ja´,Joseph,361
HTML,236–238,251,582 Jarn´ık,Vojteˇch,696
Huang,Bing-Chao,580 joinfunctionofstrclass,723Index 743
Karger,David,696 Liskov,Barbara,108,254,298
Karp,Richard,361 list
KeyboardInterrupt,33,83,303 offavorites,286–291
KeyError,33,34,83,303,403,404,422, positional,277–285
460 listclass,7,9,202–207
keywordparameter,27 sortmethod,23,569
Klein,Philip,696 listcomprehension,43,207,209,221
Kleinberg,Jon,580 literal,6
Knuth,Donald,147,227,298,361,400, Littman,Michael,580
458,535,580,618,696,719 liveobjects,700
Knuth-Morris-Prattalgorithm,590–593 loadfactor,417,420–421
Kosaraju,S.Rao,696 localscope,23–25,46,96
Kruskal’salgorithm,676–684 localityofreference,289,707
Kruskal,Joseph,696 locator,390
log-starfunction,684
L’Hoˆpital’srule,731 logarithmfunction,115–116,725
Landis,Evgenii,481,535 logicaloperators,12
Langston,Michael,580 longestcommonsubsequence,597–600
last-in,ﬁrst-out(LIFO),229 looking-glassheuristic,586
lazyevaluation,39,80 lookuptable,410
LCS,seelongestcommonsubsequence LookupError,83,303
leaves,302 loopinvariant,140
Lecroq,Thierry,618 lowestcommonancestor,358
Leiserson,Charles,535,696 Lutz,Mark,55
lenfunction,29
Lesuisse,R.,182 Magnanti,Thomas,696
Letscher,David,55,108 mainmemory,705
levelinatree,315 map
levelnumbering,325,371 abstractdatatype,402–408
lexicographicorder,15,203,385,565 AVLtree,481–488
LIFO,229 binarysearchtree,460–479
linearexponential,728 hashtable,410–426
linearfunction,117 red-blacktree,512–525
linearprobing,418 skiplist,437–445
linearityofexpectation,573,730 sorted,460
linkedlist,256–293 (2,4)tree,502–511
doublylinked,260,270–276,281 update operations, 442, 465, 466,
singlylinked,256–260 483,486
linkedstructure,317 MapBaseclass,407–408
LinkedBinaryTree class, 303, 318–324, Mappingabstractbaseclass,406
335,348 mark-sweepalgorithm,701,702
LinkedDequeclass,275–276 mathmodule,28,49
LinkedQueue class, 264–265, 271, 306, matrix,219
335 matrixchain-product,594–596
LinkedStackclass,261–263 maxfunction,27–29
Lins,Rafael,719 maximalindependentset,692744 Index
McDiarmid,Colin,400 move-to-frontheuristic,289–291
McIlroy,Douglas,580 MST,seeminimumspanningtree
median,155,571 multidimensionaldatasets,219–223
median-of-three,561 multimap,450
Megiddo,Nimrod,580 multipleinheritance,468
Mehlhorn,Kurt,535,696,719 multiplerecursion,175
member Multiply-Add-and-Divide(MAD),416
function,seemethod multiset,450
nonpublic,72,86 multiwaymerge-sort,715–716
private,86 multiwaysearchtree,502–504
protected,86 Munro,J.Ian,400
memoryaddress,5,185,698 MutableLinkedBinaryTreeclass,319,353
memoryallocation,699 MutableMappingabstractbaseclass,406,
memoryheap,699 468
memoryhierarchy,705 MutableSetabstractbaseclass,446,448
memorymanagement,698–704,708 mutuallyindependent,729
merge-sort,538–550
multiway,715–716 n-log-nfunction,117
mergeableheap,534 nameresolution,46,100
Mersennetwister,50 NameError,33,46
method,6,57,69 namespace,23,46–47,96–100
implied,76 naturaljoin,227,297
minfunction,29 negativeindex,14
minimumspanningtree,670–684 nestedclass,98–99
Kruskal’salgorithm,676–684 nestedloops,118
Prim-Jarnikalgorithm,672–675 nextfunction,29
modularity,58,59 next-ﬁtalgorithm,699
module,48,59 node,256,301,620
abc,60,93,306 ancestor,302
array,191 child,301
collections,35,93,249,406,450 descendant,302
copy,49,102,188 external,302
ctypes,191,195 internal,302
gc,701 leaf,302
heapq,384 parent,301
math,28,49 root,301
os,49,159,182,357 sibling,302
random,49,49–50,225,438 None,5,7,9,24,76,187
re,49 nonpublicmember,72,86
sys,49,190,192,701 not inoperator,14–15
time,49,111 notoperator,12
unittest,68
modulooperator,13,216,242,726 objectclass,303
Moore,J.Strother,618 object-orienteddesign,57–108
Morris,James,618 objects,57
Morrison,Donald,618 ﬁrstclass,47Index 745
openfunction,29,31 Perkovic,Ljubomir,55
operandstack,704 permutation,150
operators,12–17 Peters,Tim,568
arithmetic,13 Phillips,Dusty,108
bitwise,14 polymorphism,26,77,93
chaining,17 polynomialfunction,119,146
comparisons,13 polynomialhashcode,413
logical,12 portability,58
overloading,74 position,279–281,305,438
precedence,17 positionallist,277–285
oroperator,12 abstractdatatype,279–281
ordfunction,29 PositionalListclass,281–285,287,628
orderstatistic,571 positionalparameter,27
OrderedDictclass,457 postﬁxnotation,252,253,359
Orlin,James,696 postordertreetraversal,329
osmodule,49,159,182,357 powfunction,29
out-degree,621 powerfunction,172
outgoingedge,621 Pratt,Vaughan,618
overﬂow,506 precedenceofoperators,17
override,82,100 PredatoryCreditCard, 83–86, 96–100,
106
p-norm,53 preﬁx,583
packingasequence,44 preﬁxaverage,131–134
palindrome,181,615 preﬁxcode,601
parameter,24–28 preordertreetraversal,328
actual,24 Prim,Robert,696
defaultvalue,26 Prim-Jarnikalgorithm,672–675
formal,24 primitiveoperations,113
keyword,27 printfunction,29,30
positional,27 priorityqueue,363–400
parentclass,82 adaptable,390–395,666
parentnode,301 ADT,364
parentheticstringrepresentation,339 heapimplementation,372–379
partialorder,16 sortedlistimplementation,368–369
partition,679,681–684 unsortedlistimplementation,
passstatement,38,478 366–367
path,302,623 prioritysearchtree,400
compression,684 PriorityQueueBaseclass,365
directed,623 privatemember,86
length,356,660 probability,728–730
simple,623 ProbeHashMapclass,425–426
patternmatching,208,584–593 programcounter,703
Boyer-Moorealgorithm,586–589 progression,87–91,93
bruteforce,584–585 arithmetic,89,199–200
Knuth-Morris-Prattalgorithm, Fibonacci,90–91
590–593 geometric,90,199746 Index
prune-and-search,571–573 Reed,Bruce,400
pseudo-code,64 reference,187
pseudo-randomnumbergenerator,49–50, referencecount,209,701
438 reﬂexiveproperty,385,537
Pugh,William,458 rehashing,420
puzzlesolver,175–176 reservedwords,4
Pythonheap,699 returnstatement,24
Pythoninterpreter,2 reusability,57,58
Pythoninterpreterstack,703 reversedfunction,29
Ribeiro-Neto,Berthier,618
quadraticfunction,117 Rivest,Ronald,535,696
quadraticprobing,419 Robson,David,298
queue,239 robustness,57
abstractdatatype,240 rootobjects,700
arrayimplementation,241–246 rootofatree,301
linked-listimplementation,264–265 rotation,475
quick-sort,550–561 roundfunction,29
round-robin,267
radix-sort,565–566 runningtime,110
Raghavan,Prabhakar,458,580
raisestatement,34–35,38 Samet,Hanan,719
Ramachandran,Vijaya,361 Schaffer,Russel,400
randomaccessmemory(RAM),185 scheduling,400
Randomclass,50 scope,46–47,96,98,701
randommodule,49,49–50,225,438 global,46,96
randomseed,50 local,23–25,46,96
randomvariable,729 Scoreboardclass,211–213
randomization,438 script,2
randomizedquick-select,572 searchengine,612
randomizedquick-sort,557 searchtable,428–433
randrangefunction,50,51,225 searchtree,460–535
rangeclass,22,27,29,80–81 Sedgewick,Robert,400,535
remodule,49 seed,50,438
reachability,623,638 selection,571–573
recurrenceequation,162,546,573,576 selection-sort,386–387
recursion,149–179,703–704 selfidentiﬁer,69
binary,174 self-loop,622
depthlimit,168,528 sentinel,270–271
linear,169–173 separatechaining,417
multiple,175–176 sequentialsearch,155
tail,178–179 setclass,7,11,446
trace,151,161,703 setcomprehension,43
red-blacktree,512–525 shallowcopy,101,188
depthproperty,512 Sharir,Micha,361
recoloring,516 short-circuitevaluation,12,20,208
redproperty,512 shortestpath,660–669Index 747
tree,669 linked-listimplementation,261–263
shuﬄefunction,50,225 Stein,Clifford,535,696
sievealgorithm,454 Stephen,Graham,618
signature,23 Stirling’sapproximation,727
simultaneousassignment,45,91 stopwords,606,617
singlylinkedlist,256–260 StopIteration,33,39,41,79
skiplist,437–445 strclass,7,9,10,208–210,721–724
analysis,443–445 strictweakorder,385
insertion,440 string,seealsostrclass
removal,442–443 null,583
searching,439–440 preﬁx,583
updateoperations,440–443 sufﬁx,583
Sleator,Daniel,535 stronglyconnectedcomponents,646
slicingnotation,14–15,188,203,583 stronglyconnectedgraph,623
sortedfunction,6, 23, 28, 29, 136,537, subclass,82
569 subgraph,623
sortedmap,427–436 subproblemoverlap,597
abstractdatatype,427 subsequence,597
searchtable,428–433 subtree,302
SortedPriorityQueueclass,368–369 sufﬁx,583
SortedTableMapclass,429–433 sumfunction,29,35
sorting,214,385–386,537–566 summation,120
bubble-sort,297 geometric,121,728
bucket-sort,564–565 telescoping,727
external-memory,715–716 Summerﬁeld,Mark,55
heap-sort,384,388–389 superfunction,84
in-place,389,559 superclass,82
insertion-sort,214–215,285,387 Sussman,Gerald,182
key,385 Sussman,Julie,182
lowerbound,562–563 sysmodule,49,190,192,701
merge-sort,538–550 SystemExit,83,303
priority-queue,385–386
quick-sort,550–561 Tamassia,Roberto,361,696
radix-sort,565–566 Tardos,E´va,580
selection-sort,386–387 Tarjan,Robert,361,535,696
stable,565 telescopingsum,727
Tim-sort,568 template method pattern, 93, 342, 406,
sourcecode,2 448,478
spaceusage,110 testing,62
spanningtree,623,638,642,643,670 unit,49
sparsearray,298 textcompression,601–602
splaytree,478,490–501 three-waysetdisjointness,134–135
splitfunctionofstrclass,724 Tic-Tac-Toe,221–223,330,361
stablesorting,565 Tim-sort,568
stack,229–238 timemodule,49,111
abstractdatatype,230–231 Tollis,Ioannis,361,696748 Index
totalorder,16 (2,4)tree,502–511
tower-of-twos,684 typefunction,29,449
TowersofHanoi,181 TypeError,33–35,72,415
trailersentinel,270
transitiveclosure,643,651–654 Ullman,Jeffrey,254,298,535,719
transitiveproperty,385,537 Unicode,10,217,583,721
tree,164,299–361,623 union-ﬁnd,679,681–684
abstractdatatype,305–306 unittesting,49,68
binary,seebinarytree unittestmodule,68
binarysearch,seebinarysearchtree unpackingasequence,44
binarytreerepresentation,356 UnsortedPriorityQueueclass,366–367
childnode,301 UnsortedTableMapclass,408–409,424
decision,311 up-heapbubbling,372
depth,308–310 updatemethods,6
edge,302
ValueError,8,33,83,206,303,305
expression,312,348–351
vanLeeuwen,Jan,696
externalnode,302
vanRossum,Guido,2
height,309–310
varsfunction,46
internalnode,302
Vector,77–78
leaf,302
vertex,620
level,315
degree,621
linkedstructure,327
virtualmemory,707
multiway,502–504
Vishkin,Uzi,361
node,301
Vitter,Jeffrey,147,458,719
ordered,304
parentnode,301
Warshall,Stephen,696
path,302
Wegner,Peter,108,254
red-black,seered-blacktree
whileloop,20
rootnode,301
whitespace,3,722–724
splay,seesplaytree
Williams,J.W.J.,400
traversal,164,328–347
Wood,Derick,298
breadth-ﬁrst,330,335–336
worst-ﬁtalgorithm,699
Eulertour,341–347
inorder,331,335–336,461,476 XML,237,582
postorder,329,335
preorder,328,333–334 yieldstatement,40–41,296,334
(2,4),see(2,4)tree
Treeclass,303,306–310 Zelle,John,55
triangulation,615 zero-indexing,14,219
trie,604–612 ZeroDivisionError,33,36,83,303
compressed,608
trinoderestructuring,476,484,515
True,7,76
truedivision,13
try-exceptstructure,36–38
Tsakalidis,Athanasios,535